(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Letsee", [], factory);
	else if(typeof exports === 'object')
		exports["Letsee"] = factory();
	else
		root["Letsee"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Context.js":
/*!********************!*\
  !*** ./Context.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.context = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _os = null;
  var _width = null;
  var _height = null;
  var _orientation = null;
  var _isPortrait = null;
  var BodyId = "body-".concat((0, _Util.UUID)());
  var DomRendererId = "dom-".concat((0, _Util.UUID)());
  var VideoContainerId = "video-".concat((0, _Util.UUID)());
  var PlaceholderId = "placeholder-".concat((0, _Util.UUID)());

  var Context =
  /*#__PURE__*/
  function () {
    function Context() {
      _classCallCheck(this, Context);
    }

    _createClass(Context, [{
      key: "setConfig",
      value: function setConfig(config) {
        _width = config.width;
        _height = config.height;
        _orientation = config.orientation;
        _isPortrait = _orientation === 0 || _orientation === 180;
      }
    }, {
      key: "bodyId",
      get: function get() {
        return BodyId;
      },
      set: function set(value) {
        BodyId = value;
      }
    }, {
      key: "domRendererId",
      get: function get() {
        return DomRendererId;
      }
    }, {
      key: "videoContainerId",
      get: function get() {
        return VideoContainerId;
      }
    }, {
      key: "placeholderId",
      get: function get() {
        return PlaceholderId;
      }
    }, {
      key: "os",
      get: function get() {
        return _os;
      },
      set: function set(value) {
        _os = value;
      }
    }, {
      key: "orientation",
      get: function get() {
        return _orientation;
      },
      set: function set(value) {
        _orientation = value;
      }
    }, {
      key: "width",
      get: function get() {
        return _width;
      },
      set: function set(value) {
        _width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return _height;
      },
      set: function set(value) {
        _height = value;
      }
    }, {
      key: "isPortrait",
      get: function get() {
        return _isPortrait;
      }
    }, {
      key: "screenWidth",
      get: function get() {
        return _width;
      }
    }, {
      key: "screenHeight",
      get: function get() {
        return _height;
      }
    }]);

    return Context;
  }();

  var context = new Context();
  _exports.context = context;
});

/***/ }),

/***/ "./Screen.js":
/*!*******************!*\
  !*** ./Screen.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var Screen =
  /*#__PURE__*/
  function () {
    function Screen(_width, _height, _videoManager) {
      _classCallCheck(this, Screen);

      this.width = _width;
      this.height = _height;
      this.videoManager = _videoManager;
    }
    /**
     * Fit the canvas size when fullscreen and exit fullscreen request.
     */


    _createClass(Screen, [{
      key: "fitWidthAndHeight",
      value: function fitWidthAndHeight() {
        console.log("fit window.innerWidth: ".concat(window.innerWidth, " / window.innerHeight: ").concat(window.innerHeight, " to screen")); // Set canvas size with current window width & height.

        this.videoManager.canvasElement.width = window.innerWidth;
        this.videoManager.canvasElement.height = window.innerHeight; // Send screen size to tracker.

        this.videoManager.screenInfo.width = window.innerWidth;
        this.videoManager.screenInfo.height = window.innerHeight;
      }
    }, {
      key: "requestFullscreen",

      /* 이것도요..screen object 통해서 호출하면 되어요. by ahn */
      value: function requestFullscreen() {
        // Find <ar-renderer> element
        var _arRenderer = document.getElementsByClassName('ar-renderer'); // Set fullscreen for ar-renderer element


        if (_arRenderer[0] !== undefined) {
          if (_arRenderer[0].requestFullscreen) {
            _arRenderer[0].requestFullscreen().then(function (e) {//
            })["catch"](function (err) {
              console.log("Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")"));
            });
          } else if (_arRenderer[0].mozRequestFullScreen) {
            _arRenderer[0].mozRequestFullScreen();
          } else if (_arRenderer[0].webkitRequestFullscreen) {
            _arRenderer[0].webkitRequestFullscreen();
          } else if (_arRenderer[0].msRequestFullscreen) {
            _arRenderer[0].msRequestFullscreen();
          }
        }
      }
    }, {
      key: "exitFullscreen",

      /* 이것도 screen object에서 제공하면 됩니다. letsee.screen.exitFullscreen() 이렇게 by ahn */
      value: function exitFullscreen() {
        var _this = this;

        if (document.exitFullscreen) {
          document.exitFullscreen().then(function () {
            // Set current canvas size when exit fullscreen
            _this.fitWidthAndHeight();
          })["catch"](function (err) {
            console.log(err);
          });
        } else if (document.mozCancelFullScreen) {
          /* Firefox */
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          /* Chrome, Safari and Opera */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          /* IE/Edge */
          document.msExitFullscreen();
        }
      }
    }]);

    return Screen;
  }();

  _exports["default"] = Screen;
});

/***/ }),

/***/ "./Util.js":
/*!*****************!*\
  !*** ./Util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, Message) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.isNil = _exports.isNull = _exports.removeArrayItem = _exports.chunk = _exports.hasWbcam = _exports.getBrowserInfo = _exports.UUID = _exports.loadImage = _exports.addViewport = _exports.createStatusScreen = _exports.createLoader = _exports.createLetseeWrapper = void 0;
  Message = _interopRequireWildcard(Message);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  var style = document.createElement('style');
  var letseeWrapper = document.createElement('div');
  var letseeLoader = document.createElement('div');
  var letseeStatus = document.createElement('div');
  var defaultLoaderContent = '<div class="letseeLoader"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDQiIGhlaWdodD0iNDQiIHZpZXdCb3g9IjAgMCA0NCA0NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBzdHJva2U9IiNmZmYiPiAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDBiMWM3IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS13aWR0aD0iMiI+ICAgIDxjaXJjbGUgY3g9IjIyIiBjeT0iMjIiIHI9IjEiPiAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiICAgICAgICAgICAgICAgYmVnaW49IjBzIiBkdXI9IjEuOHMiICAgICAgICAgICAgICAgdmFsdWVzPSIxOyAyMCIgICAgICAgICAgICAgICBjYWxjTW9kZT0ic3BsaW5lIiAgICAgICAgICAgICAgIGtleVRpbWVzPSIwOyAxIiAgICAgICAgICAgICAgIGtleVNwbGluZXM9IjAuMTY1LCAwLjg0LCAwLjQ0LCAxIiAgICAgICAgICAgICAgIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPiAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InN0cm9rZS1vcGFjaXR5IiAgICAgICAgICAgICAgIGJlZ2luPSIwcyIgZHVyPSIxLjhzIiAgICAgICAgICAgICAgIHZhbHVlcz0iMTsgMCIgICAgICAgICAgICAgICBjYWxjTW9kZT0ic3BsaW5lIiAgICAgICAgICAgICAgIGtleVRpbWVzPSIwOyAxIiAgICAgICAgICAgICAgIGtleVNwbGluZXM9IjAuMywgMC42MSwgMC4zNTUsIDEiICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIC8+ICAgIDwvY2lyY2xlPiAgICA8Y2lyY2xlIGN4PSIyMiIgY3k9IjIyIiByPSIxIj4gICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJyIiAgICAgICAgICAgICAgIGJlZ2luPSItMC45cyIgZHVyPSIxLjhzIiAgICAgICAgICAgICAgIHZhbHVlcz0iMTsgMjAiICAgICAgICAgICAgICAgY2FsY01vZGU9InNwbGluZSIgICAgICAgICAgICAgICBrZXlUaW1lcz0iMDsgMSIgICAgICAgICAgICAgICBrZXlTcGxpbmVzPSIwLjE2NSwgMC44NCwgMC40NCwgMSIgICAgICAgICAgICAgICByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgLz4gICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJzdHJva2Utb3BhY2l0eSIgICAgICAgICAgICAgICBiZWdpbj0iLTAuOXMiIGR1cj0iMS44cyIgICAgICAgICAgICAgICB2YWx1ZXM9IjE7IDAiICAgICAgICAgICAgICAgY2FsY01vZGU9InNwbGluZSIgICAgICAgICAgICAgICBrZXlUaW1lcz0iMDsgMSIgICAgICAgICAgICAgICBrZXlTcGxpbmVzPSIwLjMsIDAuNjEsIDAuMzU1LCAxIiAgICAgICAgICAgICAgIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPiAgICA8L2NpcmNsZT4gIDwvZz48L3N2Zz4="></div>';
  var letseeStyle = ["@font-face{font-family:Roboto;font-style:normal;font-weight:400;src:url(https://cdn.letsee.io/font/roboto-400.woff) format('woff')}", ".letseeStatus,.letseeLoader{font-family: 'Roboto', sans-serif;}", "#letseeWrapper>div{display:none;position:fixed!important;width:100%!important;height:100%!important;z-index:10000000!important;background:#fff!important;top:0;left:0;right:0;bottom:0;text-align:center}", ".letseeLoader img{position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;width:50px!important;height:50px!important}", ".letsee-loading #letseeWrapper .letseeLoader{display:block}", ".letsee-status #letseeWrapper .letseeStatus{display:block}", "body.ar-mode-off .ar-renderer{display:none!important;}"];

  var statusHtml = function statusHtml(type) {
    var _html;

    switch (type) {
      case 101:
        _html = "<div class=\"title\"><h2>Use safari for awesome AR app with iPhone</h2></div><div class=\"body\"><p id=\"copyText\" class=\"url\">".concat(window.location.href, "</p><p class=\"text\">Copy url and paste to safari.</p></div><script>document.getElementById(\"copyText\").addEventListener(\"click\",function(){!function(e){const t=document.createElement(\"textArea\");let n,o;t.value=e,document.body.appendChild(t),navigator.userAgent.match(/ipad|iphone/i)?((n=document.createRange()).selectNodeContents(t),(o=window.getSelection()).removeAllRanges(),o.addRange(n),t.setSelectionRange(0,999999)):t.select(),document.execCommand(\"copy\"),document.body.removeChild(t)}(e.target.textContent)});</script>"); // eslint-disable-line

        break;

      case 102:
        _html = '<div class="title"><h2>Unsupported browser</h2></div><div class="body"><p class="text">Please use Chrome, Firefox, iOS 11, Android 5 or higher, Safari 11 or higher</p></div>'; // eslint-disable-line

        break;

      case 103:
        _html = '<div class="title"><h2>No camera detected</h2></div><div class="body"><p class="text">Please install an external webcam device.</p></div>'; // eslint-disable-line

        break;

      case 104:
        _html = '<div class="title"><h2>No mobile device detected</h2></div><div class="body"><p class="text">Please use mobile browser.</p></div>'; // eslint-disable-line

        break;

      case 105:
        _html = '<div class="title"><h2>Camera denied</h2></div><div class="body"><p class="text">Please allow camera permission.</p></div>'; // eslint-disable-line

        break;

      default:
        _html = '<div class="title"><h2>General error</h2></div><div class="body"><p class="text">General error</p></div>';
      // eslint-disable-line
    }

    return _html;
  };

  var statusCss = function statusCss(type) {
    var _css;

    switch (type) {
      case 101:
        _css = [];
        break;

      case 102:
        _css = [];
        break;

      case 103:
        _css = [];
        break;

      case 104:
        _css = [];
        break;

      case 105:
        _css = [];
        break;

      default:
        _css = [];
    }

    return _css;
  };

  var createLetseeWrapper = function createLetseeWrapper() {
    style.setAttribute('type', 'text/css');
    document.head.append(style);
    letseeStyle.forEach(function (val, index) {
      style.sheet.insertRule(val, index);
    });
    letseeWrapper.id = 'letseeWrapper';
    letseeLoader.classList.add('letseeLoader');
    letseeStatus.classList.add('letseeStatus');
    letseeWrapper.appendChild(letseeLoader);
    letseeWrapper.appendChild(letseeStatus);
    document.body.insertBefore(letseeWrapper, document.body.firstChild);
  };

  _exports.createLetseeWrapper = createLetseeWrapper;

  var createLoader = function createLoader() {
    var _html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultLoaderContent;

    var _css = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (_css) {
      _css.forEach(function (val, index) {
        style.sheet.insertRule(val, index);
      });
    }

    letseeLoader.innerHTML = '';
    letseeLoader.innerHTML = _html;
  };

  _exports.createLoader = createLoader;

  var createStatusScreen = function createStatusScreen(type) {
    document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);
    document.body.classList.add(Message.LETSEE_CSS.LETSEE_STATUS);
    letseeStatus.setAttribute('data-status-code', type);
    letseeStatus.innerHTML = statusHtml(type);
    statusCss(type).forEach(function (val, index) {
      style.sheet.insertRule(val, index);
    });
  };

  _exports.createStatusScreen = createStatusScreen;

  var addViewport = function addViewport() {
    var viewPortTag = document.createElement('meta');
    viewPortTag.id = 'viewport';
    viewPortTag.name = 'viewport';
    viewPortTag.content = 'minimum-scale=1.0, width=device-width, maximum-scale=1, user-scalable=no, viewport-fit=cover';
    document.getElementsByTagName('head')[0].appendChild(viewPortTag);
  };

  _exports.addViewport = addViewport;

  var loadImage = function loadImage(path) {
    var img = new Image();
    img.src = path;
    img.crossOrigin = 'Anonymous';
    return new Promise(function (resolve, reject) {
      img.onload = function () {
        if (img.naturalWidth * img.naturalHeight > 640000) {
          reject('Too large refference image');
        } else {
          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          ctx.drawImage(img, 0, 0);

          var _ctx$getImageData = ctx.getImageData(0, 0, canvas.width, canvas.height),
              width = _ctx$getImageData.width,
              height = _ctx$getImageData.height,
              data = _ctx$getImageData.data;

          resolve({
            // uri: uri,
            img: {
              width: width,
              height: height,
              data: data
            }
          });
        }
      };
    });
  };

  _exports.loadImage = loadImage;

  var UUID = function UUID() {
    var d = new Date().getTime();

    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      d += performance.now(); // use high-precision timer if available
    }

    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  _exports.UUID = UUID;

  var isWebRTCSupported = function isWebRTCSupported() {
    // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.
    var isWebRTCSupported = false;
    ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
      if (isWebRTCSupported) return;
      if (item in window) isWebRTCSupported = true;
    });
    return isWebRTCSupported;
  };

  var isMobile = {
    Android: function Android() {
      return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function BlackBerry() {
      return navigator.userAgent.match(/BlackBerry|BB10/i);
    },
    iOS: function iOS() {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function Opera() {
      return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function Windows() {
      return navigator.userAgent.match(/IEMobile/i);
    },
    any: function any() {
      return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
    },
    getOsName: function getOsName() {
      var osName = 'Unknown OS';
      if (isMobile.Android()) osName = 'Android';
      if (isMobile.BlackBerry()) osName = 'BlackBerry';
      if (isMobile.iOS()) osName = 'iOS';
      if (isMobile.Opera()) osName = 'Opera Mini';
      if (isMobile.Windows()) osName = 'Windows';
      return osName;
    }
  }; // https://www.websocket.org/js/stuff.js (DetectBrowser.js)

  var getBrowserInfo = function getBrowserInfo() {
    var navigator = window.navigator;
    var isMobileDevice = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''); // eslint-disable-line

    var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);
    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    var isFirefox = typeof window.InstallTrigger !== 'undefined';
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var isChrome = !!window.chrome && !isOpera;
    var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;
    var nVer = navigator.appVersion; // eslint-disable-line

    var nAgt = navigator.userAgent;
    var browserName = navigator.appName;
    var fullVersion = '' + parseFloat(navigator.appVersion);
    var majorVersion = parseInt(navigator.appVersion, 10);
    var nameOffset, verOffset, ix; // both and safri and chrome has same userAgent

    if (isSafari && !isChrome && nAgt.indexOf('CriOS') !== -1) {
      isSafari = false;
      isChrome = true;
    } // In Opera, the true version is after 'Opera' or after 'Version'


    if (isOpera) {
      browserName = 'Opera';

      try {
        fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
        majorVersion = fullVersion.split('.')[0];
      } catch (e) {
        fullVersion = '0.0.0.0';
        majorVersion = 0;
      } // In MSIE version <=10, the true version is after 'MSIE' in userAgent // In IE 11, look for the string after 'rv:'

    } else if (isIE) {
      verOffset = nAgt.indexOf('rv:');

      if (verOffset > 0) {
        // IE 11
        fullVersion = nAgt.substring(verOffset + 3);
      } else {
        // IE 10 or earlier
        verOffset = nAgt.indexOf('MSIE');
        fullVersion = nAgt.substring(verOffset + 5);
      }

      browserName = 'IE';
    } else if (isChrome) {
      // In Chrome, the true version is after 'Chrome'
      verOffset = nAgt.indexOf('Chrome');
      browserName = 'Chrome';
      fullVersion = nAgt.substring(verOffset + 7);
    } else if (isSafari) {
      // In Safari, the true version is after 'Safari' or after 'Version'
      verOffset = nAgt.indexOf('Safari');
      browserName = 'Safari';
      fullVersion = nAgt.substring(verOffset + 7);

      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        fullVersion = nAgt.substring(verOffset + 8);
      }

      if (navigator.userAgent.indexOf('Version/') !== -1) {
        fullVersion = navigator.userAgent.split('Version/')[1].split(' ')[0];
      }
    } else if (isFirefox) {
      // In Firefox, the true version is after 'Firefox'
      verOffset = nAgt.indexOf('Firefox');
      browserName = 'Firefox';
      fullVersion = nAgt.substring(verOffset + 8); // In most other browsers, 'name/version' is at the end of userAgent
    } else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browserName = nAgt.substring(nameOffset, verOffset);
      fullVersion = nAgt.substring(verOffset + 1);

      if (browserName.toLowerCase() === browserName.toUpperCase()) {
        browserName = navigator.appName;
      }
    }

    if (isEdge) {
      browserName = 'Edge';
      fullVersion = navigator.userAgent.split('Edge/')[1]; // fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
    } // trim the fullVersion string at semicolon/space/bracket if present


    if ((ix = fullVersion.search(/[; \)]/)) !== -1) {
      fullVersion = fullVersion.substring(0, ix);
    }

    majorVersion = parseInt('' + fullVersion, 10);

    if (isNaN(majorVersion)) {
      fullVersion = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }

    return {
      'fullVersion': fullVersion,
      'version': majorVersion,
      'name': browserName,
      'isPrivateBrowsing': false,
      'isMobileDevice': isMobileDevice,
      'isWebRTCSupported': isWebRTCSupported(),
      'osName': isMobile.getOsName()
    };
  };

  _exports.getBrowserInfo = getBrowserInfo;

  var hasWbcam = function hasWbcam(devices) {
    var hasWebcam = false;
    var deviceList = [];
    devices.forEach(function (device) {
      if (device.kind === 'videoinput') {
        hasWebcam = true;
        deviceList.push(device.deviceId);
      }
    }); // return {hasWebcam: hasWebcam, deviceList: deviceList};

    return hasWebcam; // devices.forEach((_device) => {
    //   const device = {};
    //
    //   for (const d in _device) {
    //     try {
    //       if (typeof _device[d] !== 'function') {
    //         device[d] = _device[d];
    //       }
    //     } catch (e) {}
    //   }
    //
    //
    //   // if it is MediaStreamTrack.getSources
    //   if (device.kind === 'audio') {
    //     device.kind = 'audioinput';
    //   }
    //
    //   if (device.kind === 'video') {
    //     device.kind = 'videoinput';
    //   }
    //
    //   if (!device.deviceId) {
    //     device.deviceId = device.id;
    //   }
    //
    //   if (!device.id) {
    //     device.id = device.deviceId;
    //   }
    //
    //   if (!device.label) {
    //     device.isCustomLabel = true;
    //
    //     if (device.kind === 'videoinput') {
    //       device.label = 'Camera ' + (videoInputDevices.length + 1);
    //     } else if (device.kind === 'audioinput') {
    //       device.label = 'Microphone ' + (audioInputDevices.length + 1);
    //     } else if (device.kind === 'audiooutput') {
    //       device.label = 'Speaker ' + (audioOutputDevices.length + 1);
    //     } else {
    //       device.label = 'Please invoke getUserMedia once.';
    //     }
    //
    //     if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
    //       if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
    //         device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
    //       }
    //     }
    //   } else {
    //     // Firefox on Android still returns empty label
    //     if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
    //       isWebsiteHasWebcamPermissions = true;
    //     }
    //
    //     if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
    //       isWebsiteHasMicrophonePermissions = true;
    //     }
    //   }
    //
    //   if (device.kind === 'audioinput') {
    //     hasMicrophone = true;
    //
    //     if (audioInputDevices.indexOf(device) === -1) {
    //       audioInputDevices.push(device);
    //     }
    //   }
    //
    //   if (device.kind === 'audiooutput') {
    //     hasSpeakers = true;
    //
    //     if (audioOutputDevices.indexOf(device) === -1) {
    //       audioOutputDevices.push(device);
    //     }
    //   }
    //
    //   if (device.kind === 'videoinput') {
    //     hasWebcam = true;
    //
    //     if (videoInputDevices.indexOf(device) === -1) {
    //       videoInputDevices.push(device);
    //     }
    //   }
    //
    //   // there is no 'videoouput' in the spec.
    //   MediaDevices.push(device);
    //
    //   alreadyUsedDevices[device.deviceId + device.label + device.kind] = device;
    // });
  };

  _exports.hasWbcam = hasWbcam;

  var chunk = function chunk(arr) {
    var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    var tmp = _toConsumableArray(arr);

    if (chunkSize <= 0) return cache;

    while (tmp.length) {
      cache.push(tmp.splice(0, chunkSize));
    }

    return cache;
  };
  /**
   * Removes all elements from `array` that are equal to `element`. The `array`
   * parameter is modified after this export function call.
   * @memberof module:Util
   * @method removeArrayItem
   * @param {Array} array
   * @param {*} element
   * @return {Array}
   * @example
   * let array = [1, 2, 3, 4];
   * removeArrayItem(array, 1);
   *
   * console.log(array);
   * // => [2, 3, 4]
   */


  _exports.chunk = chunk;

  var removeArrayItem = function removeArrayItem(array, element) {
    var idx = array.indexOf(element);
    if (idx > -1) array.splice(idx, 1);
  };

  _exports.removeArrayItem = removeArrayItem;

  var isNull = function isNull(value) {
    return value === null;
  };

  _exports.isNull = isNull;

  var isNil = function isNil(value) {
    return value == null;
  }; //
  // document.getElementById('copyText').addEventListener('click',function () {
  //   (function(text) {
  //     const textArea = document.createElement('textArea');
  //     let range,
  //       selection;
  //
  //     textArea.value = text;
  //     document.body.appendChild(textArea);
  //     if (navigator.userAgent.match(/ipad|iphone/i)) {
  //       range = document.createRange();
  //       range.selectNodeContents(textArea);
  //       selection = window.getSelection();
  //       selection.removeAllRanges();
  //       selection.addRange(range);
  //       textArea.setSelectionRange(0, 999999);
  //     } else {
  //       textArea.select();
  //     }
  //
  //     document.execCommand('copy');
  //     document.body.removeChild(textArea);
  //   })(e.target.textContent);
  // })

  /*
  function clipboard(text) {
    const textArea = document.createElement('textArea');
    let range,
      selection;
  
    textArea.value = text;
    document.body.appendChild(textArea);
    if (navigator.userAgent.match(/ipad|iphone/i)) {
      range = document.createRange();
      range.selectNodeContents(textArea);
      selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      textArea.setSelectionRange(0, 999999);
    } else {
      textArea.select();
    }
  
    document.execCommand('copy');
    document.body.removeChild(textArea);
  };*/


  _exports.isNil = isNil;
});

/***/ }),

/***/ "./core/Camera.js":
/*!************************!*\
  !*** ./core/Camera.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Object3D2, _Matrix, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);
  _Matrix = _interopRequireDefault(_Matrix);
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var _type = 'Camera';
  /**
   * Used to check whether this or derived classes are cameras. You should not
   * change this, as it is used internally by the renderer for optimisation.
   * @member {boolean} isCamera
   * @memberof Camera.prototype
   * @default true
   */

  var _isCamera = true;
  /**
   * @ignore
   * @class Camera
   * @classdesc
   * Abstract base class for cameras. This class should always be inherited when
   * you build a new camera. Note that this class is not intended to be called
   * directly; You probably want a {@link PerspectiveCamera} or
   * {@link OrthographicCamera} instead.
   * @extends Object3D
   */

  var Camera =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(Camera, _Object3D);

    function Camera() {
      var _this;

      _classCallCheck(this, Camera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this));
      _this.projectionMatrix = new _Matrix["default"]();
      _this.projectionMatrixInverse = new _Matrix["default"]();
      _this.matrixWorldInverse = new _Matrix["default"]();
      return _this;
    }

    _createClass(Camera, [{
      key: "lookAt",

      /**
       * This makes the camera look at the vector position in the global space as
       * long as the parent of this camera is the scene or at position `(0, 0, 0)`.
       * @method lookAt
       * @memberof Camera.prototype
       * @param  {Vector3} target Position in 3D space for the camera to point towards
       */
      value: function lookAt(target) {
        var m = new _Matrix["default"]();
        m.lookAt(this.position, target, this.up);
        this.quaternion.setFromRotationMatrix(m);
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }, {
      key: "isCamera",
      get: function get() {
        return _isCamera;
      }
      /**
       * This is the inverse of {@link Object3D#matrixWorld}.
       * {@link Object3D#matrixWorld} contains the {@link Matrix4} which has the
       * world transform of the {@link Camera}.
       * @member {Matrix4} matrixWorldInverse
       * @memberof Camera#
       * @readonly
       */
      // get matrixWorldInverse() {
      //   return new Matrix4().getInverse(this.matrixWorld);
      // }

      /**
       * This is the matrix which contains the projection.
       * @member {Matrix4} projectionMatrix
       * @memberof Camera#
       * @readonly
       */
      // get projectionMatrix() {
      //   return this.projectionMatrix;
      // }
      //
      // set projectionMatrix(value) {
      //   this.projectionMatrix = value;
      // }
      // get projectionMatrixInverse() {
      //   return this.projectionMatrixInverse;
      // }
      //
      // set projectionMatrixInverse(value) {
      //   this.projectionMatrixInverse = value;
      // }

    }, {
      key: "worldZ",
      get: function get() {
        return new _Vector["default"](0, 0, -1).applyQuaternion(this.worldQuaternion);
      }
    }]);

    return Camera;
  }(_Object3D2["default"]);

  var _default = Camera;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/Data.js":
/*!**********************!*\
  !*** ./core/Data.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EntityDataObject = _exports.EventDataObject = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // Observer Data Object
  var EventData = new Map();

  var EventDataObject =
  /*#__PURE__*/
  function () {
    function EventDataObject() {
      _classCallCheck(this, EventDataObject);
    }

    _createClass(EventDataObject, null, [{
      key: "addHandler",
      value: function addHandler(target, handlers) {
        EventData.set(target, handlers);
      }
    }, {
      key: "getTarget",
      value: function getTarget(target) {
        return EventData.get(target);
      }
    }, {
      key: "getHandler",
      value: function getHandler(target, type) {
        var eventName = type.toLowerCase();
        var currentTarget = EventData.get(target);

        if ((0, _Util.isNil)(currentTarget)) {
          return "".concat(target, " does not exist");
        }

        var eventHandler = currentTarget.get(type);
        return (0, _Util.isNil)(eventHandler) ? "".concat(target, " does not have ").concat(eventName) : eventHandler;
      }
    }]);

    return EventDataObject;
  }(); // Entity Data Object


  _exports.EventDataObject = EventDataObject;
  var EntityData = new Map();

  var EntityDataObject =
  /*#__PURE__*/
  function () {
    function EntityDataObject() {
      _classCallCheck(this, EntityDataObject);
    }

    _createClass(EntityDataObject, null, [{
      key: "addElement",
      value: function addElement(element, map) {
        EntityData.set(element, map);
      }
    }, {
      key: "getElement",
      value: function getElement(ele) {
        return EntityData.get(ele);
      }
    }, {
      key: "getAllElements",
      value: function getAllElements() {
        return EntityData;
      }
    }]);

    return EntityDataObject;
  }();

  _exports.EntityDataObject = EntityDataObject;
});

/***/ }),

/***/ "./core/Object3D.js":
/*!**************************!*\
  !*** ./core/Object3D.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ../math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../observers/Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Quaternion, _Euler, _Matrix, _Observer2, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _Matrix = _interopRequireDefault(_Matrix);
  _Observer2 = _interopRequireDefault(_Observer2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import {ENTITY_EVENT} from '../libs/MessageTypes';
  // import EntityEvent from '../event/EntityEvent';
  var objectId = 0;
  /**
   * Used to check whether this or derived classes are {@link Object3D}s. You
   * should not change this, as it is used internally for optimisation.
   * @member {boolean} isObject3D
   * @memberof Object3D#
   * @default true
   */

  var _isObject3D = true;
  var _type = 'Object3D';
  var handlers = new Map([[_MessageTypes.OBJECT_EVENT.OBJECT_ADDED, new Set()], [_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED, new Set()]]);
  /**
   * @class Object3D
   * @extends EventDispatcher
   * @classdesc
   * This is the base class for most objects and provides a set of properties and
   * methods for manipulating objects in 3D space. Note that this can be used for
   * grouping objects via the {@link Object3D#add} method which adds the object
   * as a child, however it is better to use {@link Group} for this.
   */
  // class Object3D extends EventDispatcher {

  var Object3D =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(Object3D, _Observer);

    function Object3D() {
      var _this;

      _classCallCheck(this, Object3D);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Object3D).call(this, "object_".concat(objectId), handlers));
      /**
       * Unique number for this object instance.
       * @member {number} id
       * @memberof Object3D#
       * @readonly
       */
      // this.id = objectId;
      // TODO @default

      /**
       * The object's local position.
       * @member {Vector3} position
       * @memberof Object3D#
       * @default (0, 0, 0)
       */

      _this.position = new _Vector["default"](0, 0, 0);
      /**
       * Object's local rotation as a {@link Quaternion}.
       * @member {Quaternion} quaternion
       * @memberof Object3D#
       */

      _this.quaternion = new _Quaternion["default"]();
      /**
       * The object's local scale.
       * @member {Vector3} scale
       * @memberof Object3D#
       * @default (1, 1, 1)
       */

      _this.scale = new _Vector["default"](1, 1, 1);
      /**
       * This is used by the {@link Object3D#lookAt} method, for example, to
       * determine the orientation of the result.
       * @member {Vector3} up
       * @memberof Object3D#
       * @default (0, 1, 0)
       */

      _this.up = new _Vector["default"](0, 1, 0);
      /**
       * Object gets rendered if `true`.
       * @member {boolean} visible
       * @memberof Object3D#
       * @default true
       */

      _this.visible = true;
      _this.track = false;
      /**
       * Object's parent in the
       * [scene graph](https://en.wikipedia.org/wiki/Scene_graph).
       * @member {Object3D|null} parent
       * @memberof Object3D#
       * @default null
       */

      _this.parent = null;
      /**
       * Array with object's children. See {@link Group} for info on manually
       * grouping objects.
       * @member {Object3D[]} children
       * @memberof Object3D#
       * @default []
       */

      _this.children = [];
      _this.matrix = new _Matrix["default"]();
      _this.matrixWorld = new _Matrix["default"]();
      _this.matrixAutoUpdate = true;
      _this.matrixWorldNeedsUpdate = false; // this.rotation = new Euler();
      // this.id = objectId;

      Object.defineProperty(_assertThisInitialized(_this), 'id', {
        value: "object_".concat(objectId)
      });
      objectId++;
      return _this;
    } // get id() {
    //   return objectId;
    // };
    // get parent() {
    //   return this.parent;
    // };
    //
    // set parent(value) {
    //   this.parent = value;
    // }
    //
    // get children() {
    //   return this.children;
    // };
    // get position() {
    //   return this.position;
    // };
    // get quaternion() {
    //   return this.quaternion;
    // };
    // get scale() {
    //   return this.scale;
    // };
    // get up() {
    //   return this.up;
    // };
    // get visible() {
    //   return this.visible;
    // };
    // get track() {
    //   return this.track;
    // };
    //
    // set track(value) {
    //   this.track = value;
    // }


    _createClass(Object3D, [{
      key: "translate",

      /**
       * @method translate
       * @memberof Object3D.prototype
       * @param  {number} x
       * @param  {number} y
       * @param  {number} z
       */
      value: function translate(x, y, z) {
        var xAxis = new _Vector["default"](1, 0, 0);
        var yAxis = new _Vector["default"](0, 1, 0);
        var zAxis = new _Vector["default"](0, 0, 1);
        xAxis.applyQuaternion(this.quaternion);
        yAxis.applyQuaternion(this.quaternion);
        zAxis.applyQuaternion(this.quaternion);
        this.position.add(xAxis.multiplyScalar(x));
        this.position.add(yAxis.multiplyScalar(y));
        this.position.add(zAxis.multiplyScalar(z));
      }
    }, {
      key: "translateX",
      value: function translateX(value) {
        var xAxis = new _Vector["default"](1, 0, 0);
        xAxis.applyQuaternion(this.quaternion);
        this.position.add(xAxis.multiplyScalar(value));
      }
    }, {
      key: "translateY",
      value: function translateY(value) {
        var yAxis = new _Vector["default"](0, 1, 0);
        yAxis.applyQuaternion(this.quaternion);
        this.position.add(yAxis.multiplyScalar(value));
      }
    }, {
      key: "translateZ",
      value: function translateZ(value) {
        var zAxis = new _Vector["default"](0, 0, 1);
        zAxis.applyQuaternion(this.quaternion);
        this.position.add(zAxis.multiplyScalar(value));
      }
    }, {
      key: "rotateX",

      /**
       * Rotates the object around x axis in local space.
       * @method rotateX
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */
      value: function rotateX(angle) {
        var axis = new _Vector["default"](1, 0, 0);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Rotates the object around y axis in local space.
       * @method rotateY
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */

    }, {
      key: "rotateY",
      value: function rotateY(angle) {
        var axis = new _Vector["default"](0, 1, 0);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Rotates the object around z axis in local space.
       * @method rotateZ
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */

    }, {
      key: "rotateZ",
      value: function rotateZ(angle) {
        var axis = new _Vector["default"](0, 0, 1);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Returns a vector of the scaling factors applied to the object for each axis
       * in world space.
       * @member {Vector3} worldScale
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "localToWorld",

      /**
       * The local transform matrix.
       * @member {Matrix4} matrix
       * @memberof Object3D#
       * @readonly
       */
      // get matrix() {
      //   return new Matrix4().compose(this.position, this.quaternion, this.scale);
      // }

      /**
       * The global transform of the object. If the object has no parent, then it's
       * identical to the local transform {@link Object3D#matrix}.
       * @member {Matrix4} matrixWorld
       * @memberof Object3D#
       * @readonly
       */
      // get matrixWorld() {
      //   const parent = this.parent;
      //   const matrix = this.matrix;
      //
      //   if (parent === null) {
      //     return matrix;
      //   }
      //
      //   return new Matrix4().multiplyMatrices(parent.matrixWorld, matrix);
      // }

      /**
       * Converts the vector from local space to world space.
       * @method localToWorld
       * @memberof Object3D.prototype
       * @param  {Vector3} vector A vector representing a position in local (object) space.
       * @return {Vector3}
       */
      value: function localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      }
      /**
       * Updates the vector from world space to local space.
       * @method worldToLocal
       * @memberof Object3D.prototype
       * @param  {Vector3} vector A world vector.
       * @return {Vector3}
       */

    }, {
      key: "worldToLocal",
      value: function worldToLocal(vector) {
        return vector.applyMatrix4(new _Matrix["default"]().getInverse(this.matrixWorld));
      }
      /**
       * Adds `object` as child of this object. An arbitrary number of objects may
       * be added. See {@link Group} for info on manually grouping objects.
       * @method add
       * @memberof Object3D.prototype
       * @param {Object3D} object
       */

    }, {
      key: "add",
      value: function add(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }

          return this;
        }

        if (object === this) {
          console.error('Letsee.Object3D.add: object can\'t be added as a child of itself.', object);
          return this;
        }

        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }

          object.parent = this;
          object.notify(_MessageTypes.OBJECT_EVENT.OBJECT_ADDED);
          this.children.push(object);
        } else {
          console.error('Letsee.Object3D.add: object not an instance of Letsee.Object3D.', object);
        }

        return this; // if (object && object !== this && object.isObject3D) {
        //   if (object.parent) {
        //     object.parent.remove(object);
        //   }
        //
        //   if (!this.isScene) {
        //     object.track = this.track;
        //   }
        //
        //   object.parent = this;
        //   object.dispatchEvent({type: 'added'});
        //
        //   // this.children = [
        //   //   ...this.children,
        //   //   object,
        //   // ];
        // }
        //
        // for (let i = 0; i < object.length; i += 1) {
        //   this.add(object[i]);
        // }
      }
      /**
       * Removes `object` as child of this object. An arbitrary number of objects
       * may be eremoved.
       * @method remove
       * @memberof Object3D.prototype
       * @param  {Object3D} object
       */

    }, {
      key: "remove",
      value: function remove(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }

          return this;
        }

        var index = this.children.indexOf(object);

        if (index !== -1) {
          object.parent = null;
          object.notify(_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED);
          this.children.splice(index, 1);
        }

        return this; //
        //
        // const index = this.children.indexOf(object);
        //
        // if (index > -1) {
        //   object.parent = null;
        //   object.dispatchEvent({type: 'removed'});
        //
        //   for (let child of object.children) {
        //   object.remove(child);
        // }
        //
        // this.children = [
        //   ...this.children.slice(0, index),
        //   ...this.children.slice(index + 1),
        // ];
        // }
        //
        // for (let i = 0; i < other.length; i += 1) {
        //   this.remove(other[i]);
        // }
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();

        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }

          this.matrixWorldNeedsUpdate = false;
          force = true;
        } // update children


        var children = this.children;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].updateMatrixWorld(force);
        }
      }
    }, {
      key: "updateWorldMatrix",
      value: function updateWorldMatrix(updateParents, updateChildren) {
        var parent = this.parent;

        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }

        if (this.matrixAutoUpdate) this.updateMatrix();

        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        } // update children


        if (updateChildren === true) {
          var children = this.children;

          for (var i = 0, l = children.length; i < l; i++) {
            children[i].updateWorldMatrix(false, true);
          }
        }
      }
    }, {
      key: "lookAt",
      value: function lookAt(vector3) {
        var m = new _Matrix["default"]();
        m.lookAt(vector3, this.position, this.up);
        this.quaternion.setFromRotationMatrix(m);
      }
    }, {
      key: "applyMatrix",
      value: function applyMatrix(matrix) {
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      /**
       * Returns a clone of this object and optionally all descendants.
       * @method clone
       * @memberof Object3D.prototype
       * @param  {boolean} [recursive=true] If true, descendants of the object are also cloned.
       * @return {Object3D}
       */

    }, {
      key: "clone",
      value: function clone() {
        var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return new Object3D().copy(this, recursive);
      }
      /**
       * Copy the given `source` object into this object.
       * @method copy
       * @memberof Object3D.prototype
       * @param  {Object3D} source
       * @param  {boolean} [recursive=true] If true, descendants of the object are also copied.
       */

    }, {
      key: "copy",
      value: function copy(source) {
        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.up.copy(source.copy);
        this.visible = source.visible;

        if (recursive === true || recursive === undefined) {
          for (var i = 0; i < source.children.length; i += 1) {
            var child = source.children[i];
            this.add(child.clone());
          }
        }

        return this;
      }
      /**
       * Executes the `callback` on this object and all descendants.
       * @method traverse
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverse",
      value: function traverse(callback) {
        callback(this);
        this.children.forEach(function (child) {
          child.traverse(callback);
        });
      }
      /**
       * Like {@link Object3D#traverse}, but the `callback` will only be executed
       * for visible objects. Descendants of invisible objects are not traversed.
       * @method traverseVisible
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverseVisible",
      value: function traverseVisible(callback) {
        if (this.visible) {
          callback(this);
          this.children.forEach(function (child) {
            child.traverseVisible(callback);
          });
        }
      }
      /**
       * Executes the `callback` on all ancestors.
       * @method traverseAncestors
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverseAncestors",
      value: function traverseAncestors(callback) {
        var parent = this.parent;

        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
    }, {
      key: "traverseRenderable",
      value: function traverseRenderable(callback) {
        if (this.visible && this.track) {
          callback(this);
          this.children.forEach(function (child) {
            child.traverseRenderable(callback);
          });
        }
      }
    }, {
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Object3D.prototype), "subscribe", this)).call.apply(_get2, [this, this.id, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(Object3D.prototype), "unsubscribe", this).call(this, this.id, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        var e = event ? event : {};
        e.target = this;
        e.type = type;

        _get(_getPrototypeOf(Object3D.prototype), "notify", this).call(this, this.id, type, e);
      }
    }, {
      key: "isObject3D",
      get: function get() {
        return _isObject3D;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
      /**
       * Returns a vector representing the position of the object in world space.
       * @member {Vector3} worldPosition
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldPosition",
      get: function get() {
        return new _Vector["default"]().setFromMatrixPosition(this.matrixWorld);
      }
    }, {
      key: "rotation",
      get: function get() {
        return new _Euler["default"]().setFromQuaternion(this.quaternion, undefined, false);
      },
      set: function set(rotation) {
        if (rotation.isEuler) {
          this.quaternion.setFromEuler(rotation);
        } else if (rotation.isQuaternion) {
          this.quaternion.copy(rotation);
        } else if (rotation.isMatrix4) {
          this.quaternion.setFromMatrix(rotation);
        } else {
          console.warn('Rotation must be one of Euler, Quaternion or Matrix4');
        }
      }
      /**
       * Returns the euler angles representing the rotation of the object in world
       * space.
       * @member {Euler} worldRotation
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldRotation",
      get: function get() {
        return new _Euler["default"]().setFromQuaternion(this.worldQuaternion, this.rotation.order, false);
      }
      /**
       * Returns a quaternion representing the rotation of the object in world
       * space.
       * @member {Quaternion} worldQuaternion
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldQuaternion",
      get: function get() {
        var result = new _Quaternion["default"]();
        this.matrixWorld.decompose(new _Vector["default"](), result, new _Vector["default"]());
        return result;
      }
    }, {
      key: "worldX",
      get: function get() {
        return new _Vector["default"](1, 0, 0).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldY",
      get: function get() {
        return new _Vector["default"](0, 1, 0).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldZ",
      get: function get() {
        return new _Vector["default"](0, 0, 1).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldScale",
      get: function get() {
        var result = new _Vector["default"]();
        this.matrixWorld.decompose(new _Vector["default"](), new _Quaternion["default"](), result);
        return result;
      }
    }]);

    return Object3D;
  }(_Observer2["default"]);

  var _default = Object3D;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/PerspectiveCamera.js":
/*!***********************************!*\
  !*** ./core/PerspectiveCamera.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Camera */ "./core/Camera.js"), __webpack_require__(/*! ../math/Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Camera2, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Camera2 = _interopRequireDefault(_Camera2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * @typedef {Object} PerspectiveCameraViewOffset
   * @property {number} fullWidth
   * @property {number} fullHeight
   * @property {number} offsetX
   * @property {number} offsetY
   * @property {number} width
   * @property {number} height
   */
  // type PerspectiveCameraViewOffset = {
  //   fullWidth,
  //   fullHeight,
  //   offsetX,
  //   offsetY,
  //   width,
  //   height,
  // };

  /*
  
  
  /!**
   * Camera frustum vertical field of view, from bottom to top of view, in
   * degrees.
   * @member {number} fov
   * @memberof PerspectiveCamera#
   * @default 50
   *!/
  let this.fov = 50;
  /!**
   * Gets or sets the zoom factor of the camera.
   * @member {number} zoom
   * @memberof PerspectiveCamera#
   * @default 1
   *!/
  let this.zoom = 1;
  
  /!**
   * Camera frustum near plane. The valid range is greater than `0` and less
   * than the current value of the {@link PerspectiveCamera#far} plane. Note
   * that, unlike for the {@link OrthographicCamera}, `0` is _not_ a valid value
   * for a {@link PerspectiveCamera}'s near plane.
   * @member {number} near
   * @memberof PerspectiveCamera#
   * @default 0.1
   *!/
  let this.near = 0.1;
  
  /!**
   * Camera frustum far plane. The valid range is between the current value of
   * the {@link PerspectiveCamera#near} plane and infinity.
   * @member {number} far
   * @memberof PerspectiveCamera#
   * @default 2000
   *!/
  let this.far = 2000;
  
  /!**
   * Object distance used for stereoscopy and depth-of-field effects. This
   * parameter does not influence the projection matrix unless a
   * {@link StereoCamera} is being used.
   * @member {number} focus
   * @memberof PerspectiveCamera#
   * @default 10
   *!/
  let this.focus = 10;
  
  /!**
   * Camera frustum aspect ratio, usually the canvas width / canvas height.
   * @member {number} aspect
   * @memberof PerspectiveCamera#
   * @default 1 (square canvas)
   *!/
  let this.aspect = 1;
  
  /!**
   * Frustum window specification or `null`. This is set using the
   * {@link PerspectiveCamera#setViewOffset} method and cleared using
   * {@link PerspectiveCamera#clearViewOffset}.
   * @member {PerspectiveCameraViewOffset} view
   * @memberof PerspectiveCamera#
   * @default null
   *!/
  let this.view = null;
  
  /!**
   * Film size used for the larger axis. This parameter does not influence the
   * projection matrix unless {@link PerspectiveCamera#filmOffset} is set to a
   * nonzero value.
   * @member {number} filmGauge
   * @memberof PerspectiveCamera#
   * @default 35 (millimeters)
   *!/
  let this.filmGauge = 35;
  
  /!**
   * Horizontal off-center offset in the same unit as
   * {@link PerspectiveCamera#filmGauge}.
   * @member {number} filmOffset
   * @memberof PerspectiveCamera#
   * @default 0
   *!/
  let this.filmOffset = 0;
  
  /!**
   * Camera projection matrix
   * @member {Matrix4} projectionMatrix
   * @memberof LetseeEngine.camera
   *!/
  // let _projectionMatrix = new Matrix4();
  
  /!**
   * Used to test whether this or derived classes are
   * {@link PerspectiveCamera}s. This should not be changed as it is used
   * internally by the renderer for optimisation.
   * @member {boolean} isPerspectiveCamera
   * @memberof PerspectiveCamera.prototype
   * @default true
   *!/*/
  var isPerspectiveCamera = true;
  var _type = 'PerspectiveCamera';
  /**
   * @namespace camera
   * @memberof letsee
   * @class PerspectiveCamera
   * @classdesc
   * Camera that uses
   * [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).
   * This projection mode is designed to mimic the way the human eye sees. It is
   * the most common projection mode used for rendering a 3D scene.
   * @extends Camera
   * @example
   * var camera = new PerspectiveCamera(45, width/height, 1, 1000);
   * scene.add(camera);
   * @constructor
   * @param  {number} [fov]    Camera frustum vertical field of view.
   * @param  {number} [aspect] Camera frustum aspect ratio.
   * @param  {number} [near]   Camera frustum near plane.
   * @param  {number} [far]    Camera frustum far plane.
   */

  var PerspectiveCamera =
  /*#__PURE__*/
  function (_Camera) {
    _inherits(PerspectiveCamera, _Camera);

    function PerspectiveCamera(fov, aspect, near, far) {
      var _this;

      _classCallCheck(this, PerspectiveCamera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PerspectiveCamera).call(this));
      _this.fov = fov !== undefined ? fov : 50;
      _this.zoom = 1;
      _this.near = near !== undefined ? near : 0.1;
      _this.far = far !== undefined ? far : 2000;
      _this.focus = 10;
      _this.aspect = aspect !== undefined ? aspect : 1;
      _this.view = null;
      _this.filmGauge = 35;
      _this.filmOffset = 0;

      _this.updateProjectionMatrix();

      return _this;
    } //
    // get fov() {
    //   return this.fov;
    // }
    //
    // get zoom() {
    //   return this.zoom;
    // }
    //
    // get near() {
    //   return this.near;
    // }
    //
    // get far() {
    //   return this.far;
    // }
    //
    // get focus() {
    //   return this.focus;
    // }
    //
    // get aspect() {
    //   return this.aspect;
    // }
    //
    // get view() {
    //   return this.view;
    // }
    //
    // get filmGauge() {
    //   return this.filmGauge;
    // }
    //
    // get filmOffset() {
    //   return this.filmOffset;
    // }


    _createClass(PerspectiveCamera, [{
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(PerspectiveCamera.prototype), "copy", this).call(this, source);

        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : _objectSpread({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset; // _projectionMatrix = source.projectionMatrix;

        return this;
      }
    }, {
      key: "getEffectiveFOV",

      /**
       * Returns the current vertical field of view angle in degrees considering
       * {@link PerspectiveCamera#zoom}.
       * @member {number} effectiveFOV
       * @memberof PerspectiveCamera#
       * @readonly
       */
      value: function getEffectiveFOV() {
        return 2 * (0, _Math.radToDeg)(Math.atan(Math.tan(0.5 * (0, _Math.degToRad)(this.fov)) / this.zoom));
      }
    }, {
      key: "updateProjectionMatrix",
      // get projectionMatrix() {
      //   return _projectionMatrix;
      // }
      value: function updateProjectionMatrix() {
        var near = this.near,
            top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
            height = 2 * top,
            width = this.aspect * height,
            left = -0.5 * width,
            view = this.view;

        if (this.view !== null && this.view.enabled) {
          var fullWidth = view.fullWidth,
              fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }

        var skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.filmWidth();
        this.projectionMatrix = this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse = this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      }
    }, {
      key: "setViewPort",
      value: function setViewPort(rotationMatrix) {
        if (rotationMatrix.isMatrix4) {
          this.quaternion.setFromRotationMatrix(rotationMatrix);
          LetseeEngine.renderer.render();
        }
      }
    }, {
      key: "focalLength",
      set: function set(focalLength) {
        var vExtentSlope = 0.5 * this.filmHeight / focalLength;
        this.fov = 2 * (0, _Math.radToDeg)(Math.atan(vExtentSlope));
      }
      /**
       * The focal length of the current {@link PerspectiveCamera#fov} in respect to
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} focalLength
       * @memberof PerspectiveCamera#
       */
      ,
      get: function get() {
        var vExtentSlope = Math.tan(0.5 * (0, _Math.degToRad)(this.fov));
        return 0.5 * this.filmHeight / vExtentSlope;
      }
      /**
       * The width of the image on the film. If {@link PerspectiveCamera#aspect} is
       * greater than or equal to `1` (landscape format), the result equals
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} filmWidth
       * @memberof PerspectiveCamera#
       * @readonly
       */

    }, {
      key: "filmWidth",
      get: function get() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      /**
       * The height of the image on the film. If {@link PerspectiveCamera#aspect} is
       * less than or equal to `1` (portrait format), the result equals
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} filmHeight
       * @memberof PerspectiveCamera#
       * @readonly
       */

    }, {
      key: "filmHeight",
      get: function get() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
    }, {
      key: "viewOffset",
      set: function set(view) {
        this.view = view;

        if (this.view !== null) {
          this.aspect = this.view.fullWidth / this.view.fullHeight;
        }
      }
    }]);

    return PerspectiveCamera;
  }(_Camera2["default"]);

  var _default = PerspectiveCamera;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/Scene.js":
/*!***********************!*\
  !*** ./core/Scene.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Object3D */ "./core/Object3D.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Object3D2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

  function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  /**
   * @class Scene
   * @classdesc
   * Scenes allow you to set up what and where is to be rendered. This is where
   * you place objects, lights, and cameras.
   * @extends Object3D
   */
  var _type = 'Scene';
  var _isScene = true;

  var Scene =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(Scene, _Object3D);

    function Scene() {
      var _this;

      _classCallCheck(this, Scene);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this));

      _set(_getPrototypeOf(Scene.prototype), "track", true, _assertThisInitialized(_this), true);

      return _this;
    }

    _createClass(Scene, [{
      key: "isScene",
      get: function get() {
        return _isScene;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }]);

    return Scene;
  }(_Object3D2["default"]);

  _exports["default"] = Scene;
});

/***/ }),

/***/ "./core/TrackableManager.js":
/*!**********************************!*\
  !*** ./core/TrackableManager.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ../renderer/DOMRenderable */ "./renderer/DOMRenderable.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Entity, _DOMRenderable, _Euler) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.trackableManager = void 0;
  _Entity = _interopRequireDefault(_Entity);
  _DOMRenderable = _interopRequireDefault(_DOMRenderable);
  _Euler = _interopRequireDefault(_Euler);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _entities;

  var TrackableManager =
  /*#__PURE__*/
  function () {
    function TrackableManager() {
      _classCallCheck(this, TrackableManager);

      _entities = {};
    }

    _createClass(TrackableManager, [{
      key: "load",
      value: function load(entity) {
        if (entity instanceof _Entity["default"]) return window._native.loadEntity(entity.uri);
        return new Promise(function (resolve, reject) {
          reject('parameter is not entity');
        });
      }
    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        if (_entities[uri]) return _entities[uri];
        return null;
      }
    }, {
      key: "getEntities",
      value: function getEntities() {
        return Object.values(_entities);
      }
    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        if (_entities[uri]) return true;
        return false;
      }
    }, {
      key: "addEntity",
      value: function addEntity(entity) {
        _entities[entity.uri] = entity; // if (entity.type !== "object") {
        //     PlaceController.addEntity(entity);
        // }
      }
    }, {
      key: "removeEntity",
      value: function removeEntity(param) {
        var uri = param;

        if (param instanceof _Entity["default"]) {
          uri = param.uri;
        }

        if (this.hasEntity(uri)) {
          var entity = _entities[uri];

          if (entity.type !== 'object') {// PlaceController.removeEntity(entity);
          }

          _entities[uri].removeRenderables();

          delete _entities[uri];
        }
      }
    }, {
      key: "setEntity",
      value: function setEntity(entity) {
        var uri = entity.uri;

        if (_entities[uri]) {
          _entities[uri].setData(entity);
        } else {
          _entities[uri] = entity;
        }
      } // traverseEntity(callback: (entity: Entity) => void) {
      //   for (let entity of Object.values(this.entities)) {
      //     callback(entity);
      //   }
      // }

    }, {
      key: "setDatas",
      value: function setDatas(data) {
        var _this = this;

        if (!data) return;
        var objects = data; // const self = this;

        if (objects && objects.length > 0) {
          objects.forEach(function (object) {
            var e = object.entity;
            var currentEntity = new _Entity["default"](e.uri, e);

            _this.addEntity(currentEntity);

            var renderables = object.renderables;
            renderables.forEach(function (r) {
              var selector = r.selector,
                  translate = r.translate,
                  rotation = r.rotation;
              var elems = document.querySelectorAll(selector);
              elems.forEach(function (elem) {
                var _renderable$position;

                var renderable = new _DOMRenderable["default"](elem);

                (_renderable$position = renderable.position).set.apply(_renderable$position, _toConsumableArray(translate));

                renderable.rotation = _construct(_Euler["default"], _toConsumableArray(rotation));
                currentEntity.addRenderable(renderable);
              });
            });
          });
        } // const places = data.place;
        //
        // if (places && places.length > 0) {
        //   places.forEach(function (place) {
        //     const e = place.entity;
        //     const entity = new Entity(e.uri, e);
        //     const renderables = place.renderables;
        //
        //     if (entity.uri === 'geolocation') {
        //       entity.track = true;
        //     }
        //
        //     for (let j = 0; j < renderables.length; j += 1) {
        //       const r = renderables[j];
        //       const selector = r.selector;
        //       const pose = r.pose;
        //       const elems = document.querySelectorAll(selector);
        //
        //       for (let k = 0; k < elems.length; k += 1) {
        //         const elem = elems[k];
        //         let renderable = new GeoRenderable(elem);
        //
        //         renderable.setLocation(pose[0], pose[1], pose[2]);
        //
        //         entity.addRenderable(renderable);
        //       }
        //     }
        //   });
        // }

      }
    }]);

    return TrackableManager;
  }(); // export default new TrackableManager();
  // export default TrackableManager;


  var trackableManager = new TrackableManager();
  _exports.trackableManager = trackableManager;
});

/***/ }),

/***/ "./engine.js":
/*!*******************!*\
  !*** ./engine.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Context */ "./Context.js"), __webpack_require__(/*! ./renderer/DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ./libs/ObjectTracker */ "./libs/ObjectTracker.js"), __webpack_require__(/*! ./core/TrackableManager */ "./core/TrackableManager.js"), __webpack_require__(/*! ./core/PerspectiveCamera */ "./core/PerspectiveCamera.js"), __webpack_require__(/*! ./external/THREE */ "./external/THREE.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _DOMRenderer, _ObjectTracker, _TrackableManager, _PerspectiveCamera, _THREE) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _PerspectiveCamera = _interopRequireDefault(_PerspectiveCamera);
  _THREE = _interopRequireDefault(_THREE);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _instance; // let _config = {};


  var Engine =
  /*#__PURE__*/
  function () {
    function Engine(_config) {
      _classCallCheck(this, Engine);

      if (_instance) return _instance;
      this.config = _objectSpread({}, _config);
      console.log(this.config);
      this.camera = _construct(_PerspectiveCamera["default"], _toConsumableArray(this.config.projectionParameter));

      _Context.context.setConfig(this.config);

      _DOMRenderer.domRenderer.initRenderer(this.camera, this.config.domRendererId, this.config.zIndex, this.config.zIndexIncrement);

      _ObjectTracker.objectTracker.camera = this.camera;
      this.threeRenderer = null;

      if (this.config.external === 'THREE') {
        this.threeRenderer = new _THREE["default"](this.config.projectionParameter, this.config.zIndex, this.config.zIndexIncrement);
      }

      _TrackableManager.trackableManager.setDatas(this.config.data);

      var style = document.body.style;
      style.margin = 0;
      style.padding = 0; // document.getElementsByTagName('html')[0].removeAttribute('style');

      _instance = this;
    }

    _createClass(Engine, [{
      key: "onConfigurationChanged",
      value: function onConfigurationChanged(newConfig) {
        _Context.context.setConfig(newConfig);

        _DOMRenderer.domRenderer.updateOrientation(newConfig);

        if (config.external === 'THREE' && this.threeRenderer) this.threeRenderer.updateOrientation(newConfig);
      }
    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        return _TrackableManager.trackableManager.getEntity(uri);
      }
    }, {
      key: "getEntities",
      value: function getEntities() {
        return _TrackableManager.trackableManager.getEntities();
      }
    }, {
      key: "removeEntity",
      value: function removeEntity(uri) {
        _TrackableManager.trackableManager.removeEntity(uri);
      }
    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        return _TrackableManager.trackableManager.hasEntity(uri);
      }
    }, {
      key: "resetDomRenderable",
      value: function resetDomRenderable() {
        this.domRenderer.resetElement();
      }
    }, {
      key: "appendDomRenderable",
      value: function appendDomRenderable(element) {
        this.domRenderer.appendElement(element);
      }
    }, {
      key: "appendAllDomRenderables",
      value: function appendAllDomRenderables() {
        this.domRenderer.appendAllElements();
      }
    }, {
      key: "getThreerenderer",
      value: function getThreerenderer() {
        return this.threeRenderer;
      }
    }, {
      key: "objectTracker",
      get: function get() {
        return _ObjectTracker.objectTracker;
      }
    }, {
      key: "domRenderer",
      get: function get() {
        return _DOMRenderer.domRenderer;
      }
    }]);

    return Engine;
  }();

  _exports["default"] = Engine;
});

/***/ }),

/***/ "./entity/Entity.js":
/*!**************************!*\
  !*** ./entity/Entity.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../renderer/DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../observers/Observer */ "./observers/Observer.js"), __webpack_require__(/*! ./EntityEvent */ "./entity/EntityEvent.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util, _Object3D, _DOMRenderer, _MessageTypes, _Observer2, _EntityEvent) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D = _interopRequireDefault(_Object3D);
  _Observer2 = _interopRequireDefault(_Observer2);
  _EntityEvent = _interopRequireDefault(_EntityEvent);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var handlers = new Map([[_MessageTypes.ENTITY_EVENT.TRACK_START, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_MOVE, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_END, new Set()]]);
  /**
   * Class representing a real world object that can be detected and be associated with HTML elements.
   * @class
   * @name Entity
   * @hideconstructor
   */

  var Entity =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(Entity, _Observer);

    function Entity(uri, data) {
      var _this;

      _classCallCheck(this, Entity);

      if (!uri) throw new Error('Entity requires an entity uri');
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Entity).call(this, uri, handlers));
      _this.uri = uri;
      _this.type = data && data.type ? data.type : 'object';
      _this.name = data && data.name ? data.name : '';
      _this.image = data && data.image ? data.image : '';
      _this.size = data && data.size ? data.size : {
        width: 0,
        height: 0,
        depth: 0,
        unit: 'mm'
      };
      _this.renderables = [];
      _this.object = new _Object3D["default"]();
      _this._visible = true;
      _this._track = false;
      return _this;
    }

    _createClass(Entity, [{
      key: "setData",
      value: function setData(data) {
        this.type = data && data.type ? data.type : 'object';
        this.name = data && data.name ? data.name : '';
        this.image = data && data.image ? data.image : '';
        this.size = data && data.size ? data.size : {
          width: 0,
          height: 0,
          depth: 0,
          unit: 'mm'
        };
      }
    }, {
      key: "translateX",
      value: function translateX(value) {
        this.object.translateX(value);
        return this;
      }
    }, {
      key: "translateY",
      value: function translateY(value) {
        this.object.translateY(value);
        return this;
      }
    }, {
      key: "translateZ",
      value: function translateZ(value) {
        this.object.translateZ(value);
        return this;
      }
    }, {
      key: "rotateX",
      value: function rotateX(value) {
        this.object.rotateX(value);
        return this;
      }
    }, {
      key: "rotateY",
      value: function rotateY(value) {
        this.object.rotateY(value);
        return this;
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(value) {
        this.object.rotateZ(value);
        return this;
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.object.updateMatrix();
        return this;
      }
      /**
       * 전달된 `Renderable`을 엔터티에 등록합니다. `Renderable`은 엔터티가 증강되면 화면에 보여집니다.
       * Registers the given `Renderable` to this entity. The `Renderable` will be
       * rendered when this entity is tracked.
       * @method Entity#addRenderable
       * @param {Renderable} renderable
       * @example
       * // Create a renderable HTML element
       * // html로 만들어진 renderable을 생성합니다.
       * var helloWorldElem = document.createElement('h1');
       * helloWorldElement.appendChild(document.createTextNode('Hello World!'));
       * var helloWorld = new DOMRenderable(helloWorldElem);
       *
       * // Register the renderable to the entity
       * // renderable을 엔터티에 등록합니다.
       * entity.addRenderable(helloWorld);
       */

    }, {
      key: "addRenderable",
      value: function addRenderable(renderable) {
        if (renderable) {
          if (this.renderables.length === 0) {
            _DOMRenderer.domRenderer.add(this.object);
          }

          this.renderables.push(renderable);
          this.object.add(renderable);

          if (this.track) {
            var track = this.track;
            renderable.traverse(function (obj) {
              obj.track = track;

              if (obj.element) {
                obj.element.style.display = '';
              }
            });
          }
        }
      }
      /**
       * 전달된 `Renderable`을 엔터티에서 삭제합니다. 삭제된 `Renderable`은 더이상 화면에 표시되지 않습니다.
       * Removes the given `Renderable` from this entity's renderables.
       * The `Renderable` will no longer be rendered
       * when this entity is tracked.
       * @method removeRenderable
       * @memberof Entity.prototype
       * @param {Renderable} renderable
       */

    }, {
      key: "removeRenderable",
      value: function removeRenderable(renderable) {
        if (renderable) {
          (0, _Util.removeArrayItem)(this.renderables, renderable);
          this.object.remove(renderable);

          if (this.renderables.length === 0) {
            _DOMRenderer.domRenderer.remove(this.object);
          }
        }
      }
      /**
       * Reset all `Renderables` registered to this entity.
       * 등록된 모든 `Renderables`을 삭제합니다.
       * @method Entity#resetRenderables
       */

    }, {
      key: "resetRenderables",
      value: function resetRenderables() {
        if (this.renderables.length > 0) {
          // for (let renderable of this.renderables) {
          //   this.object.remove(renderable);
          // }
          this.renderables = [];

          _DOMRenderer.domRenderer.remove(this.object);
        }
      }
      /**
       * Returns all the Renderables of this entity.
       * 등록된 모든 `Renderables`을 반환합니다.
       * @method Entity#getAllRenderables
       * @return {Renderable[]}
       */

    }, {
      key: "getAllRenderables",
      value: function getAllRenderables() {
        return this.renderables;
      }
      /**
       * Returns the Renderable with the given `uuid`, or `null` if no such
       * Renderable exists.
       * 지정된 UUID를 가진 `Renderables`을 반환합니다. 없으면 `null`을 반환합니다.
       * @method getRenderable
       * @memberof Entity.prototype
       * @param {string} uuid
       * @return {Renderable|null}
       */

    }, {
      key: "getRenderable",
      value: function getRenderable(uuid) {
        for (var i = this.renderables.length; i >= 0; i -= 1) {
          if (this.renderables[i].uuid === uuid) {
            return this.renderables[i];
          }
        }

        return null;
      } // getScreen() {
      //   const camera = LetseeEngine.camera;
      //
      //   if (camera) {
      //     const matrix = new Matrix4();
      //     matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse.toCSS3D());
      //
      //     const v = this.object.position.clone();
      //     v.applyMatrix4(matrix);
      //
      //     const halfWidth = Context.width * 0.5;
      //     const halfHeight = Context.height * 0.5;
      //
      //     return new Vector2().set(
      //       (v.x + 1) * halfWidth,
      //       (-v.y + 1) * halfHeight
      //     );
      //
      //   } else {
      //     console.error('Camera is not initialized');
      //   }
      // }

    }, {
      key: "lookAt",
      value: function lookAt(position) {
        this.object.lookAt(position);
      }
    }, {
      key: "lootAtRenderables",
      value: function lootAtRenderables(position) {
        var _this2 = this;

        this.object.traverse(function (obj) {
          if (_this2.object !== obj) {
            obj.lookAt(position);
          }
        });
      }
    }, {
      key: "lookAtCamera",
      value: function lookAtCamera() {
        var cameraPose = LetseeEngine.camera.position;
        this.lootAtRenderables(cameraPose);
      } // addEventListener(type, listener) {
      //   eventManager.addEventListener(type, this.uri, listener);
      // }
      //
      // removeEventListener(type, callback) {
      //   eventManager.removeEventListener(type, this.uri, callback);
      // }

    }, {
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Entity.prototype), "subscribe", this)).call.apply(_get2, [this, this.uri, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(Entity.prototype), "unsubscribe", this).call(this, this.uri, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        if (event instanceof _EntityEvent["default"]) {
          _get(_getPrototypeOf(Entity.prototype), "notify", this).call(this, this.uri, type, event);
        }
      }
    }, {
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(visible) {
        this._visible = visible;
        this.object.traverse(function (obj) {
          obj.visible = visible;

          if (obj.element) {
            if (visible) {
              obj.element.style.display = '';
            } else {
              obj.element.style.display = 'none';
            }
          }
        });
      }
    }, {
      key: "track",
      get: function get() {
        return this._track;
      },
      set: function set(track) {
        this._track = track;
        this.object.traverse(function (obj) {
          obj.track = track;

          if (obj.element) {
            if (track) {
              obj.element.style.display = '';
            } else {
              obj.element.style.display = 'none';
            }
          }
        });
      }
    }, {
      key: "position",
      get: function get() {
        return this.object.position;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.object.matrix;
      }
    }, {
      key: "matrixWorld",
      get: function get() {
        return this.object.matrixWorld;
      }
    }, {
      key: "quaternion",
      get: function get() {
        return this.object.quaternion;
      }
    }, {
      key: "rotation",
      get: function get() {
        return this.object.rotation;
      }
    }, {
      key: "scale",
      get: function get() {
        return this.object.scale;
      },
      set: function set(scale) {
        if (scale) this.object.scale.setScalar(scale);
        return this;
      }
    }]);

    return Entity;
  }(_Observer2["default"]);

  _exports["default"] = Entity;
  ;
});

/***/ }),

/***/ "./entity/EntityEvent.js":
/*!*******************************!*\
  !*** ./entity/EntityEvent.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Matrix) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Matrix = _interopRequireDefault(_Matrix);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @typedef {'trackstart'|'trackmove'|'trackend'} EntityEventType
   */
  // export type EntityEventType = 'trackstart' | 'trackmove' | 'trackend';

  /**
   * @callback EntityEventListener
   * @param {EntityEvent} event
   */
  // export type EntityEventListener = (event: EntityEvent) => void;

  /**
   * @class EntityEvent
   * @classdesc Class representing feature tracking events.
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2016. 03. 23.
   * @param {string} type
   * @param {Entity} entity
   * @param {Trackable} trackable
   * @param {number[]} [matrix]
   * @param {number} [scale=1]
   * @throws {Error} Throws an error if `type` or `entity` is not specified.
   */

  /*/!**
   * The type of this track event.
   * @member {string} type
   * @memberof EntityEvent#
   *!/
  let _type;
  
  /!**
   * The target of this track event.
   * @member {Entity} target
   * @memberof EntityEvent#
   *!/
  let _target;
  
  /!**
   * A 4x4 [matrix]{@link "https://en.wikipedia.org/wiki/Matrix_(mathematics)"}
   * in a
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
   * format that represents the translation and the rotation of the entity
   * relative to the device camera.
   * @todo column vs row, rotation/translation of what relative to what
   * @member {Matrix4} matrix
   * @memberof EntityEvent#
   * @default [
   * 1, 0, 0, 0,
   * 0, 1, 0, 0,
   * 0, 0, 1, 0,
   * 0, 0, 0, 1
   * ]
   *!/
  let _matrix;
  
  /!**
   *
   * @member {Object} pixelSize
   * @memberof EntityEvent#
   * @default {
   * width: 0.0,
   * height: 0.0,
   * depth: 0,0
   * }
   *!/
  let _pixelSize = {
    width: null,
    height: null,
    depth: null
  };
  
  let _scale;*/
  var EntityEvent = function EntityEvent(type, target, matrix, pixelSize, scale) {
    _classCallCheck(this, EntityEvent);

    if (!type || !target) throw new Error('EntityEvent requires an event type and entity');
    this.type = type;
    this.target = target;
    this.matrix = matrix || new _Matrix["default"]();
    this.pixelSize = pixelSize || {
      width: 0.0,
      height: 0.0,
      depth: 0.0
    };
    this.scale = scale || 1.0;
  };

  _exports["default"] = EntityEvent;
});

/***/ }),

/***/ "./entity/EntityEventType.js":
/*!***********************************!*\
  !*** ./entity/EntityEventType.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  var EventType = {
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend'
  };
  var _default = EventType;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./external/THREE.js":
/*!***************************!*\
  !*** ./external/THREE.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Context */ "./Context.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _Matrix, _EntityObserver2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Matrix = _interopRequireDefault(_Matrix);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  var _this = void 0;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  var _type = 'LetseeThree';
  var _instance = null;
  var _renderer = null;
  var _camera = null;
  var _scene = null;
  var _autoRender = true;

  var _canvas = document.createElement('canvas');

  var LETSEE_THREE = null;

  var _entityGroup = new Map();

  var renderScene = function renderScene(event) {
    if (_autoRender) {
      // this.clear(true, true, true);
      _renderer.state.reset();

      _renderer.render(_scene, _camera); // this.onRenderCallback(event);

    }
  };

  var getThreeGroup = function getThreeGroup(uri) {
    if (_entityGroup.get(uri) == null) {
      var group = new LETSEE_THREE.Group();
      group.name = uri;

      _entityGroup.set(uri, group);

      _scene.add(group);

      return group;
    }

    return _entityGroup.get(uri);
  };

  var _addObjectToEntity = function _addObjectToEntity(uri, object) {
    var group = getThreeGroup(uri);
    group.add(object);
  };

  var _removeObjectFromEntity = function removeObjectFromEntity(uri, object) {
    if (_this.objects[uri]) {
      _this.objects[uri].remove(object);

      if (_this.objects[uri].children.length === 0) {
        delete _this.objects[uri];
      }
    }
  };

  var onTrackStartCallback = function onTrackStartCallback(e) {};

  var onTrackMoveCallback = function onTrackMoveCallback(e) {};

  var onTrackEndCallback = function onTrackEndCallback(e) {};

  var onTrackMove = function onTrackMove(e) {
    if (_entityGroup.get(e.target.uri) != null) {
      // const object = this.objects[e.target.uri];
      // const group = this.getThreeGroup(e.target.uri);
      var group = _entityGroup.get(e.target.uri);

      group.matrix.compose(group.position, group.quaternion, group.scale);
      group.matrixAutoUpdate = false; // e.event was dispatched from ObjectTracker.
      // Invert X axis was already applied at ObjectTracker

      var matrix = e.matrix;
      matrix.decompose(_camera.position, _camera.quaternion, _camera.scale);

      _camera.updateMatrix();

      var tmp = new _Matrix["default"]().getInverse(_camera.matrix);

      _camera.matrix.identity();

      _camera.applyMatrix(tmp);

      _camera.updateMatrix();

      _camera.updateMatrixWorld();

      _camera.matrixWorldInverse.getInverse(_camera.matrixWorld);

      group.visible = true;
      renderScene(e);
      onTrackMoveCallback(e);
    }
  };

  var onTrackStart = function onTrackStart(e) {
    if (_entityGroup.get(e.target.uri) != null) _entityGroup.get(e.target.uri).visible = true;
    renderScene(e);
    onTrackStartCallback(e);
  };

  var onTrackEnd = function onTrackEnd(e) {
    if (_entityGroup.get(e.target.uri) != null) _entityGroup.get(e.target.uri).visible = false;
    renderScene(e);
    onTrackEndCallback(e);
  };

  var init = function init(cameraParam, zIndex, zIndexIncrement) {
    LETSEE_THREE = window.THREE;
    _canvas.className = 'ar-renderer';
    _canvas.style.position = 'absolute';
    _canvas.style.top = 0;
    _canvas.style.left = 0;
    _canvas.style.margin = 0;
    _canvas.style.padding = 0;
    _canvas.style.zIndex = zIndex + zIndexIncrement;
    document.body.insertBefore(_canvas, document.body.firstChild);
    _camera = _construct(LETSEE_THREE.PerspectiveCamera, _toConsumableArray(cameraParam));
    _scene = new LETSEE_THREE.Scene();
    _renderer = new LETSEE_THREE.WebGLRenderer({
      alpha: true,
      canvas: _canvas
    });
    _camera.matrixAutoUpdate = false;

    _camera.lookAt(_scene.position);

    _renderer.setSize(_Context.context.screenWidth, _Context.context.screenHeight);

    _scene.add(_camera); // eventManager.addEventListener('trackmove', (e) => onTrackMove(e));
    // eventManager.addEventListener('trackstart', (e) => onTrackStart(e));
    // eventManager.addEventListener('trackend', (e) => onTrackEnd(e));

  };

  var LetseeThree =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(LetseeThree, _EntityObserver);

    function LetseeThree(param, zIndex, zIndexIncrement) {
      var _this2;

      _classCallCheck(this, LetseeThree);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(LetseeThree).call(this));
      if (!window.THREE) throw new Error('THREE is not definded. please import three.js library.');
      if (_instance) return _possibleConstructorReturn(_this2, _instance);
      init(param, zIndex, zIndexIncrement);

      _this2.subscribe('trackmove', function (e) {
        return onTrackMove(e);
      });

      _this2.subscribe('trackstart', function (e) {
        return onTrackStart(e);
      });

      _this2.subscribe('trackend', function (e) {
        return onTrackEnd(e);
      });

      _instance = _assertThisInitialized(_this2);
      return _this2;
    }

    _createClass(LetseeThree, [{
      key: "addObjectToEntity",
      value: function addObjectToEntity(uri, object) {
        _addObjectToEntity(uri, object);
      }
    }, {
      key: "entityGroup",
      value: function entityGroup(uri) {
        if (_entityGroup.get(uri) == null) {
          throw new Error('No entity group founded');
        }

        return _entityGroup.get(uri);
      }
    }, {
      key: "removeObjectFromEntity",
      value: function removeObjectFromEntity(uri, object) {
        _removeObjectFromEntity(uri, object);
      }
    }, {
      key: "updateOrientation",
      value: function updateOrientation(newConfig) {
        _renderer.setSize(newConfig.width, newConfig.height);

        _camera.aspect = newConfig.aspect;

        _camera.updateProjectionMatrix();
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }, {
      key: "camera",
      get: function get() {
        return _camera;
      }
    }, {
      key: "scene",
      get: function get() {
        return _scene;
      }
    }]);

    return LetseeThree;
  }(_EntityObserver2["default"]);

  _exports["default"] = LetseeThree;
});

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./libs/VideoManager */ "./libs/VideoManager.js"), __webpack_require__(/*! ./libs/AR3DRenderModuleManager */ "./libs/AR3DRenderModuleManager.js"), __webpack_require__(/*! ./libs/EventManager */ "./libs/EventManager.js"), __webpack_require__(/*! ./libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ./libs/CSSParser */ "./libs/CSSParser.js"), __webpack_require__(/*! ./Util */ "./Util.js"), __webpack_require__(/*! ./libs/EntityParser */ "./libs/EntityParser.js"), __webpack_require__(/*! Context */ "./Context.js"), __webpack_require__(/*! ./observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js"), __webpack_require__(/*! ./engine */ "./engine.js"), __webpack_require__(/*! ./Screen */ "./Screen.js"), __webpack_require__(/*! ./math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ./math/Matrix3 */ "./math/Matrix3.js"), __webpack_require__(/*! ./math/Vector2 */ "./math/Vector2.js"), __webpack_require__(/*! ./math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ./core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ./entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ./entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ./renderer/DOMRenderable */ "./renderer/DOMRenderable.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _VideoManager, _AR3DRenderModuleManager, _EventManager, Message, _CSSParser, _Util, _EntityParser, _Context, _EntityObserver, _engine, _Screen, _Matrix, _Matrix2, _Vector, _Vector2, _Quaternion, _Euler, _Object3D, _Entity, _EntityEvent, _DOMRenderable) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.letsee = void 0;
  _VideoManager = _interopRequireDefault(_VideoManager);
  _AR3DRenderModuleManager = _interopRequireDefault(_AR3DRenderModuleManager);
  _EventManager = _interopRequireDefault(_EventManager);
  Message = _interopRequireWildcard(Message);
  _EntityParser = _interopRequireDefault(_EntityParser);
  _EntityObserver = _interopRequireDefault(_EntityObserver);
  _engine = _interopRequireDefault(_engine);
  _Screen = _interopRequireDefault(_Screen);
  _Matrix = _interopRequireDefault(_Matrix);
  _Matrix2 = _interopRequireDefault(_Matrix2);
  _Vector = _interopRequireDefault(_Vector);
  _Vector2 = _interopRequireDefault(_Vector2);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _Object3D = _interopRequireDefault(_Object3D);
  _Entity = _interopRequireDefault(_Entity);
  _EntityEvent = _interopRequireDefault(_EntityEvent);
  _DOMRenderable = _interopRequireDefault(_DOMRenderable);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /* letseeEngine에 넘겨줄 인자를 객체로 따로 만들지 않고, 해당 값을 관리하는 멤버 객체를 Letsee Class에서 쥐고 있으면
     letseeEngine에서 직접 그 값을 참조하여 사용하도록 변경합시다. by ahn */
  var _letseeEngineConfig = {
    runType: 'BROWSER',
    width: null,
    height: null,
    orientation: null,
    data: null,
    projectionParameter: null,
    external: null
  };
  /* validateConfig라고 되어 있는데 그냥 사용자 설정에 대한 기본값 지정해 주는 함수이군요. 이런 경우 Config or Settings Class를
    따로 만들어 그 안에 관련 parser와 validation 로직을 담는 게 어떨까 합니다. by ahn */

  var validateConfig = function validateConfig(_config) {
    var config = {
      appKey: "".concat("ad32ab3e5ab12c7d4e0774009eacd045:29640916e9a511a273705825d8d3f05fd9d093a3ba6588e4fcb4da9a03fcde89e7c31f9d6f16f1f9e11a79031b830f4b4c6215bd1f87d076b39ada3460ee180a763e7e5f77fa7ad5173a03ad109dd266"),
      trackerType: _config.trackerType || 'IMAGE',
      external: null,
      cameraParameter: {
        fov: 50,
        near: 0.1,
        far: 2000
      },
      zIndex: 100,
      zIndexIncrement: 10
    };
    if (_config.type) config.trackerType = _config.type;
    if (_config.external) config.external = _config.external;

    if (_config.cameraParameter) {
      if (_config.cameraParameter.fov && _config.cameraParameter.near && _config.cameraParameter.far) {
        config.cameraParameter = _config.cameraParameter;
      } else {
        throw new Error('fov, near, far are mandatory field.');
      }
    } // @author treetory : LOCAL 환경일 때, 앱키를 받아오는 것이 있으면 설정하고, 없으면 기본키 사용?


    if (true) {
      if (_config.appKey) config.appKey = _config.appKey;
      if (_config.videoUrl) config.appKey = _config.appKey;
      if (_config.debug) config.appKey = _config.appKey;
    }

    if (typeof _config.zIndex === 'number') config.zIndex = _config.zIndex;
    if (typeof _config.zIndexIncrement === 'number') config.zIndexIncrement = _config.zIndexIncrement;

    if (_config.bodyId) {
      config.bodyId = _config.bodyId;
      _Context.context.bodyId = _config.bodyId;
    } else {
      config.bodyId = _Context.context.bodyId;
    }

    config.domRendererId = _Context.context.domRendererId;
    config.videoId = _Context.context.videoContainerId;
    return config;
  }; // render module end

  /**
   * @typedef {("IMAGE"|"MARKER"|"QRCODE")} TrackerType - 사용 가능한 트랙커 타입
   */

  /**
   * @typedef {object} EntityEvent
   * @property {"trackstart"|"trackmove"|"trackend"} type - 현재 트랙킹 상태
   * @property {object} matrix
   * @property {Array} matrix.elements
   * @property {number} scale
   * @property {object} pixelSize
   * @property {number} pixelSize.width
   * @property {number} pixelSize.height
   * @property {number} pixelSize.depth
   * @property {("mm")} pixelSize.unit
   * @property {Entity} target
   */

  /**
   * @typedef {object} LetseeStatus
   * @property {number} code - 상태 코드
   * @property {string} message - 상태 메세지
   * @description
   * LetseeStatus는 Letsee Engine 작동중 발생하는 각종 상태 변경이나 예외 상황을 정의한 코드를 나타냅니다.
   * 상태 코드와 설명 메시지는 아래의 표와 같습니다.
   *
   * |CODE |MESSAGE  |
   * |---  |---  |
   * |101  | Use chrome with ios|
   * |102  | Unsupported browser|
   * |103  | No camera detected|
   * |104  | No mobile device detected|
   * |200  | Camera initialize start|
   * |201  | Camera initialize done|
   * |202  | Video start|
   */

  /**
   * Letsee 객체를 생성합니다.
   * @class
   * @name Letsee
   * @param {object} config - 렛시 콘피그
   * @param {string} config.appKey - Letsee Web AR SDK 인증 키
   * @param {TrackerType} config.trackerType - 트랙커 타입
   * @returns {Letsee}
   */


  var Letsee =
  /*#__PURE__*/
  function () {
    // LetseeObserver는 EventManager로 분리 독립시킨 뒤 Letsee의 멤버 객체로 관리한다. by ahn
    function Letsee() {
      _classCallCheck(this, Letsee);

      console.log('Letsee is constructed!'); // 추후 좀 더 친절한 메시지로 보완합시다. by ahn

      this.VERSION = '0.9.20.0028';
      this.VERSION_STRING =  true ?  true ? "VERSION: ".concat(this.VERSION, "_local") : undefined : undefined; // eslint-disable-next-line max-len

      this.refImageData = null; // 로딩한 Entity 객체의 속성으로 지정된 이미지인데 EntityManager에서 로드한 이미지 blob을 Tracker에서 가져가면 되니 여기선 관리할 필요가 없음 by ahn

      this._isPause = false; // 엔진의 일시정지 상태를 관리하는 변수로 보이는데 아님 getter/setter 인가? 변수이면 그에 맞는 네이밍을 하자 by ahn

      this._updateFlag = false; // 이것도 뭐하는데 쓰는지 아직은 모르겠음 Flag의 역할을 하는 건가? by ahn

      this.videoLoadFlag = false;
      this.firstLoadFlag = false;
      this.barcodeReadFlag = false;
      this.state = null; // 이거 뭐하는데 쓰는지 아직은 모르겠음 변수명으로 추정이 안됨 by ahn

      this.config = {};
      this.cssData = null; // CSSParser에 넘기는 소스인건가 아님 파싱된 결과인건가 근데 Letsee Class가 저장하고 관리해야 하는 건가??? by ahn

      this.promiseChain = []; // 뉘신지? T_T by ahn

      this.arScreen = {}; // OK by ahn

      this.entityManager = null; // 귀하게 모시자 by ahn

      this.videoManager = null; // 얘도 정중히 모시자 귀인이시다 by ahn

      this.AR3DRenderModuleManager = null; // 얜 뭐지? EntityManager와 뭐가 다르지? Entity별 Event 관리하는 것이라면 TrackerManager에서 EventManager로 전달되어야 할 듯 by ahn

      this.entityObserver = null;
      this.eventManager = null;
      this.tracker = null;
      this.fps = 30;
      this.fpsInterval = 1000 / this.fps;
      this.now = null;
      this.then = Date.now();
      this.elapsed = null;
    }
    /* 결론: prepare의 내용들은 constructor 또는 init로 나누고 정리하는 게 맞지 않을까? 한번 더 고민....by ahn */


    _createClass(Letsee, [{
      key: "prepare",
      value: function prepare(_config) {
        var _this = this;

        this.Matrix4 = _Matrix["default"];
        this.Matrix3 = _Matrix2["default"];
        this.Vector2 = _Vector["default"];
        this.Vector3 = _Vector2["default"];
        this.Quaternion = _Quaternion["default"];
        this.Euler = _Euler["default"];
        this.Object3D = _Object3D["default"];
        this.Entity = _Entity["default"];
        this.EntityObserver = _EntityEvent["default"];
        this.DOMRenderable = _DOMRenderable["default"];
        document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADING); // 로딩메시지에 대한 거? by ahn

        (0, _Util.addViewport)(); // ARWebApp의 viewport를 AR에 적합하게 조정해줌. user define과 값이 다르면 어떻게 되지? by ahn

        (0, _Util.createLetseeWrapper)(); // LetseeWrapper가 뭔가요? by ahn

        (0, _Util.createLoader)(); // createLoader는 무엇을 가져오는 로더를 만드나요? loader가 한두개냐...만든거 어디에 있나요? by ahn

        this.entityManager = new _EntityParser["default"](); // prepare와 init 단계가 명확히 구분되지 않아여. 이거 constructor에서 생성해서 넣어주면 왜 안돼요? by ahn

        this.videoManager = new _VideoManager["default"](); // 얘는 왜 안돼요? 일반적으로 Class constructor가 멤버 변수 초기화 하는 로직 들어가는데... by ahn

        /* 아래 구문은 videoManager가 초기화 될 때 등록해야 하는 거 아니에요? by ahn*/

        this.videoManager.subscribe(Message.LETSEE_EVENT.ON_STATUS, function (e) {
          // this.notify(LETSEE_EVENT.ON_STATUS, e);
          if (e.code === 202) _this.videoLoadFlag = true;
          if (e.status === 'error') (0, _Util.createStatusScreen)(e.code);
        });
        this.AR3DRenderModuleManager = new _AR3DRenderModuleManager["default"]();
        this.eventManager = new _EventManager["default"](); // @author treetory : LOCAL 환경일 때, validate 하는 것이 조건이 달라지게 하면 되지 않을까?
        // @author ahn : Settings 클래스로 따로 빼는건 어때요?

        this.config = validateConfig(_config);
        document.querySelector('body').setAttribute('id', this.config.bodyId); // 이건 왜 하나요? by ahn

        document.body.classList.add(Message.LETSEE_CSS.AR_MODE_ON); // 이건 무슨 일을 하나요? by ahn

        /* Start dom place holder
          domPlaceholder는 무엇이냐? 너 Letsee Class에 있어야 하는 놈이냐? by ahn */

        var domPlaceholder = document.createElement('div');
        domPlaceholder.id = _Context.context.placeholderId;
        domPlaceholder.style.setProperty('display', 'none', 'important');
        document.body.appendChild(domPlaceholder); // End dom place holder

        this.cssData = _CSSParser.cssParser.parse(this.config.bodyId); // 네 cssData는 cssParser의 산출물이십니다. by ahn

        this.entityObserver = new _EntityObserver["default"](); // 초기화 구문은 위쪽으로 몰아서 정리하죠 by ahn

        /* 아래 entityObserver.subscribe 부분은 EventManager와의 관계로 입장 정리 가능할듯? by ahn */

        this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_START, function (e) {// this.eventManager.notify(ENTITY_EVENT.TRACK_START, e);
          // this.trackStatusCss(ENTITY_EVENT.TRACK_START);
        });
        this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_MOVE, function (e) {// this.eventManager.notify(LETSEE_EVENT.TRACK_MOVE, e);
          // this.trackStatusCss(ENTITY_EVENT.TRACK_MOVE);
        });
        this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_END, function (e) {// this.eventManager.notify(LETSEE_EVENT.TRACK_END, e);
          // this.trackStatusCss(ENTITY_EVENT.TRACK_END);
        });
        /* 음..여기서 loadImage를 하네요. checkEntity는 EntityManager로 편입하는 게 어때요? by ahn */

        var checkEntity = new Promise(function (resolve, reject) {
          _this.entityManager.initEntity(_this.cssData).then(function (obj) {
            _this.state = obj;

            if (_this.config.trackerType === 'IMAGE') {
              (0, _Util.loadImage)(_this.state[0].entity.image).then(function (result) {
                _this.refImageData = result;
                resolve(_this.refImageData);
              })["catch"](function (error) {
                reject(error);
              });
            } else {
              resolve(null);
            }
          })["catch"](function (error) {
            reject(error);
          });
        });
        /* checkEnv는 무엇입니까? screen 등 기본 정보는 각 source 객체에서 지가 직접 가져가면 되지. 그렇지 Engine? 그리고 넌 이제 Engine이 아니야 by ahn */

        var checkEnv = new Promise(function (resolve, reject) {
          _this.videoManager.init(_this.config.zIndex, _this.config.zIndexIncrement).then(function (_screenSize) {
            _this.arScreen = new _Screen["default"](_screenSize.width, _screenSize.height, _this.videoManager);
            _letseeEngineConfig.width = _this.videoManager.screenInfo.width;
            _letseeEngineConfig.height = _this.videoManager.screenInfo.height;
            _letseeEngineConfig.orientation = _this.videoManager.screenInfo.angle;
            _letseeEngineConfig.data = _this.cssData;
            _letseeEngineConfig.domRendererId = _this.config.domRendererId;
            _letseeEngineConfig.zIndex = _this.config.zIndex;
            _letseeEngineConfig.zIndexIncrement = _this.config.zIndexIncrement;
            _letseeEngineConfig.projectionParameter = [_this.config.cameraParameter.fov, _this.videoManager.screenInfo.screenAspectRatio, _this.config.cameraParameter.near, _this.config.cameraParameter.far];
            _letseeEngineConfig.external = _this.config.external || null;
            _this.engine = new _engine["default"](_letseeEngineConfig);

            _this.eventManager.addEngine(_this.engine);

            _this.AR3DRenderModuleManager.addEngine(_this.engine); // this.dispatchEntityEvent();


            resolve();
          })["catch"](function (error) {
            console.warn(error);
            reject(error);
          });
        });
        /* 별도 분리된 Tracker.js 파일을 로드하는 거? 필요함? by ahn */

        var checkScript = new Promise(function (resolve, reject) {
          var script = document.createElement('script');

          switch (_this.config.trackerType) {
            default:
            case 'IMAGE':
              script.src = "".concat("../../lib/").concat("ImageTracker.0.9.10.js");
              break;

            case 'MARKER':
              script.src = "".concat("../../lib/").concat("MarkerTracker.0.9.6.js");
              break;

            case 'QRCODE':
              script.src = "".concat("../../lib/").concat("QrTracker.0.9.4.js");
              break;
          } // if (type !== 'SLAM') {


          document.body.append(script); // Exposed Tracker from webpack

          script.onload = function () {
            return resolve(new Tracker(_this));
          };

          script.onerror = function () {
            return reject(new Error("Script load error for ".concat(src)));
          }; // } else if (type === 'SLAM') {
          //   resolve(new Slam());
          // }

        });
        /* 이거 아직도 모르겠어요 by ahn */

        this.promiseChain = [checkEntity, checkEnv, checkScript];
        /* 자, orientationchange 이벤트가 발생했을 때 videoManager에 있는 스크린 상태값을 EngineConfig에 퍼나릅니다.
          바보같아요...이제는 Engine에서 letsee.screen을 구독해서 직접 알아가는 게 좋겠어요
        window.addEventListener('orientationchange', e => {
          if (this.tracker) this.tracker.stopTracker = true;
          this.videoManager.orientationChange();
          _letseeEngineConfig.width = this.videoManager.screenInfo.width;
          _letseeEngineConfig.height = this.videoManager.screenInfo.height;
          _letseeEngineConfig.orientation = this.videoManager.screenInfo.angle;
          _letseeEngineConfig.projectionParameter =
              [
                this.config.cameraParameter.fov,
                this.videoManager.screenInfo.screenAspectRatio,
                this.config.cameraParameter.near,
                this.config.cameraParameter.far
              ];
          this.engine.onConfigurationChanged({
            'width': _letseeEngineConfig.width,
            'height': _letseeEngineConfig.height,
            'orientation': _letseeEngineConfig.angle,
            'aspect': this.videoManager.screenInfo.screenAspectRatio
          });
          if (this.tracker) this.tracker.stopTracker = false;
          // this.dispatch(Message.EVENT_APP_ROTATIONCHANGE, e);
          this.eventManager.notify(LETSEE_EVENT.ROTATION_CHANGE, e);
        });
        */

        window.addEventListener('resize', function (ev) {
          console.log('resize');

          if (_this.videoManager.screen !== undefined) {
            _this.videoManager.screen.fitWidthAndHeight();
          }
        });
        console.log('Letsee is prepared!!!');
      }
      /* 결국 init은 tracker 하나만 다루고 마네요. tracker를 위한 init이군요. */

    }, {
      key: "init",
      value: function init(config, callback) {
        var _this2 = this;

        this.eventManager.onLoad(callback);
        return new Promise(function (resolve, reject) {
          _this2.config = validateConfig(config);
          console.log(_this2.config);
          Promise.all(_this2.promiseChain).then(function (value) {
            _this2.tracker = value[2];
            return _this2.tracker.initTracker(_this2.videoManager.videoElement, _this2.videoManager.canvasElement, _this2.config.appKey);
          }).then(function () {
            // frameByteAddress = tracker.updateScreen(this.videoManager.screenWidth, this.videoManager.screenHeight);
            // if (this.config.trackerType === 'IMAGE') this.setReferenceImage(refImageData.img);
            if (_this2.config.trackerType === 'IMAGE') {
              _this2.tracker.setRefImage(_this2.refImageData.img);
            }

            if (_this2.config.trackerType === 'MARKER') {
              _this2.tracker.createMarkerState(_this2.entityManager.markerList || null);
            }

            if (_this2.config.trackerType === 'QRCODE') {
              _this2.tracker.createMarkerState(_this2.entityManager.codeList || null);
            } // if (this.config.trackerType === 'SLAM') tracker.createMarkerState(this.entityManager.codeList || null);


            _this2.renderAllTask();

            resolve();
          })["catch"](function (error) {
            console.log(error);
            reject(error);
          });
        });
      }
      /* 무슨 일을 하는지 모르겠습니다. 돌아는 가는데 안보이게만 하는 거네요? */

    }, {
      key: "pause",
      value: function pause() {
        this._isPause = true;
        document.body.classList.remove(Message.LETSEE_CSS.AR_MODE_ON);
        document.body.classList.add(Message.LETSEE_CSS.AR_MODE_OFF);
        document.body.classList.remove(Message.ENTITY_EVENT.TRACK_START, Message.ENTITY_EVENT.TRACK_MOVE, Message.ENTITY_EVENT.TRACK_END);
        this.videoManager.container.style.display = 'none';
      }
      /* 이것도 안보이던거 보이게만 하는...? by ahn */

    }, {
      key: "resume",
      value: function resume() {
        document.body.classList.add(Message.LETSEE_CSS.AR_MODE_ON);
        document.body.classList.remove(Message.LETSEE_CSS.AR_MODE_OFF);
        this.videoManager.container.style.display = 'block';
        this._isPause = false;
      }
    }, {
      key: "renderAllTask",

      /* 메인 룹 */
      value: function renderAllTask() {
        var _this3 = this;

        // calc elapsed time since last loop
        this.now = Date.now();
        this.elapsed = this.now - this.then; // if enough time has elapsed, draw the next frame

        if (this.elapsed > this.fpsInterval) {
          // Get ready for next frame by setting then=now, but also adjust for your
          // specified fpsInterval not being a multiple of RAF's interval (16.7ms)
          this.then = this.now - this.elapsed % this.fpsInterval; // @author treetory 아래 코드 넣으면 동작안됨 -> 코로이 진행 중, 갑자기 발생한 것임
          // this.AR3DRenderModuleManager.renderModules.forEach(val => val(performance.now()));

          if (doCapture !== undefined) {
            if (this.barcodeReadFlag) {
              doCapture();
            }
          }

          this.tracker.processFrame(this._isPause);
        }

        if (this.videoLoadFlag && !this.firstLoadFlag) {
          // 이부분....뭐지 by ahn
          this.firstLoadFlag = true;
          document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADED);
          document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);
          var checkLoader = setTimeout(function () {
            document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADED);
            document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);

            _this3.eventManager.notify(Message.EVENT_APP_ONLOAD);

            clearTimeout(checkLoader);
          }, 2000);
        }

        ;
        window.requestAnimationFrame(function () {
          _this3.renderAllTask();
        });
      }
      /* 이것도 뭔지 모르겠습니다. by ahn */

    }, {
      key: "trackStatusCss",
      value: function trackStatusCss(status) {
        document.body.classList.remove(Message.ENTITY_EVENT.TRACK_START, Message.ENTITY_EVENT.TRACK_MOVE, Message.ENTITY_EVENT.TRACK_END);
        document.body.classList.add(status);
      }
    }, {
      key: "setLoadingScreen",

      /**
       * 커스텀 로딩 화면을 등록합니다. 전달된 html 소스는 `id=letseeLoaderWrapper`인 `div`태그에 추가됩니다.
       * @method Letsee#setLoadingScreen
       * @param {string} html - 사용할 로딩 화면의 html 코드
       * @param {Array} css - 입력한 html코드를 위한 css
       * @example
       * // string형태로 html코드를 생성합니다.
       * const customLoader = "<p><span>Loading...</span></p>";
       * // css를 string으로 생성하고 Array에 담습니다.
       * const customLoaderCss = [
       * `#letseeLoaderWrapper p {
       *    position: absolute;
       *    left: 50%;
       *    top: 50%;
       *    transform: translate(-50%, -50%);
       *  }`,
       * `#letseeLoaderWrapper p span {
       *    color: #666666;
       * }`];
       * // html과 css를 등록합니다.
       * myApp.setLoadingScreen(customLoader, customLoaderCss);
       */
      value: function setLoadingScreen(html, css) {
        // 이게 최선인가요? by ahn
        if (!!html && !!css) (0, _Util.createLoader)(html, css);else console.log('You need setup both html and css');
      }
      /**
       * 등록된 모든 엔터티를 반환합니다.
       * @method Letsee#getEntities
       * @returns {Array}
       */

    }, {
      key: "getAllEntities",
      value: function getAllEntities() {
        // EntityManager를 통해서 접근하면 됨 by ahn
        return (0, _Util.isNil)(this) ? new Error('Run letsee.init first') : this.engine.getEntities();
      }
      /**
       * 주어진 uri를 가진 엔터티를 반환합니다.
       * @method Letsee#getEntity
       * @param {string} uri
       * @returns {Entity} Entity
       */

    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        // EntityManager를 통해서 접근하면 됨 by ahn
        return (0, _Util.isNil)(this) ? new Error('Run letsee.init first') : this.engine.getEntity(uri);
      }
      /**
       * 지정된 uri를 가진 엔터티를 삭제합니다.
       * @method Letsee#removeEntity
       * @param {string} uri
       */

    }, {
      key: "removeEntity",
      value: function removeEntity(uri) {
        // EntityManager를 통해서 접근하면 됨 by ahn
        return (0, _Util.isNil)(this) ? new Error('Run letsee.init first') : this.engine.removeEntity(uri);
      }
      /**
       * 지정된 uri를 가진 엔터티가 있는지 확인합니다.
       * @method Letsee#hasEntity
       * @param {string} uri
       * @returns {boolean}
       */

    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        // EntityManager를 통해서 접근하면 됨. by ahn
        return (0, _Util.isNil)(this) ? new Error('Run letsee.init first') : this.engine.hasEntity(uri);
      }
      /**
       * Letsee Web AR SDK의 버전을 반환합니다.
       * @member {string} Letsee#version
       * @readonly
       */

    }, {
      key: "isPause",
      get: function get() {
        return this._isPause;
      }
    }, {
      key: "version",
      get: function get() {
        // 어짜피 이렇게 가져갈 꺼면서 왜 const를 만드나요? by ahn
        return VERSION_STRING;
      }
      /* 음 이건 어떠한 경우에 쓰이나요? by ahn */

    }, {
      key: "cssSelector",
      get: function get() {
        if ((0, _Util.isNil)(this)) {
          return new Error('Run letsee.init first');
        }

        return {
          bodyId: this.config.bodyId,
          domRendererId: this.config.domRendererId,
          videoId: this.config.videoId
        };
      }
    }]);

    return Letsee;
  }(); // export default Letsee;


  var letsee = new Letsee({});
  _exports.letsee = letsee;
  window.letsee = letsee;
  document.addEventListener('DOMContentLoaded', function (event) {
    console.log('DOM is ready.');
    letsee.prepare({});
  });
});

/***/ }),

/***/ "./libs/AR3DRenderModuleManager.js":
/*!*****************************************!*\
  !*** ./libs/AR3DRenderModuleManager.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var renderModule = new Map();

  var AR3DRenderModuleManager =
  /*#__PURE__*/
  function () {
    function AR3DRenderModuleManager() {
      _classCallCheck(this, AR3DRenderModuleManager);

      // 이거 아직은 사용하지 않는 것으로 아는데, DOMRenderer와 ThreeRenderer등 외부 렌더링 엔진과 연동되는 모듈들이 호출될 목록 by ahn
      // this.renderModule = new Map();
      this.engine = null;
    }

    _createClass(AR3DRenderModuleManager, [{
      key: "addEngine",
      value: function addEngine(_engine) {
        this.engine = _engine;
      }
      /**
       * 렌더링시에 작동할 커스텀 모듈을 등록합니다. 등록된 모듈은 Letsee의 렌더링 루프에 맞추어 실행됩니다.
       * @method Letsee#addRenderModule
       * @param {object} moduleObject
       * @param {string} moduleObject.name - 커스텀 모듈의 이름입니다. 유니크하여야 합니다.
       * @param {Function} moduleObject.onRender - 실행될 렌더 모듈 입니다.
       * @param {number} moduleObject.onRender.tick - ms단위로 반환되는 시간입니다.
       * @returns {boolean}
       * @example
       * const customModule = (tick) => console.log(tick);
       * myApp.addRenderModule({
       *     name: 'myCustomModule',
       *     onRender: customModule
       * });
       */

    }, {
      key: "addRenderModule",
      value: function addRenderModule(moduleObject) {
        // 8thwall 따라한 거긴 한데...단순 호출만 되는 건 문제입니다. by ahn
        return function (moduleObject) {
          if (!!moduleObject.name && !!moduleObject.onRender) {
            if (typeof moduleObject.onRender !== 'function') {
              console.log('Render Module\'s action is function');
              return false;
            }

            if (renderModule.has(moduleObject.name)) {
              console.log('Duplicate module name');
              return false;
            }

            renderModule.set(moduleObject.name, moduleObject.onRender);
          } else {
            console.log('You must set name and onRender');
            return false;
          }

          return true;
        }(moduleObject);
      }
      /**
       * 해당 이름을 가진 렌더 모듈을 삭제합니다.
       * @method Letsee#removeRenderModule
       * @param {string} name - 삭제하고자 하는 모듈 이름
       */

    }, {
      key: "removeRenderModule",
      value: function removeRenderModule(name) {
        // 이것도 세트이지요. by ahn
        return function (name) {
          var flag = false;

          if (!!name && renderModule.has(name)) {
            renderModule["delete"](name);
            flag = true;
          }

          return flag;
        }(name);
      }
      /**
       * 등록된 모든 렌더 모듈을 삭제합니다.
       * @method Letsee#resetRenderModules
       */

    }, {
      key: "resetRenderModules",
      value: function resetRenderModules() {
        // 이게 필요한건가?
        return function () {
          renderModule.clear();
        }();
      }
      /**
       * 등록된 렌더 모듈을 반환합니다.
       * @member {Array} Letsee#renderModule
       * @readonly
       */

    }, {
      key: "renderModules",
      get: function get() {
        // render module을 선언하려면 어떻게 해야 하나요?
        console.log(renderModule);
        return function () {
          (function (renderModuleMap) {
            var obj = {};
            renderModuleMap.forEach(function (v, k) {
              obj[k] = v;
            });
            return obj;
          });
        }(renderModule);
      }
      /**
       * three.js의 `WebglRenderer`를 취득합니다.
       * @member {THREE.WebglRenderer} Letsee#threeRenderer
       * @readonly
       */

    }, {
      key: "threeRenderer",
      get: function get() {
        // 이건 RenderModule로 만들어 지는 것일텐데? by ahn
        return this.engine.threeRenderer;
      }
    }]);

    return AR3DRenderModuleManager;
  }();

  ;
  var _default = AR3DRenderModuleManager;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./libs/CSSParser.js":
/*!***************************!*\
  !*** ./libs/CSSParser.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cssParser = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // const HTTP = '&@http@;';
  // const HTTPS = '&@https@;';
  var ATTR_TRANSLATE = 'translate';
  var ATTR_ROTATE = 'rotate';
  var PROPERTY_TARGET = '-letsee-target';
  var PROPERTY_TRANSFORM = '-letsee-transform';
  var ANGLE_UNIT = {
    degree: 'deg',
    radian: 'rad',
    turn: 'turn',
    gradian: 'grad'
  };
  var TRANSLATE_REG = new RegExp("".concat(ATTR_TRANSLATE, "(.[0-9,.-]+)"), 'g');
  var ROTATE_REG = new RegExp("".concat(ATTR_ROTATE, "(.([0-9,.-]|").concat(ANGLE_UNIT.degree, "|").concat(ANGLE_UNIT.radian, "|").concat(ANGLE_UNIT.turn, "|").concat(ANGLE_UNIT.gradian, ")+)"), 'g'); // eslint-disable-line

  var URI_REG = /uri\(['"].[^'|"]+['"]\)/g; // const URI_REG = /uri\(('|")(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+('|")\)/g;

  /**
   * @class CSSParser
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2017. 03. 10.
   */

  var CSSParser =
  /*#__PURE__*/
  function () {
    function CSSParser() {
      _classCallCheck(this, CSSParser);

      this.dataMap = {};
      this.domRendererId = null;
    }
    /**
     * @method parse
     * @memberof CSSParser.prototype
     * @return {[type]} [description]
     */


    _createClass(CSSParser, [{
      key: "parse",
      value: function parse(id) {
        this.dataMap = {};
        this.domRendererId = id;
        var styleTags = document.getElementsByTagName('style');

        for (var i = 0; i < styleTags.length; i += 1) {
          var tag = styleTags[i];

          if (tag.media === 'place') {
            var style = this.removeComment(tag.innerHTML);
            this.parseData(style);
            this.removeMedia(tag, style);
          }
        }

        return Object.values(this.dataMap);
      }
      /**
       * @method removeComment
       * @memberof CSSParser
       * @param  {string} text
       * @return {string}
       */

    }, {
      key: "removeComment",
      value: function removeComment(text) {
        return text.replace(/\/\*(.|[\r\n])*?\*\//g, '');
      }
      /**
       * @method parseData
       * @memberof CSSParser.prototype
       * @param  {string} text
       */

    }, {
      key: "parseData",
      value: function parseData(text) {
        var _this = this;

        var styles = text.split('}');
        styles.pop();
        styles.forEach(function (style) {
          var seperateStyle = style.split('{');
          var selector = seperateStyle[0].trim();
          var propertyValues = seperateStyle[1].split(';');
          var renderable = {
            selector: selector,
            translate: [0.0, 0.0, 0.0],
            rotation: [0, 0, 0]
          };
          var entity = null;
          propertyValues.pop();
          propertyValues.forEach(function (prop) {
            prop = prop.trim().replace(/\s/g, '');
            var key = prop.substring(0, prop.indexOf(':'));
            var value = prop.substring(prop.indexOf(':') + 1);

            switch (key) {
              case PROPERTY_TARGET:
                var parseValue = _this.parseTarget(value);

                entity = {
                  type: parseValue[0],
                  uri: parseValue[1]
                };
                break;

              case PROPERTY_TRANSFORM:
                var _this$parsePosition = _this.parsePosition(value),
                    translate = _this$parsePosition.translate,
                    rotate = _this$parsePosition.rotate;

                renderable.translate[0] = translate[0];
                renderable.translate[1] = translate[1];
                renderable.translate[2] = translate[2];
                renderable.rotation[0] = rotate[0];
                renderable.rotation[1] = rotate[1];
                renderable.rotation[2] = rotate[2]; // if (container === 'geo') {
                //   entity = {
                //     type: 'geo',
                //     uri: 'geolocation'
                //   };
                // }

                break;
            }
          });

          if (entity) {
            if (!_this.dataMap[entity.uri]) {
              _this.dataMap[entity.uri] = {
                entity: entity,
                renderables: []
              };
            }

            var data = _this.dataMap[entity.uri]; // TODO: get entity description

            data.entity = entity;
            data.renderables.push(renderable);
          }
        });
      }
    }, {
      key: "parseTarget",
      value: function parseTarget(value) {
        var str = value.replace(/\s/g, '');
        var uri = str.match(URI_REG) ? str.match(URI_REG)[0].replace(/uri\(['"]|['"]\)/g, '') : '';
        return ['object', uri];
      }
      /**
       * @method parseValue
       * @memberof CSSParser
       * @param  {string} value
       * @return {{rotate: Array, translate: Array}}
       */

    }, {
      key: "parsePosition",
      value: function parsePosition(value) {
        var str = value.replace(/\s/g, '');
        var propPosition = str.match(TRANSLATE_REG) ? str.match(TRANSLATE_REG)[0].replace(new RegExp("".concat(ATTR_TRANSLATE, "\\(|\\)"), 'g'), '') : ''; // eslint-disable-line

        var propRotation = str.match(ROTATE_REG) ? str.match(ROTATE_REG)[0].replace(new RegExp("".concat(ATTR_ROTATE, "\\(|\\)"), 'g'), '') : ''; // eslint-disable-line

        return {
          translate: !!propPosition ? _toConsumableArray(this.getTranslate(propPosition)) : [0, 0, 0],
          // eslint-disable-line
          rotate: !!propRotation ? _toConsumableArray(this.getRotation(propRotation)) : [0, 0, 0] // eslint-disable-line

        };
      }
    }, {
      key: "getTranslate",
      value: function getTranslate(values) {
        return values.split(',').map(function (value) {
          if ((0, _Util.isNull)(value.match(/[0-9]/))) throw new Error('Numeric value not provided');
          return parseFloat(value);
        });
      }
    }, {
      key: "getRotation",
      value: function getRotation(values) {
        return values.split(',').map(function (value) {
          if (value.match(new RegExp(ANGLE_UNIT.degree))) return parseFloat(value.replace(ANGLE_UNIT.degree, '')) * (Math.PI / 180); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.radian))) return parseFloat(value.replace(ANGLE_UNIT.radian, '')); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.gradian))) return parseFloat(value.replace(ANGLE_UNIT.gradian, '')) * 360 / 400 * (Math.PI / 180); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.turn))) return parseFloat(value.replace(ANGLE_UNIT.turn, '')) * 360 * (Math.PI / 180); // eslint-disable-line

          if ((0, _Util.isNull)(value.match(/[0-9]/))) throw new Error('Numeric value not provided');
          throw new Error("Allowed unit are \"".concat(ANGLE_UNIT.degree, "\", \"").concat(ANGLE_UNIT.radian, "\", \"").concat(ANGLE_UNIT.gradian, "\", \"").concat(ANGLE_UNIT.turn, "\".")); // eslint-disable-line
        });
      }
    }, {
      key: "splitAndRemoveTail",
      value: function splitAndRemoveTail(value, separatorm, remove) {
        var tempArray = value.replace(remove, '');
        tempArray.split(separator);
        return tempArray;
      }
      /**
       * @method getBase
       * @memberof CSSParser
       * @return {string}
       */

    }, {
      key: "getBase",
      value: function getBase() {
        var url = window.location.href;
        var pathArray = url.split('/');
        var last = pathArray[pathArray.length - 1];

        if (last.indexOf('.html') > -1) {
          pathArray.pop();
        }

        var base = pathArray.join('/');

        if (base.substr(base.length - 1) !== '/') {
          base += '/';
        }

        return base;
      }
      /**
       * @method removeMedia
       * @memberof CSSParser
       * @param  {Element} tagElem
       * @param style
       */

    }, {
      key: "removeMedia",
      value: function removeMedia(tagElem, style) {
        var _this2 = this;

        var head = document.head;
        var newStyle = document.createElement('style');
        var modifiedStyle = style // .replace(/(-letsee-target).+;/g, '')
        // .replace(/(-letsee-transform).+;/g, '')
        .replace(new RegExp("(".concat(PROPERTY_TARGET, ").+;"), 'g'), '').replace(new RegExp("(".concat(PROPERTY_TRANSFORM, ").+;"), 'g'), '').replace(/\n/g, '').replace(/({\s+)/g, '{').replace(/(;\s+)/g, ';').split('}');
        modifiedStyle.pop();
        var placeStyle = modifiedStyle.map(function (val) {
          var selector = val.split('{')[0].split(',');
          var value = val.split('{')[1];
          var newSelector = selector.map(function (sel) {
            return "#".concat(_this2.domRendererId, ".ar-mode-on ").concat(sel.trim());
          });
          return "".concat(newSelector.join(','), "{").concat(value, "}");
        });
        newStyle.setAttribute('type', 'text/css');
        placeStyle.unshift("body#".concat(this.domRendererId, ".ar-mode-on{overflow:hidden;}"));
        newStyle.appendChild(document.createTextNode(placeStyle.join('')));
        head.replaceChild(newStyle, tagElem);
      }
    }]);

    return CSSParser;
  }();

  var cssParser = new CSSParser();
  _exports.cssParser = cssParser;
});

/***/ }),

/***/ "./libs/EntityParser.js":
/*!******************************!*\
  !*** ./libs/EntityParser.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var instance = null;
  var template = {
    entity: {
      type: 'object',
      uri: null,
      letseeMarkerId: null,
      codeString: null,
      name: null,
      image: null,
      size: {
        width: null,
        height: null,
        depth: 0.0,
        unit: 'mm'
      }
    },
    pixelSize: {
      width: null,
      height: null,
      depth: null,
      unit: 'px'
    },
    scale: null
  };
  var _entityState = [],
      _markerList = [],
      _codeList = [];

  var Fetcher =
  /*#__PURE__*/
  function () {
    function Fetcher(url) {
      _classCallCheck(this, Fetcher);

      this.entity = {};
      this.entity.uri = url.toString();
    }

    _createClass(Fetcher, [{
      key: "fetchEntity",
      get: function get() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          fetch(_this.entity.uri).then(function (response) {
            return response.json();
          }).then(function (data) {
            // temp.entity.uri = data;
            _this.entity.letseeMarkerId = data.letseeMarkerId || null;
            _this.entity.codeString = data.codeString || null;
            _this.entity.name = data.name || null;
            _this.entity.image = data.image || null;
            _this.entity.size = {
              width: data.size.width || 0,
              height: data.size.height || 0,
              depth: data.size.height || 0,
              unit: data.size.unit || 'mm'
            };
            _this.pixelSize = {
              width: data.size.width || 0,
              height: data.size.height || 0,
              depth: data.size.height || 0,
              unit: data.size.unit || 'mm'
            };
            _this.scale = data.scale || 1;
            if (_this.entity.letseeMarkerId !== null) _markerList.push(_this.entity.letseeMarkerId);
            if (_this.entity.codeString !== null) _codeList.push(_this.entity.codeString);
            var json = JSON.stringify(_this);

            var entity = _objectSpread({}, template, {}, JSON.parse(json));

            _entityState.push(entity);

            resolve(entity);
          })["catch"](function (error) {
            reject(error);
          });
        });
      }
    }]);

    return Fetcher;
  }();

  var EntityParser =
  /*#__PURE__*/
  function () {
    function EntityParser() {
      _classCallCheck(this, EntityParser);

      if (!instance) instance = this;
      this.entityList = [];
    }

    _createClass(EntityParser, [{
      key: "initEntity",
      value: function initEntity(entity) {
        this.entityList = entity.map(function (object) {
          return object.entity.uri;
        }).map(function (object) {
          return new Fetcher(object);
        });
        return Promise.all(this.entityList.map(function (object) {
          return object.fetchEntity;
        })).then(function (data) {
          return data;
        });
      }
    }, {
      key: "entityState",
      get: function get() {
        return _entityState;
      }
    }, {
      key: "markerList",
      get: function get() {
        return _markerList;
      }
    }, {
      key: "codeList",
      get: function get() {
        return _codeList;
      }
    }]);

    return EntityParser;
  }();

  _exports["default"] = EntityParser;
});

/***/ }),

/***/ "./libs/EventManager.js":
/*!******************************!*\
  !*** ./libs/EventManager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../observers/observer/LetseeObserver */ "./observers/observer/LetseeObserver.js"), __webpack_require__(/*! ./MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _LetseeObserver2, Message, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _LetseeObserver2 = _interopRequireDefault(_LetseeObserver2);
  Message = _interopRequireWildcard(Message);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var EventManager =
  /*#__PURE__*/
  function (_LetseeObserver) {
    _inherits(EventManager, _LetseeObserver);

    function EventManager() {
      var _this;

      _classCallCheck(this, EventManager);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(EventManager).call(this));
      _this.engine = null;
      return _this;
    }

    _createClass(EventManager, [{
      key: "addEngine",
      value: function addEngine(_engine) {
        this.engine = _engine;
      }
      /**
       * dispatch 시리즈 모두 일단 EventManager로 그런데 합칠 수는 없나? by ahn
       *
       * @author tracker 가 합쳐지면, 이 관련된 부분은 merge 되어야 함
       * @param matrix
       * @param currentState
       */

    }, {
      key: "dispatchTrackState",
      value: function dispatchTrackState(matrix, currentState) {
        var newState = [];

        if ((this.engine !== null || typeof this.engine !== 'undefined') && (matrix !== null || typeof matrix !== 'undefined') && currentState !== null && currentState !== Message.STATE_RECOGNIZE && typeof currentState !== 'undefined') {
          newState = letsee.state.map(function (obj) {
            obj.type = currentState;
            obj.matrix = JSON.parse('[' + matrix + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState);
        } else {// console.log('[error] letsee is not loaded!');
        }
      }
      /**
       * tracker 합쳐지면, merge 될 예정
       *
       * @param matrix
       * @param currentState
       * @param markerId
       */

    }, {
      key: "dispatchTrackStateMarker",
      value: function dispatchTrackStateMarker(matrix, currentState) {
        var markerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var newState = [];

        if ((this.engine !== null || typeof this.engine !== 'undefined') && (matrix !== null || typeof matrix !== 'undefined') && currentState !== null && currentState !== Message.STATE_RECOGNIZE && typeof currentState !== 'undefined') {
          newState = letsee.state.filter(function (obj) {
            return markerId.includes(obj.entity.letseeMarkerId);
          }).map(function (obj) {
            obj.type = currentState[markerId.indexOf(obj.entity.letseeMarkerId)];
            obj.matrix = JSON.parse('[' + matrix[markerId.indexOf(obj.entity.letseeMarkerId)] + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState);
        } else {// console.log('[error] letsee is not loaded!');
        }
      }
      /**
       * tracker 합쳐지면, merge 될 예정
       *
       * @param matrix
       * @param currentState
       * @param markerId
       */

    }, {
      key: "dispatchTrackStateQr",
      value: function dispatchTrackStateQr(matrix, currentState) {
        var markerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var newState = [];

        if (!(0, _Util.isNil)(this.engine) && !(0, _Util.isNil)(matrix) && !(0, _Util.isNil)(currentState) && currentState !== Message.ENTITY_EVENT.RECOGNIZE) {
          newState = letsee.state.filter(function (obj) {
            return markerId.includes(obj.entity.codeString);
          }).map(function (obj) {
            obj.type = currentState[markerId.indexOf(obj.entity.codeString)];
            obj.matrix = JSON.parse('[' + matrix[markerId.indexOf(obj.entity.codeString)] + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState);
        } else {// console.log('[error] letsee is not loaded!');
        }
      }
      /**
       * 렛시 엔진이 시작된 후에 전달됩니다. `onload`이벤트의 숏컷 입니다.
       * @method Letsee#onLoad
       * @param {Function} callback
       */

    }, {
      key: "onLoad",
      value: function onLoad(callback) {
        // 왜 엔진이 '시작'되면 전달되는가! '로드'되면 전달되어야지!!!
        this.subscribe(Message.LETSEE_EVENT.ON_LOAD, callback);
      }
      /**
       * 증강 대상의 트랙킹 시작과 함께 전달되는 이벤트 입니다. `trackstart` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackStart
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackStart",
      value: function onTrackStart(callback) {
        // TrackStart, TrackMove, TrackEnd는 DOM UI 이벤트와 같은 수준으로 처리하면 됩니다. by ahn
        this.subscribe(Message.LETSEE_EVENT.TRACK_START, callback);
      }
      /**
       * 증강 대상의 트랙킹중 전달되는 이벤트 입니다. `trackmove` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackMove
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackMove",
      value: function onTrackMove(callback) {
        // 이것도 DOM UI 이벤트와 같은 수준입니다. 콜백 등록은 Entity Manager에서 제공하는 건 어때요? by ahn
        this.subscribe(Message.LETSEE_EVENT.TRACK_MOVE, callback);
      }
      /**
       * 증강 대상의 트랙킹이 멈추면 전달되는 이벤트 입니다. `trackend` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackEnd
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(callback) {
        // 이것도 위와 같이 셋트임 by ahn
        this.subscribe(Message.LETSEE_EVENT.TRACK_END, callback);
      }
      /**
       * 렛시 객체의 상태를 전달하는 이벤트 입니다. . `app_status` 이벤트의 숏컷 입니다.
       * @method Letsee#onStatus
       * @param {Function} callback
       * @param {LetseeStatus} callback.event
       */

    }, {
      key: "onStatus",
      value: function onStatus(callback) {
        // 이건 Letsee Lifecycle이 먼저 정의되는 게 필요할 듯.
        this.subscribe(Message.LETSEE_EVENT.ON_STATUS, callback);
      }
      /**
       * 기기의 가로/세로 변환 후 전달되는 이벤트 입니다. window의 `orientationchange` 이벤트와는 달리 화면 방향 전환에따른 Letsee 내부의 연산이 완료된 후 전달됩니다.
       * 콜백은 window의 `orientationchange`와 동일합니다.
       * @method Letsee#onOrientationChange
       * @param {Function} callback
       * @param {event} callback.event
       */

    }, {
      key: "onOrientationChange",
      value: function onOrientationChange(callback) {
        // screen object 화이팅! 거기로 몰자. by ahn
        this.subscribe(Message.LETSEE_EVENT.ROTATION_CHANGE, callback);
      }
      /**
       * Letsee 객체에 이벤트를 등록합니다.
       * @method Letsee#addEventListener
       * @param {string} EventType
       * @param {Function} callback
       * @param {event} callback.event
       */

    }, {
      key: "addEventListener",
      value: function addEventListener(type, callback) {
        // 무엇을 등록할 수 있는 겁니까? by ahn
        this.subscribe(type, callback);
      }
      /**
       * Letsee 객체에서 이벤트를 삭제합니다.
       * @method Letsee#removeEventListener
       * @param {string} EventType
       * @param {Function} callback
       */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        // 무엇을 제거할 수 있는 겁니까? 결국 LetseeObserver로 넘기는데...EventManager로 일단. by ahn
        this.unsubscribe(type, callback);
      }
    }]);

    return EventManager;
  }(_LetseeObserver2["default"]);

  ;
  var _default = EventManager;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./libs/MessageTypes.js":
/*!******************************!*\
  !*** ./libs/MessageTypes.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LETSEE_CSS = _exports.LETSEE_EVENT = _exports.ENTITY_EVENT = _exports.OBJECT_EVENT = _exports.STATE_RECOGNIZE = _exports.STATE_TRACK_END = _exports.STATE_TRACK_MOVE = _exports.STATE_TRACK_START = _exports.EVENT_APP_ROTATIONCHANGE = _exports.EVENT_APP_ONLOAD = _exports.EVENT_APP_STATUS = void 0;
  var EVENT_APP_STATUS = 'app_status';
  _exports.EVENT_APP_STATUS = EVENT_APP_STATUS;
  var EVENT_APP_ONLOAD = 'onload';
  _exports.EVENT_APP_ONLOAD = EVENT_APP_ONLOAD;
  var EVENT_APP_ROTATIONCHANGE = 'rotationchange';
  _exports.EVENT_APP_ROTATIONCHANGE = EVENT_APP_ROTATIONCHANGE;
  var STATE_TRACK_START = 'trackstart';
  _exports.STATE_TRACK_START = STATE_TRACK_START;
  var STATE_TRACK_MOVE = 'trackmove';
  _exports.STATE_TRACK_MOVE = STATE_TRACK_MOVE;
  var STATE_TRACK_END = 'trackend';
  _exports.STATE_TRACK_END = STATE_TRACK_END;
  var STATE_RECOGNIZE = 'recognize';
  _exports.STATE_RECOGNIZE = STATE_RECOGNIZE;
  var OBJECT_EVENT = {
    OBJECT_ADDED: 'added',
    OBJECT_REMOVED: 'removed'
  };
  _exports.OBJECT_EVENT = OBJECT_EVENT;
  var ENTITY_EVENT = {
    TARGET: 'EntityEvent',
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend',
    RECOGNIZE: 'recognize'
  };
  _exports.ENTITY_EVENT = ENTITY_EVENT;
  var LETSEE_EVENT = {
    TARGET: 'LetseeEvent',
    ON_LOAD: 'onload',
    ON_STATUS: 'app_status',
    ROTATION_CHANGE: 'rotationchange',
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend'
  };
  _exports.LETSEE_EVENT = LETSEE_EVENT;
  var LETSEE_CSS = {
    AR_MODE_ON: 'ar-mode-on',
    AR_MODE_OFF: 'ar-mode-off',
    LETSEE_LOADING: 'letsee-loading',
    LETSEE_LOADED: 'letsee-loaded',
    LETSEE_STATUS: 'letsee-status'
  };
  _exports.LETSEE_CSS = LETSEE_CSS;
});

/***/ }),

/***/ "./libs/ObjectTracker.js":
/*!*******************************!*\
  !*** ./libs/ObjectTracker.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ../math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ../core/TrackableManager */ "./core/TrackableManager.js"), __webpack_require__(/*! ../entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ../entity/EntityEventType */ "./entity/EntityEventType.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Entity, _Matrix, _Vector, _Quaternion, _Euler, _TrackableManager, _EntityEvent, _EntityEventType, _EntityObserver2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.objectTracker = void 0;
  _Entity = _interopRequireDefault(_Entity);
  _Matrix = _interopRequireDefault(_Matrix);
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _EntityEvent = _interopRequireDefault(_EntityEvent);
  _EntityEventType = _interopRequireDefault(_EntityEventType);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var translateMatrix = new _Matrix["default"]();
  var rotationMatrix = new _Matrix["default"]();

  var ObjectTracker =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(ObjectTracker, _EntityObserver);

    /**
     * @ignore
     * @member {Object<string, Entity>} targets
     * @memberof LetseeEngine.renderer
     */
    // targets: {[uri: string]: Entity};
    function ObjectTracker() {
      var _this;

      _classCallCheck(this, ObjectTracker);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ObjectTracker).call(this));
      _this.targets = {};
      _this.camera = null;
      _this.useCamera = false;
      return _this;
    }
    /**
     * Returns `true` if currently tracking an entity with `uri`.
     * @method isTracking
     * @memberof LetseeEngine.renderer
     * @param {string} [uri]
     * @return {boolean} Tracking 여부
     */


    _createClass(ObjectTracker, [{
      key: "isTracking",
      value: function isTracking(uri) {
        if (uri) {
          if (this.targets[uri]) return true;
        } else {
          if (Object.keys(this.targets).length > 0) return true;
        }

        return false;
      }
      /**
       * Returns the number of currently tracked objects.
       * @method getTrackingCount
       * @memberof LetseeEngine.tracker
       * @return {number}
       */

    }, {
      key: "getTarget",

      /**
       *
       * @param uri
       * @returns {*}
       */
      value: function getTarget(uri) {
        return this.targets[uri];
      }
    }, {
      key: "addTarget",
      value: function addTarget(target) {
        this.targets[target.uri] = target;
      }
    }, {
      key: "removeTarget",
      value: function removeTarget(target) {
        delete this.targets[target.uri];
      }
      /**
       * Clears the renderer by dispatching a `'trackend'` event for all entities
       * that are currently tracked.
       * 모든 TrackEvent를 clear
       * Tracking 중인 대상에 대해서는 TrackEnd 이벤트 발생
       * @method clear
       * @memberof LetseeEngine.renderer
       */

    }, {
      key: "clear",
      value: function clear() {
        for (var _i = 0, _Object$values = Object.values(this.targets); _i < _Object$values.length; _i++) {
          var entity = _Object$values[_i];
          this.onTrackEnd(new _EntityEvent["default"]('trackend', entity), true);
        }

        this.targets = {}; // LetseeEngine.renderer.render();
      }
      /**
       * @ignore
       * @method onUpdateState
       * @memberof LetseeEngine.tracker
       * @param  {Array} state
       */

    }, {
      key: "updateState",
      value: function updateState(state) {
        var _this2 = this;

        if (state === undefined || state.length === 0) {
          this.clear();
          return;
        }

        state.forEach(function (event) {
          var e = event.entity;
          var entity = _TrackableManager.trackableManager.getEntity(e.uri) || new _Entity["default"](e.uri, e);
          entity.setData(e);
          entity.object.updateMatrix();
          entity.object.updateMatrixWorld();
          var matrix = new _Matrix["default"]().fromArray(event.matrix);
          var entityEvent = new _EntityEvent["default"](event.type, entity, matrix, event.pixelSize, event.scale);

          if (entityEvent) {
            if (event.type === _EntityEventType["default"].TRACK_START) {
              _this2.onTrackStart(entityEvent);
            } else if (event.type === _EntityEventType["default"].TRACK_MOVE) {
              _this2.onTrackMove(entityEvent);
            } else if (event.type === _EntityEventType["default"].TRACK_END) {
              _this2.onTrackEnd(entityEvent);
            }
          }
        });
      }
      /**
       * @ignore
       * @method onTrackStart
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackStart",
      value: function onTrackStart(event) {
        var target = event.target;
        target.track = true;
        this.addTarget(target);

        if (target.uri !== 'unknown') {
          target.scale = event.scale;
          this.notify('trackstart', event);
          target.notify('trackstart', event);
        }
      }
      /**
       * @ignore
       * @method onTrackMove
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackMove",
      value: function onTrackMove(event) {
        var entity = event.target;
        var entityObject = entity.object; // Start invert X Axis

        var rotateM = new _Matrix["default"]();
        var q = new _Quaternion["default"]().setFromEuler(new _Euler["default"](Math.PI, 0, 0));
        rotateM.makeRotationFromQuaternion(q);
        event.matrix.multiply(rotateM); // End invert X axis
        // Apply pose to camera or object.

        if (this.useCamera) {
          event.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
          this.camera.updateMatrix();
          var tmp = new _Matrix["default"]().getInverse(this.camera.matrix);
          this.camera.matrix.identity();
          this.camera.applyMatrix(tmp);
          this.camera.updateMatrix();
          this.camera.updateMatrixWorld();
          this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld);
        } else {
          var _event$matrix$decompo = event.matrix.decomposedValue,
              position = _event$matrix$decompo.position,
              quaternion = _event$matrix$decompo.quaternion,
              scale = _event$matrix$decompo.scale;
          translateMatrix.makeTranslation.apply(translateMatrix, _toConsumableArray(position.toArray()));
          rotationMatrix.makeRotationFromQuaternion(quaternion);
          entityObject.matrix.multiply(translateMatrix);
          entityObject.matrix.multiply(rotationMatrix);
          entityObject.matrixAutoUpdate = false;
          entityObject.updateMatrixWorld(true);
        }

        if (entity.uri !== 'unknown') {
          this.notify('trackmove', event);
          entity.notify('trackmove', event);
        }
      }
      /**
       * @ignore
       * @method onTrackEnd
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(event) {
        var target = event.target;
        target.track = false;
        this.removeTarget(target);

        if (target.uri !== 'unknown') {
          this.notify('trackend', event);
          target.notify('trackend', event);
        }
      }
    }, {
      key: "count",
      get: function get() {
        return Object.keys(this.targets).length;
      }
    }]);

    return ObjectTracker;
  }(_EntityObserver2["default"]);

  var objectTracker = new ObjectTracker();
  _exports.objectTracker = objectTracker;
});

/***/ }),

/***/ "./libs/VideoManager.js":
/*!******************************!*\
  !*** ./libs/VideoManager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../vendor/adapter_no_edge */ "./vendor/adapter_no_edge.js"), __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../observers/observer/LetseeObserver */ "./observers/observer/LetseeObserver.js"), __webpack_require__(/*! ./MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../Context */ "./Context.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _adapter_no_edge, _Util, _LetseeObserver2, _MessageTypes, _Context) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _adapter_no_edge = _interopRequireDefault(_adapter_no_edge);
  _LetseeObserver2 = _interopRequireDefault(_LetseeObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import * as Message from './MessageTypes';
  // import {VIDEO_EVENT} from './MessageTypes';
  // import LetseeEvent from './LetseeEvent';
  // import VideoObserver from '../observers/observer/VideoObserver';
  var instance;

  var _container = document.createElement('div');

  var _videoElement = document.createElement('video');

  var _sceneCanvas = document.createElement('canvas');

  var _screenWidth;

  var _screenHeight;

  var _angle = 0;

  var _screenAspectRatio;

  var _type = null;
  var _browser = 'unknown';
  var _os = 'unknown';
  var _videoAttached = false; // eslint-disable-line

  var _isPortrait = true; // eslint-disable-line

  var deviceList = [];
  var isFirstCameraInit = true; // 초기 카메라 Init 시에

  var getUserMediaConstraints = function getUserMediaConstraints(src) {
    var constraints = {};
    constraints.audio = false;
    constraints.video = {};

    if (src === 'environment') {
      constraints.video.facingMode = 'environment';
      /**
      * 후면 카메라의 디바이스 장치에 대한 예외 출력. (Exception about front-back camera device)
      * || 구문 이후로 추가하여 추가적인 Label 등록이 가능. (Add Label using || syntax for add exception device)
      * s10 : camera2 0, facing back
      */

      var exceptionDevices = deviceList.filter(function (device) {
        return device.label === 'camera2 0, facing back' || device.label === 'additional ....';
      });

      if (exceptionDevices.length >= 1) {
        constraints.video.deviceId = exceptionDevices[0].deviceId;
      }
    } else if (src === 'user') {
      constraints.video.facingMode = 'user';
    } else {
      constraints.video.deviceId = src;
    }

    constraints.video.width = {};
    constraints.video.width.min = 1024;
    constraints.video.width.ideal = 1280;
    constraints.video.width.max = 1920;
    constraints.video.height = {};
    constraints.video.height.min = 576;
    constraints.video.height.ideal = 720;
    constraints.video.height.max = 1080;
    return constraints;
  };

  var getMedia = function getMedia(constraints) {
    if (window.stream) {
      window.stream.getTracks().forEach(function (track) {
        track.stop();
      });
    }

    return new Promise(function (resolve, reject) {
      navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
        resolve(stream);
      })["catch"](function (e) {
        reject(e);
      });
    });
  };

  var checkCamera = function checkCamera(devices) {
    return new Promise(function (resolve, reject) {
      var hasWebcam = false;
      deviceList = [];
      devices.forEach(function (device) {
        if (device.kind === 'videoinput') {
          hasWebcam = true;
          deviceList.push({
            deviceId: device.deviceId,
            label: device.label
          });
        }
      });

      if (!hasWebcam) {
        reject('No videoInput Stream');
      } else {
        if (isFirstCameraInit) {
          resolve(getUserMediaConstraints('environment'));
          isFirstCameraInit = false;
        }
      }
    });
  };

  var gotStream = function gotStream(mediaStream) {
    _videoElement.srcObject = mediaStream;
    _videoAttached = true;
  };
  /**
   * remove current video stream, and connect new stream.
   */


  var removeStream = function removeStream(mediaStream) {
    if (window.stream) {
      window.stream.getTracks().forEach(function (track) {
        track.stop();
      });
    }

    window.stream = mediaStream;
    _videoElement.srcObject = null;
    _videoAttached = false;
  };

  var _initCameraContainer = function _initCameraContainer(zIndex, zIndexIncrement) {
    _videoElement.setAttribute('playsinline', true);

    _videoElement.autoplay = true;
    _videoElement.muted = true;
    _videoElement.style.position = 'fixed';
    _videoElement.style.top = '0px';
    _videoElement.style.left = '0px';
    _videoElement.style.zIndex = '-100';
    _videoElement.style.width = '100%';
    _videoElement.style.height = '100%';
    _videoElement.style.border = '1px solid pink';
    /**
    * iOS safari 의 경우, <video> 태그의 visibility 를 hidden 으로 처리하면 스트림 재생 시에 stream 이 freezing 되는 현상이 발생함
    * Android Chrome 의 경우, <video> 태그의 visibility 를 hidden 으로 처리해도 stream 재생이 잘 됨
    * @author treetory@letsee.io
    */
    // _videoElement.style.visibility = 'hidden';
    // _videoElement.style.objectFit = 'cover';
    // // _videoElement.style.width = '100vw';
    // _videoElement.style.height = '100vh';

    _sceneCanvas.style.position = 'fixed';
    _sceneCanvas.style.top = '0px';
    _sceneCanvas.style.left = '0px';
    _sceneCanvas.style.zIndex = '0';
    _sceneCanvas.style.border = '1px solid blue';

    _container.appendChild(_videoElement);

    _container.appendChild(_sceneCanvas);

    _container.style.position = 'fixed';
    _container.style.top = '0px';
    _container.style.right = '0px';
    _container.style.bottom = '0px';
    _container.style.left = '0px';
    _container.style.width = '100%';
    _container.style.height = '100%';
    _container.style.zIndex = zIndex;
    _container.style.border = '1px solid red';
    document.body.style.margin = '0px';
    document.body.style.padding = '0px';
    document.body.appendChild(_container);
  };

  var _attachSourceToVideo = function _attachSourceToVideo(videoUrl) {
    var sourceMP4 = document.createElement('source');
    sourceMP4.src = videoUrl;
    sourceMP4.type = 'video/mp4';

    _videoElement.appendChild(sourceMP4);

    _videoElement.addEventListener('canplay', function () {
      return true;
    });
  };

  var _setAspectRatio = function _setAspectRatio() {
    var angle = typeof screen.orientation === 'undefined' || !screen.orientation ? window.orientation : screen.orientation.angle; // eslint-disable-line

    var type = typeof screen.orientation === 'undefined' || !screen.orientation ? 'safari' : 'chrome';
    _angle = angle;
    _type = type;

    if ((_angle === 90 || _angle === -90 || _angle === 270 || _angle === -270) && _type !== 'chrome') {
      _screenWidth = screen.height;
      _screenHeight = screen.width;
    } else {
      _screenWidth = screen.width;
      _screenHeight = screen.height;
    }

    _screenAspectRatio = _screenWidth / _screenHeight;
    _isPortrait = _screenAspectRatio <= 1;
    _sceneCanvas.width = _screenWidth;
    _sceneCanvas.height = _screenHeight;
    _sceneCanvas.style.width = "".concat(_screenWidth, "px");
    _sceneCanvas.style.height = "".concat(_screenHeight, "px");
    _sceneCanvas.style.transform = 'translateZ(0)';
    return {
      width: _screenWidth,
      height: _screenHeight
    };
  };

  var _initCanvas = function _initCanvas() {
    return _setAspectRatio();
  };

  var videoManager =
  /*#__PURE__*/
  function (_LetseeObserver) {
    _inherits(videoManager, _LetseeObserver);

    function videoManager() {
      var _this;

      _classCallCheck(this, videoManager);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(videoManager).call(this));
      if (instance) return _possibleConstructorReturn(_this, instance);

      _videoElement.addEventListener('loadeddata', function () {
        // this.dispatch(Message.EVENT_APP_STATUS, {
        _this.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
          status: 'success',
          code: 202,
          message: 'Video start'
        });
      });

      _this.container = _container;
      _this.containerId = _Context.context.videoContainerId;

      _this.container.setAttribute('id', _this.containerId);

      instance = _assertThisInitialized(_this); // update deviceList when device connection state changed.

      navigator.mediaDevices.addEventListener('devicechange', function (e) {
        navigator.mediaDevices.enumerateDevices().then(function (devices) {
          deviceList = [];
          devices.forEach(function (device) {
            if (device.kind === 'videoinput') {
              deviceList.push({
                deviceId: device.deviceId,
                label: device.label
              });
            }
          });
        })["catch"](function (err) {
          console.log(err);
        });
      });
      return _this;
    }

    _createClass(videoManager, [{
      key: "init",
      value: function init(zIndex, zIndexIncrement) {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          _initCameraContainer(zIndex, zIndexIncrement);

          if (_this2.videoUrl) {
            _attachSourceToVideo(_this2.videoUrl);
          } else {
            _this2.getAttachedVideo().then(function () {
              // this.dispatch(Message.EVENT_APP_STATUS, {
              _this2.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
                code: 200,
                message: 'Camera initialize start'
              });

              return navigator.mediaDevices.enumerateDevices();
            }).then(checkCamera).then(function (constraints) {
              return getMedia(constraints);
            }).then(function (stream) {
              removeStream(stream);
              gotStream(stream); // this.dispatch(Message.EVENT_APP_STATUS, {

              _this2.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
                code: 201,
                message: 'Camera initialize done'
              });

              var _screenSize = _initCanvas(); // this.screen = new Screen(_screenSize.width, _screenSize.height, this);


              resolve(_screenSize);
            })["catch"](function (error) {
              reject(error);
            });
          }
        });
      }
    }, {
      key: "getAttachedVideo",
      value: function getAttachedVideo() {
        var _this3 = this;

        return new Promise(function (resolve, reject) {
          var browserInfo = (0, _Util.getBrowserInfo)();
          var browserName = browserInfo.name.toLowerCase();
          var osName = browserInfo.osName.toLowerCase();

          if (browserName.match(/chrome/i)) {
            _browser = 'chrome';
          } else if (browserName.match(/safari/i)) {
            _browser = 'safari';
          } else {
            _browser = 'unknown';
          }

          if (osName.match(/ios/i)) {
            _os = 'ios';
          } else if (osName.match(/android/i)) {
            _os = 'android';
          } else {
            _os = 'unknown';
          }

          if (_os === 'ios' && _browser !== 'safari') {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 101,
              message: 'Please use safari with ios'
            });

            reject('Please use safari with ios');
          }

          if (browserInfo.isWebRTCSupported === false) {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 102,
              message: 'Unsupported browser'
            });

            reject('Please use Chrome, Firefox, iOS 11, Android 5 or higher, Safari 11 or higher');
          } // if (!browserInfo.isMobileDevice) {
          //   // this.dispatch(Message.EVENT_APP_STATUS, {
          //   this.notify(LETSEE_EVENT.ON_STATUS, {
          //     status: 'error',
          //     code: 104,
          //     message: 'No mobile device detected'
          //   });
          //   reject('No mobile device');
          // }
          // if ((screen.height * screen.width) > 921600) {
          //   // this.dispatch(Message.EVENT_APP_STATUS, {
          //   this.notify(LETSEE_EVENT.ON_STATUS, {
          //     status: 'error',
          //     code: 106,
          //     message: 'Screen size is too large.'
          //   });
          //   reject('Screen size is too large');
          // }


          resolve();
        });
      }
    }, {
      key: "orientationChange",
      value: function orientationChange() {
        _setAspectRatio();
      }
    }, {
      key: "setVideoSource",
      value: function setVideoSource(src) {
        if (/[^\s]+\.mp4\b/.test(src)) {
          _attachSourceToVideo(src);
        } else {
          var constraints = getUserMediaConstraints(src);
          this.reconnectMediaStream(constraints);
        }
      }
    }, {
      key: "getSourceDeviceList",
      value: function getSourceDeviceList() {
        return deviceList;
      } // Fixed getter/setter

    }, {
      key: "reconnectMediaStream",
      // constraint를 이용하여 미디어 Stream을 얻어오는 메서드.
      // get mediaStream using constraints.
      value: function reconnectMediaStream(constraints) {
        var _this4 = this;

        return new Promise(function (resolve, reject) {
          getMedia(constraints).then(function (stream) {
            removeStream();
            window.stream = stream;
            gotStream(stream);

            _this4.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              code: 201,
              message: 'Camera initialize done'
            });

            _initCanvas();

            resolve();
          })["catch"](function (error) {
            reject(error);
          });
        });
      }
    }, {
      key: "screenInfo",
      get: function get() {
        return {
          width: _screenWidth,
          height: _screenHeight,
          angle: _angle,
          screenAspectRatio: _screenAspectRatio
        };
      }
    }, {
      key: "videoElement",
      get: function get() {
        return _videoElement;
      }
    }, {
      key: "canvasElement",
      get: function get() {
        return _sceneCanvas;
      }
    }]);

    return videoManager;
  }(_LetseeObserver2["default"]);

  var _default = videoManager;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./math/Euler.js":
/*!***********************!*\
  !*** ./math/Euler.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ./Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Quaternion, _Vector, _Matrix, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Vector = _interopRequireDefault(_Vector);
  _Matrix = _interopRequireDefault(_Matrix);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /**
   * @typedef {'XYZ'|'YZX'|'ZXY'|'XZY'|'YXZ'|'ZYX'} EulerRotationOrder
   */
  // type EulerRotationOrder = 'XYZ' | 'YZX' | 'ZXY' | 'XZY' | 'YXZ' | 'ZYX';

  /**
   * By default this is an empty function, however it can be set via
   * {@link Euler#onChange}. It getse called after changing the {@link Euler#x},
   * {@link Euler#y}, {@link Euler#z}, or {@link Euler#order} properties, and
   * also after calling most setter functions.
   * @member {Function} onChangeCallback
   * @memberof Euler#
   * @default function() { }
   */
  var onChangeCallback = function onChangeCallback() {};

  var _isEuler = true;
  var DefaultOrder = 'XYZ';
  var RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
  /**
   * @class Euler
   * @classdesc
   * A class representing
   * [Euler Angles](http://en.wikipedia.org/wiki/Euler_angles). Euler angles
   * describe a rotational transformation by rotating an object on its various
   * axes in specified amounts per axis, and a specified axis order.
   * @example
   * var a = new Euler(0, 1, 1.57, 'XYZ');
   * var b = new Vector3(1, 0, 1);
   * b.applyEuler(a);
   * @param {number} [x=0] The angle of the x axis in radians.
   * @param {number} [y=0] The angle of the y axis in radians.
   * @param {number} [z=0] The angle of the z axis in radians.
   * @param {EulerRotationOrder} [order='XYZ'] A string representing the order that the rotations are applied. (Must be upper case).
   */

  var Euler =
  /*#__PURE__*/
  function () {
    function Euler() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultOrder;

      _classCallCheck(this, Euler);

      // constants for optimisation
      this.setFromQuaternionQ;
      this.reorderQ;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    /**
     * The current value of the x component. If this is changed,
     * {@link Euler#onChangeCallback} will be called.
     * @member {number} x
     * @memberof Euler#
     * @default 0
     */


    _createClass(Euler, [{
      key: "set",

      /**
       * Sets the angles of this euler transform and optionally the
       * {@link Euler#order} and then call {@link Euler#onChangeCallback}.
       * @method set
       * @memberof Euler.prototype
       * @param {number} x The angle of the x axis in radians.
       * @param {number} y The angle of the y axis in radians.
       * @param {number} z The angle of the z axis in radians.
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       */
      value: function set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        onChangeCallback();
        return this;
      }
      /**
       * Returns a new {@link Euler} with the same parameters as this one.
       * @method clone
       * @memberof Euler.prototype
       * @return {Euler}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Euler(this._x, this._y, this._z, this._order);
      }
      /**
       * Copies value of `euler` to this euler.
       * @method copy
       * @memberof Euler.prototype
       * @param  {Euler} e
       */

    }, {
      key: "copy",
      value: function copy(e) {
        this._x = e.x;
        this._y = e.y;
        this._z = e.z;
        this._order = e.order;
        onChangeCallback();
        return this;
      }
      /**
       * Sets the angles of this euler transform from a pure rotation matrix based
       * on the orientation specified by `order`.
       * @method setFromRotationMatrix
       * @memberof Euler.prototype
       * @param {Matrix4} m A {@link Matrix4} of which the upper 3x3 of matrix is a pure [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix) (i.e. unscaled).
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       * @param {boolean} [update=true] Whether to call {@link Euler#onChangeCallback} after applying the matrix.
       */

    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m, order) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;

        var _te = _slicedToArray(te, 12),
            m11 = _te[0],
            m21 = _te[1],
            m31 = _te[2],
            m41 = _te[3],
            m12 = _te[4],
            m22 = _te[5],
            m32 = _te[6],
            m42 = _te[7],
            m13 = _te[8],
            m23 = _te[9],
            m33 = _te[10],
            m43 = _te[11];

        order = order || this._order;

        if (order === 'XYZ') {
          this._y = Math.asin((0, _Math.clamp)(m13, -1, 1));

          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-(0, _Math.clamp)(m23, -1, 1));

          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin((0, _Math.clamp)(m32, -1, 1));

          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-(0, _Math.clamp)(m31, -1, 1));

          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin((0, _Math.clamp)(m21, -1, 1));

          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-(0, _Math.clamp)(m12, -1, 1));

          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          console.warn("Euler: .setFromRotationMatrix() given unsupported order: ".concat(order));
        }

        this._order = order;

        if (update !== false) {
          onChangeCallback();
        }

        return this;
      }
      /**
       * Sets the angles of this euler transform from a normalized quaternion based
       * on the orientation specified by `order`.
       * @method setFromQuaternion
       * @memberof Euler.prototype
       * @param {Quaternion} q A normalized quaternion.
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       * @param {boolean} [update=true] Whether to call {@link Euler#onChangeCallback} after applying the matrix.
       */

    }, {
      key: "setFromQuaternion",
      value: function setFromQuaternion(q, order) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (typeof this.setFromQuaternionQ === 'undefined') {
          this.setFromQuaternionQ = new _Matrix["default"]();
        }

        this.setFromQuaternionQ.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(this.setFromQuaternionQ, order, update);
      }
      /**
       * Sets the {@link Euler#x}, {@link Euler#y}, and {@link Euler#z}, and
       * optionally update the {@link Euler#order}. {@link Euler#onChangeCallback}
       * is called after these changes are made.
       * @method setFromVector3
       * @memberof Euler.prototype
       * @param {Vector3} v
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       */

    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
        return this.set(v.x, v.y, v.z, order);
      }
      /**
       * Resets the euler angle with a `newOrder` by creating a quaternion from this
       * euler angle and then setting this euler angle with the quaternion and the
       * `newOrder`.
       *
       * _WARNING_: this discards revolution information.
       * @method reorder
       * @memberof Euler.prototype
       * @param  {EulerRotationOrder} [newOrder]
       */

    }, {
      key: "reorder",
      value: function reorder(newOrder) {
        if (typeof this.reorderQ === 'undefined') {
          this.reorderQ = new _Quaternion["default"]();
        }

        this.reorderQ.setFromEuler(this);
        return this.setFromQuaternion(this.reorderQ, newOrder);
      }
      /**
       * Checks for strict equality of this euler and `euler`.
       * @method equals
       * @memberof Euler.prototype
       * @param  {Euler} euler
       * @return {Boolean}
       */

    }, {
      key: "equals",
      value: function equals(euler) {
        return euler.x === this._x && euler.y === this._y && euler.z === this._z && euler.order === this._order;
      }
      /**
       * Assigns this euler's {@link Euler#x} angle to `array[0]`. Assigns this
       * euler's {@link Euler#y} angle to `array[1]`. Assigns this euler's
       * {@link Euler#z} angle to `array[2]`. Optionally assigns this euler's
       * {@link Euler#order} to `array[3]`.
       * @method fromArray
       * @memberof Euler.prototype
       * @param  {Array} array Array of length 3 or 4. The optional 4th argument corresponds to {@link Euler#order}.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];

        if (array[3] !== undefined && array[3] !== null) {
          this._order = array[3];
        }

        onChangeCallback();
        return this;
      }
      /**
       * Returns an array of the form `[x, y, z, order]`.
       * @method toArray
       * @memberof Euler.prototype
       * @param  {Array} [array=[]] Array to store the euler in.
       * @param  {number} [offset=0] Offset in the array.
       * @return {Array}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      }
      /**
       * Returns the euler's {@link Euler#x}, {@link Euler#y}, and {@link Euler#z}
       * properties as a {@link Vector3}.
       * @method toVector3
       * @memberof Euler.prototype
       * @param  {Vector3} [optionalResult]
       * @return {Vector3}
       */

    }, {
      key: "toVector3",
      value: function toVector3(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        }

        return new _Vector["default"](this._x, this._y, this._z);
      }
      /**
       * Sets the value of the {@link Euler#onChangeCallback} function.
       * @method onChange
       * @memberof Euler.prototype
       * @param {Function} callback
       */

    }, {
      key: "onChange",
      value: function onChange(callback) {
        onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        onChangeCallback();
      }
      /**
       * The current value of the y component. If this is changed,
       * {@link Euler#onChangeCallback} will be called.
       * @member {number} y
       * @memberof Euler#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        onChangeCallback();
      }
      /**
       * The current value of the z component. If this is changed,
       * {@link Euler#onChangeCallback} will be called.
       * @member {number} z
       * @memberof Euler#
       * @default 0
       */

    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        onChangeCallback();
      }
    }, {
      key: "isEuler",
      get: function get() {
        return _isEuler;
      }
      /**
       * The order in which to apply rotations. Default is `'XYZ'`, which means
       * that the object will first be rotated around its X axis, then its Y axis,
       * and finally its Z axis. Other possibilities are: `'YZX'`, `'ZXY'`,
       * `'XZY'`, `'YXZ'`, and `'ZYX'`. These must be in upper case.
       *
       * Letsee uses _intrinsic_ (Tait-Bryan) ordering, also known as this._yaw_,
       * _pitch_, and _roll_. This means that rotations are performed with respect
       * to the _local_ coordinate system. That is, for order `'XYZ'`, the rotation
       * is first around world-X, then around local-Y (which may now be different
       * from the world Y-axis), then local-Z (which may be different from the
       * world Z-axis).
       *
       * Some implementations may use _extrinsic_ (proper) ordering, in which case
       * rotations are performed with respect to the _world_ coordinate system, so
       * that for order `'XYZ'`, the rotations are around world-X, world-Y, and
       * world-Z.
       *
       * Converting between the two types is relatively straightforward, you just
       * need to reverse the order and the rotation, so that an intrinsic
       * (Letsee) Euler rotation of angles `a`, `b`, `c` about `'XYZ'` will be
       * equivalent to an extrinsic Euler rotation of angles `c`, `b`, `a` abbout
       * `'ZYX'`.
       *
       * If this is changed, {@link Euler#onChangeCallback} will be called.
       * @member {EulerRotationOrder} order
       * @memberof Euler#
       * @default 'XYZ'
       */

    }, {
      key: "order",
      get: function get() {
        return this._order;
      },
      set: function set(value) {
        this._order = value;
        onChangeCallback();
      }
    }]);

    return Euler;
  }();

  _exports["default"] = Euler;
});

/***/ }),

/***/ "./math/Math.js":
/*!**********************!*\
  !*** ./math/Math.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Vector2 */ "./math/Vector2.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Vector2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = _exports.nextPowerOfTwo = _exports.nearestPowerOfTwo = _exports.isPowerOfTwo = _exports.randFloatSpread = _exports.randFloat = _exports.randInt = _exports.smootherstep = _exports.smoothstep = _exports.lerp = _exports.mapLinear = _exports.euclideanModulo = _exports.clamp = _exports.worldToScreen = _exports.radToDeg = _exports.degToRad = _exports.RAD2DEG = _exports.DEG2RAD = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Vector2 = _interopRequireDefault(_Vector2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  var DEG2RAD = Math.PI / 180;
  _exports.DEG2RAD = DEG2RAD;
  var RAD2DEG = 180 / Math.PI;
  /**
   * Converts degress to radians.
   * @method degToRad
   * @memberof module:Math
   * @param  {number} degrees
   * @return {number}
   */

  _exports.RAD2DEG = RAD2DEG;

  var degToRad = function degToRad(degrees) {
    return degrees * DEG2RAD;
  };
  /**
   * Converts radians to degrees.
   * @method radToDeg
   * @memberof module:Math
   * @param  {number} radians
   * @return {number}
   */


  _exports.degToRad = degToRad;

  var radToDeg = function radToDeg(radians) {
    return radians * RAD2DEG;
  };
  /**
   * Vector3 값을 현재 Screen 내에 Vector2 값으로 변환
   * @memberof module:Math
   * @method worldToScreen
   * @param {Vector3} position
   * @return {Vector2}
   */


  _exports.radToDeg = radToDeg;

  var worldToScreen = function worldToScreen(position) {
    var camera = LetseeEngine.camera;

    if (camera) {
      var v = position.clone();
      v.project(camera);
      return new _Vector2["default"]().set((v.x + 1) * (screen.width / 2), (-v.y + 1) * (screen.height / 2));
    }

    console.error('Camera is not initialized');
    return null;
  };
  /**
   * Clamps the `value` to be between `min` and `max`.
   * @method clamp
   * @memberof module:Util
   * @param  {number} value Value to be clamped.
   * @param  {number} min   Minimum value.
   * @param  {number} max   Maximum value.
   * @return {number}
   */


  _exports.worldToScreen = worldToScreen;

  var clamp = function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  };
  /**
   * Compute the Euclidean module of `m % n`, that is:
   * ```
   * ((n % m) + m) % m
   * ```
   * @method euclideanModulo
   * @memberof module:Util
   * @param  {number} n
   * @param  {number} m
   * @return {number}
   */
  // https://en.wikipedia.org/wiki/Modulo_operation


  _exports.clamp = clamp;

  var euclideanModulo = function euclideanModulo(n, m) {
    return (n % m + m) % m;
  };
  /**
   * Linear mapping of `x` from range `[a1, a2]` to range `[b1, b2]`.
   * @method mapLinear
   * @memberof module:Util
   * @param  {number} x  Value to be mapped.
   * @param  {number} a1 Minimum value for range A.
   * @param  {number} a2 Maximum value for range A.
   * @param  {number} b1 Minimum value for range B.
   * @param  {number} b2 Maximum value for range B.
   * @return {number}
   */


  _exports.euclideanModulo = euclideanModulo;

  var mapLinear = function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  };
  /**
   * Returns a value
   * [linearly interpolated](https://en.wikipedia.org/wiki/Linear_interpolation)
   * from two known points based on the given interval - `t = 0` will return `x`
   * and `t = 1` will return `y`.
   * @method lerp
   * @memberof module:Util
   * @param  {number} x Start point.
   * @param  {number} y End point.
   * @param  {number} t Interpolation factor in the closed inverval `[0, 1]`.
   * @return {number}
   */


  _exports.mapLinear = mapLinear;

  var lerp = function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  };
  /**
   * Returns a value between `0` and `1` that represents the percentage that `x`
   * has moved between `min` and `max`, but smoothed or slowed down the closer `x`
   * is to the `min` and `max`. See
   * [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for details.
   * @method smoothstep
   * @memberof module:Util
   * @param  {number} x   The value to evaluate based on its position between `min` and `max`.
   * @param  {number} min Any `x` value below `min` will be `0`.
   * @param  {number} max Any `x` value above `max` will be `1`.
   * @return {number}
   */


  _exports.lerp = lerp;

  var smoothstep = function smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  };
  /**
   * Returns a value between `0` and `1`. A
   * [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
   * that has zero 1st and 2nd order derivatives at `x = 0` and `x = 1`.
   * @method smootherstep
   * @memberof module:Util
   * @param  {number} x   The value to evaluate based on its position between `min` and `max`.
   * @param  {number} min Any `x` value below `min` will be `0`.
   * @param  {number} max Any `x` value above `max` will be `1`.
   * @return {number}
   */


  _exports.smoothstep = smoothstep;

  var smootherstep = function smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  };
  /**
   * Random integer in the interval `low` to `high`.
   * @method randInt
   * @memberof module:Util
   * @param  {number} low
   * @param  {number} high
   * @return {number}
   */


  _exports.smootherstep = smootherstep;

  var randInt = function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  };
  /**
   * Random float in the interval `low` to `high`.
   * @method randFloat
   * @memberof module:Util
   * @param  {number} low
   * @param  {number} high
   * @return {number}
   */


  _exports.randInt = randInt;

  var randFloat = function randFloat(low, high) {
    return low + Math.random() * (high - low);
  };
  /**
   * Random float in the interval `-range/2` to `range/2`.
   * @method randFloatSpread
   * @memberof module:Util
   * @param  {number} range
   * @return {number}
   */


  _exports.randFloat = randFloat;

  var randFloatSpread = function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  };
  /**
   * Returns `true` if `value` is a power of 2.
   * @method isPowerOfTwo
   * @memberof module:Util
   * @param  {number}  value
   * @return {Boolean}
   */


  _exports.randFloatSpread = randFloatSpread;

  var isPowerOfTwo = function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  };
  /**
   * Return the nearest power of 2 to a given number `value`.
   * @method nearestPowerOfTwo
   * @memberof module:Util
   * @param  {number} value
   * @return {number}
   */


  _exports.isPowerOfTwo = isPowerOfTwo;

  var nearestPowerOfTwo = function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
  };
  /**
   * Return the nearest power of 2 that is bigger than `value`.
   * @method nextPowerOfTwo
   * @memberof module:Util
   * @param  {number} value
   * @return {number}
   */


  _exports.nearestPowerOfTwo = nearestPowerOfTwo;

  var nextPowerOfTwo = function nextPowerOfTwo(value) {
    var result = value;
    result -= 1;
    result |= result >> 1;
    result |= result >> 2;
    result |= result >> 4;
    result |= result >> 8;
    result |= result >> 16;
    result += 1;
    return result;
  };
  /**
   * An object with several utility functions.
   * @module Util
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2016. 03. 17.
   * @ignore
   */


  _exports.nextPowerOfTwo = nextPowerOfTwo;
  var MathUtil = {
    degToRad: degToRad,
    radToDeg: radToDeg,
    worldToScreen: worldToScreen,
    clamp: clamp,
    euclideanModulo: euclideanModulo,
    mapLinear: mapLinear,
    lerp: lerp,
    smoothstep: smoothstep,
    smootherstep: smootherstep,
    randInt: randInt,
    randFloat: randFloat,
    randFloatSpread: randFloatSpread,
    isPowerOfTwo: isPowerOfTwo,
    nearestPowerOfTwo: nearestPowerOfTwo,
    nextPowerOfTwo: nextPowerOfTwo
  };
  window.Math.degToRad = degToRad;
  window.Math.radToDeg = radToDeg;
  window.Math.worldToScreen = worldToScreen;
  var _default = MathUtil;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./math/Matrix3.js":
/*!*************************!*\
  !*** ./math/Matrix3.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Matrix4 from './Matrix4';

  /**
   * A
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)
   * list of matrix values.
   * @member {Float32Array} elements
   * @memberof Matrix3#
   * @default [
   * 1, 0, 0,
   * 0, 1, 0,
   * 0, 0, 1
   * ]
   */
  // let this._elements;

  /**
   * Used to check whether this or derived classes are {@link Matrix3}s. You
   * should not change this, as it is used internally for optimisation.
   * @property isMatrix3
   * @type {Boolean}
   * @default true
   */
  var _isMatrix3 = true;
  /**
   * @class Matrix3
   * @classdesc
   * A class representing a 3x3
   * [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)).
   * @example
   * var m = new Matrix3();
   */

  var Matrix3 =
  /*#__PURE__*/
  function () {
    function Matrix3() {
      _classCallCheck(this, Matrix3);

      this._elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }

    _createClass(Matrix3, [{
      key: "set",

      /**
       * Sets the 3x3 matrix values to the given
       * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)
       * sequence of values.
       * @method set
       * @memberof Matrix3.prototype
       * @param {number} n11 Value to put in row 1, col 1.
       * @param {number} n12 Value to put in row 1, col 2.
       * @param {number} n13 Value to put in row 1, col 3.
       * @param {number} n21 Value to put in row 2, col 1.
       * @param {number} n22 Value to put in row 2, col 2.
       * @param {number} n23 Value to put in row 2, col 3.
       * @param {number} n31 Value to put in row 3, col 1.
       * @param {number} n32 Value to put in row 3, col 2.
       * @param {number} n33 Value to put in row 3, col 3.
       */
      value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this._elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      /**
       * Resets this matrix to the 3x3 identity matrix:
       * ```
       * 1 0 0
       * 0 1 0
       * 0 0 1
       * ```
       * @method identity
       * @memberof Matrix3.prototype
       */

    }, {
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      /**
       * Creates a new matrix with identical elements to this one.
       * @method clone
       * @memberof Matrix3.prototype
       * @return {Matrix3}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Matrix3().fromArray(this._elements);
      }
      /**
       * Copies the elements of matrix `m` into this matrix.
       * @method copy
       * @memberof Matrix3.prototype
       * @param  {Matrix3} m
       */

    }, {
      key: "copy",
      value: function copy(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      }
      /**
       * Set this matrix to the upper 3x3 matrix of the {@link Matrix4} `m`.
       * @method setFromMatrix4
       * @memberof Matrix3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrix4",
      value: function setFromMatrix4(m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
      /**
       * Multiplies (applies) this matrix to every 3D vector in the `attribute`.
       * @method applyToBufferAttribute
       * @memberof Matrix3.prototype
       * @param  {BufferAttribute} attribute An attribute of floats that represet 3D vectors.
       * @return {BufferAttribute}
       */

    }, {
      key: "applyToBufferAttribute",
      value: function applyToBufferAttribute(attribute) {
        var v1 = new _Vector["default"]();

        for (var i = 0, l = attribute.count; i < l; i += 1) {
          v1.x = attribute.getX(i);
          v1.y = attribute.getY(i);
          v1.z = attribute.getZ(i);
          v1.applyMatrix3(this);
          attribute.setXYZ(i, v1.x, v1.y, v1.z);
        }

        return attribute;
      }
      /**
       * Multiplies every component of the matrix by the scalar value `s`.
       * @method multiplyScalar
       * @memberof Matrix3.prototype
       * @param {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this._elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      /**
       * Computes and returns the
       * [determinant](https://en.wikipedia.org/wiki/Determinant) of this matrix.
       * @method determinant
       * @memberof Matrix3.prototype
       * @return {number}
       */

    }, {
      key: "determinant",
      value: function determinant() {
        var te = this._elements;
        var a = te[0];
        var b = te[1];
        var c = te[2];
        var d = te[3];
        var e = te[4];
        var f = te[5];
        var g = te[6];
        var h = te[7];
        var i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      }
      /**
       * Set this matrix to the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of the passed
       * matrix `matrix`, using the
       * [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
       * If `throwOnDegenerate` is not set and the matrix is not invertible, set
       * this to the 3x3 identity matrix.
       * @method getInverse
       * @memberof Matrix3.prototype
       * @param  {Matrix3} matrix The matrix to take the inverse of.
       * @param  {boolean} [throwOnDegenerate=false] If true, throw an error if the matrix is degenerate (not invertible).
       */

    }, {
      key: "getInverse",
      value: function getInverse(matrix) {
        var throwOnDegenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var me = matrix.elements;
        var te = this._elements;
        var n11 = me[0];
        var n21 = me[1];
        var n31 = me[2];
        var n12 = me[3];
        var n22 = me[4];
        var n32 = me[5];
        var n13 = me[6];
        var n23 = me[7];
        var n33 = me[8];
        var t11 = n33 * n22 - n32 * n23;
        var t12 = n32 * n13 - n33 * n12;
        var t13 = n23 * n12 - n22 * n13;
        var det = n11 * t11 + n21 * t12 + n31 * t13;

        if (det === 0) {
          var msg = 'Matrix3.getInverse(): can\'t invert matrix, determinant is 0';

          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }

          return this.identity();
        }

        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix in place.
       * @method transpose
       * @memberof Matrix3.prototype
       */

    }, {
      key: "transpose",
      value: function transpose() {
        var tmp;
        var m = this._elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      }
      /**
       * Sets this matrix as the upper left 3x3 of the
       * [normal matrix](https://en.wikipedia.org/wiki/Normal_matrix) of the passed
       * `matrix4`. The normal matrix is the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix)
       * [transpose](https://en.wikipedia.org/wiki/Transpose) of the matrix
       * `matrix4`.
       * @method getNormalMatrix
       * @memberof Matrix3.prototype
       * @param {Matrix4} matrix4
       */

    }, {
      key: "getNormalMatrix",
      value: function getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix into the
       * supplied array, and returns itself unchanged.
       * @method transposeIntoArray
       * @memberof Matrix3.prototype
       * @param {Array} r Array to store the resulting vector in.
       */

    }, {
      key: "transposeIntoArray",
      value: function transposeIntoArray(r) {
        var m = this._elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      }
      /**
       * Sets the elements of this matrix based on an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method fromArray
       * @memberof Matrix3.prototype
       * @param  {Array} array The array to read the elements from.
       * @param  {number} [offset=0] Index of first element in the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var index = offset || 0;

        for (var i = 0; i < 9; i += 1) {
          this._elements[i] = array[i + index];
        }

        return this;
      }
      /**
       * Writes the elements of this matrix to an array in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method toArray
       * @memberof Matrix3.prototype
       * @param  {Array} [array=[]]  Array to store the resulting vector in. If not given a new array will be created.
       * @param  {number} [offset=0] Offset in the array at which to put the result.
       * @return {Array}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (array === undefined) {
          array = [];
        }

        var index = offset || 0;
        var te = this._elements;

        for (var i = 0; i < te.length; i += 1) {
          array[index + i] = te[i];
        }

        return array;
      }
    }, {
      key: "elements",
      get: function get() {
        return this._elements;
      }
    }, {
      key: "isMatrix3",
      get: function get() {
        return _isMatrix3;
      }
    }]);

    return Matrix3;
  }();

  _exports["default"] = Matrix3;
});

/***/ }),

/***/ "./math/Matrix4.js":
/*!*************************!*\
  !*** ./math/Matrix4.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Quaternion, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // constants for optimisation
  var extractRotationV;
  var lookAtX;
  var lookAtY;
  var lookAtZ;
  var decomposeV;
  var decomposeM;
  /**
   * A
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
   * list of matrix values.
   * @member {number[]} elements
   * @memberof Matrix4#
   * @default [
   * 1, 0, 0, 0,
   * 0, 1, 0, 0,
   * 0, 0, 1, 0,
   * 0, 0, 0, 1
   * ]
   */
  // let this.elements = [
  //   1, 0, 0, 0,
  //   0, 1, 0, 0,
  //   0, 0, 1, 0,
  //   0, 0, 0, 1
  // ];

  var onChangeCallback = function onChangeCallback() {};

  var _isMatrix4 = true;
  /**
   * @class Matrix4
   * @classdesc
   * A class representing a 4x4
   * [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)). The most
   * common use of a 4x4 matrix in 3D computer graphics is as a
   * [transformation matrix](https://en.wikipedia.org/wiki/Transformation_matrix).
   * For an introduction to transformation matrices as used in WebGL, check out
   * this
   * [tutorial](http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices).
   * This allows a {@link Vector3} representing a point in 3D space to undergo
   * transformations such as translation, rotation, shear, scale, reflection,
   * orthogonal or perspective projection and so on, by being multiplied by the
   * matrix. This is known as _applying_ the matrix to the vector.
   *
   * Every {@link Object3D} has three associated {@link Matrix4}s:
   * * {@link Object3D#matrix}: this stores the local transform of the object.
   * * {@link Object3D#matrixWorld}: the global or world transform of the object. This is the objects transformation relative to its parent. If the object has no parent, then this is identical to the local transform.
   * * {@link Object3D#modelViewMatrix}: TODO.
   *
   * {@link Camera}s have two additional {@link Matrix4}s:
   * * {@link Camera#matrixWorldInverse}: The inverse of the {@link Object3D#matrixWorld} described above.
   * * {@link Camera#projectionMatrix}: TODO.
   */

  var Matrix4 =
  /*#__PURE__*/
  function () {
    function Matrix4() {
      _classCallCheck(this, Matrix4);

      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    } //
    // get elements() {
    //   return this.elements;
    // }


    _createClass(Matrix4, [{
      key: "set",

      /**
       * Set the {@link Matrix4#elements} of this matrix to the supplied row-major
       * values `n11`, `n12`, ..., `n44`.
       * @method set
       * @memberof Matrix4.prototype
       * @param {number} n11
       * @param {number} n12
       * @param {number} n13
       * @param {number} n14
       * @param {number} n21
       * @param {number} n22
       * @param {number} n23
       * @param {number} n24
       * @param {number} n31
       * @param {number} n32
       * @param {number} n33
       * @param {number} n34
       * @param {number} n41
       * @param {number} n42
       * @param {number} n43
       * @param {number} n44
       */
      value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        this.onChangeCallback();
        return this;
      }
      /**
       * Resets this matrix to the
       * [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix).
       * @method identity
       * @memberof Matrix4.prototype
       */

    }, {
      key: "identity",
      value: function identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Creates a new matrix with identical {@link Matrix4#elements} to this one.
       * @method clone
       * @memberof Matrix4.prototype
       * @return {Matrix4}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Matrix4().fromArray(this.elements);
      }
      /**
       * Copies the {@link Matrix4#elements} of matrix `m` into this matrix.
       * @method copy
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "copy",
      value: function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        this.onChangeCallback();
        return this;
      }
      /**
       * Copies the translation component of the supplied matrix `m` into this
       * matrix's translation component.
       * @method copyPosition
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "copyPosition",
      value: function copyPosition(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        this.onChangeCallback();
        return this;
      }
      /**
       * Extracts the [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra))
       * of this matrix into the three axis vectors provided. If this matrix is:
       * ```
       * a b c d
       * e f g h
       * i j k l
       * m n o p
       * ```
       * then the `xAxis`, `yAxis`, `zAxis` will be set to:
       * ```
       * xAxis = (a, e, i)
       * yAxis = (d, f, j)
       * zAxis = (c, g, k)
       * ```
       * @method extractBasis
       * @memberof Matrix4.prototype
       * @param {Vector3} xAxis
       * @param {Vector3} yAxis
       * @param {Vector3} zAxis
       */

    }, {
      key: "extractBasis",
      value: function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      /**
       * Set this to the
       * [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra)) matrix
       * consisting of the three provided basis vectors:
       * ```
       * xAxis.x  yAxis.x  zAxis.x  0
       * xAxis.y  yAxis.y  zAxis.y  0
       * xAxis.z  yAxis.z  zAxis.z  0
       *    0        0        0     0
       * ```
       * @method makeBasis
       * @memberof Matrix4.prototype
       * @param {Vector3} xAxis
       * @param {Vector3} yAxis
       * @param {Vector3} zAxis
       */

    }, {
      key: "makeBasis",
      value: function makeBasis(xAxis, yAxis, zAxis) {
        return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      }
      /**
       * Extracts the rotation component of the supplied matrix `m` into this
       * matrix's rotation component.
       * @method extractRotation
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "extractRotation",
      value: function extractRotation(m) {
        if (typeof extractRotationV === 'undefined') {
          extractRotationV = new _Vector["default"]();
        }

        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / extractRotationV.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / extractRotationV.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / extractRotationV.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
       * the orientation specified by the given {@link Euler} angle. The rest of the
       * matrix is set to the identity. Depending on the {@link Euler#order} of the
       * `euler`, there are six possible outcomes. See
       * [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
       * for a complete list.
       * @method makeRotationFromEuler
       * @memberof Matrix4.prototype
       * @param  {Euler} euler
       */

    }, {
      key: "makeRotationFromEuler",
      value: function makeRotationFromEuler(euler) {
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z,
            order = euler.order;
        var cx = Math.cos(x);
        var sx = Math.sin(x);
        var cy = Math.cos(y);
        var sy = Math.sin(y);
        var cz = Math.cos(z);
        var sz = Math.sin(z);

        if (order === 'XYZ') {
          te[0] = cy * cz;
          te[4] = -cy * sz;
          te[8] = sy;
          te[1] = cx * sz + sx * cz * sy;
          te[5] = cx * cz - sx * sz * sy;
          te[9] = -sx * cy;
          te[2] = sx * sz - cx * cz * sy;
          te[6] = sx * cz + cx * sz * sy;
          te[10] = cx * cy;
        } else if (order === 'YXZ') {
          te[0] = cy * cz + sy * sz * sx;
          te[4] = sy * cz * sx - cy * sz;
          te[8] = cx * sy;
          te[1] = cx * sz;
          te[5] = cx * cz;
          te[9] = -sx;
          te[2] = cy * sz * sx - sy * cz;
          te[6] = sy * sz + cy * cz * sx;
          te[10] = cx * cy;
        } else if (order === 'ZXY') {
          te[0] = cy * cz - sy * sz * sx;
          te[4] = -cx * sz;
          te[8] = sy * cz + cy * sz * sx;
          te[1] = cy * sz + sy * cz * sx;
          te[5] = cx * cz;
          te[9] = sy * sz - cy * cz * sx;
          te[2] = -cx * sy;
          te[6] = sx;
          te[10] = cx * cy;
        } else if (order === 'ZYX') {
          te[0] = cy * cz;
          te[4] = sx * cz * sy - cx * sz;
          te[8] = cx * cz * sy + sx * sz;
          te[1] = cy * sz;
          te[5] = sx * sz * sy + cx * cz;
          te[9] = cx * sz * sy - sx * cz;
          te[2] = -sy;
          te[6] = sx * cy;
          te[10] = cx * cy;
        } else if (order === 'YZX') {
          te[0] = cy * cz;
          te[4] = sx * sy - cx * cy * sz;
          te[8] = sx * cy * sz + cx * sy;
          te[1] = sz;
          te[5] = cx * cz;
          te[9] = -sx * cz;
          te[2] = -sy * cz;
          te[6] = cx * sy * sz + sx * cy;
          te[10] = cx * cy - sx * sy * sz;
        } else if (order === 'XZY') {
          te[0] = cy * cz;
          te[4] = -sz;
          te[8] = sy * cz;
          te[1] = cx * cy * sz + sx * sy;
          te[5] = cx * cz;
          te[9] = cx * sy * sz - sx * cy;
          te[2] = sx * cy * sz - cx * sy;
          te[6] = sx * cz;
          te[10] = sx * sy * sz + cx * cy;
        } // last column


        te[3] = 0;
        te[7] = 0;
        te[11] = 0; // bottom row

        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the rotation component of this matrix to the rotation specified by
       * `q`, as outlined
       * [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion). The rest
       * of the matrix is set to the identity. So, given `q = w + xi + yj + zk`,
       * the resulting matrix will be:
       * <pre class="code prettyprint prettyprinted" style=""><code><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2y<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2z<sup>2</sup></span><span class="pln">     </span><span class="lit">2xy</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2zw</span><span class="pln">       </span><span class="lit">2xz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2yw</span><span class="pln">     </span><span class="lit">0</span>
       * <span class="pln"> </span><span class="lit">2xy</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2zw</span><span class="pln">      </span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2x<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2z<sup>2</sup></span><span class="pln">     </span><span class="lit">2yz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2xw</span><span class="pln">     </span><span class="lit">0</span>
       * <span class="pln"> </span><span class="lit">2xz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2yw</span><span class="pln">        </span><span class="lit">2yz</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2xw</span><span class="pln">     </span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2x<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2y<sup>2</sup></span><span class="pln">   </span><span class="lit">0</span>
       * <span class="pln">     </span><span class="lit">0</span><span class="pln">                </span><span class="lit">0</span><span class="pln">               </span><span class="lit">0</span><span class="pln">         </span><span class="lit">1</span></code></pre>
       * @method makeRotationFromQuaternion
       * @memberof Matrix4.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "makeRotationFromQuaternion",
      value: function makeRotationFromQuaternion(q) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        return this.set(1 - (yy + zz), xy - wz, xz + wy, 0, xy + wz, 1 - (xx + zz), yz - wx, 0, xz - wy, yz + wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
      }
      /**
       * Constructs a rotation matrix, looking from `eye` towards `target` oriented
       * by the `up` vector.
       * @method lookAt
       * @memberof Matrix4.prototype
       * @param  {Vector3} eye
       * @param  {Vector3} target
       * @param  {Vector3} up
       */

    }, {
      key: "lookAt",
      value: function lookAt(eye, target, up) {
        if (typeof lookAtX === 'undefined') {
          lookAtX = new _Vector["default"]();
        }

        if (typeof lookAtY === 'undefined') {
          lookAtY = new _Vector["default"]();
        }

        if (typeof lookAtZ === 'undefined') {
          lookAtZ = new _Vector["default"]();
        }

        var te = this.elements;
        lookAtZ.subVectors(eye, target);

        if (lookAtZ.lengthSq() === 0) {
          lookAtZ._z = 1;
        }

        lookAtZ.normalize();
        lookAtX.crossVectors(up, lookAtZ);

        if (lookAtX.lengthSq() === 0) {
          lookAtZ._z += 0.0001;
          lookAtX.crossVectors(up, lookAtZ);
        }

        lookAtX.normalize();
        lookAtY.crossVectors(lookAtZ, lookAtX);
        te[0] = lookAtX._x;
        te[4] = lookAtY._x;
        te[8] = lookAtZ._x;
        te[1] = lookAtX._y;
        te[5] = lookAtY._y;
        te[9] = lookAtZ._y;
        te[2] = lookAtX._z;
        te[6] = lookAtY._z;
        te[10] = lookAtZ._z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Post-multiplies this matrix by `m`.
       * @method multiply
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "multiply",
      value: function multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      /**
       * Pre-multiplies this matrix by `m`.
       * @method premultiply
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "premultiply",
      value: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      /**
       * Sets this matrix to `a × b`.
       * @method multiplyMatrices
       * @memberof Matrix4.prototype
       * @param {Matrix4} a
       * @param {Matrix4} b
       */

    }, {
      key: "multiplyMatrices",
      value: function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var _ae = _slicedToArray(ae, 16),
            a11 = _ae[0],
            a21 = _ae[1],
            a31 = _ae[2],
            a41 = _ae[3],
            a12 = _ae[4],
            a22 = _ae[5],
            a32 = _ae[6],
            a42 = _ae[7],
            a13 = _ae[8],
            a23 = _ae[9],
            a33 = _ae[10],
            a43 = _ae[11],
            a14 = _ae[12],
            a24 = _ae[13],
            a34 = _ae[14],
            a44 = _ae[15];

        var _be = _slicedToArray(be, 16),
            b11 = _be[0],
            b21 = _be[1],
            b31 = _be[2],
            b41 = _be[3],
            b12 = _be[4],
            b22 = _be[5],
            b32 = _be[6],
            b42 = _be[7],
            b13 = _be[8],
            b23 = _be[9],
            b33 = _be[10],
            b43 = _be[11],
            b14 = _be[12],
            b24 = _be[13],
            b34 = _be[14],
            b44 = _be[15];

        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies every component of the matrix by a scalar value `s`.
       * @method multiplyScalar
       * @memberof Matrix4.prototype
       * @param  {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this.elements;

        for (var i = 0; i < te.length; i++) {
          te[i] *= s;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Computes and returns the
       * [determinant](https://en.wikipedia.org/wiki/Determinant) of this matrix.
       * Based on the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm).
       * @method determinant
       * @memberof Matrix4.prototype
       * @return {number}
       */

    }, {
      key: "determinant",
      value: function determinant() {
        var te = this.elements;

        var _te = _slicedToArray(te, 16),
            n11 = _te[0],
            n21 = _te[1],
            n31 = _te[2],
            n41 = _te[3],
            n12 = _te[4],
            n22 = _te[5],
            n32 = _te[6],
            n42 = _te[7],
            n13 = _te[8],
            n23 = _te[9],
            n33 = _te[10],
            n43 = _te[11],
            n14 = _te[12],
            n24 = _te[13],
            n34 = _te[14],
            n44 = _te[15]; // TODO: make this more efficient
        // ( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )


        var a = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var b = n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31;
        var c = n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31;
        var d = -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31;
        return n41 * a + n42 * b + n43 * c + n44 * d;
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix.
       * @method transpose
       * @memberof Matrix4.prototype
       */

    }, {
      key: "transpose",
      value: function transpose() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the position component for this matrix from vector `v`, without
       * affecting the rest of the matrix - i.e. if the matrix is currently:
       * ```
       * a  b  c  d
       * e  f  g  h
       * i  j  k  l
       * m  n  o  p
       * ```
       * this becomes:
       * ```
       * a  b  c v.x
       * e  f  g v.y
       * i  j  k v.z
       * m  n  o  p
       * ```
       * @method setPosition
       * @memberof Matrix4.prototype
       * @param {Vector3} v
       */

    }, {
      key: "setPosition",
      value: function setPosition(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this matrix to the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of the passed
       * matrix `m`, using the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm).
       * If `throwOnDegenerate` is not set and the matrix is not invertible, sets
       * this to the 4x4 identity matrix.
       * @method getInverse
       * @memberof Matrix4.prototype
       * @param {Matrix4} m The matrix to take the inverse of.
       * @param {boolean} [throwOnDegenerate=false] If true, throw an error if the matrix is degenerate (not invertible).
       */

    }, {
      key: "getInverse",
      value: function getInverse(m) {
        var throwOnDegenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var te = this.elements;
        var me = m.elements;

        var _me = _slicedToArray(me, 16),
            n11 = _me[0],
            n21 = _me[1],
            n31 = _me[2],
            n41 = _me[3],
            n12 = _me[4],
            n22 = _me[5],
            n32 = _me[6],
            n42 = _me[7],
            n13 = _me[8],
            n23 = _me[9],
            n33 = _me[10],
            n43 = _me[11],
            n14 = _me[12],
            n24 = _me[13],
            n34 = _me[14],
            n44 = _me[15];

        var t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        var t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        var t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        var t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

        if (det === 0) {
          var msg = 'Matrix4.getInverse(): can\'t invert matrix, determinant is 0';

          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }

          this.onChangeCallback();
          return this.identity();
        }

        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies the columns of this matrix by vector `v`.
       * @method scale
       * @memberof Matrix4.prototype
       * @param {Vector3} v
       */

    }, {
      key: "scale",
      value: function scale(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Gets the maximum scale value of the 3 axes.
       * @method getMaxScaleOnAxis
       * @memberof Matrix4.prototype
       * @return {number}
       */

    }, {
      key: "getMaxScaleOnAxis",
      value: function getMaxScaleOnAxis() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      /**
       * Sets this matrix as a translation transform:
       * ```
       * 1  0  0  x
       * 0  1  0  y
       * 0  0  1  z
       * 0  0  0  1
       * ```
       * @method makeTranslation
       * @memberof Matrix4.prototype
       * @param {number} x The amount to translate in the x axis.
       * @param {number} y The amount to translate in the y axis.
       * @param {number} z The amount to translate in the z axis.
       */

    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the x axis by
       * `theta`. The resulting matrix will be:
       * ```
       * 1    0      0      0
       * 0  cos(θ) -sin(θ)  0
       * 0  sin(θ)  cos(θ)  0
       * 0    0      0      1
       * ```
       * @method makeRotationX
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationX",
      value: function makeRotationX(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the y axis by
       * `theta`. The resulting matrix will be:
       * ```
       *  cos(θ)  0  sin(θ)  0
       *    0     1    0     0
       * -sin(θ)  0  cos(θ)  0
       *    0     0    0     1
       * ```
       * @method makeRotationY
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationY",
      value: function makeRotationY(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the z axis by
       * `theta`. The resulting matrix will be:
       * ```
       * cos(θ) -sin(θ)  0  0
       * sin(θ)  cos(θ)  0  0
       *   0       0     1  0
       *   0       0     0  1
       * ```
       * @method makeRotationZ
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationZ",
      value: function makeRotationZ(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as rotation transform around `axis` by `theta`. This is a
       * somewhat controversial but mathematically sound alternative to rotating
       * via {@link Quaternion}s. See the discussion
       * [here](http://www.gamedev.net/reference/articles/article1199.asp).
       * @method makeRotationAxis
       * @memberof Matrix4.prototype
       * @param {Vector3} axis
       * @param {number} angle
       */

    }, {
      key: "makeRotationAxis",
      value: function makeRotationAxis(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x;
        var ty = t * y;
        return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a scale transform:
       * ```
       * x  0  0  0
       * 0  y  0  0
       * 0  0  z  0
       * 0  0  0  1
       * ```
       * @method makeScale
       * @memberof Matrix4.prototype
       * @param {number} x The amount to scale in the x axis.
       * @param {number} y The amount to scale in the y axis.
       * @param {number} z The amount to scale in the z axis.
       */

    }, {
      key: "makeScale",
      value: function makeScale(x, y, z) {
        return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a shear transform:
       * ```
       * 1  y  z  0
       * x  1  z  0
       * x  y  1  0
       * 0  0  0  1
       * ```
       * @method makeShear
       * @memberof Matrix4.prototype
       * @param {number} x The amount to shear in the x axis.
       * @param {number} y The amount to shear in the y axis.
       * @param {number} z The amount to shear in the z axis.
       */

    }, {
      key: "makeShear",
      value: function makeShear(x, y, z) {
        return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix to the transformation composed of `position`,
       * `quaternion`, and `scale`. Internally this calls
       * {@link Matrix4#makeRotationFromQuaternion} followed by
       * {@link Matrix4#scale}, then finally {@link Matrix4#setPosition}.
       * @method compose
       * @memberof Matrix4.prototype
       * @param  {Vector3} position
       * @param  {Quaternion} quaternion
       * @param  {Vector3} scale
       */

    }, {
      key: "compose",
      value: function compose(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      }
      /**
       * Decomposes this matrix into it's `position`, 'quaternion', and 'scale'
       * components.
       * @method decompose
       * @memberof Matrix4.prototype
       * @param  {Vector3} position
       * @param  {Quaternion} quaternion
       * @param  {Vector3} scale
       */

    }, {
      key: "decompose",
      value: function decompose() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var quaternion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (typeof decomposeV === 'undefined') {
          decomposeV = new _Vector["default"]();
        }

        if (typeof decomposeM === 'undefined') {
          decomposeM = new Matrix4();
        }

        var te = this.elements;
        var sx = decomposeV.set(te[0], te[1], te[2]).length();
        var sy = decomposeV.set(te[4], te[5], te[6]).length();
        var sz = decomposeV.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

        var det = this.determinant();

        if (det < 0) {
          sx = -sx;
        }

        position.set(te[12], te[13], te[14]); // scale the rotation part
        // at this point matrix is incomplete so we can't use .copy()

        decomposeM.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        decomposeM.elements[0] *= invSX;
        decomposeM.elements[1] *= invSX;
        decomposeM.elements[2] *= invSX;
        decomposeM.elements[4] *= invSY;
        decomposeM.elements[5] *= invSY;
        decomposeM.elements[6] *= invSY;
        decomposeM.elements[8] *= invSZ;
        decomposeM.elements[9] *= invSZ;
        decomposeM.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(decomposeM);
        scale.set(sx, sy, sz);
        return this;
      }
    }, {
      key: "makeFrustum",

      /**
       * Creates a
       * [perspective projection](https://en.wikipedia.org/wiki/3D_projection#Perspective_projection)
       * matrix.
       * @method makeFrustum
       * @memberof Matrix4.prototype
       * @param {number} left
       * @param {number} right
       * @param {number} top
       * @param {number} bottom
       * @param {number} near
       * @param {number} far
       */
      value: function makeFrustum(left, right, top, bottom, near, far) {
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near); //     return this.set(
        //         x, 0, a, 0,
        //         0, y, b, 0,
        //         0, 0, c, d,
        //         0, 0, -1, 0,
        //     );

        return this.set(0, -x, a, 0, -y, 0, b, 0, 0, 0, -c, d, 0, 0, 1, 0);
      }
    }, {
      key: "makePerspective",
      value: function makePerspective(fov, aspect, near, far) {
        var ymin = near * Math.tan((0, _Math.degToRad)(fov * 0.5));
        var ymax = -ymin;
        var xmin = ymax * aspect;
        var xmax = ymin * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      }
      /**
       * Creates an
       * [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)
       * matrix. This is used internally by
       * {@link OrthographicCamera#updateProjectionMatrix}.
       * @method makeOrthographic
       * @memberof Matrix4.prototype
       * @param {number} left
       * @param {number} right
       * @param {number} top
       * @param {number} bottom
       * @param {number} near
       * @param {number} far
       */

    }, {
      key: "makeOrthographic",
      value: function makeOrthographic(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        return this.set(2 * w, 0, 0, -x, 0, 2 * h, 0, -y, 0, 0, -2 * p, -z, 0, 0, 0, 1);
      }
      /**
       * Return true if this matrix and `matrix` are equal.
       * @method equals
       * @memberof Matrix4.prototype
       * @param  {Matrix4} matrix
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;

        for (var i = 0; i < 16; i += 1) {
          if (te[i] !== me[i]) {
            return false;
          }
        }

        return true;
      }
      /**
       * Sets the {@link Matrix4#elements} of this matrix based on an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method fromArray
       * @memberof Matrix4.prototype
       * @param  {Array} array The array to read the {@link Matrix4#elements} from.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;

        for (var i = 0; i < te.length; i += 1) {
          te[i] = array[i + offset];
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Writes the elements of this matrix to an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method toArray
       * @memberof Matrix4.prototype
       * @param  {Array} [array=[]] Array to store the resulting vector in.
       * @param  {number} [offset=0] Offset in the array at which to put the result.
       * @return {Array}        [description]
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;

        for (var i = 0; i < 16; i += 1) {
          array[offset + i] = te[i];
        }

        return array;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "isMatrix4",
      get: function get() {
        return _isMatrix4;
      }
    }, {
      key: "decomposedValue",
      get: function get() {
        var position = new _Vector["default"]();
        var quaternion = new _Quaternion["default"]();
        var scale = new _Vector["default"]();

        if (typeof decomposeV === 'undefined') {
          decomposeV = new _Vector["default"]();
        }

        if (typeof decomposeM === 'undefined') {
          decomposeM = new Matrix4();
        }

        var te = this.elements;
        var sx = decomposeV.set(te[0], te[1], te[2]).length();
        var sy = decomposeV.set(te[4], te[5], te[6]).length();
        var sz = decomposeV.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

        var det = this.determinant();

        if (det < 0) {
          sx = -sx;
        }

        position.set(te[12], te[13], te[14]); // scale the rotation part
        // at this point matrix is incomplete so we can't use .copy()

        decomposeM.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        decomposeM.elements[0] *= invSX;
        decomposeM.elements[1] *= invSX;
        decomposeM.elements[2] *= invSX;
        decomposeM.elements[4] *= invSY;
        decomposeM.elements[5] *= invSY;
        decomposeM.elements[6] *= invSY;
        decomposeM.elements[8] *= invSZ;
        decomposeM.elements[9] *= invSZ;
        decomposeM.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(decomposeM);
        scale.set(sx, sy, sz);
        return {
          position: position,
          quaternion: quaternion,
          scale: scale
        };
      }
    }]);

    return Matrix4;
  }();

  _exports["default"] = Matrix4;
});

/***/ }),

/***/ "./math/Quaternion.js":
/*!****************************!*\
  !*** ./math/Quaternion.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Euler from './Euler';
  // import Matrix4 from './Matrix4';
  var EPSILON = Number.EPSILON;

  if (typeof EPSILON === 'undefined') {
    EPSILON = Math.pow(2, -52);
  } // constants for optimisation


  var setFromUnitVectorsEPS = 0.000001;
  var setFromUnitVectorsV; // let this.x = 0, this.y = 0, this.z = 0, this.w = 1;

  /**
   * This function is called whenever and of the following occur:
   * * The {@link Quaternion#x}, {@link Quaternion#y}, {@link Quaternion#z}, or {@link Quaternion#w} properties are changed.
   * * The {@link Quaternion#set}, {@link Quaternion#copy}, {@link Quaternion$clone}, {@link Quaternion#setFromAxisAngle}, {@link Quaternion$setFromRotationMatrix}, {@link Quaternion#conjugate}, {@link Quaternion#normalize}, {@link Quaternion#multiplyQuaternions}, {@link Quaternion#slerp}, {@link Quaternion#fromArray} functions are called.
   * * {@link Quaternion#setFromEuler} function is called with its `update` argument set to `true`.
   * By default, it is an empty function, however you can change it if needed using {@link Quaternion#onChange}.
   * @property onChangeCallback
   * @type {Function}
   * @default function() {}
   */

  var onChangeCallback = function onChangeCallback() {};

  var _isQuaternion = true;
  /**
   * @class Quaternion
   * @classdesc
   * Implementation of a [quaternion](http://en.wikipedia.org/wiki/Quaternion).
   * This is used for
   * [rotating things](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)
   * without encountering the dreaded
   * [gimbal lock](http://en.wikipedia.org/wiki/Gimbal_lock) issue, amongst other
   * advantages.
   * @example
   * var quaternion = new Quaternion();
   * quaternion.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
   *
   * var vector = new Vector3(1, 0, 0);
   * vector.applyQuaternion(quaternion);
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @param {number} [z=0]
   * @param {number} [w=1]
   */

  var Quaternion =
  /*#__PURE__*/
  function () {
    function Quaternion() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      _classCallCheck(this, Quaternion);

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} x
     * @memberof Quaternion#
     * @default 0
     */
    // get x() {
    //   return this.x;
    // }
    //
    // set x(value) {
    //   this.x = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} y
     * @memberof Quaternion#
     * @default 0
     */
    // get y() {
    //   return this.y;
    // }
    //
    // set y(value) {
    //   this.y = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} z
     * @memberof Quaternion#
     * @default 0
     */
    // get z() {
    //   return this.z;
    // }
    //
    // set z(value) {
    //   this.z = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} w
     * @memberof Quaternion#
     * @default 1
     */
    // get w() {
    //   return this.w;
    // }
    //
    // set w(value) {
    //   this.w = value;
    //   this.onChangeCallback();
    // }


    _createClass(Quaternion, [{
      key: "set",

      /**
       * Sets {@link Quaternion#x}, {@link Quaternion#y}, {@link Quaternion#z}, and
       * {@link Quaternion#w} properties of this quaternion.
       * @method set
       * @memberof Quaternion.prototype
       * @param {number} x
       * @param {number} y
       * @param {number} z
       * @param {number} w
       */
      value: function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        this.onChangeCallback();
        return this;
      }
      /**
       * Creates a new {@link Quaternion} with identical {@link Quaternion#x},
       * {@link Quaternion#y}, {@link Quaternion#z}, and {@link Quaternion#w}
       * properties to this one.
       * @method clone
       * @memberof Quaternion.prototype
       * @return {Quaternion}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      }
      /**
       * Copies the {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties of `quaternion`
       * into this quaternion.
       * @method copy
       * @memberof Quaternion.prototype
       * @param {Quaternion} quaternion
       */

    }, {
      key: "copy",
      value: function copy(quaternion) {
        this.x = quaternion.x;
        this.y = quaternion.y;
        this.z = quaternion.z;
        this.w = quaternion.w;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion from the rotation specified by {@link Euler} angle.
       * @method setFromEuler
       * @memberof Quaternion.prototype
       * @param {Euler} euler
       * @param {boolean} update
       */

    }, {
      key: "setFromEuler",
      value: function setFromEuler(euler) {
        var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        // content/SpinCalc.m
        var c1 = Math.cos(euler.x / 2);
        var c2 = Math.cos(euler.y / 2);
        var c3 = Math.cos(euler.z / 2);
        var s1 = Math.sin(euler.x / 2);
        var s2 = Math.sin(euler.y / 2);
        var s3 = Math.sin(euler.z / 2);
        var order = euler.order;

        if (order === 'XYZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        }

        if (update !== false) {
          this.onChangeCallback();
        }

        return this;
      }
      /**
       * Sets this quaternion from rotation specified by `axis` and `angle`. Adapted
       * from the method
       * [here](http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm).
       * `axis` is assumed to be normalized, `angle` is in radians.
       * @method setFromAxisAngle
       * @memberof Quaternion.prototype
       * @param {Vector3} axis
       * @param {number} number
       */

    }, {
      key: "setFromAxisAngle",
      value: function setFromAxisAngle(axis, angle) {
        var halfAngle = angle / 2;
        var s = Math.sin(halfAngle);
        this.x = axis.x * s;
        this.y = axis.y * s;
        this.z = axis.z * s;
        this.w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion from rotation component of `m`. Adapted from the
       * method
       * [here](http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm).
       * @method setFromRotationMatrix
       * @memberof Quaternion.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;

        var _te = _slicedToArray(te, 12),
            m11 = _te[0],
            m21 = _te[1],
            m31 = _te[2],
            m41 = _te[3],
            m12 = _te[4],
            m22 = _te[5],
            m32 = _te[6],
            m42 = _te[7],
            m13 = _te[8],
            m23 = _te[9],
            m33 = _te[10],
            m43 = _te[11];

        var trace = m11 + m22 + m33;
        var s;

        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this.w = 0.25 / s;
          this.x = (m32 - m23) * s;
          this.y = (m13 - m31) * s;
          this.z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this.w = (m32 - m23) / s;
          this.x = 0.25 * s;
          this.y = (m12 + m21) / s;
          this.z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this.w = (m13 - m31) / s;
          this.x = (m12 + m21) / s;
          this.y = 0.25 * s;
          this.z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this.w = (m21 - m12) / s;
          this.x = (m13 + m31) / s;
          this.y = (m23 + m32) / s;
          this.z = 0.25 * s;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion to the rotation required to rotate direction vector
       * `vFrom` to direction vector `vTo`. Adapted from the method
       * [here](http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors).
       * `vFrom` and `vTo` are assumed to be normalized.
       * @method setFromUnitVectors
       * @memberof Quaternion.prototype
       * @param {Vector3} vFrom
       * @param {Vector3} vTo
       */

    }, {
      key: "setFromUnitVectors",
      value: function setFromUnitVectors(vFrom, vTo) {
        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
        if (typeof setFromUnitVectorsV === 'undefined') {
          setFromUnitVectorsV = new _Vector["default"]();
        }

        var r = vFrom.dot(vTo) + 1;

        if (r < setFromUnitVectorsEPS) {
          r = 0;

          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            setFromUnitVectorsV.set(-vFrom.y, vFrom.x, 0);
          } else {
            setFromUnitVectorsV.set(0, -vFrom.z, vFrom.y);
          }
        } else {
          setFromUnitVectorsV.crossVectors(vFrom, vTo);
        }

        this.x = setFromUnitVectorsV.x;
        this.y = setFromUnitVectorsV.y;
        this.z = setFromUnitVectorsV.z;
        this.w = r;
        return this.normalize();
      }
      /**
       * Inverts this quaternion - calculate the {@link Quaternion#conjugate} and
       * then [normalizes]{@link Quaternion#normalize} the result.
       * @method inverse
       * @memberof Quaternion.prototype
       */

    }, {
      key: "inverse",
      value: function inverse() {
        return this.conjugate().normalize();
      }
      /**
       * Returns the rotational conjugate of this quaternion. The conjugate of a
       * quaternion represents the same rotation in the opposite direction about
       * the rotational axis.
       * @method conjugate
       * @memberof Quaternion.prototype
       */

    }, {
      key: "conjugate",
      value: function conjugate() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        this.onChangeCallback();
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * quaternions `v` and this one.
       * @method dot
       * @memberof Quaternion.prototype
       * @param {Quaternion} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) of this quaternion, considered as a 4 dimensional
       * vector. This can be useful if you are comparing the lengths of two
       * quaternions, as this is slightly more efficient calculation than
       * {@link Quaternion#length}.
       * @method lengthSq
       * @memberof Quaternion.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) of this quaternion, considered as a 4 dimensional
       * vector.
       * @method length
       * @memberof Quaternion.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      /**
       * [Normalizes](https://en.wikipedia.org/wiki/Normalized_vector) this
       * quaternion - that is, calculates the quaternion that performs the same
       * rotation as this one, but has {@link Quaternion#length} equal to `1`.
       * @method normalize
       * @memberof Quaternion.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        var l = this.length();

        if (l === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 1;
        } else {
          l = 1 / l;
          this.x = this.x * l;
          this.y = this.y * l;
          this.z = this.z * l;
          this.w = this.w * l;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this quaternion by `q`.
       * @method multiply
       * @memberof Quaternion.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "multiply",
      value: function multiply(q) {
        return this.multiplyQuaternions(this, q);
      }
      /**
       * Pre-multiplies this quaternion by `q`.
       * @method premultiply
       * @memberof Quaternion.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "premultiply",
      value: function premultiply(q) {
        return this.multiplyQuaternions(q, this);
      }
      /**
       * Sets this quaternion to `a × b`. Adapted from the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm).
       * @method multiplyQuaternions
       * @memberof Quaternion.prototype
       * @param {Quaternion} a
       * @param {Quaternion} b
       */

    }, {
      key: "multiplyQuaternions",
      value: function multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = a.x;
        var qay = a.y;
        var qaz = a.z;
        var qaw = a.w;
        var qbx = b.x;
        var qby = b.y;
        var qbz = b.z;
        var qbw = b.w;
        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      }
      /**
       * Handles the spherical linear interpolation between quaternions. `t`
       * represents the amount of rotation between this quaternion (where `t = 0`)
       * and `qb` (where `t = 1`). This quaternion is set to the result. Also see
       * the static version of the {@link Quaternion.slerp}.
       * @method slerp
       * @memberof Quaternion.prototype
       * @param  {Quaternion} qb The other quaternion rotation
       * @param  {number} t  Interpolation factor in the closed interval `[0, 1]`.
       * @example
       * // rotate a mesh towards a target quaternion
       * mesh.quaternion.slerp(endQuaternion, 0.01);
       */

    }, {
      key: "slerp",
      value: function slerp(qb, t) {
        if (t === 0) {
          return this;
        }

        if (t === 1) {
          return this.copy(qb);
        }

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

        if (cosHalfTheta < 0) {
          this.w = -qb.w;
          this.x = -qb.x;
          this.y = -qb.y;
          this.z = -qb.z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }

        if (cosHalfTheta >= 1.0) {
          this.w = w;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }

        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
          this.w = 0.5 * (w + this.w);
          this.x = 0.5 * (x + this.x);
          this.y = 0.5 * (y + this.y);
          this.z = 0.5 * (z + this.z);
          return this;
        }

        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
        var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this.w = w * ratioA + this.w * ratioB;
        this.x = x * ratioA + this.x * ratioB;
        this.y = y * ratioA + this.y * ratioB;
        this.z = z * ratioA + this.z * ratioB;
        this.onChangeCallback();
        return this;
      }
      /**
       * Compares the {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties of `quaternion`
       * to the equivalent properties of this quaternion to determine if they
       * represent the same rotation.
       * @method equals
       * @memberof Quaternion.prototype
       * @param {Quaternion} q Quaternion that this quaternion will be compared to.
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(q) {
        return q.x === this.x && q.y === this.y && q.z === this.z && q.w === this.w;
      }
      /**
       * Sets this quaternion's {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties from the `array`.
       * @method fromArray
       * @memberof Quaternion.prototype
       * @param {number[]} array Array of format `(x, y, z, w)` used to construct the quaternion.
       * @param {number} [offset=0] An offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        this.onChangeCallback();
        return this;
      }
      /**
       * Returns the numerical elements of this quaternion in an array of format
       * `[x, y, z, w]`.
       * @method toArray
       * @memberof Quaternion.prototype
       * @param {number[]} [array=[]] An optional array to store the quaternion. If not specified a new array will be created.
       * @param {number} [offset=0] If specified, the result will be copied into the `array`.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset + 0] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      }
      /**
       * Sets the {@link Quaternion#onChangeCallback} method.
       * @method onChange
       * @memberof Quaternion.prototype
       * @param {Function} callback
       */

    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "isQuaternion",
      get: function get() {
        return _isQuaternion;
      }
    }], [{
      key: "slerp",

      /**
       * Unlike the [normal]{@link Quaternion#slerp} method, the static version of
       * {@link Quaternion.slerp} sets a target quaternion to the result of the
       * slerp operation.
       * @method slerp
       * @memberof Quaternion
       * @param {Quaternion} qStart The starting quaternion (where `t = 0`).
       * @param {Quaternion} qEnd The ending quaternion (where `t = 1`).
       * @param {Quaternion} qTarget The target quaternion that gets set with the result.
       * @param {number} t Interpolation factor in the closed interval `[0, 1]`.
       * @return {Quaternion}
       * @example
       * // Code setup
       * var startQuaternion = new Quaternion().set(0, 0, 0, 1).normalize();
       * var endQuaternion = new Quaternion().set(1, 1, 1, 1).normalize();
       * var t = 0;
       *
       * // Update a mesh's rotation in the loop
       * t = (t + 0.01) % 1; // constant angular momentum
       * Quaternion.slerp(startQuaternion, endQuaternion, mesh.quaternion, t);
       */
      value: function slerp(qStart, qEnd, qTarget, t) {
        return qTarget.copy(qStart).slerp(qEnd, t);
      }
      /**
       * Like the static {@link Quaternion.slerp} method, but operates directly on
       * flat arrays of numbers.
       * @method slerpFlat
       * @memberof Quaternion
       * @param {number[]} dst The output array.
       * @param {number} dstOffset An offset into the output array.
       * @param {number[]} src0 The source array of the starting quaternion.
       * @param {number} srcOffset0 An offset into the array `src0`.
       * @param {number[]} src1 The source array of the target quaternion.
       * @param {number} srcOffset1 An offset into the array `src1`.
       * @param {number} t Normalized interpolation factor (between `0` and `1`).
       */

    }, {
      key: "slerpFlat",
      value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        var x0 = src0[srcOffset0 + 0];
        var y0 = src0[srcOffset0 + 1];
        var z0 = src0[srcOffset0 + 2];
        var w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1 + 0];
        var y1 = src1[srcOffset1 + 1];
        var z1 = src1[srcOffset1 + 2];
        var w1 = src1[srcOffset1 + 3];

        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          var s = 1 - t;
          var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
          var dir = cos >= 0 ? 1 : -1;
          var sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

          if (sqrSin > EPSILON) {
            var sin = Math.sqrt(sqrSin);
            var len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t = Math.sin(t * len) / sin;
          }

          var tDir = t * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

          if (s === 1 - t) {
            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }

        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
    }]);

    return Quaternion;
  }();

  _exports["default"] = Quaternion;
});

/***/ }),

/***/ "./math/Vector2.js":
/*!*************************!*\
  !*** ./math/Vector2.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _isVector2 = true;
  /**
   * @class Vector2
   * @classdesc
   * Class representing a 2D [vector](https://en.wikipedia.org/wiki/Vector_space).
   * A 2D vector is an ordered pair of numbers (labeled `x` and `y`), which can be
   * used to represent a number of things, such as:
   * * A point in 2D space (i.e. a position on a plane).
   * * A direction and length across a plane. For Letsee, the length will always be the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) (straight-line distance) from `(0, 0)` to `(x, y)` and the direction is also measured from `(0, 0)` towards `(x, y)`.
   * * Any arbitrary ordered pair of numbers.
   * These are other things a 2D vector can be used to represent, such as momentum
   * vectors, complex numbers and so on, however these are the most common uses.
   * @example
   * var a = new Vector2(0, 1);
   *
   * // no arguments; will be initialised to (0, 0)
   * var b = new Vector2();
   *
   * var d = a.distanceTo(b);
   * @param  {number} [x=0] The {@link Vector2#x} value of the vector.
   * @param  {number} [y=0] The {@link Vector2#y} value of the vector.
   */

  var Vector2 =
  /*#__PURE__*/
  function () {
    function Vector2() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Vector2);

      this._x = x;
      this._y = y;
    }
    /**
     * Alias for {@link Vector2#x}.
     * @member {number} width
     * @memberof Vector2#
     */


    _createClass(Vector2, [{
      key: "set",

      /**
       * Sets the {@link Vector2#x} and {@link Vector2#y} components of this vector.
       * @method set
       * @memberof Vector2.prototype
       * @param {number} x
       * @param {number} y
       */
      value: function set(x, y) {
        this._x = x;
        this._y = y;
        return this;
      }
      /**
       * Sets the {@link Vector2#x} and {@link Vector2#y} values of this vector both
       * equal to `scalar`.
       * @method setScalar
       * @memberof Vector2.prototype
       * @param {number} scalar
       */

    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this._x = scalar;
        this._y = scalar;
        return this;
      }
      /**
       * Replace this vector's {@link Vector2#x} value with `x`.
       * @method setX
       * @memberof Vector2.prototype
       * @param {number} x
       */

    }, {
      key: "setX",
      value: function setX(x) {
        this._x = x;
        return this;
      }
      /**
       * Replace this vector's {@link Vector2#y} value with `y`.
       * @method setY
       * @memberof Vector2.prototype
       * @param {number} y
       */

    }, {
      key: "setY",
      value: function setY(y) {
        this._y = y;
        return this;
      }
      /**
       * If `index` equals to `0`, set {@link Vector2#x} to `value`.
       * If `index` equals to `1`, set {@link Vector2#y} to `value`.
       * @method setComponent
       * @memberof Vector2.prototype
       * @param {0|1} index
       * @param {number} value
       */

    }, {
      key: "setComponent",
      value: function setComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1;
        var value = arguments.length > 1 ? arguments[1] : undefined;

        switch (index) {
          case 0:
            this._x = value;
            break;

          case 1:
            this._y = value;
            break;

          default:
            throw new Error("index is out of range: ".concat(index));
        }

        return this;
      }
      /**
       * If `index` equals to `0`, returns {@link Vector2#x}.
       * If `index` equals to `1`, returns {@link Vector2#y}.
       * @method getComponent
       * @memberof Vector2.prototype
       * @param  {0|1} index
       * @return {number}
       */

    }, {
      key: "getComponent",
      value: function getComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1;

        switch (index) {
          case 0:
            return this._x;

          case 1:
            return this._y;

          default:
            throw new Error("index is out of range: ".concat(index));
        }
      }
      /**
       * Returns a new {@link Vector2} with the same {@link Vector2#x} and
       * {@link Vector2#y} values as this one.
       * @method clone
       * @memberof Vector2.prototype
       * @return {Vector2}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Vector2(this._x, this._y);
      }
      /**
       * Copies the values of the passed {@link Vector2}'s {@link Vector2#x} and
       * {@link Vector2#y} properties to this vector.
       * @method copy
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "copy",
      value: function copy(v) {
        this._x = v.x;
        this._y = v.y;
        return this;
      }
      /**
       * Adds `v` to this vector.
       * @method add
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "add",
      value: function add(v) {
        this._x += v.x;
        this._y += v.y;
        return this;
      }
      /**
       * Adds the scalar value `s` to this vector's {@link Vector2#x} and
       * {@link Vector2#y} values.
       * @method addScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this._x += s;
        this._y += s;
        return this;
      }
      /**
       * Sets this vector to `a + b`.
       * @method addVectors
       * @memberof Vector2.prototype
       * @param {Vector2} a
       * @param {Vector2} b
       */

    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this._x = a.x + b.x;
        this._y = a.y + b.y;
        return this;
      }
      /**
       * Adds the multiple of `v` and `s` to this vector.
       * @method addScaledVector
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @param {number} s
       */

    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this._x += v.x * s;
        this._y += v.y * s;
        return this;
      }
      /**
       * Subtracts `v` from this vector.
       * @method sub
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "sub",
      value: function sub(v) {
        this._x -= v.x;
        this._y -= v.y;
        return this;
      }
      /**
       * Subtracts `s` from this vector's {@link Vector2#x} and {@link Vector2#y}
       * components.
       * @method subScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this._x -= s;
        this._y -= s;
        return this;
      }
      /**
       * Sets this vector to `a - b`.
       * @method subVectors
       * @memberof Vector2.prototype
       * @param  {Vector2} a
       * @param  {Vector2} b
       */

    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this._x = a.x - b.x;
        this._y = a.y - b.y;
        return this;
      }
      /**
       * Multiplies this vector by `v`.
       * @method multiply
       * @memberof Vector2.prototype
       * @param  {Vector2} v
       */

    }, {
      key: "multiply",
      value: function multiply(v) {
        this._x *= v.x;
        this._y *= v.y;
        return this;
      }
      /**
       * Multiplies this vector by scalar `s`.
       * @method multiplyScalar
       * @memberof Vector2.prototype
       * @param  {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        if (isFinite(s)) {
          this._x *= s;
          this._y *= s;
        } else {
          this._x = 0;
          this._y = 0;
        }

        return this;
      }
      /**
       * Divides this vector by `v`.
       * @method divide
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "divide",
      value: function divide(v) {
        this._x /= v.x;
        this._y /= v.y;
        return this;
      }
      /**
       * Divides this vector by scalar `s`. Sets vector to `(0, 0)` if `s = 0`.
       * @method divideScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        return this.multiplyScalar(1 / s);
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is greater
       * than `v`'s {@link Vector2#x} or {@link Vector2#y} value, replace that value
       * with the corresponding min value.
       * @method min
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "min",
      value: function min(v) {
        this._x = Math.min(this._x, v.x);
        this._y = Math.min(this._y, v.y);
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is less than
       * `v`'s {@link Vector2#x} or {@link Vector2#y} value, replace that value with
       * the corresponding max value.
       * @method max
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "max",
      value: function max(v) {
        this._x = Math.max(this._x, v.x);
        this._y = Math.max(this._y, v.y);
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is greater
       * than the `max` vector's {@link Vector2#x} or {@link Vector2#y} value, it is
       * replaced by the corresponding value. If this vector's {@link Vector2#x} or
       * {@link Vector2#y} value is less than the `min` vector's {@link Vector2#x}
       * or {@link Vector2#y} value, it is replaced by the corresponding value.
       * @method clamp
       * @memberof Vector2.prototype
       * @param {Vector2} min The minimum {@link Vector2#x} and {@link Vector2#y} values.
       * @param {Vector2} max The maximum {@link Vector2#x} and {@link Vector2#y} values in the desired range.
       */

    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min.x, Math.min(max.x, this._x));
        this._y = Math.max(min.y, Math.min(max.y, this._y));
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} values are greater
       * than the `max` value, they are replaced by the `max` value. If this
       * vector's {@link Vector2#x} or {@link Vector2#y} values are less than the
       * `min` value, they are replaced by the `min` value.
       * @method clampScalar
       * @memberof Vector2.prototype
       * @param {number} minVal The minimum value the components will be clamped to.
       * @param {number} maxVal The maximum value the components will be clamped to.
       */

    }, {
      key: "clampScalar",
      value: function clampScalar(minVal, maxVal) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(minVal, Math.min(maxVal, this._x));
        this._y = Math.max(minVal, Math.min(maxVal, this._y));
        return this;
      }
      /**
       * If this vector's length is greater than the `max` value, it is replaced by
       * the `max` value. If this vector's length is less than the `min` value, it
       * is replaced by the `min` value.
       * @method clampLength
       * @memberof Vector2.prototype
       * @param {number} min The minimum value the length will be clamped to.
       * @param {number} max The maximum value the length will be clamped to.
       */

    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      }
      /**
       * The components of the vector are rounded down to the nearest integer value.
       * @method floor
       * @memberof Vector2.prototype
       */

    }, {
      key: "floor",
      value: function floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y);
        return this;
      }
      /**
       * The {@link Vector2#x} and {@link Vector2#y} components of the vector are
       * rounded up to the nearest integer value.
       * @method ceil
       * @memberof Vector2.prototype
       */

    }, {
      key: "ceil",
      value: function ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y);
        return this;
      }
      /**
       * The components of the vector are rounded to the nearest integer value.
       * @method round
       * @memberof Vector2.prototype
       */

    }, {
      key: "round",
      value: function round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y);
        return this;
      }
      /**
       * The components of the vector are rounded towards zero (up if negative, down
       * if positive) to an integer value.
       * @method roundToZero
       * @memberof Vector2.prototype
       */

    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x);
        this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y);
        return this;
      }
      /**
       * Inverts this vector - i.e. sets `x = -x` and `y = -y`.
       * @method negate
       * @memberof Vector2.prototype
       */

    }, {
      key: "negate",
      value: function negate() {
        this._x = -this._x;
        this._y = -this._y;
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * this vector and `v`.
       * @method dot
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this._x * v.x + this._y * v.y;
      }
      /**
       * Computes the square of the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0)` to `(x, y)`. If you are comparing the
       * lengths of vectors, you should compare the length squared instead as it is
       * slightly more efficient to calculate.
       * @method lengthSq
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this._x * this._x + this._y * this._y;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0)` to `(x, y)`.
       * @method length
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y);
      }
      /**
       * Computes the
       * [Manhattan length](http://en.wikipedia.org/wiki/Taxicab_geometry) of this
       * vector.
       * @method lengthManhattan
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "lengthManhattan",
      value: function lengthManhattan() {
        return Math.abs(this._x) + Math.abs(this._y);
      }
      /**
       * Convert this vector to be a
       * [unit vector](https://en.wikipedia.org/wiki/Unit_vector) - that is, sets it
       * equal to the vector with the same direction as this one, but
       * {@link Vector2#length} 1.
       * @method normalize
       * @memberof Vector2.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
      /**
       * Computes the angle in radians of this vector with respect to the positive
       * x-axis.
       * @method angle
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "angle",
      value: function angle() {
        var angle = Math.atan2(this._y, this._x);
        if (angle < 0) angle += 2 * Math.PI;
        return angle;
      }
      /**
       * Computes the distance from this vector to `v`.
       * @method distanceTo
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      /**
       * Computes the squared distance from this vector to `v`. If you are just
       * comparing the distance with another distance, you should compare the
       * distance squared instead as it is slightly more efficient to calculate.
       * @method distanceToSquared
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this._x - v.x;
        var dy = this._y - v.y;
        return dx * dx + dy * dy;
      }
      /**
       * Computes the
       * [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry)
       * from this vector to `v`.
       * @method distanceToManhattan
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceToManhattan",
      value: function distanceToManhattan(v) {
        return Math.abs(this._x - v.x) + Math.abs(this._y - v.y);
      }
      /**
       * Sets this vector to the vector with the same direction as this one, but
       * {@link Vector2#length} `length`.
       * @method setLength
       * @memberof Vector2.prototype
       * @param {number} length
       */

    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.multiplyScalar(length / this.length());
      }
      /**
       * Linearly interpolate between this vector and `v`, where `alpha` is the
       * distance along the line - `alphq = 0` will be this vector, and `alpha = 1`
       * will be `v`.
       * @method lerp
       * @memberof Vector2.prototype
       * @param {Vector2} v {@link Vector2} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this._x += (v.x - this._x) * alpha;
        this._y += (v.y - this._y) * alpha;
        return this;
      }
      /**
       * Sets this vector to be the vector linearly interpolated between `v1` and
       * `v2` where `alpha` is the distance along the line connecting the two
       * vectors - `alpha = 0` will be `v1`, and `alpha = 1` will be `v2`.
       * @method lerpVectors
       * @memberof Vector2.prototype
       * @param {Vector2} v1 The starting {@link Vector2}.
       * @param {Vector2} v2 {@link Vector2} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
      /**
       * Checks for strict equality of this vector and `v`.
       * @method equals
       * @memberof Vector2.prototype
       * @param  {Vector2} v
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this._x && v.y === this._y;
      }
      /**
       * Sets this vector's {@link Vector2#x} to be `array[0 + offset]` and
       * {@link Vector2#y} to be `array[1 + offset]`.
       * @method fromArray
       * @memberof Vector2.prototype
       * @param  {Array} array The source array.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        return this;
      }
      /**
       * Returns an array `[x, y]`, or copies of {@link Vector2#x} and
       * {@link Vector2#y} into the provided `array`.
       * @method toArray
       * @memberof Vector2.prototype
       * @param  {number[]} [array=[]]  Array to store the vector to. If this is not provided a new array will be created.
       * @param  {number} [offset=0] Optional offset into the array.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        return array;
      }
      /**
       * Rotate the vector around `center` by `angle` in radians.
       * @method rotateAround
       * @memberof Vector2.prototype
       * @param {Vector2} center The point around which to rotate.
       * @param {number} angle The angle to rotate, in radians.
       */

    }, {
      key: "rotateAround",
      value: function rotateAround(center, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var x = this._x - center.x;
        var y = this._y - center.y;
        this._x = x * c - y * s + center.x; // eslint-disable-line no-mixed-operators

        this._y = x * s + y * c + center.y;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
      }
      /**
       * Alias for {@link Vector2#y}.
       * @member {number} height
       * @memberof Vector2#
       */

    }, {
      key: "height",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
      }
      /**
       * @member {number} x
       * @memberof Vector2#
       * @default 0
       */

    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} y
       * @memberof Vector2#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this.onChangeCallback();
      }
    }, {
      key: "isVector2",
      get: function get() {
        return _isVector2;
      }
    }]);

    return Vector2;
  }();

  _exports["default"] = Vector2;
});

/***/ }),

/***/ "./math/Vector3.js":
/*!*************************!*\
  !*** ./math/Vector3.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Math */ "./math/Math.js"), __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Math, _Quaternion) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Quaternion = _interopRequireDefault(_Quaternion);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Euler from './Euler';
  // import Camera from '../camera/Camera';
  // constants for optimisation
  var applyEulerQ;
  var applyAxisAngleQ; // let projectM;
  // let unprojectM;

  var projectOnPlaneV;
  var reflectV; // let this._x = 0, this._y = 0, this._z = 0;

  var onChangeCallback = function onChangeCallback() {};

  var _isVector3 = true;
  /**
   * @class Vector3
   * @classdesc
   * Class representing a 3D [vector](https://en.wikipedia.org/wiki/Vector_space).
   * A 3D vector is an ordered triplet of numbers (labeled `x`, `y`, and `z`),
   * which can be used to represent a number of things, such as:
   * * A point in 3D space.
   * * A direction and length in 3D space. For Letsee, the length will always be
   * the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)
   * (straight-line distance) from `(0, 0, 0)` to `(x, y, z)` and the direction is
   * also measured from `(0, 0, 0)` towards `(x, y, z)`.
   * * Any arbitrary ordered triplet of numbers.
   * There are other things a 3D vector can be used to represent, such as momentum
   * vectors and so on, however these are the most common uses.
   * @example
   * var a = new Vector3(0, 1, 0);
   *
   * // no arguments; will be initialised to (0, 0, 0)
   * var b = new Vector3();
   *
   * var d = a.distanceTo(b);
   * @param {number} [x=0] The x value of the vector.
   * @param {number} [y=0] The y value of the vector.
   * @param {number} [z=0] The z value of the vector.
   */

  var Vector3 =
  /*#__PURE__*/
  function () {
    function Vector3() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      _classCallCheck(this, Vector3);

      this._x = x;
      this._y = y;
      this._z = z;
    }
    /**
     * @member {number} x
     * @memberof Vector3#
     * @default 0
     */


    _createClass(Vector3, [{
      key: "set",

      /**
       * Sets the {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z}
       * components of this vector.
       * @method set
       * @memberof Vector3.prototype
       * @param {number} x
       * @param {number} y
       * @param {number} z
       */
      value: function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z} values
       * of this vector all equal to `scalar`.
       * @method setScalar
       * @memberof Vector3.prototype
       * @param {number} scalar
       */

    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this._x = scalar;
        this._y = scalar;
        this._z = scalar;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#x} value with `x`.
       * @method setX
       * @memberof Vector3.prototype
       * @param {number} x
       */

    }, {
      key: "setX",
      value: function setX(x) {
        this._x = x;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#y} value with `y`.
       * @method setY
       * @memberof Vector3.prototype
       * @param {number} y
       */

    }, {
      key: "setY",
      value: function setY(y) {
        this._y = y;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#z} value with `z`.
       * @method setZ
       * @memberof Vector3.prototype
       * @param {number} z
       */

    }, {
      key: "setZ",
      value: function setZ(z) {
        this._z = z;
        this.onChangeCallback();
        return this;
      }
      /**
       * If `index` equals `0` set {@link Vector3#x} to `value`.
       * If `index` equals `1` set {@link Vector3#y} to `value`.
       * If `index` equals `2` set {@link Vector3#z} to `value`.
       * @method setComponent
       * @memberof Vector3.prototype
       * @param {0|1|2} index
       * @param {number} value
       */

    }, {
      key: "setComponent",
      value: function setComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1 | 2;
        var value = arguments.length > 1 ? arguments[1] : undefined;

        switch (index) {
          case 0:
            this._x = value;
            this.onChangeCallback();
            break;

          case 1:
            this._y = value;
            this.onChangeCallback();
            break;

          case 2:
            this._z = value;
            this.onChangeCallback();
            break;

          default:
            throw new Error("index is out of range: ".concat(index));
        }

        return this;
      }
      /**
       * If `index` equals `0` returns the {@link Vector3#x} value.
       * If `index` equals `1` returns the {@link Vector3#y} value.
       * If `index` equals `2` returns the {@link Vector3#z} value.
       * @method getComponent
       * @memberof Vector3.prototype
       * @param {0|1|2} index
       * @return {number}
       */

    }, {
      key: "getComponent",
      value: function getComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1 | 2;

        switch (index) {
          case 0:
            return this._x;

          case 1:
            return this._y;

          case 2:
            return this._z;

          default:
            throw new Error("index is out of range: ".concat(index));
        }
      }
      /**
       * Returns a new {@link Vector3} with the same {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values as this one.
       * @method clone
       * @memberof Vector3.prototype
       * @return {Vector3}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Vector3(this._x, this._y, this._z);
      }
      /**
       * Copies the values of the passed {@link Vector3}'s {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} properties to this vector.
       * @method copy
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "copy",
      value: function copy(v) {
        this._x = v.x;
        this._y = v.y;
        this._z = v.z; // this.onChangeCallback();

        return this;
      }
      /**
       * Adds `v` to this vector.
       * @method add
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "add",
      value: function add(v) {
        this._x += v.x;
        this._y += v.y;
        this._z += v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Adds the scalar value `s` to this vector's {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values.
       * @method addScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this._x += s;
        this._y += s;
        this._z += s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to `a + b`.
       * @method addVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this._x = a.x + b.x;
        this._y = a.y + b.y;
        this._z = a.z + b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Adds the multiple of `v` and `s` to this vector.
       * @method addScaledVector
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @param {number} s
       */

    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this._x += v.x * s;
        this._y += v.y * s;
        this._z += v.z * s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Subtracts `v` from this vector.
       * @method sub
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "sub",
      value: function sub(v) {
        this._x -= v.x;
        this._y -= v.y;
        this._z -= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Subtracts `s` from this vector's {@link Vector3#x}, {@link Vector3#y}, and
       * {@link Vector3#z} components.
       * @method subScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this._x -= s;
        this._y -= s;
        this._z -= s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to `a - b`.
       * @method subVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this._x = a.x - b.x;
        this._y = a.y - b.y;
        this._z = a.z - b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this vector by `v`.
       * @method multiply
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "multiply",
      value: function multiply(v) {
        this._x *= v.x;
        this._y *= v.y;
        this._z *= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this vector by scalar `s`.
       * @method multiplyScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector equal to `a × b`.
       * @method multiplyVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "multiplyVectors",
      value: function multiplyVectors(a, b) {
        this._x = a.x * b.x;
        this._y = a.y * b.y;
        this._z = a.z * b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Applies euler transform to this vector by converting the {@link Euler}
       * object to a {@link Quaternion} and applying.
       * @method applyEuler
       * @memberof Vector3.prototype
       * @param {Euler} euler
       */

    }, {
      key: "applyEuler",
      value: function applyEuler(euler) {
        if (typeof applyEulerQ === 'undefined') {
          applyEulerQ = new _Quaternion["default"]();
        }

        return this.applyQuaternion(applyEulerQ.setFromEuler(euler));
      }
      /**
       * Applies a rotation specified by an `axis` and an `angle` to this vector.
       * @method applyAxisAngle
       * @memberof Vector3.prototype
       * @param {Vector3} axis A normalized {@link Vector3}.
       * @param {number} angle An angle in radians.
       */

    }, {
      key: "applyAxisAngle",
      value: function applyAxisAngle(axis, angle) {
        if (typeof applyAxisAngleQ === 'undefined') {
          applyAxisAngleQ = new _Quaternion["default"]();
        }

        return this.applyQuaternion(applyAxisAngleQ.setFromAxisAngle(axis, angle));
      }
      /**
       * Multiplies this vector (with an implicit `1` in the 4th dimension) and `m`,
       * and divides by perspective.
       * @method applyMatrix4
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var e = m.elements;
        this._x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this._y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this._z = e[2] * x + e[6] * y + e[10] * z + e[14];
        var w = e[3] * x + e[7] * y + e[11] * z + e[15];
        return this.divideScalar(w);
      }
      /**
       * Applies a {@link Quaternion} transform this vector.
       * @method applyQuaternion
       * @memberof Vector3.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w; // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

        this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        this.onChangeCallback();
        return this;
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) the vector
       * with the `camera`.
       * @method project
       * @memberof Vector3.prototype
       * @param {Camera} camera Camera to use in the projection.
       */

    }, {
      key: "project",
      value: function project(camera) {
        // if (typeof projectM === 'undefined') {
        //   projectM = new Matrix4();
        // }
        //
        // projectM.multiplyMatrices(camera.projectionMatrix, projectM.getInverse(camera.matrixWorld));
        // return this.applyMatrix4(projectM);
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      /**
       * [Unprojects](https://en.wikipedia.org/wiki/Vector_projection) the vector
       * with the `camera`'s projection matrix.
       * @method unproject
       * @memberof Vector3.prototype
       * @param {Camera} camera Camera to use in the projection.
       */

    }, {
      key: "unproject",
      value: function unproject(camera) {
        // if (typeof unprojectM === 'undefined') {
        //   unprojectM = new Matrix4();
        // }
        //
        // unprojectM.multiplyMatrices(camera.matrixWorld, unprojectM.getInverse(camera.projectionMatrix));
        // return this.applyMatrix4(unprojectM);
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      /**
       * Transforms the direction of this vector by a matrix (the upper left 3 x 3
       * subset of the `m`) and then [normalizes]{@link Vector3#normalize} the
       * result.
       * @method transformDirection
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        // input affine matrix
        // vector interpreted as a direction
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var e = m.elements;
        this._x = e[0] * x + e[4] * y + e[8] * z;
        this._y = e[1] * x + e[5] * y + e[9] * z;
        this._z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      }
      /**
       * Divides this vector by `v`.
       * @method divide
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "divide",
      value: function divide(v) {
        this._x /= v.x;
        this._y /= v.y;
        this._z /= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Divides this vector by scalar `s`. Sets vector to `(0, 0, 0)` if `s = 0`.
       * @method divideScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        return this.multiplyScalar(1 / s);
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is greater than `v`'s {@link Vector3#x}, {@link Vector3#y}, or
       * {@link Vector3#z} value, replace that value with the corresponding min
       * value.
       * @method min
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "min",
      value: function min(v) {
        this._x = Math.min(this._x, v.x);
        this._y = Math.min(this._y, v.y);
        this._z = Math.min(this._z, v.z);
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is less than `v`'s {@link Vector3#x}, {@link Vector3#y}, or
       * {@link Vector3#z} value, replace that value with the corresponding max
       * value.
       * @method max
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "max",
      value: function max(v) {
        this._x = Math.max(this._x, v.x);
        this._y = Math.max(this._y, v.y);
        this._z = Math.max(this._z, v.z);
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is greater than the `max` vector's {@link Vector3#x},
       * {@link Vector3#y}, or {@link Vector3#z} value, it is replaced by the
       * corresponding value. If this vector's {@link Vector3#x}, {@link Vector3#y},
       * or {@link Vector3#z} value is less than the `min` vector's
       * {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z} value, it is
       * replaced by the corresponding value.
       * @method clamp
       * @memberof Vector3.prototype
       * @param {Vector3} min
       * @param {Vector3} max
       */

    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min.x, Math.min(max.x, this._x));
        this._y = Math.max(min.y, Math.min(max.y, this._y));
        this._z = Math.max(min.z, Math.min(max.z, this._z));
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * values are greater than the `max` value, it is replaced by the `max` value.
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * values are less than the `min` value, it is replaced by the `min` value.
       * @method clampScalar
       * @memberof Vector3.prototype
       * @param {number} min The minimum value the components will be clamped to.
       * @param {number} max The maximum value the components will be clamped to.
       */

    }, {
      key: "clampScalar",
      value: function clampScalar(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min, Math.min(max, this._x));
        this._y = Math.max(min, Math.min(max, this._y));
        this._z = Math.max(min, Math.min(max, this._z));
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's length is greater than the `max` value, it is replaced by
       * the `max` value. If this vector's length is less than the `min` value, it
       * is replaced by the `min` value.
       * @method clampLength
       * @memberof Vector3.prototype
       * @param {number} min The minimum value the length will be clamped to.
       * @param {number} max The maximum value the length will be clamped to.
       */

    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      }
      /**
       * The components of the vector are rounded down to the nearest integer value.
       * @method floor
       * @memberof Vector3.prototype
       */

    }, {
      key: "floor",
      value: function floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y);
        this._z = Math.floor(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z} components
       * of the vector are rounded up to the nearest integer value.
       * @method ceil
       * @memberof Vector3.prototype
       */

    }, {
      key: "ceil",
      value: function ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y);
        this._z = Math.ceil(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The components of the vector are rounded to the nearest integer value.
       * @method round
       * @memberof Vector3.prototype
       */

    }, {
      key: "round",
      value: function round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y);
        this._z = Math.round(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The components of the vector are rounded towards zero (up if negative,
       * down if positive) to an integer value.
       * @method roundToZero
       * @memberof Vector3.prototype
       */

    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x);
        this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y);
        this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * Inverts this vector - i.e. sets `x = -x`, `y = -y`, and `z = -z`.
       * @method negate
       * @memberof Vector3.prototype
       */

    }, {
      key: "negate",
      value: function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * this vector and `v`.
       * @method dot
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this._x * v.x + this._y * v.y + this._z * v.z;
      }
      /**
       * Computes the square of the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0, 0)` to `(x, y, z)`. If you are
       * comparing lengths of vectors, you should compare the length squared
       * instead as it is slightly more efficient to calculate.
       * @method lengthSq
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0, 0)` to `(x, y, z)`.
       * @method length
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
      }
      /**
       * Computes the
       * [Manhattan length](http://en.wikipedia.org/wiki/Taxicab_geometry) of this
       * vector.
       * @method lengthManhattan
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "lengthManhattan",
      value: function lengthManhattan() {
        return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
      }
      /**
       * Convert this vector to a
       * [unit vector](https://en.wikipedia.org/wiki/Unit_vector) - that is, sets
       * it equal to the vector with the same direction as this one, but
       * {@link Vector3#length} `1`.
       * @method normalize
       * @memberof Vector3.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
      /**
       * Sets this vector to the vector with the same direction as this one, but
       * {@link Vector3#length} `length`.
       * @method setLength
       * @memberof Vector3.prototype
       * @param {number} length
       */

    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.multiplyScalar(length / this.length());
      }
      /**
       * Linearly interpolate between this vector and `v`, where `alpha` is the
       * distance along the line - `alpha = 0` will be this vector, and `alpha = 1`
       * will be `v`.
       * @method lerp
       * @memberof Vector3.prototype
       * @param {Vector3} v {@link Vector3} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this._x += (v.x - this._x) * alpha;
        this._y += (v.y - this._y) * alpha;
        this._z += (v.z - this._z) * alpha;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to be the vector linearly interpolated between `v1` and
       * `v2` where `alpha` is the distance along the line connecting the two
       * vectors - `alpha = 0` will be `v1`, and `alpha = 1` will be `v2`.
       * @method lerpVectors
       * @memberof Vector3.prototype
       * @param {Vector3} v1 The starting {@link Vector3}.
       * @param {Vector3} v2 {@link Vector3} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
      /**
       * Sets this vector to
       * [cross product](https://en.wikipedia.org/wiki/Cross_product) of itself and
       * `v`.
       * @method cross
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "cross",
      value: function cross(v) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        this._x = y * v.z - z * v.y;
        this._y = z * v.x - x * v.z;
        this._z = x * v.y - y * v.x;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to
       * [cross product](https://en.wikipedia.org/wiki/Cross_product) of `a` and
       * `b`.
       * @method crossVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "crossVectors",
      value: function crossVectors(a, b) {
        var ax = a.x;
        var ay = a.y;
        var az = a.z;
        var bx = b.x;
        var by = b.y;
        var bz = b.z;
        this._x = ay * bz - az * by;
        this._y = az * bx - ax * bz;
        this._z = ax * by - ay * bx;
        this.onChangeCallback();
        return this;
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) this vector
       * onto another `vector`.
       * @method projectOnVector
       * @memberof Vector3.prototype
       * @param {Vector3} vector
       */

    }, {
      key: "projectOnVector",
      value: function projectOnVector(vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar);
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) this vector
       * onto a plane by subtracting this vector projected onto the plane's normal
       * from this vector.
       * @method projectOnPlane
       * @memberof Vector3.prototype
       * @param {Vector3} planeNormal A vector representing a plane normal.
       */

    }, {
      key: "projectOnPlane",
      value: function projectOnPlane(planeNormal) {
        if (typeof projectOnPlaneV === 'undefined') {
          projectOnPlaneV = new Vector3();
        }

        projectOnPlaneV.copy(this).projectOnVector(planeNormal);
        return this.sub(projectOnPlaneV);
      }
      /**
       * Reflect the vector off of plane orthogonal to `normal`. `normal` is
       * assumed to have unit length.
       * @method reflect
       * @memberof Vector3.prototype
       * @param {Vector3} normal The normal to the reflecting plane.
       */

    }, {
      key: "reflect",
      value: function reflect(normal) {
        if (typeof reflectV === 'undefined') {
          reflectV = new Vector3();
        }

        return this.sub(reflectV.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
      /**
       * Returns the angle between this vector and vector `v` in radians.
       * @method angleTo
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "angleTo",
      value: function angleTo(v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq()); // clamp, to handle numerical problems

        return Math.acos((0, _Math.clamp)(theta, -1, 1));
      }
      /**
       * Computes the distance from this vector to `v`.
       * @method distanceTo
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      /**
       * Computes the squared distance from this vector to `v`. If you are just
       * comparing the distance with another distance, you should compare the
       * distance squared instead as it is slightly more efficient to calculate.
       * @method distanceToSquared
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this._x - v.x;
        var dy = this._y - v.y;
        var dz = this._z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
      /**
       * Computes the
       * [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) from
       * this vector to `v`.
       * @method distanceToManhattan
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceToManhattan",
      value: function distanceToManhattan(v) {
        return Math.abs(this._x - v.x) + Math.abs(this._y - v.y) + Math.abs(this._z - v.z);
      }
      /**
       * Set this vector to the position elements of the
       * [transform matrix](https://en.wikipedia.org/wiki/Transformation_matrix)
       * `m`.
       * @method setFromMatrixPosition
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrixPosition",
      value: function setFromMatrixPosition(m) {
        // return this.setFromMatrixColumn(m, 3);
        var e = m.elements;
        this._x = e[12];
        this._y = e[13];
        this._z = e[14];
        return this;
      }
      /**
       * Sets this vector to the scale elements of the
       * [transform matrix](https://en.wikipedia.org/wiki/Transformation_matrix)
       * `m`.
       * @method setFromMatrixScale
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrixScale",
      value: function setFromMatrixScale(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this._x = sx;
        this._y = sy;
        this._z = sz;
        this.onChangeCallback(); // TODO redundant

        return this;
      }
      /**
       * Sets this vector's {@link Vector3#x}, {@link Vector3#y}, and
       * {@link Vector3#z} equal to the column of the `matrix` specified by the
       * `index`.
       * @method setFromMatrixColumn
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       * @param {number} index
       */

    }, {
      key: "setFromMatrixColumn",
      value: function setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
      /**
       * Checks for strict equality of this vector and `v`.
       * @method equals
       * @memberof Vector3.prototype
       * @param  {Vector3} v
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this._x && v.y === this._y && v.z === this._z;
      }
      /**
       * Sets this vector's {@link Vector3#x} value to be `array[0 + offset]`,
       * {@link Vector3#y} value to be `array[1 + offset]`, {@link Vector3#z} value
       * to be `array[2 + offset]`.
       * @method fromArray
       * @memberof Vector3.prototype
       * @param  {number[]} array  The source array.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this._x = array[offset + 0];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this.onChangeCallback();
        return this;
      }
      /**
       * Returns an array `[x, y, z]`, or copies {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values into the provided `array`.
       * @method toArray
       * @memberof Vector3.prototype
       * @param  {number[]} [array=[]] Array to store the vector to. If this is not provided a new array will be created.
       * @param  {number} [offset=0] Optional offset into the array.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset + 0] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        return array;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} y
       * @memberof Vector3#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} z
       * @memberof Vector3#
       * @default 0
       */

    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this.onChangeCallback();
      }
    }, {
      key: "isVector3",
      get: function get() {
        return _isVector3;
      }
    }]);

    return Vector3;
  }();

  _exports["default"] = Vector3;
});

/***/ }),

/***/ "./observers/Observer.js":
/*!*******************************!*\
  !*** ./observers/Observer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../core/Data */ "./core/Data.js"), __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Data, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var Observer =
  /*#__PURE__*/
  function () {
    function Observer(target, handlers) {
      _classCallCheck(this, Observer);

      if ((0, _Util.isNil)(_Data.EventDataObject.getTarget(target))) {
        _Data.EventDataObject.addHandler(target, handlers);
      }
    }

    _createClass(Observer, [{
      key: "subscribe",
      value: function subscribe(target, type, callback) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler.add(callback);
        } else {
          console.warn(handler);
        }
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(target, type, callback) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler["delete"](callback);
        } else {
          console.warn(handler);
        }
      }
    }, {
      key: "notify",
      value: function notify(target, type, args) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler.forEach(function (value) {
            return value(args);
          });
        } else {
          console.warn(handler);
        }
      }
    }, {
      key: "trace",
      value: function trace(_target, _type, _event) {
        console.log("".concat(_target, " => ").concat(_type, " [").concat(_event !== null ? _event : 'empty!', "]"));
      }
    }]);

    return Observer;
  }();

  _exports["default"] = Observer;
});

/***/ }),

/***/ "./observers/observer/EntityObserver.js":
/*!**********************************************!*\
  !*** ./observers/observer/EntityObserver.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../../entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ../../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Observer2, _EntityEvent, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Observer2 = _interopRequireDefault(_Observer2);
  _EntityEvent = _interopRequireDefault(_EntityEvent);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import Matrix4 from '../math/Matrix4';[
  var EntityType = {
    type: null,
    target: null,
    matrix: null,
    pixelSize: {
      width: 0.0,
      height: 0.0,
      depth: 0.0
    },
    scale: 1.0
  };
  var handlers = new Map([[_MessageTypes.ENTITY_EVENT.TRACK_START, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_MOVE, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_END, new Set()]]);
  var target = _MessageTypes.ENTITY_EVENT.TARGET;

  var EntityObserver =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(EntityObserver, _Observer);

    function EntityObserver() {
      _classCallCheck(this, EntityObserver);

      return _possibleConstructorReturn(this, _getPrototypeOf(EntityObserver).call(this, target, handlers));
    }

    _createClass(EntityObserver, [{
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(EntityObserver.prototype), "subscribe", this)).call.apply(_get2, [this, target, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(EntityObserver.prototype), "unsubscribe", this).call(this, target, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        if (event instanceof _EntityEvent["default"]) {
          _get(_getPrototypeOf(EntityObserver.prototype), "notify", this).call(this, target, type, event); // super.trace(target, type, event);

        } else {// console.
          }
      }
    }]);

    return EntityObserver;
  }(_Observer2["default"]);

  _exports["default"] = EntityObserver;
});

/***/ }),

/***/ "./observers/observer/LetseeObserver.js":
/*!**********************************************!*\
  !*** ./observers/observer/LetseeObserver.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Observer2, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Observer2 = _interopRequireDefault(_Observer2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var handlers = new Map([[_MessageTypes.LETSEE_EVENT.ON_LOAD, new Set()], [_MessageTypes.LETSEE_EVENT.ON_STATUS, new Set()], [_MessageTypes.LETSEE_EVENT.ROTATION_CHANGE, new Set()]]);
  var target = _MessageTypes.LETSEE_EVENT.TARGET;

  var LetseeObserver =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(LetseeObserver, _Observer);

    function LetseeObserver() {
      _classCallCheck(this, LetseeObserver);

      return _possibleConstructorReturn(this, _getPrototypeOf(LetseeObserver).call(this, target, handlers));
    }

    _createClass(LetseeObserver, [{
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(LetseeObserver.prototype), "subscribe", this)).call.apply(_get2, [this, target, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(LetseeObserver.prototype), "unsubscribe", this).call(this, target, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        _get(_getPrototypeOf(LetseeObserver.prototype), "notify", this).call(this, target, type, event);

        _get(_getPrototypeOf(LetseeObserver.prototype), "trace", this).call(this, target, type, event);
      }
    }]);

    return LetseeObserver;
  }(_Observer2["default"]);

  _exports["default"] = LetseeObserver;
});

/***/ }),

/***/ "./renderer/DOMRenderable.js":
/*!***********************************!*\
  !*** ./renderer/DOMRenderable.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ../core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../core/Data */ "./core/Data.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../Context */ "./Context.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _DOMRenderer, _Object3D2, _Data, _MessageTypes, _Util, _Context) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var _type = 'DOMRenderable';
  var _isDOMRenderable = true;
  var ghostId = 0;
  /**
   * @class Class representing a HTML element that can be augmented.
   * @name DOMRenderable
   * @param {HTMLElement} element - HTML Element
   * @returns {DOMRenderable}
   * @example
   * // Create HTML element
   * // HTML 엘리먼트를 생성합니다.
   * const sampleElement = document.createElement('div');
   *
   * // or get exist element
   * // 또한 DOM상에 존재하는 HTML 엘리먼트를 사용할 수도 있습니다.
   * const existElement = document.getElementById('foo');
   *
   * // Create DOM Renderable
   * // DOM Renderable을 생성합니다.
   * const sampleRenderable = new DOMRenderable(sampleElement);
   * const existRenderable = new DOMRenderable(existElement);
   *
   * // 생성한 renderable을 엔터티에 등록합니다.
   * entity.addRenderable(sampleRenderable);
   * entity.addRenderable(existRenderable);
   */

  var DOMRenderable =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(DOMRenderable, _Object3D);

    function DOMRenderable(element) {
      var _this;

      _classCallCheck(this, DOMRenderable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMRenderable).call(this)); // this.renderer = new DOMRenderer();

      if ((0, _Util.isNull)(element.parentElement)) document.getElementById(_Context.context.placeholderId).appendChild(element);
      var originalElement = element.cloneNode(true);
      var ghostElement = document.createElement('div');
      ghostElement.id = "ghost-".concat(ghostId);
      ghostElement.style.setProperty('display', 'none', 'important'); // ghostElement.style.display = 'none !important'

      _Data.EntityDataObject.addElement(element, new Map([['original', originalElement], ['ghost', ghostElement]]));

      ghostId++;
      _this.element = element;
      _this.element.style.position = 'absolute';
      _this.element.style.display = 'none';
      _this.element.style.willChange = 'transform';
      _this.isAddedToCamera = false; // this.element.style.backfaceVisibility = 'hidden';
      // this.element.style.WebkitBackfaceVisibility = 'hidden';

      _this.subscribe(_MessageTypes.OBJECT_EVENT.OBJECT_ADDED, function (e) {
        if (e.target.isDOMRenderable) _this.added(e);
      });

      _this.subscribe(_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED, function (e) {
        if (e.target.isDOMRenderable) _this.removed(e);
      });

      return _this;
    }

    _createClass(DOMRenderable, [{
      key: "added",
      value: function added(e) {
        if (this.parent && this.parent.track) this.element.style.display = '';
        var object = e.target;

        while (true) {
          if (object.isScene) {
            if (!this.isAddedToCamera) {
              _DOMRenderer.domRenderer.appendElement(this.element);

              this.isAddedToCamera = true;
            }

            break;
          }

          if (object.parent) {
            object = object.parent;
          } else {
            break;
          }
        }
      }
    }, {
      key: "removed",
      value: function removed(e) {
        if (this.element.parentNode && this.element.parentNode.removeChild) {
          this.element.parentNode.removeChild(this.element);
        }
      }
    }, {
      key: "isDOMRenderable",
      get: function get() {
        return _isDOMRenderable;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }]);

    return DOMRenderable;
  }(_Object3D2["default"]);

  _exports["default"] = DOMRenderable;
});

/***/ }),

/***/ "./renderer/DOMRenderer.js":
/*!*********************************!*\
  !*** ./renderer/DOMRenderer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Context */ "./Context.js"), __webpack_require__(/*! ../core/Scene */ "./core/Scene.js"), __webpack_require__(/*! ../math/Math */ "./math/Math.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js"), __webpack_require__(/*! ../core/Data */ "./core/Data.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _Scene, _Math, _EntityObserver2, _Data) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.domRenderer = void 0;
  _Scene = _interopRequireDefault(_Scene);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var epsilon = function epsilon(value) {
    return Math.abs(value) < 1e-10 ? 0 : value;
  };

  var getCameraCSSMatrix = function getCameraCSSMatrix(camera) {
    var cameraMatrix = camera.matrixWorldInverse.elements.map(function (element, index) {
      return index === 1 || index === 5 || index === 9 || index === 13 ? epsilon(-element) : epsilon(element);
    });
    return "matrix3d(".concat(cameraMatrix.join(','), ")");
  };

  var getObjectCSSMatrix = function getObjectCSSMatrix(renderable) {
    renderable.updateMatrix();
    var objectMatrix = renderable.matrixWorld.elements.map(function (element, index) {
      return index >= 4 && index <= 7 ? epsilon(-element) : epsilon(element);
    });
    return "translate(-50%,-50%) matrix3d(".concat(objectMatrix.join(','), ")");
  };

  var _cachedStyles;

  var _camera = null;

  var _scene = new _Scene["default"]();

  var _domElement = document.createElement('div');

  var _cameraElement = document.createElement('div');

  var DOMRenderer =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(DOMRenderer, _EntityObserver);

    function DOMRenderer() {
      var _this;

      _classCallCheck(this, DOMRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMRenderer).call(this));
      _cachedStyles = {};
      _domElement.style.overflow = 'hidden';
      _domElement.style.WebkitTransformStyle = 'preserve-3d';
      _domElement.style.transformStyle = 'preserve-3d';
      _domElement.className = 'ar-renderer';
      _domElement.style.position = 'fixed';
      _domElement.style.top = '0';
      _domElement.style.left = '0';
      _domElement.style.margin = '0';
      _domElement.style.padding = '0';
      _domElement.style.zIndex = '110';
      _cameraElement.style.WebkitTransformStyle = 'preserve-3d';
      _cameraElement.style.transformStyle = 'preserve-3d';

      _domElement.appendChild(_cameraElement);

      _this.subscribe('trackmove', function (e) {
        return _this.render(e);
      });

      _this.subscribe('trackstart', function (e) {
        return _this.render(e);
      });

      _this.subscribe('trackend', function (e) {
        return _this.render(e);
      });

      _this._width = 0;
      _this._height = 0;
      return _this;
    }

    _createClass(DOMRenderer, [{
      key: "initRenderer",
      value: function initRenderer(camera, id, zIndex, zIndexIncrement) {
        _camera = camera;
        this.width = _Context.context.width;
        this.height = _Context.context.height;
        this.setSize();
        _domElement.id = id;
        _domElement.style.zIndex = zIndex + zIndexIncrement;
        document.body.insertBefore(_domElement, document.body.firstChild);
      }
    }, {
      key: "updateOrientation",
      value: function updateOrientation(newConfig) {
        this.width = newConfig.width;
        this.height = newConfig.height;
        this.setSize();
      }
    }, {
      key: "setSize",
      value: function setSize() {
        _domElement.style.width = _cameraElement.style.width = "".concat(this.width, "px");
        _domElement.style.height = _cameraElement.style.height = "".concat(this.height, "px");
      }
    }, {
      key: "add",
      value: function add(object) {
        _scene.add(object);
      }
    }, {
      key: "remove",
      value: function remove(object) {
        _scene.remove(object);
      }
    }, {
      key: "appendElement",
      value: function appendElement(element) {
        if (_Data.EntityDataObject.getElement(element) != null) {
          var ghost = _Data.EntityDataObject.getElement(element).get('ghost');

          var original = _Data.EntityDataObject.getElement(element).get('original');

          if (original.parentElement === null) {
            element.parentElement.replaceChild(ghost, element);

            _cameraElement.appendChild(element);
          } else {
            original.parentElement.replaceChild(element, original);
          }
        }
      }
    }, {
      key: "appendAllElements",
      value: function appendAllElements() {
        _Data.EntityDataObject.getAllElements().forEach(function (value, key) {
          var ghost = value.get('ghost');
          var original = value.get('original');
          original.parentElement.replaceChild(ghost, original);

          _cameraElement.appendChild(key);
        });
      }
    }, {
      key: "resetElement",
      value: function resetElement() {
        _Data.EntityDataObject.getAllElements().forEach(function (value, key) {
          var ghost = value.get('ghost');
          var original = value.get('original');
          ghost.parentElement.replaceChild(original, ghost);

          _cameraElement.removeChild(key);
        });
      }
    }, {
      key: "removeElement",
      value: function removeElement(element) {
        _cameraElement.removeChild(element);
      }
    }, {
      key: "onTrackMove",
      value: function onTrackMove(e) {}
    }, {
      key: "onTrackStart",
      value: function onTrackStart(e) {}
    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(e) {}
    }, {
      key: "render",
      value: function render(e) {
        if (_camera) {
          var fov = 0.5 / Math.tan((0, _Math.degToRad)(_camera.getEffectiveFOV() * 0.5)) * this.height;
          var cameraCSSMatrix = "translateZ(".concat(fov, "px)").concat(getCameraCSSMatrix(_camera));
          var cameraTransform = "".concat(cameraCSSMatrix, "translate(").concat(this.width * 0.5, "px,").concat(this.height * 0.5, "px)");
          _domElement.style.WebkitPerspective = "".concat(fov, "px");
          _domElement.style.perspective = "".concat(fov, "px");
          _cameraElement.style.WebkitTransform = cameraTransform;
          _cameraElement.style.transform = cameraTransform;
          this.setSize();

          _scene.traverse(function (obj) {
            if (obj.element) {
              var element = obj.element;
              var style = getObjectCSSMatrix(obj);
              var cachedStyle = _cachedStyles[obj.id];

              if (cachedStyle === undefined || cachedStyle !== style) {
                element.style.WebkitTransform = style;
                element.style.transform = style;
                _cachedStyles[obj.id] = style;
              }
            }
          });
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
      }
    }, {
      key: "scene",
      get: function get() {
        return _scene;
      }
    }]);

    return DOMRenderer;
  }(_EntityObserver2["default"]);

  var domRenderer = new DOMRenderer();
  _exports.domRenderer = domRenderer;
});

/***/ }),

/***/ "./vendor/adapter_no_edge.js":
/*!***********************************!*\
  !*** ./vendor/adapter_no_edge.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

  (function (f) {
    if (( false ? undefined : _typeof2(exports)) === "object" && typeof module !== "undefined") {
      module.exports = f();
    } else if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var g; }
  })(function () {
    var define, module, exports;
    return function () {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof require && require;
              if (!f && c) return require(i, !0);
              if (u) return u(i, !0);
              var a = new Error("Cannot find module '" + i + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }

            var p = n[i] = {
              exports: {}
            };
            e[i][0].call(p.exports, function (r) {
              var n = e[i][1][r];
              return o(n || r);
            }, p, p.exports, r, e, n, t);
          }

          return n[i].exports;
        }

        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
          o(t[i]);
        }

        return o;
      }

      return r;
    }()({
      1: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        var _adapter_factory = require('./adapter_factory.js');

        var adapter = (0, _adapter_factory.adapterFactory)({
          window: window
        });
        module.exports = adapter; // this is the difference from adapter_core.
      }, {
        "./adapter_factory.js": 2
      }],
      2: [function (require, module, exports) {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.adapterFactory = adapterFactory;

        var _utils = require('./utils');

        var utils = _interopRequireWildcard(_utils);

        var _chrome_shim = require('./chrome/chrome_shim');

        var chromeShim = _interopRequireWildcard(_chrome_shim);

        var _edge_shim = require('./edge/edge_shim');

        var edgeShim = _interopRequireWildcard(_edge_shim);

        var _firefox_shim = require('./firefox/firefox_shim');

        var firefoxShim = _interopRequireWildcard(_firefox_shim);

        var _safari_shim = require('./safari/safari_shim');

        var safariShim = _interopRequireWildcard(_safari_shim);

        var _common_shim = require('./common_shim');

        var commonShim = _interopRequireWildcard(_common_shim);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        } // Shimming starts here.

        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */


        function adapterFactory() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              window = _ref.window;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            shimChrome: true,
            shimFirefox: true,
            shimEdge: true,
            shimSafari: true
          }; // Utils.

          var logging = utils.log;
          var browserDetails = utils.detectBrowser(window);
          var adapter = {
            browserDetails: browserDetails,
            commonShim: commonShim,
            extractVersion: utils.extractVersion,
            disableLog: utils.disableLog,
            disableWarnings: utils.disableWarnings
          }; // Shim browser if found.

          switch (browserDetails.browser) {
            case 'chrome':
              if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
                logging('Chrome shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = chromeShim;
              chromeShim.shimGetUserMedia(window);
              chromeShim.shimMediaStream(window);
              chromeShim.shimPeerConnection(window);
              chromeShim.shimOnTrack(window);
              chromeShim.shimAddTrackRemoveTrack(window);
              chromeShim.shimGetSendersWithDtmf(window);
              chromeShim.shimGetStats(window);
              chromeShim.shimSenderReceiverGetStats(window);
              chromeShim.fixNegotiationNeeded(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;

            case 'firefox':
              if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
                logging('Firefox shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = firefoxShim;
              firefoxShim.shimGetUserMedia(window);
              firefoxShim.shimPeerConnection(window);
              firefoxShim.shimOnTrack(window);
              firefoxShim.shimRemoveStream(window);
              firefoxShim.shimSenderGetStats(window);
              firefoxShim.shimReceiverGetStats(window);
              firefoxShim.shimRTCDataChannel(window);
              firefoxShim.shimAddTransceiver(window);
              firefoxShim.shimCreateOffer(window);
              firefoxShim.shimCreateAnswer(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;

            case 'edge':
              if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                logging('MS edge shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = edgeShim;
              edgeShim.shimGetUserMedia(window);
              edgeShim.shimGetDisplayMedia(window);
              edgeShim.shimPeerConnection(window);
              edgeShim.shimReplaceTrack(window); // the edge shim implements the full RTCIceCandidate object.

              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;

            case 'safari':
              if (!safariShim || !options.shimSafari) {
                logging('Safari shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = safariShim;
              safariShim.shimRTCIceServerUrls(window);
              safariShim.shimCreateOfferLegacy(window);
              safariShim.shimCallbacksAPI(window);
              safariShim.shimLocalStreamsAPI(window);
              safariShim.shimRemoteStreamsAPI(window);
              safariShim.shimTrackEventTransceiver(window);
              safariShim.shimGetUserMedia(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;

            default:
              logging('Unsupported browser!');
              break;
          }

          return adapter;
        } // Browser shims.

      }, {
        "./chrome/chrome_shim": 3,
        "./common_shim": 6,
        "./edge/edge_shim": 12,
        "./firefox/firefox_shim": 7,
        "./safari/safari_shim": 10,
        "./utils": 11
      }],
      3: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        var _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          }
        });

        var _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          }
        });
        exports.shimMediaStream = shimMediaStream;
        exports.shimOnTrack = shimOnTrack;
        exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
        exports.shimGetStats = shimGetStats;
        exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
        exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
        exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.fixNegotiationNeeded = fixNegotiationNeeded;

        var _utils = require('../utils.js');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function shimMediaStream(window) {
          window.MediaStream = window.MediaStream || window.webkitMediaStream;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get: function get() {
                return this._ontrack;
              },
              set: function set(f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                }

                this.addEventListener('track', this._ontrack = f);
              },
              enumerable: true,
              configurable: true
            });
            var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              var _this = this;

              if (!this._ontrackpoly) {
                this._ontrackpoly = function (e) {
                  // onaddstream does not fire when a track is added to an existing
                  // stream. But stream.onaddtrack is implemented so we use that.
                  e.stream.addEventListener('addtrack', function (te) {
                    var receiver = void 0;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(function (r) {
                        return r.track && r.track.id === te.track.id;
                      });
                    } else {
                      receiver = {
                        track: te.track
                      };
                    }

                    var event = new Event('track');
                    event.track = te.track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];

                    _this.dispatchEvent(event);
                  });
                  e.stream.getTracks().forEach(function (track) {
                    var receiver = void 0;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(function (r) {
                        return r.track && r.track.id === track.id;
                      });
                    } else {
                      receiver = {
                        track: track
                      };
                    }

                    var event = new Event('track');
                    event.track = track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];

                    _this.dispatchEvent(event);
                  });
                };

                this.addEventListener('addstream', this._ontrackpoly);
              }

              return origSetRemoteDescription.apply(this, arguments);
            };
          } else {
            // even if RTCRtpTransceiver is in window, it is only used and
            // emitted in unified-plan. Unfortunately this means we need
            // to unconditionally wrap the event.
            utils.wrapPeerConnectionEvent(window, 'track', function (e) {
              if (!e.transceiver) {
                Object.defineProperty(e, 'transceiver', {
                  value: {
                    receiver: e.receiver
                  }
                });
              }

              return e;
            });
          }
        }

        function shimGetSendersWithDtmf(window) {
          // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
            var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
              return {
                track: track,

                get dtmf() {
                  if (this._dtmf === undefined) {
                    if (track.kind === 'audio') {
                      this._dtmf = pc.createDTMFSender(track);
                    } else {
                      this._dtmf = null;
                    }
                  }

                  return this._dtmf;
                },

                _pc: pc
              };
            }; // augment addTrack when getSenders is not available.


            if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                this._senders = this._senders || [];
                return this._senders.slice(); // return a copy of the internal state.
              };

              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

              window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
                var sender = origAddTrack.apply(this, arguments);

                if (!sender) {
                  sender = shimSenderWithDtmf(this, track);

                  this._senders.push(sender);
                }

                return sender;
              };

              var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

              window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
                origRemoveTrack.apply(this, arguments);

                var idx = this._senders.indexOf(sender);

                if (idx !== -1) {
                  this._senders.splice(idx, 1);
                }
              };
            }

            var origAddStream = window.RTCPeerConnection.prototype.addStream;

            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              var _this2 = this;

              this._senders = this._senders || [];
              origAddStream.apply(this, [stream]);
              stream.getTracks().forEach(function (track) {
                _this2._senders.push(shimSenderWithDtmf(_this2, track));
              });
            };

            var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              var _this3 = this;

              this._senders = this._senders || [];
              origRemoveStream.apply(this, [stream]);
              stream.getTracks().forEach(function (track) {
                var sender = _this3._senders.find(function (s) {
                  return s.track === track;
                });

                if (sender) {
                  // remove sender
                  _this3._senders.splice(_this3._senders.indexOf(sender), 1);
                }
              });
            };
          } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this4 = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this4;
              });
              return senders;
            };

            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function get() {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = this._pc.createDTMFSender(this.track);
                  } else {
                    this._dtmf = null;
                  }
                }

                return this._dtmf;
              }
            });
          }
        }

        function shimGetStats(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var origGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            var _this5 = this;

            var _arguments = Array.prototype.slice.call(arguments),
                selector = _arguments[0],
                onSucc = _arguments[1],
                onErr = _arguments[2]; // If selector is a function then we are in the old style stats so just
            // pass back the original getStats format to avoid breaking old users.


            if (arguments.length > 0 && typeof selector === 'function') {
              return origGetStats.apply(this, arguments);
            } // When spec-style getStats is supported, return those when called with
            // either no arguments or the selector argument is null.


            if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
              return origGetStats.apply(this, []);
            }

            var fixChromeStats_ = function fixChromeStats_(response) {
              var standardReport = {};
              var reports = response.result();
              reports.forEach(function (report) {
                var standardStats = {
                  id: report.id,
                  timestamp: report.timestamp,
                  type: {
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate'
                  }[report.type] || report.type
                };
                report.names().forEach(function (name) {
                  standardStats[name] = report.stat(name);
                });
                standardReport[standardStats.id] = standardStats;
              });
              return standardReport;
            }; // shim getStats with maplike support


            var makeMapStats = function makeMapStats(stats) {
              return new Map(Object.keys(stats).map(function (key) {
                return [key, stats[key]];
              }));
            };

            if (arguments.length >= 2) {
              var successCallbackWrapper_ = function successCallbackWrapper_(response) {
                onSucc(makeMapStats(fixChromeStats_(response)));
              };

              return origGetStats.apply(this, [successCallbackWrapper_, selector]);
            } // promise-support


            return new Promise(function (resolve, reject) {
              origGetStats.apply(_this5, [function (response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
            }).then(onSucc, onErr);
          };
        }

        function shimSenderReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
            return;
          } // shim sender stats.


          if (!('getStats' in window.RTCRtpSender.prototype)) {
            var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

            if (origGetSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                var _this6 = this;

                var senders = origGetSenders.apply(this, []);
                senders.forEach(function (sender) {
                  return sender._pc = _this6;
                });
                return senders;
              };
            }

            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

            if (origAddTrack) {
              window.RTCPeerConnection.prototype.addTrack = function addTrack() {
                var sender = origAddTrack.apply(this, arguments);
                sender._pc = this;
                return sender;
              };
            }

            window.RTCRtpSender.prototype.getStats = function getStats() {
              var sender = this;
              return this._pc.getStats().then(function (result) {
                return (
                  /* Note: this will include stats of all senders that
                   *   send a track with the same id as sender.track as
                   *   it is not possible to identify the RTCRtpSender.
                   */
                  utils.filterStats(result, sender.track, true)
                );
              });
            };
          } // shim receiver stats.


          if (!('getStats' in window.RTCRtpReceiver.prototype)) {
            var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

            if (origGetReceivers) {
              window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
                var _this7 = this;

                var receivers = origGetReceivers.apply(this, []);
                receivers.forEach(function (receiver) {
                  return receiver._pc = _this7;
                });
                return receivers;
              };
            }

            utils.wrapPeerConnectionEvent(window, 'track', function (e) {
              e.receiver._pc = e.srcElement;
              return e;
            });

            window.RTCRtpReceiver.prototype.getStats = function getStats() {
              var receiver = this;
              return this._pc.getStats().then(function (result) {
                return utils.filterStats(result, receiver.track, false);
              });
            };
          }

          if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
            return;
          } // shim RTCPeerConnection.getStats(track).


          var origGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
              var track = arguments[0];
              var sender = void 0;
              var receiver = void 0;
              var err = void 0;
              this.getSenders().forEach(function (s) {
                if (s.track === track) {
                  if (sender) {
                    err = true;
                  } else {
                    sender = s;
                  }
                }
              });
              this.getReceivers().forEach(function (r) {
                if (r.track === track) {
                  if (receiver) {
                    err = true;
                  } else {
                    receiver = r;
                  }
                }

                return r.track === track;
              });

              if (err || sender && receiver) {
                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
              } else if (sender) {
                return sender.getStats();
              } else if (receiver) {
                return receiver.getStats();
              }

              return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
            }

            return origGetStats.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrackWithNative(window) {
          // shim addTrack/removeTrack with native variants in order to make
          // the interactions with legacy getLocalStreams behave as in other browsers.
          // Keeps a mapping stream.id => [stream, rtpsenders...]
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            var _this8 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
              return _this8._shimmedLocalStreams[streamId][0];
            });
          };

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            if (!stream) {
              return origAddTrack.apply(this, arguments);
            }

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            var sender = origAddTrack.apply(this, arguments);

            if (!this._shimmedLocalStreams[stream.id]) {
              this._shimmedLocalStreams[stream.id] = [stream, sender];
            } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
              this._shimmedLocalStreams[stream.id].push(sender);
            }

            return sender;
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this9 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = _this9.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            });
            var existingSenders = this.getSenders();
            origAddStream.apply(this, arguments);
            var newSenders = this.getSenders().filter(function (newSender) {
              return existingSenders.indexOf(newSender) === -1;
            });
            this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            delete this._shimmedLocalStreams[stream.id];
            return origRemoveStream.apply(this, arguments);
          };

          var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            var _this10 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            if (sender) {
              Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
                var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);

                if (idx !== -1) {
                  _this10._shimmedLocalStreams[streamId].splice(idx, 1);
                }

                if (_this10._shimmedLocalStreams[streamId].length === 1) {
                  delete _this10._shimmedLocalStreams[streamId];
                }
              });
            }

            return origRemoveTrack.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrack(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window); // shim addTrack and removeTrack.

          if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
            return shimAddTrackRemoveTrackWithNative(window);
          } // also shim pc.getLocalStreams when addTrack is shimmed
          // to return the original streams.


          var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;

          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            var _this11 = this;

            var nativeStreams = origGetLocalStreams.apply(this);
            this._reverseStreams = this._reverseStreams || {};
            return nativeStreams.map(function (stream) {
              return _this11._reverseStreams[stream.id];
            });
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this12 = this;

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = _this12.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            }); // Add identity mapping for consistency with addTrack.
            // Unless this is being used with a stream from addTrack.

            if (!this._reverseStreams[stream.id]) {
              var newStream = new window.MediaStream(stream.getTracks());
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              stream = newStream;
            }

            origAddStream.apply(this, [stream]);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
            delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
            delete this._streams[stream.id];
          };

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            var _this13 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            }

            var streams = [].slice.call(arguments, 1);

            if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
              return t === track;
            })) {
              // this is not fully correct but all we can manage without
              // [[associated MediaStreams]] internal slot.
              throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
            }

            var alreadyExists = this.getSenders().find(function (s) {
              return s.track === track;
            });

            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            var oldStream = this._streams[stream.id];

            if (oldStream) {
              // this is using odd Chrome behaviour, use with caution:
              // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
              // Note: we rely on the high-level addTrack/dtmf shim to
              // create the sender with a dtmf sender.
              oldStream.addTrack(track); // Trigger ONN async.

              Promise.resolve().then(function () {
                _this13.dispatchEvent(new Event('negotiationneeded'));
              });
            } else {
              var newStream = new window.MediaStream([track]);
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              this.addStream(newStream);
            }

            return this.getSenders().find(function (s) {
              return s.track === track;
            });
          }; // replace the internal stream id with the external one and
          // vice versa.


          function replaceInternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          function replaceExternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          ['createOffer', 'createAnswer'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];

            var methodObj = _defineProperty({}, method, function () {
              var _this14 = this;

              var args = arguments;
              var isLegacyCall = arguments.length && typeof arguments[0] === 'function';

              if (isLegacyCall) {
                return nativeMethod.apply(this, [function (description) {
                  var desc = replaceInternalStreamId(_this14, description);
                  args[0].apply(null, [desc]);
                }, function (err) {
                  if (args[1]) {
                    args[1].apply(null, err);
                  }
                }, arguments[2]]);
              }

              return nativeMethod.apply(this, arguments).then(function (description) {
                return replaceInternalStreamId(_this14, description);
              });
            });

            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
          var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;

          window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
            if (!arguments.length || !arguments[0].type) {
              return origSetLocalDescription.apply(this, arguments);
            }

            arguments[0] = replaceExternalStreamId(this, arguments[0]);
            return origSetLocalDescription.apply(this, arguments);
          }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier


          var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
          Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
            get: function get() {
              var description = origLocalDescription.get.apply(this);

              if (description.type === '') {
                return description;
              }

              return replaceInternalStreamId(this, description);
            }
          });

          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            var _this15 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            } // We can not yet check for sender instanceof RTCRtpSender
            // since we shim RTPSender. So we check if sender._pc is set.


            if (!sender._pc) {
              throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
            }

            var isLocal = sender._pc === this;

            if (!isLocal) {
              throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
            } // Search for the native stream the senders track belongs to.


            this._streams = this._streams || {};
            var stream = void 0;
            Object.keys(this._streams).forEach(function (streamid) {
              var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
                return sender.track === track;
              });

              if (hasTrack) {
                stream = _this15._streams[streamid];
              }
            });

            if (stream) {
              if (stream.getTracks().length === 1) {
                // if this is the last track of the stream, remove the stream. This
                // takes care of any shimmed _senders.
                this.removeStream(this._reverseStreams[stream.id]);
              } else {
                // relying on the same odd chrome behaviour as above.
                stream.removeTrack(sender.track);
              }

              this.dispatchEvent(new Event('negotiationneeded'));
            }
          };
        }

        function shimPeerConnection(window) {
          var browserDetails = utils.detectBrowser(window);

          if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.webkitRTCPeerConnection;
          }

          if (!window.RTCPeerConnection) {
            return;
          } // shim implicit creation of RTCSessionDescription/RTCIceCandidate


          if (browserDetails.version < 53) {
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              var methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });

              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          } // support for addIceCandidate(null or undefined)


          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

          window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }

              return Promise.resolve();
            } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
            // in older versions. Native support planned for Chrome M77.


            if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
              return Promise.resolve();
            }

            return nativeAddIceCandidate.apply(this, arguments);
          };
        }

        function fixNegotiationNeeded(window) {
          utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
            var pc = e.target;

            if (pc.signalingState !== 'stable') {
              return;
            }

            return e;
          });
        }
      }, {
        "../utils.js": 11,
        "./getdisplaymedia": 4,
        "./getusermedia": 5
      }],
      4: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;

        function shimGetDisplayMedia(window, getSourceId) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }

          if (!window.navigator.mediaDevices) {
            return;
          } // getSourceId is a function that returns a promise resolving with
          // the sourceId of the screen/window/tab to be shared.


          if (typeof getSourceId !== 'function') {
            console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
            return;
          }

          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            return getSourceId(constraints).then(function (sourceId) {
              var widthSpecified = constraints.video && constraints.video.width;
              var heightSpecified = constraints.video && constraints.video.height;
              var frameRateSpecified = constraints.video && constraints.video.frameRate;
              constraints.video = {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: sourceId,
                  maxFrameRate: frameRateSpecified || 3
                }
              };

              if (widthSpecified) {
                constraints.video.mandatory.maxWidth = widthSpecified;
              }

              if (heightSpecified) {
                constraints.video.mandatory.maxHeight = heightSpecified;
              }

              return window.navigator.mediaDevices.getUserMedia(constraints);
            });
          };
        }
      }, {}],
      5: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimGetUserMedia = shimGetUserMedia;

        var _utils = require('../utils.js');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        var logging = utils.log;

        function shimGetUserMedia(window) {
          var navigator = window && window.navigator;

          if (!navigator.mediaDevices) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          var constraintsToChrome_ = function constraintsToChrome_(c) {
            if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
              return c;
            }

            var cc = {};
            Object.keys(c).forEach(function (key) {
              if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                return;
              }

              var r = _typeof(c[key]) === 'object' ? c[key] : {
                ideal: c[key]
              };

              if (r.exact !== undefined && typeof r.exact === 'number') {
                r.min = r.max = r.exact;
              }

              var oldname_ = function oldname_(prefix, name) {
                if (prefix) {
                  return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                }

                return name === 'deviceId' ? 'sourceId' : name;
              };

              if (r.ideal !== undefined) {
                cc.optional = cc.optional || [];
                var oc = {};

                if (typeof r.ideal === 'number') {
                  oc[oldname_('min', key)] = r.ideal;
                  cc.optional.push(oc);
                  oc = {};
                  oc[oldname_('max', key)] = r.ideal;
                  cc.optional.push(oc);
                } else {
                  oc[oldname_('', key)] = r.ideal;
                  cc.optional.push(oc);
                }
              }

              if (r.exact !== undefined && typeof r.exact !== 'number') {
                cc.mandatory = cc.mandatory || {};
                cc.mandatory[oldname_('', key)] = r.exact;
              } else {
                ['min', 'max'].forEach(function (mix) {
                  if (r[mix] !== undefined) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname_(mix, key)] = r[mix];
                  }
                });
              }
            });

            if (c.advanced) {
              cc.optional = (cc.optional || []).concat(c.advanced);
            }

            return cc;
          };

          var shimConstraints_ = function shimConstraints_(constraints, func) {
            if (browserDetails.version >= 61) {
              return func(constraints);
            }

            constraints = JSON.parse(JSON.stringify(constraints));

            if (constraints && _typeof(constraints.audio) === 'object') {
              var remap = function remap(obj, a, b) {
                if (a in obj && !(b in obj)) {
                  obj[b] = obj[a];
                  delete obj[a];
                }
              };

              constraints = JSON.parse(JSON.stringify(constraints));
              remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
              remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
              constraints.audio = constraintsToChrome_(constraints.audio);
            }

            if (constraints && _typeof(constraints.video) === 'object') {
              // Shim facingMode for mobile & surface pro.
              var face = constraints.video.facingMode;
              face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : {
                ideal: face
              });
              var getSupportedFacingModeLies = browserDetails.version < 66;

              if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
                delete constraints.video.facingMode;
                var matches = void 0;

                if (face.exact === 'environment' || face.ideal === 'environment') {
                  matches = ['back', 'rear'];
                } else if (face.exact === 'user' || face.ideal === 'user') {
                  matches = ['front'];
                }

                if (matches) {
                  // Look for matches in label, or use last cam for back (typical).
                  return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                    devices = devices.filter(function (d) {
                      return d.kind === 'videoinput';
                    });
                    var dev = devices.find(function (d) {
                      return matches.some(function (match) {
                        return d.label.toLowerCase().includes(match);
                      });
                    });

                    if (!dev && devices.length && matches.includes('back')) {
                      dev = devices[devices.length - 1]; // more likely the back cam
                    }

                    if (dev) {
                      constraints.video.deviceId = face.exact ? {
                        exact: dev.deviceId
                      } : {
                        ideal: dev.deviceId
                      };
                    }

                    constraints.video = constraintsToChrome_(constraints.video);
                    logging('chrome: ' + JSON.stringify(constraints));
                    return func(constraints);
                  });
                }
              }

              constraints.video = constraintsToChrome_(constraints.video);
            }

            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          };

          var shimError_ = function shimError_(e) {
            if (browserDetails.version >= 64) {
              return e;
            }

            return {
              name: {
                PermissionDeniedError: 'NotAllowedError',
                PermissionDismissedError: 'NotAllowedError',
                InvalidStateError: 'NotAllowedError',
                DevicesNotFoundError: 'NotFoundError',
                ConstraintNotSatisfiedError: 'OverconstrainedError',
                TrackStartError: 'NotReadableError',
                MediaDeviceFailedDueToShutdown: 'NotAllowedError',
                MediaDeviceKillSwitchOn: 'NotAllowedError',
                TabCaptureError: 'AbortError',
                ScreenCaptureError: 'AbortError',
                DeviceCaptureError: 'AbortError'
              }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString: function toString() {
                return this.name + (this.message && ': ') + this.message;
              }
            };
          };

          var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
            shimConstraints_(constraints, function (c) {
              navigator.webkitGetUserMedia(c, onSuccess, function (e) {
                if (onError) {
                  onError(shimError_(e));
                }
              });
            });
          };

          navigator.getUserMedia = getUserMedia_.bind(navigator); // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
          // function which returns a Promise, it does not accept spec-style
          // constraints.

          if (navigator.mediaDevices.getUserMedia) {
            var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

            navigator.mediaDevices.getUserMedia = function (cs) {
              return shimConstraints_(cs, function (c) {
                return origGetUserMedia(c).then(function (stream) {
                  if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                    stream.getTracks().forEach(function (track) {
                      track.stop();
                    });
                    throw new DOMException('', 'NotFoundError');
                  }

                  return stream;
                }, function (e) {
                  return Promise.reject(shimError_(e));
                });
              });
            };
          }
        }
      }, {
        "../utils.js": 11
      }],
      6: [function (require, module, exports) {
        /*
         *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimRTCIceCandidate = shimRTCIceCandidate;
        exports.shimMaxMessageSize = shimMaxMessageSize;
        exports.shimSendThrowTypeError = shimSendThrowTypeError;
        exports.shimConnectionState = shimConnectionState;
        exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

        var _sdp = require('sdp');

        var _sdp2 = _interopRequireDefault(_sdp);

        var _utils = require('./utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function shimRTCIceCandidate(window) {
          // foundation is arbitrarily chosen as an indicator for full support for
          // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
          if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
            return;
          }

          var NativeRTCIceCandidate = window.RTCIceCandidate;

          window.RTCIceCandidate = function RTCIceCandidate(args) {
            // Remove the a= which shouldn't be part of the candidate string.
            if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substr(2);
            }

            if (args.candidate && args.candidate.length) {
              // Augment the native candidate with the parsed fields.
              var nativeCandidate = new NativeRTCIceCandidate(args);

              var parsedCandidate = _sdp2["default"].parseCandidate(args.candidate);

              var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate); // Add a serializer that does not serialize the extra attributes.

              augmentedCandidate.toJSON = function toJSON() {
                return {
                  candidate: augmentedCandidate.candidate,
                  sdpMid: augmentedCandidate.sdpMid,
                  sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                  usernameFragment: augmentedCandidate.usernameFragment
                };
              };

              return augmentedCandidate;
            }

            return new NativeRTCIceCandidate(args);
          };

          window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype; // Hook up the augmented candidate in onicecandidate and
          // addEventListener('icecandidate', ...)

          utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
            if (e.candidate) {
              Object.defineProperty(e, 'candidate', {
                value: new window.RTCIceCandidate(e.candidate),
                writable: 'false'
              });
            }

            return e;
          });
        }

        function shimMaxMessageSize(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          if (!('sctp' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
              get: function get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              }
            });
          }

          var sctpInDescription = function sctpInDescription(description) {
            if (!description || !description.sdp) {
              return false;
            }

            var sections = _sdp2["default"].splitSections(description.sdp);

            sections.shift();
            return sections.some(function (mediaSection) {
              var mLine = _sdp2["default"].parseMLine(mediaSection);

              return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
            });
          };

          var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
            // TODO: Is there a better solution for detecting Firefox?
            var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);

            if (match === null || match.length < 2) {
              return -1;
            }

            var version = parseInt(match[1], 10); // Test for NaN (yes, this is ugly)

            return version !== version ? -1 : version;
          };

          var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
            // Every implementation we know can send at least 64 KiB.
            // Note: Although Chrome is technically able to send up to 256 KiB, the
            //       data does not reach the other peer reliably.
            //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
            var canSendMaxMessageSize = 65536;

            if (browserDetails.browser === 'firefox') {
              if (browserDetails.version < 57) {
                if (remoteIsFirefox === -1) {
                  // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                } else {
                  // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
                }
              } else if (browserDetails.version < 60) {
                // Currently, all FF >= 57 will reset the remote maximum message size
                // to the default value when a data channel is created at a later
                // stage. :(
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
              } else {
                // FF >= 60 supports sending ~2 GiB
                canSendMaxMessageSize = 2147483637;
              }
            }

            return canSendMaxMessageSize;
          };

          var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
            // Note: 65536 bytes is the default value from the SDP spec. Also,
            //       every implementation we know supports receiving 65536 bytes.
            var maxMessageSize = 65536; // FF 57 has a slightly incorrect default remote max message size, so
            // we need to adjust it here to avoid a failure when sending.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697

            if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
              maxMessageSize = 65535;
            }

            var match = _sdp2["default"].matchPrefix(description.sdp, 'a=max-message-size:');

            if (match.length > 0) {
              maxMessageSize = parseInt(match[0].substr(19), 10);
            } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
              // If the maximum message size is not present in the remote SDP and
              // both local and remote are Firefox, the remote peer can receive
              // ~2 GiB.
              maxMessageSize = 2147483637;
            }

            return maxMessageSize;
          };

          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            this._sctp = null; // Chrome decided to not expose .sctp in plan-b mode.
            // As usual, adapter.js has to do an 'ugly worakaround'
            // to cover up the mess.

            if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
              var _getConfiguration = this.getConfiguration(),
                  sdpSemantics = _getConfiguration.sdpSemantics;

              if (sdpSemantics === 'plan-b') {
                Object.defineProperty(this, 'sctp', {
                  get: function get() {
                    return typeof this._sctp === 'undefined' ? null : this._sctp;
                  },
                  enumerable: true,
                  configurable: true
                });
              }
            }

            if (sctpInDescription(arguments[0])) {
              // Check if the remote is FF.
              var isFirefox = getRemoteFirefoxVersion(arguments[0]); // Get the maximum message size the local peer is capable of sending

              var canSendMMS = getCanSendMaxMessageSize(isFirefox); // Get the maximum message size of the remote peer.

              var remoteMMS = getMaxMessageSize(arguments[0], isFirefox); // Determine final maximum message size

              var maxMessageSize = void 0;

              if (canSendMMS === 0 && remoteMMS === 0) {
                maxMessageSize = Number.POSITIVE_INFINITY;
              } else if (canSendMMS === 0 || remoteMMS === 0) {
                maxMessageSize = Math.max(canSendMMS, remoteMMS);
              } else {
                maxMessageSize = Math.min(canSendMMS, remoteMMS);
              } // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
              // attribute.


              var sctp = {};
              Object.defineProperty(sctp, 'maxMessageSize', {
                get: function get() {
                  return maxMessageSize;
                }
              });
              this._sctp = sctp;
            }

            return origSetRemoteDescription.apply(this, arguments);
          };
        }

        function shimSendThrowTypeError(window) {
          if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
            return;
          } // Note: Although Firefox >= 57 has a native implementation, the maximum
          //       message size can be reset for all data channels at a later stage.
          //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831


          function wrapDcSend(dc, pc) {
            var origDataChannelSend = dc.send;

            dc.send = function send() {
              var data = arguments[0];
              var length = data.length || data.size || data.byteLength;

              if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
                throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
              }

              return origDataChannelSend.apply(dc, arguments);
            };
          }

          var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;

          window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
            var dataChannel = origCreateDataChannel.apply(this, arguments);
            wrapDcSend(dataChannel, this);
            return dataChannel;
          };

          utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
            wrapDcSend(e.channel, e.target);
            return e;
          });
        }
        /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
         * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
         * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
         * since DTLS failures would be hidden. See
         * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
         * for the Firefox tracking bug.
         */


        function shimConnectionState(window) {
          if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
            return;
          }

          var proto = window.RTCPeerConnection.prototype;
          Object.defineProperty(proto, 'connectionState', {
            get: function get() {
              return {
                completed: 'connected',
                checking: 'connecting'
              }[this.iceConnectionState] || this.iceConnectionState;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(proto, 'onconnectionstatechange', {
            get: function get() {
              return this._onconnectionstatechange || null;
            },
            set: function set(cb) {
              if (this._onconnectionstatechange) {
                this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
                delete this._onconnectionstatechange;
              }

              if (cb) {
                this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
              }
            },
            enumerable: true,
            configurable: true
          });
          ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
            var origMethod = proto[method];

            proto[method] = function () {
              if (!this._connectionstatechangepoly) {
                this._connectionstatechangepoly = function (e) {
                  var pc = e.target;

                  if (pc._lastConnectionState !== pc.connectionState) {
                    pc._lastConnectionState = pc.connectionState;
                    var newEvent = new Event('connectionstatechange', e);
                    pc.dispatchEvent(newEvent);
                  }

                  return e;
                };

                this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
              }

              return origMethod.apply(this, arguments);
            };
          });
        }

        function removeAllowExtmapMixed(window) {
          /* remove a=extmap-allow-mixed for Chrome < M71 */
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
            return;
          }

          var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;

          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
            if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
              desc.sdp = desc.sdp.split('\n').filter(function (line) {
                return line.trim() !== 'a=extmap-allow-mixed';
              }).join('\n');
            }

            return nativeSRD.apply(this, arguments);
          };
        }
      }, {
        "./utils": 11,
        "sdp": 13
      }],
      7: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        var _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          }
        });

        var _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          }
        });
        exports.shimOnTrack = shimOnTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.shimSenderGetStats = shimSenderGetStats;
        exports.shimReceiverGetStats = shimReceiverGetStats;
        exports.shimRemoveStream = shimRemoveStream;
        exports.shimRTCDataChannel = shimRTCDataChannel;
        exports.shimAddTransceiver = shimAddTransceiver;
        exports.shimCreateOffer = shimCreateOffer;
        exports.shimCreateAnswer = shimCreateAnswer;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        }

        function shimPeerConnection(window) {
          var browserDetails = utils.detectBrowser(window);

          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
            return; // probably media.peerconnection.enabled=false in about:config
          }

          if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.mozRTCPeerConnection;
          }

          if (browserDetails.version < 53) {
            // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              var methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });

              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          } // support for addIceCandidate(null or undefined)
          // as well as ignoring {sdpMid, candidate: ""}


          if (browserDetails.version < 68) {
            var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

            window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
              if (!arguments[0]) {
                if (arguments[1]) {
                  arguments[1].apply(null);
                }

                return Promise.resolve();
              } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
              // in older versions.


              if (arguments[0] && arguments[0].candidate === '') {
                return Promise.resolve();
              }

              return nativeAddIceCandidate.apply(this, arguments);
            };
          }

          var modernStatsTypes = {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          };
          var nativeGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            var _arguments = Array.prototype.slice.call(arguments),
                selector = _arguments[0],
                onSucc = _arguments[1],
                onErr = _arguments[2];

            return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
              if (browserDetails.version < 53 && !onSucc) {
                // Shim only promise getStats with spec-hyphens in type names
                // Leave callback version alone; misc old uses of forEach before Map
                try {
                  stats.forEach(function (stat) {
                    stat.type = modernStatsTypes[stat.type] || stat.type;
                  });
                } catch (e) {
                  if (e.name !== 'TypeError') {
                    throw e;
                  } // Avoid TypeError: "type" is read-only, in old versions. 34-43ish


                  stats.forEach(function (stat, i) {
                    stats.set(i, Object.assign({}, stat, {
                      type: modernStatsTypes[stat.type] || stat.type
                    }));
                  });
                }
              }

              return stats;
            }).then(onSucc, onErr);
          };
        }

        function shimSenderGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }

          if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
            return;
          }

          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this;
              });
              return senders;
            };
          }

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              var sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }

          window.RTCRtpSender.prototype.getStats = function getStats() {
            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
          };
        }

        function shimReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }

          if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
            return;
          }

          var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              var _this2 = this;

              var receivers = origGetReceivers.apply(this, []);
              receivers.forEach(function (receiver) {
                return receiver._pc = _this2;
              });
              return receivers;
            };
          }

          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            e.receiver._pc = e.srcElement;
            return e;
          });

          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            return this._pc.getStats(this.track);
          };
        }

        function shimRemoveStream(window) {
          if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
            return;
          }

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this3 = this;

            utils.deprecated('removeStream', 'removeTrack');
            this.getSenders().forEach(function (sender) {
              if (sender.track && stream.getTracks().includes(sender.track)) {
                _this3.removeTrack(sender);
              }
            });
          };
        }

        function shimRTCDataChannel(window) {
          // rename DataChannel to RTCDataChannel (native fix in FF60):
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
          if (window.DataChannel && !window.RTCDataChannel) {
            window.RTCDataChannel = window.DataChannel;
          }
        }

        function shimAddTransceiver(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;

          if (origAddTransceiver) {
            window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
              this.setParametersPromises = [];
              var initParameters = arguments[1];
              var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;

              if (shouldPerformCheck) {
                // If sendEncodings params are provided, validate grammar
                initParameters.sendEncodings.forEach(function (encodingParam) {
                  if ('rid' in encodingParam) {
                    var ridRegex = /^[a-z0-9]{0,16}$/i;

                    if (!ridRegex.test(encodingParam.rid)) {
                      throw new TypeError('Invalid RID value provided.');
                    }
                  }

                  if ('scaleResolutionDownBy' in encodingParam) {
                    if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                      throw new RangeError('scale_resolution_down_by must be >= 1.0');
                    }
                  }

                  if ('maxFramerate' in encodingParam) {
                    if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                      throw new RangeError('max_framerate must be >= 0.0');
                    }
                  }
                });
              }

              var transceiver = origAddTransceiver.apply(this, arguments);

              if (shouldPerformCheck) {
                // Check if the init options were applied. If not we do this in an
                // asynchronous way and save the promise reference in a global object.
                // This is an ugly hack, but at the same time is way more robust than
                // checking the sender parameters before and after the createOffer
                // Also note that after the createoffer we are not 100% sure that
                // the params were asynchronously applied so we might miss the
                // opportunity to recreate offer.
                var sender = transceiver.sender;
                var params = sender.getParameters();

                if (!('encodings' in params)) {
                  params.encodings = initParameters.sendEncodings;
                  this.setParametersPromises.push(sender.setParameters(params)["catch"](function () {}));
                }
              }

              return transceiver;
            };
          }
        }

        function shimCreateOffer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

          window.RTCPeerConnection.prototype.createOffer = function createOffer() {
            var _this4 = this,
                _arguments2 = arguments;

            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises).then(function () {
                return origCreateOffer.apply(_this4, _arguments2);
              })["finally"](function () {
                _this4.setParametersPromises = [];
              });
            }

            return origCreateOffer.apply(this, arguments);
          };
        }

        function shimCreateAnswer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;

          window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
            var _this5 = this,
                _arguments3 = arguments;

            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises).then(function () {
                return origCreateAnswer.apply(_this5, _arguments3);
              })["finally"](function () {
                _this5.setParametersPromises = [];
              });
            }

            return origCreateAnswer.apply(this, arguments);
          };
        }
      }, {
        "../utils": 11,
        "./getdisplaymedia": 8,
        "./getusermedia": 9
      }],
      8: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;

        function shimGetDisplayMedia(window, preferredMediaSource) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }

          if (!window.navigator.mediaDevices) {
            return;
          }

          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            if (!(constraints && constraints.video)) {
              var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
              err.name = 'NotFoundError'; // from https://heycam.github.io/webidl/#idl-DOMException-error-names

              err.code = 8;
              return Promise.reject(err);
            }

            if (constraints.video === true) {
              constraints.video = {
                mediaSource: preferredMediaSource
              };
            } else {
              constraints.video.mediaSource = preferredMediaSource;
            }

            return window.navigator.mediaDevices.getUserMedia(constraints);
          };
        }
      }, {}],
      9: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimGetUserMedia = shimGetUserMedia;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function shimGetUserMedia(window) {
          var browserDetails = utils.detectBrowser(window);
          var navigator = window && window.navigator;
          var MediaStreamTrack = window && window.MediaStreamTrack;

          navigator.getUserMedia = function (constraints, onSuccess, onError) {
            // Replace Firefox 44+'s deprecation warning with unprefixed version.
            utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
            navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
          };

          if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
            var remap = function remap(obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };

            var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

            navigator.mediaDevices.getUserMedia = function (c) {
              if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
              }

              return nativeGetUserMedia(c);
            };

            if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
              var nativeGetSettings = MediaStreamTrack.prototype.getSettings;

              MediaStreamTrack.prototype.getSettings = function () {
                var obj = nativeGetSettings.apply(this, arguments);
                remap(obj, 'mozAutoGainControl', 'autoGainControl');
                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
                return obj;
              };
            }

            if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
              var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;

              MediaStreamTrack.prototype.applyConstraints = function (c) {
                if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                  c = JSON.parse(JSON.stringify(c));
                  remap(c, 'autoGainControl', 'mozAutoGainControl');
                  remap(c, 'noiseSuppression', 'mozNoiseSuppression');
                }

                return nativeApplyConstraints.apply(this, [c]);
              };
            }
          }
        }
      }, {
        "../utils": 11
      }],
      10: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
        exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
        exports.shimCallbacksAPI = shimCallbacksAPI;
        exports.shimGetUserMedia = shimGetUserMedia;
        exports.shimConstraints = shimConstraints;
        exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
        exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
        exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function shimLocalStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
              if (!this._localStreams) {
                this._localStreams = [];
              }

              return this._localStreams;
            };
          }

          if (!('addStream' in window.RTCPeerConnection.prototype)) {
            var _addTrack = window.RTCPeerConnection.prototype.addTrack;

            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              var _this = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }

              if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              } // Try to emulate Chrome's behaviour of adding in audio-video order.
              // Safari orders by track id.


              stream.getAudioTracks().forEach(function (track) {
                return _addTrack.call(_this, track, stream);
              });
              stream.getVideoTracks().forEach(function (track) {
                return _addTrack.call(_this, track, stream);
              });
            };

            window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
              var stream = arguments[1];

              if (stream) {
                if (!this._localStreams) {
                  this._localStreams = [stream];
                } else if (!this._localStreams.includes(stream)) {
                  this._localStreams.push(stream);
                }
              }

              return _addTrack.apply(this, arguments);
            };
          }

          if (!('removeStream' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              var _this2 = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }

              var index = this._localStreams.indexOf(stream);

              if (index === -1) {
                return;
              }

              this._localStreams.splice(index, 1);

              var tracks = stream.getTracks();
              this.getSenders().forEach(function (sender) {
                if (tracks.includes(sender.track)) {
                  _this2.removeTrack(sender);
                }
              });
            };
          }
        }

        function shimRemoteStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
              return this._remoteStreams ? this._remoteStreams : [];
            };
          }

          if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
              get: function get() {
                return this._onaddstream;
              },
              set: function set(f) {
                var _this3 = this;

                if (this._onaddstream) {
                  this.removeEventListener('addstream', this._onaddstream);
                  this.removeEventListener('track', this._onaddstreampoly);
                }

                this.addEventListener('addstream', this._onaddstream = f);
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach(function (stream) {
                    if (!_this3._remoteStreams) {
                      _this3._remoteStreams = [];
                    }

                    if (_this3._remoteStreams.includes(stream)) {
                      return;
                    }

                    _this3._remoteStreams.push(stream);

                    var event = new Event('addstream');
                    event.stream = stream;

                    _this3.dispatchEvent(event);
                  });
                });
              }
            });
            var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              var pc = this;

              if (!this._onaddstreampoly) {
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach(function (stream) {
                    if (!pc._remoteStreams) {
                      pc._remoteStreams = [];
                    }

                    if (pc._remoteStreams.indexOf(stream) >= 0) {
                      return;
                    }

                    pc._remoteStreams.push(stream);

                    var event = new Event('addstream');
                    event.stream = stream;
                    pc.dispatchEvent(event);
                  });
                });
              }

              return origSetRemoteDescription.apply(pc, arguments);
            };
          }
        }

        function shimCallbacksAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          var prototype = window.RTCPeerConnection.prototype;
          var origCreateOffer = prototype.createOffer;
          var origCreateAnswer = prototype.createAnswer;
          var setLocalDescription = prototype.setLocalDescription;
          var setRemoteDescription = prototype.setRemoteDescription;
          var addIceCandidate = prototype.addIceCandidate;

          prototype.createOffer = function createOffer(successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = origCreateOffer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = origCreateAnswer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          var withCallback = function withCallback(description, successCallback, failureCallback) {
            var promise = setLocalDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setLocalDescription = withCallback;

          withCallback = function withCallback(description, successCallback, failureCallback) {
            var promise = setRemoteDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setRemoteDescription = withCallback;

          withCallback = function withCallback(candidate, successCallback, failureCallback) {
            var promise = addIceCandidate.apply(this, [candidate]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.addIceCandidate = withCallback;
        }

        function shimGetUserMedia(window) {
          var navigator = window && window.navigator;

          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // shim not needed in Safari 12.1
            var mediaDevices = navigator.mediaDevices;

            var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);

            navigator.mediaDevices.getUserMedia = function (constraints) {
              return _getUserMedia(shimConstraints(constraints));
            };
          }

          if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
              navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
            }.bind(navigator);
          }
        }

        function shimConstraints(constraints) {
          if (constraints && constraints.video !== undefined) {
            return Object.assign({}, constraints, {
              video: utils.compactObject(constraints.video)
            });
          }

          return constraints;
        }

        function shimRTCIceServerUrls(window) {
          // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
          var OrigPeerConnection = window.RTCPeerConnection;

          window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
            if (pcConfig && pcConfig.iceServers) {
              var newIceServers = [];

              for (var i = 0; i < pcConfig.iceServers.length; i++) {
                var server = pcConfig.iceServers[i];

                if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                  utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                  server = JSON.parse(JSON.stringify(server));
                  server.urls = server.url;
                  delete server.url;
                  newIceServers.push(server);
                } else {
                  newIceServers.push(pcConfig.iceServers[i]);
                }
              }

              pcConfig.iceServers = newIceServers;
            }

            return new OrigPeerConnection(pcConfig, pcConstraints);
          };

          window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

          if ('generateCertificate' in window.RTCPeerConnection) {
            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get: function get() {
                return OrigPeerConnection.generateCertificate;
              }
            });
          }
        }

        function shimTrackEventTransceiver(window) {
          // Add event.transceiver member over deprecated event.receiver
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        }

        function shimCreateOfferLegacy(window) {
          var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

          window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
            if (offerOptions) {
              if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
              }

              var audioTransceiver = this.getTransceivers().find(function (transceiver) {
                return transceiver.receiver.track.kind === 'audio';
              });

              if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                if (audioTransceiver.direction === 'sendrecv') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('sendonly');
                  } else {
                    audioTransceiver.direction = 'sendonly';
                  }
                } else if (audioTransceiver.direction === 'recvonly') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('inactive');
                  } else {
                    audioTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
                this.addTransceiver('audio');
              }

              if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
              }

              var videoTransceiver = this.getTransceivers().find(function (transceiver) {
                return transceiver.receiver.track.kind === 'video';
              });

              if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                if (videoTransceiver.direction === 'sendrecv') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('sendonly');
                  } else {
                    videoTransceiver.direction = 'sendonly';
                  }
                } else if (videoTransceiver.direction === 'recvonly') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('inactive');
                  } else {
                    videoTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
                this.addTransceiver('video');
              }
            }

            return origCreateOffer.apply(this, arguments);
          };
        }
      }, {
        "../utils": 11
      }],
      11: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.extractVersion = extractVersion;
        exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
        exports.disableLog = disableLog;
        exports.disableWarnings = disableWarnings;
        exports.log = log;
        exports.deprecated = deprecated;
        exports.detectBrowser = detectBrowser;
        exports.compactObject = compactObject;
        exports.walkStats = walkStats;
        exports.filterStats = filterStats;

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        var logDisabled_ = true;
        var deprecationWarnings_ = true;
        /**
         * Extract browser version out of the provided user agent string.
         *
         * @param {!string} uastring userAgent string.
         * @param {!string} expr Regular expression used as match criteria.
         * @param {!number} pos position in the version string to be returned.
         * @return {!number} browser version.
         */

        function extractVersion(uastring, expr, pos) {
          var match = uastring.match(expr);
          return match && match.length >= pos && parseInt(match[pos], 10);
        } // Wraps the peerconnection event eventNameToWrap in a function
        // which returns the modified event object (or false to prevent
        // the event).


        function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var proto = window.RTCPeerConnection.prototype;
          var nativeAddEventListener = proto.addEventListener;

          proto.addEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap) {
              return nativeAddEventListener.apply(this, arguments);
            }

            var wrappedCallback = function wrappedCallback(e) {
              var modifiedEvent = wrapper(e);

              if (modifiedEvent) {
                cb(modifiedEvent);
              }
            };

            this._eventMap = this._eventMap || {};
            this._eventMap[cb] = wrappedCallback;
            return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
          };

          var nativeRemoveEventListener = proto.removeEventListener;

          proto.removeEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
              return nativeRemoveEventListener.apply(this, arguments);
            }

            var unwrappedCb = this._eventMap[cb];
            delete this._eventMap[cb];
            return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
          };

          Object.defineProperty(proto, 'on' + eventNameToWrap, {
            get: function get() {
              return this['_on' + eventNameToWrap];
            },
            set: function set(cb) {
              if (this['_on' + eventNameToWrap]) {
                this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
                delete this['_on' + eventNameToWrap];
              }

              if (cb) {
                this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
              }
            },
            enumerable: true,
            configurable: true
          });
        }

        function disableLog(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
          }

          logDisabled_ = bool;
          return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
        }
        /**
         * Disable or enable deprecation warnings
         * @param {!boolean} bool set to true to disable warnings.
         */


        function disableWarnings(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
          }

          deprecationWarnings_ = !bool;
          return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
        }

        function log() {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
            if (logDisabled_) {
              return;
            }

            if (typeof console !== 'undefined' && typeof console.log === 'function') {
              console.log.apply(console, arguments);
            }
          }
        }
        /**
         * Shows a deprecation warning suggesting the modern and spec-compatible API.
         */


        function deprecated(oldMethod, newMethod) {
          if (!deprecationWarnings_) {
            return;
          }

          console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
        }
        /**
         * Browser detector.
         *
         * @return {object} result containing browser and version
         *     properties.
         */


        function detectBrowser(window) {
          var navigator = window.navigator; // Returned result object.

          var result = {
            browser: null,
            version: null
          }; // Fail early if it's not a browser

          if (typeof window === 'undefined' || !window.navigator) {
            result.browser = 'Not a browser.';
            return result;
          }

          if (navigator.mozGetUserMedia) {
            // Firefox.
            result.browser = 'firefox';
            result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
          } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
            // Chrome, Chromium, Webview, Opera.
            // Version matches Chrome/WebRTC version.
            // Chrome 74 removed webkitGetUserMedia on http as well so we need the
            // more complicated fallback to webkitRTCPeerConnection.
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
            // Edge.
            result.browser = 'edge';
            result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
          } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
            // Safari.
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
            result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
          } else {
            // Default fallthrough: not supported.
            result.browser = 'Not a supported browser.';
            return result;
          }

          return result;
        }
        /**
         * Checks if something is an object.
         *
         * @param {*} val The something you want to check.
         * @return true if val is an object, false otherwise.
         */


        function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        }
        /**
         * Remove all empty objects and undefined values
         * from a nested object -- an enhanced and vanilla version
         * of Lodash's `compact`.
         */


        function compactObject(data) {
          if (!isObject(data)) {
            return data;
          }

          return Object.keys(data).reduce(function (accumulator, key) {
            var isObj = isObject(data[key]);
            var value = isObj ? compactObject(data[key]) : data[key];
            var isEmptyObject = isObj && !Object.keys(value).length;

            if (value === undefined || isEmptyObject) {
              return accumulator;
            }

            return Object.assign(accumulator, _defineProperty({}, key, value));
          }, {});
        }
        /* iterates the stats graph recursively. */


        function walkStats(stats, base, resultSet) {
          if (!base || resultSet.has(base.id)) {
            return;
          }

          resultSet.set(base.id, base);
          Object.keys(base).forEach(function (name) {
            if (name.endsWith('Id')) {
              walkStats(stats, stats.get(base[name]), resultSet);
            } else if (name.endsWith('Ids')) {
              base[name].forEach(function (id) {
                walkStats(stats, stats.get(id), resultSet);
              });
            }
          });
        }
        /* filter getStats for a sender/receiver track. */


        function filterStats(result, track, outbound) {
          var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
          var filteredResult = new Map();

          if (track === null) {
            return filteredResult;
          }

          var trackStats = [];
          result.forEach(function (value) {
            if (value.type === 'track' && value.trackIdentifier === track.id) {
              trackStats.push(value);
            }
          });
          trackStats.forEach(function (trackStat) {
            result.forEach(function (stats) {
              if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
                walkStats(result, stats, filteredResult);
              }
            });
          });
          return filteredResult;
        }
      }, {}],
      12: [function (require, module, exports) {}, {}],
      13: [function (require, module, exports) {
        /* eslint-env node */
        'use strict'; // SDP helpers.

        var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.
        // TODO: use UUIDs instead? https://gist.github.com/jed/982883

        SDPUtils.generateIdentifier = function () {
          return Math.random().toString(36).substr(2, 10);
        }; // The RTCP CNAME used by all peerconnections from the same JS.


        SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.

        SDPUtils.splitLines = function (blob) {
          return blob.trim().split('\n').map(function (line) {
            return line.trim();
          });
        }; // Splits SDP into sessionpart and mediasections. Ensures CRLF.


        SDPUtils.splitSections = function (blob) {
          var parts = blob.split('\nm=');
          return parts.map(function (part, index) {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
          });
        }; // returns the session description.


        SDPUtils.getDescription = function (blob) {
          var sections = SDPUtils.splitSections(blob);
          return sections && sections[0];
        }; // returns the individual media sections.


        SDPUtils.getMediaSections = function (blob) {
          var sections = SDPUtils.splitSections(blob);
          sections.shift();
          return sections;
        }; // Returns lines that start with a certain prefix.


        SDPUtils.matchPrefix = function (blob, prefix) {
          return SDPUtils.splitLines(blob).filter(function (line) {
            return line.indexOf(prefix) === 0;
          });
        }; // Parses an ICE candidate line. Sample input:
        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
        // rport 55996"


        SDPUtils.parseCandidate = function (line) {
          var parts; // Parse both variants.

          if (line.indexOf('a=candidate:') === 0) {
            parts = line.substring(12).split(' ');
          } else {
            parts = line.substring(10).split(' ');
          }

          var candidate = {
            foundation: parts[0],
            component: parseInt(parts[1], 10),
            protocol: parts[2].toLowerCase(),
            priority: parseInt(parts[3], 10),
            ip: parts[4],
            address: parts[4],
            // address is an alias for ip.
            port: parseInt(parts[5], 10),
            // skip parts[6] == 'typ'
            type: parts[7]
          };

          for (var i = 8; i < parts.length; i += 2) {
            switch (parts[i]) {
              case 'raddr':
                candidate.relatedAddress = parts[i + 1];
                break;

              case 'rport':
                candidate.relatedPort = parseInt(parts[i + 1], 10);
                break;

              case 'tcptype':
                candidate.tcpType = parts[i + 1];
                break;

              case 'ufrag':
                candidate.ufrag = parts[i + 1]; // for backward compability.

                candidate.usernameFragment = parts[i + 1];
                break;

              default:
                // extension handling, in particular ufrag
                candidate[parts[i]] = parts[i + 1];
                break;
            }
          }

          return candidate;
        }; // Translates a candidate object into SDP candidate attribute.


        SDPUtils.writeCandidate = function (candidate) {
          var sdp = [];
          sdp.push(candidate.foundation);
          sdp.push(candidate.component);
          sdp.push(candidate.protocol.toUpperCase());
          sdp.push(candidate.priority);
          sdp.push(candidate.address || candidate.ip);
          sdp.push(candidate.port);
          var type = candidate.type;
          sdp.push('typ');
          sdp.push(type);

          if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
            sdp.push('raddr');
            sdp.push(candidate.relatedAddress);
            sdp.push('rport');
            sdp.push(candidate.relatedPort);
          }

          if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
            sdp.push('tcptype');
            sdp.push(candidate.tcpType);
          }

          if (candidate.usernameFragment || candidate.ufrag) {
            sdp.push('ufrag');
            sdp.push(candidate.usernameFragment || candidate.ufrag);
          }

          return 'candidate:' + sdp.join(' ');
        }; // Parses an ice-options line, returns an array of option tags.
        // a=ice-options:foo bar


        SDPUtils.parseIceOptions = function (line) {
          return line.substr(14).split(' ');
        }; // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
        // a=rtpmap:111 opus/48000/2


        SDPUtils.parseRtpMap = function (line) {
          var parts = line.substr(9).split(' ');
          var parsed = {
            payloadType: parseInt(parts.shift(), 10) // was: id

          };
          parts = parts[0].split('/');
          parsed.name = parts[0];
          parsed.clockRate = parseInt(parts[1], 10); // was: clockrate

          parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // legacy alias, got renamed back to channels in ORTC.

          parsed.numChannels = parsed.channels;
          return parsed;
        }; // Generate an a=rtpmap line from RTCRtpCodecCapability or
        // RTCRtpCodecParameters.


        SDPUtils.writeRtpMap = function (codec) {
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          var channels = codec.channels || codec.numChannels || 1;
          return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
        }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset


        SDPUtils.parseExtmap = function (line) {
          var parts = line.substr(9).split(' ');
          return {
            id: parseInt(parts[0], 10),
            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
            uri: parts[1]
          };
        }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
        // RTCRtpHeaderExtension.


        SDPUtils.writeExtmap = function (headerExtension) {
          return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
        }; // Parses an ftmp line, returns dictionary. Sample input:
        // a=fmtp:96 vbr=on;cng=on
        // Also deals with vbr=on; cng=on


        SDPUtils.parseFmtp = function (line) {
          var parsed = {};
          var kv;
          var parts = line.substr(line.indexOf(' ') + 1).split(';');

          for (var j = 0; j < parts.length; j++) {
            kv = parts[j].trim().split('=');
            parsed[kv[0].trim()] = kv[1];
          }

          return parsed;
        }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.


        SDPUtils.writeFmtp = function (codec) {
          var line = '';
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          if (codec.parameters && Object.keys(codec.parameters).length) {
            var params = [];
            Object.keys(codec.parameters).forEach(function (param) {
              if (codec.parameters[param]) {
                params.push(param + '=' + codec.parameters[param]);
              } else {
                params.push(param);
              }
            });
            line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
          }

          return line;
        }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
        // a=rtcp-fb:98 nack rpsi


        SDPUtils.parseRtcpFb = function (line) {
          var parts = line.substr(line.indexOf(' ') + 1).split(' ');
          return {
            type: parts.shift(),
            parameter: parts.join(' ')
          };
        }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.


        SDPUtils.writeRtcpFb = function (codec) {
          var lines = '';
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
            // FIXME: special handling for trr-int?
            codec.rtcpFeedback.forEach(function (fb) {
              lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
            });
          }

          return lines;
        }; // Parses an RFC 5576 ssrc media attribute. Sample input:
        // a=ssrc:3735928559 cname:something


        SDPUtils.parseSsrcMedia = function (line) {
          var sp = line.indexOf(' ');
          var parts = {
            ssrc: parseInt(line.substr(7, sp - 7), 10)
          };
          var colon = line.indexOf(':', sp);

          if (colon > -1) {
            parts.attribute = line.substr(sp + 1, colon - sp - 1);
            parts.value = line.substr(colon + 1);
          } else {
            parts.attribute = line.substr(sp + 1);
          }

          return parts;
        };

        SDPUtils.parseSsrcGroup = function (line) {
          var parts = line.substr(13).split(' ');
          return {
            semantics: parts.shift(),
            ssrcs: parts.map(function (ssrc) {
              return parseInt(ssrc, 10);
            })
          };
        }; // Extracts the MID (RFC 5888) from a media section.
        // returns the MID or undefined if no mid line was found.


        SDPUtils.getMid = function (mediaSection) {
          var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];

          if (mid) {
            return mid.substr(6);
          }
        };

        SDPUtils.parseFingerprint = function (line) {
          var parts = line.substr(14).split(' ');
          return {
            algorithm: parts[0].toLowerCase(),
            // algorithm is case-sensitive in Edge.
            value: parts[1]
          };
        }; // Extracts DTLS parameters from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the fingerprint line as input. See also getIceParameters.


        SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
          var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role.
          // Note2: 'algorithm' is not case sensitive except in Edge.

          return {
            role: 'auto',
            fingerprints: lines.map(SDPUtils.parseFingerprint)
          };
        }; // Serializes DTLS parameters to SDP.


        SDPUtils.writeDtlsParameters = function (params, setupType) {
          var sdp = 'a=setup:' + setupType + '\r\n';
          params.fingerprints.forEach(function (fp) {
            sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
          });
          return sdp;
        }; // Parses ICE information from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the ice-ufrag and ice-pwd lines as input.


        SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
          var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too.

          lines = lines.concat(SDPUtils.splitLines(sessionpart));
          var iceParameters = {
            usernameFragment: lines.filter(function (line) {
              return line.indexOf('a=ice-ufrag:') === 0;
            })[0].substr(12),
            password: lines.filter(function (line) {
              return line.indexOf('a=ice-pwd:') === 0;
            })[0].substr(10)
          };
          return iceParameters;
        }; // Serializes ICE parameters to SDP.


        SDPUtils.writeIceParameters = function (params) {
          return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
        }; // Parses the SDP media section and returns RTCRtpParameters.


        SDPUtils.parseRtpParameters = function (mediaSection) {
          var description = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
            rtcp: []
          };
          var lines = SDPUtils.splitLines(mediaSection);
          var mline = lines[0].split(' ');

          for (var i = 3; i < mline.length; i++) {
            // find all codecs from mline[3..]
            var pt = mline[i];
            var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];

            if (rtpmapline) {
              var codec = SDPUtils.parseRtpMap(rtpmapline);
              var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.

              codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
              codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
              description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.

              switch (codec.name.toUpperCase()) {
                case 'RED':
                case 'ULPFEC':
                  description.fecMechanisms.push(codec.name.toUpperCase());
                  break;

                default:
                  // only RED and ULPFEC are recognized as FEC mechanisms.
                  break;
              }
            }
          }

          SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
            description.headerExtensions.push(SDPUtils.parseExtmap(line));
          }); // FIXME: parse rtcp.

          return description;
        }; // Generates parts of the SDP media section describing the capabilities /
        // parameters.


        SDPUtils.writeRtpDescription = function (kind, caps) {
          var sdp = ''; // Build the mline.

          sdp += 'm=' + kind + ' ';
          sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.

          sdp += ' UDP/TLS/RTP/SAVPF ';
          sdp += caps.codecs.map(function (codec) {
            if (codec.preferredPayloadType !== undefined) {
              return codec.preferredPayloadType;
            }

            return codec.payloadType;
          }).join(' ') + '\r\n';
          sdp += 'c=IN IP4 0.0.0.0\r\n';
          sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.

          caps.codecs.forEach(function (codec) {
            sdp += SDPUtils.writeRtpMap(codec);
            sdp += SDPUtils.writeFmtp(codec);
            sdp += SDPUtils.writeRtcpFb(codec);
          });
          var maxptime = 0;
          caps.codecs.forEach(function (codec) {
            if (codec.maxptime > maxptime) {
              maxptime = codec.maxptime;
            }
          });

          if (maxptime > 0) {
            sdp += 'a=maxptime:' + maxptime + '\r\n';
          }

          sdp += 'a=rtcp-mux\r\n';

          if (caps.headerExtensions) {
            caps.headerExtensions.forEach(function (extension) {
              sdp += SDPUtils.writeExtmap(extension);
            });
          } // FIXME: write fecMechanisms.


          return sdp;
        }; // Parses the SDP media section and returns an array of
        // RTCRtpEncodingParameters.


        SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
          var encodingParameters = [];
          var description = SDPUtils.parseRtpParameters(mediaSection);
          var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
          var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid

          var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (parts) {
            return parts.attribute === 'cname';
          });
          var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
          var secondarySsrc;
          var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {
            var parts = line.substr(17).split(' ');
            return parts.map(function (part) {
              return parseInt(part, 10);
            });
          });

          if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
            secondarySsrc = flows[0][1];
          }

          description.codecs.forEach(function (codec) {
            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
              var encParam = {
                ssrc: primarySsrc,
                codecPayloadType: parseInt(codec.parameters.apt, 10)
              };

              if (primarySsrc && secondarySsrc) {
                encParam.rtx = {
                  ssrc: secondarySsrc
                };
              }

              encodingParameters.push(encParam);

              if (hasRed) {
                encParam = JSON.parse(JSON.stringify(encParam));
                encParam.fec = {
                  ssrc: primarySsrc,
                  mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
                };
                encodingParameters.push(encParam);
              }
            }
          });

          if (encodingParameters.length === 0 && primarySsrc) {
            encodingParameters.push({
              ssrc: primarySsrc
            });
          } // we support both b=AS and b=TIAS but interpret AS as TIAS.


          var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');

          if (bandwidth.length) {
            if (bandwidth[0].indexOf('b=TIAS:') === 0) {
              bandwidth = parseInt(bandwidth[0].substr(7), 10);
            } else if (bandwidth[0].indexOf('b=AS:') === 0) {
              // use formula from JSEP to convert b=AS to TIAS value.
              bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
            } else {
              bandwidth = undefined;
            }

            encodingParameters.forEach(function (params) {
              params.maxBitrate = bandwidth;
            });
          }

          return encodingParameters;
        }; // parses http://draft.ortc.org/#rtcrtcpparameters*


        SDPUtils.parseRtcpParameters = function (mediaSection) {
          var rtcpParameters = {}; // Gets the first SSRC. Note tha with RTX there might be multiple
          // SSRCs.

          var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (obj) {
            return obj.attribute === 'cname';
          })[0];

          if (remoteSsrc) {
            rtcpParameters.cname = remoteSsrc.value;
            rtcpParameters.ssrc = remoteSsrc.ssrc;
          } // Edge uses the compound attribute instead of reducedSize
          // compound is !reducedSize


          var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
          rtcpParameters.reducedSize = rsize.length > 0;
          rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute.
          // Note that Edge does not support unmuxed RTCP.

          var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
          rtcpParameters.mux = mux.length > 0;
          return rtcpParameters;
        }; // parses either a=msid: or a=ssrc:... msid lines and returns
        // the id of the MediaStream and MediaStreamTrack.


        SDPUtils.parseMsid = function (mediaSection) {
          var parts;
          var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');

          if (spec.length === 1) {
            parts = spec[0].substr(7).split(' ');
            return {
              stream: parts[0],
              track: parts[1]
            };
          }

          var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (msidParts) {
            return msidParts.attribute === 'msid';
          });

          if (planB.length > 0) {
            parts = planB[0].value.split(' ');
            return {
              stream: parts[0],
              track: parts[1]
            };
          }
        }; // SCTP
        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
        // to draft-ietf-mmusic-sctp-sdp-05


        SDPUtils.parseSctpDescription = function (mediaSection) {
          var mline = SDPUtils.parseMLine(mediaSection);
          var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
          var maxMessageSize;

          if (maxSizeLine.length > 0) {
            maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
          }

          if (isNaN(maxMessageSize)) {
            maxMessageSize = 65536;
          }

          var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');

          if (sctpPort.length > 0) {
            return {
              port: parseInt(sctpPort[0].substr(12), 10),
              protocol: mline.fmt,
              maxMessageSize: maxMessageSize
            };
          }

          var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');

          if (sctpMapLines.length > 0) {
            var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0].substr(10).split(' ');
            return {
              port: parseInt(parts[0], 10),
              protocol: parts[1],
              maxMessageSize: maxMessageSize
            };
          }
        }; // SCTP
        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
        // support by now receiving in this format, unless we originally parsed
        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
        // protocol of DTLS/SCTP -- without UDP/ or TCP/)


        SDPUtils.writeSctpDescription = function (media, sctp) {
          var output = [];

          if (media.protocol !== 'DTLS/SCTP') {
            output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctp-port:' + sctp.port + '\r\n'];
          } else {
            output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'];
          }

          if (sctp.maxMessageSize !== undefined) {
            output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
          }

          return output.join('');
        }; // Generate a session ID for SDP.
        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
        // recommends using a cryptographically random +ve 64-bit value
        // but right now this should be acceptable and within the right range


        SDPUtils.generateSessionId = function () {
          return Math.random().toString().substr(2, 21);
        }; // Write boilder plate for start of SDP
        // sessId argument is optional - if not supplied it will
        // be generated randomly
        // sessVersion is optional and defaults to 2
        // sessUser is optional and defaults to 'thisisadapterortc'


        SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
          var sessionId;
          var version = sessVer !== undefined ? sessVer : 2;

          if (sessId) {
            sessionId = sessId;
          } else {
            sessionId = SDPUtils.generateSessionId();
          }

          var user = sessUser || 'thisisadapterortc'; // FIXME: sess-id should be an NTP timestamp.

          return 'v=0\r\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
        };

        SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
          var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP.

          sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP.

          sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');
          sdp += 'a=mid:' + transceiver.mid + '\r\n';

          if (transceiver.direction) {
            sdp += 'a=' + transceiver.direction + '\r\n';
          } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
            sdp += 'a=sendrecv\r\n';
          } else if (transceiver.rtpSender) {
            sdp += 'a=sendonly\r\n';
          } else if (transceiver.rtpReceiver) {
            sdp += 'a=recvonly\r\n';
          } else {
            sdp += 'a=inactive\r\n';
          }

          if (transceiver.rtpSender) {
            // spec.
            var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
            sdp += 'a=' + msid; // for Chrome.

            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

            if (transceiver.sendEncodingParameters[0].rtx) {
              sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
              sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
            }
          } // FIXME: this should be written by writeRtpDescription.


          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';

          if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
          }

          return sdp;
        }; // Gets the direction from the mediaSection or the sessionpart.


        SDPUtils.getDirection = function (mediaSection, sessionpart) {
          // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
          var lines = SDPUtils.splitLines(mediaSection);

          for (var i = 0; i < lines.length; i++) {
            switch (lines[i]) {
              case 'a=sendrecv':
              case 'a=sendonly':
              case 'a=recvonly':
              case 'a=inactive':
                return lines[i].substr(2);

              default: // FIXME: What should happen here?

            }
          }

          if (sessionpart) {
            return SDPUtils.getDirection(sessionpart);
          }

          return 'sendrecv';
        };

        SDPUtils.getKind = function (mediaSection) {
          var lines = SDPUtils.splitLines(mediaSection);
          var mline = lines[0].split(' ');
          return mline[0].substr(2);
        };

        SDPUtils.isRejected = function (mediaSection) {
          return mediaSection.split(' ', 2)[1] === '0';
        };

        SDPUtils.parseMLine = function (mediaSection) {
          var lines = SDPUtils.splitLines(mediaSection);
          var parts = lines[0].substr(2).split(' ');
          return {
            kind: parts[0],
            port: parseInt(parts[1], 10),
            protocol: parts[2],
            fmt: parts.slice(3).join(' ')
          };
        };

        SDPUtils.parseOLine = function (mediaSection) {
          var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
          var parts = line.substr(2).split(' ');
          return {
            username: parts[0],
            sessionId: parts[1],
            sessionVersion: parseInt(parts[2], 10),
            netType: parts[3],
            addressType: parts[4],
            address: parts[5]
          };
        }; // a very naive interpretation of a valid SDP.


        SDPUtils.isValidSDP = function (blob) {
          if (typeof blob !== 'string' || blob.length === 0) {
            return false;
          }

          var lines = SDPUtils.splitLines(blob);

          for (var i = 0; i < lines.length; i++) {
            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
              return false;
            } // TODO: check the modifier a bit more.

          }

          return true;
        }; // Expose public methods.


        if (_typeof2(module) === 'object') {
          module.exports = SDPUtils;
        }
      }, {}]
    }, {}, [1])(1);
  });
});

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MZXRzZWUvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0xldHNlZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9MZXRzZWUvLi9Db250ZXh0LmpzIiwid2VicGFjazovL0xldHNlZS8uL1NjcmVlbi5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9VdGlsLmpzIiwid2VicGFjazovL0xldHNlZS8uL2NvcmUvQ2FtZXJhLmpzIiwid2VicGFjazovL0xldHNlZS8uL2NvcmUvRGF0YS5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9jb3JlL09iamVjdDNELmpzIiwid2VicGFjazovL0xldHNlZS8uL2NvcmUvUGVyc3BlY3RpdmVDYW1lcmEuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vY29yZS9TY2VuZS5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9jb3JlL1RyYWNrYWJsZU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vZW5naW5lLmpzIiwid2VicGFjazovL0xldHNlZS8uL2VudGl0eS9FbnRpdHkuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vZW50aXR5L0VudGl0eUV2ZW50LmpzIiwid2VicGFjazovL0xldHNlZS8uL2VudGl0eS9FbnRpdHlFdmVudFR5cGUuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vZXh0ZXJuYWwvVEhSRUUuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbGlicy9BUjNEUmVuZGVyTW9kdWxlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL0NTU1BhcnNlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL0VudGl0eVBhcnNlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL0V2ZW50TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL01lc3NhZ2VUeXBlcy5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL09iamVjdFRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbGlicy9WaWRlb01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbWF0aC9FdWxlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9tYXRoL01hdGguanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbWF0aC9NYXRyaXgzLmpzIiwid2VicGFjazovL0xldHNlZS8uL21hdGgvTWF0cml4NC5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9tYXRoL1F1YXRlcm5pb24uanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbWF0aC9WZWN0b3IyLmpzIiwid2VicGFjazovL0xldHNlZS8uL21hdGgvVmVjdG9yMy5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9vYnNlcnZlcnMvT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vb2JzZXJ2ZXJzL29ic2VydmVyL0VudGl0eU9ic2VydmVyLmpzIiwid2VicGFjazovL0xldHNlZS8uL29ic2VydmVycy9vYnNlcnZlci9MZXRzZWVPYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9yZW5kZXJlci9ET01SZW5kZXJhYmxlLmpzIiwid2VicGFjazovL0xldHNlZS8uL3JlbmRlcmVyL0RPTVJlbmRlcmVyLmpzIiwid2VicGFjazovL0xldHNlZS8uL3ZlbmRvci9hZGFwdGVyX25vX2VkZ2UuanMiXSwibmFtZXMiOlsiX29zIiwiX3dpZHRoIiwiX2hlaWdodCIsIl9vcmllbnRhdGlvbiIsIl9pc1BvcnRyYWl0IiwiQm9keUlkIiwiRG9tUmVuZGVyZXJJZCIsIlZpZGVvQ29udGFpbmVySWQiLCJQbGFjZWhvbGRlcklkIiwiQ29udGV4dCIsImNvbmZpZyIsIndpZHRoIiwiaGVpZ2h0Iiwib3JpZW50YXRpb24iLCJ2YWx1ZSIsImNvbnRleHQiLCJTY3JlZW4iLCJfdmlkZW9NYW5hZ2VyIiwidmlkZW9NYW5hZ2VyIiwiY29uc29sZSIsImxvZyIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImNhbnZhc0VsZW1lbnQiLCJzY3JlZW5JbmZvIiwiX2FyUmVuZGVyZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0RnVsbHNjcmVlbiIsInRoZW4iLCJlIiwiZXJyIiwibWVzc2FnZSIsIm5hbWUiLCJtb3pSZXF1ZXN0RnVsbFNjcmVlbiIsIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIiwibXNSZXF1ZXN0RnVsbHNjcmVlbiIsImV4aXRGdWxsc2NyZWVuIiwiZml0V2lkdGhBbmRIZWlnaHQiLCJtb3pDYW5jZWxGdWxsU2NyZWVuIiwid2Via2l0RXhpdEZ1bGxzY3JlZW4iLCJtc0V4aXRGdWxsc2NyZWVuIiwic3R5bGUiLCJjcmVhdGVFbGVtZW50IiwibGV0c2VlV3JhcHBlciIsImxldHNlZUxvYWRlciIsImxldHNlZVN0YXR1cyIsImRlZmF1bHRMb2FkZXJDb250ZW50IiwibGV0c2VlU3R5bGUiLCJzdGF0dXNIdG1sIiwidHlwZSIsIl9odG1sIiwibG9jYXRpb24iLCJocmVmIiwic3RhdHVzQ3NzIiwiX2NzcyIsImNyZWF0ZUxldHNlZVdyYXBwZXIiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kIiwiZm9yRWFjaCIsInZhbCIsImluZGV4Iiwic2hlZXQiLCJpbnNlcnRSdWxlIiwiaWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJhcHBlbmRDaGlsZCIsImJvZHkiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiY3JlYXRlTG9hZGVyIiwiaW5uZXJIVE1MIiwiY3JlYXRlU3RhdHVzU2NyZWVuIiwicmVtb3ZlIiwiTWVzc2FnZSIsIkxFVFNFRV9DU1MiLCJMRVRTRUVfTE9BRElORyIsIkxFVFNFRV9TVEFUVVMiLCJhZGRWaWV3cG9ydCIsInZpZXdQb3J0VGFnIiwiY29udGVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibG9hZEltYWdlIiwicGF0aCIsImltZyIsIkltYWdlIiwic3JjIiwiY3Jvc3NPcmlnaW4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9ubG9hZCIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsIlVVSUQiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJmbG9vciIsInRvU3RyaW5nIiwiaXNXZWJSVENTdXBwb3J0ZWQiLCJpdGVtIiwiaXNNb2JpbGUiLCJBbmRyb2lkIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwibWF0Y2giLCJCbGFja0JlcnJ5IiwiaU9TIiwiT3BlcmEiLCJXaW5kb3dzIiwiYW55IiwiZ2V0T3NOYW1lIiwib3NOYW1lIiwiZ2V0QnJvd3NlckluZm8iLCJpc01vYmlsZURldmljZSIsInRlc3QiLCJpc0VkZ2UiLCJpbmRleE9mIiwibXNTYXZlT3JPcGVuQmxvYiIsIm1zU2F2ZUJsb2IiLCJpc09wZXJhIiwib3BlcmEiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJpc0lFIiwiZG9jdW1lbnRNb2RlIiwiblZlciIsImFwcFZlcnNpb24iLCJuQWd0IiwiYnJvd3Nlck5hbWUiLCJhcHBOYW1lIiwiZnVsbFZlcnNpb24iLCJwYXJzZUZsb2F0IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJuYW1lT2Zmc2V0IiwidmVyT2Zmc2V0IiwiaXgiLCJzcGxpdCIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsInNlYXJjaCIsImlzTmFOIiwiaGFzV2JjYW0iLCJkZXZpY2VzIiwiaGFzV2ViY2FtIiwiZGV2aWNlTGlzdCIsImRldmljZSIsImtpbmQiLCJwdXNoIiwiZGV2aWNlSWQiLCJjaHVuayIsImFyciIsImNodW5rU2l6ZSIsImNhY2hlIiwidG1wIiwibGVuZ3RoIiwic3BsaWNlIiwicmVtb3ZlQXJyYXlJdGVtIiwiYXJyYXkiLCJlbGVtZW50IiwiaWR4IiwiaXNOdWxsIiwiaXNOaWwiLCJfdHlwZSIsIl9pc0NhbWVyYSIsIkNhbWVyYSIsInByb2plY3Rpb25NYXRyaXgiLCJNYXRyaXg0IiwicHJvamVjdGlvbk1hdHJpeEludmVyc2UiLCJtYXRyaXhXb3JsZEludmVyc2UiLCJ0YXJnZXQiLCJtIiwibG9va0F0IiwicG9zaXRpb24iLCJ1cCIsInF1YXRlcm5pb24iLCJzZXRGcm9tUm90YXRpb25NYXRyaXgiLCJWZWN0b3IzIiwiYXBwbHlRdWF0ZXJuaW9uIiwid29ybGRRdWF0ZXJuaW9uIiwiT2JqZWN0M0QiLCJFdmVudERhdGEiLCJNYXAiLCJFdmVudERhdGFPYmplY3QiLCJoYW5kbGVycyIsInNldCIsImdldCIsImV2ZW50TmFtZSIsImN1cnJlbnRUYXJnZXQiLCJldmVudEhhbmRsZXIiLCJFbnRpdHlEYXRhIiwiRW50aXR5RGF0YU9iamVjdCIsIm1hcCIsImVsZSIsIm9iamVjdElkIiwiX2lzT2JqZWN0M0QiLCJPQkpFQ1RfRVZFTlQiLCJPQkpFQ1RfQURERUQiLCJTZXQiLCJPQkpFQ1RfUkVNT1ZFRCIsIlF1YXRlcm5pb24iLCJzY2FsZSIsInZpc2libGUiLCJ0cmFjayIsInBhcmVudCIsImNoaWxkcmVuIiwibWF0cml4IiwibWF0cml4V29ybGQiLCJtYXRyaXhBdXRvVXBkYXRlIiwibWF0cml4V29ybGROZWVkc1VwZGF0ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwieCIsInkiLCJ6IiwieEF4aXMiLCJ5QXhpcyIsInpBeGlzIiwibXVsdGlwbHlTY2FsYXIiLCJhbmdsZSIsImF4aXMiLCJxIiwic2V0RnJvbUF4aXNBbmdsZSIsIm11bHRpcGx5Iiwicm90YXRpb24iLCJzZXRGcm9tUXVhdGVybmlvbiIsInZlY3RvciIsImFwcGx5TWF0cml4NCIsImdldEludmVyc2UiLCJvYmplY3QiLCJhcmd1bWVudHMiLCJpIiwiZXJyb3IiLCJpc09iamVjdDNEIiwibm90aWZ5IiwiY29tcG9zZSIsImZvcmNlIiwidXBkYXRlTWF0cml4IiwiY29weSIsIm11bHRpcGx5TWF0cmljZXMiLCJsIiwidXBkYXRlTWF0cml4V29ybGQiLCJ1cGRhdGVQYXJlbnRzIiwidXBkYXRlQ2hpbGRyZW4iLCJ1cGRhdGVXb3JsZE1hdHJpeCIsInZlY3RvcjMiLCJwcmVtdWx0aXBseSIsImRlY29tcG9zZSIsInJlY3Vyc2l2ZSIsInNvdXJjZSIsImNoaWxkIiwiY2xvbmUiLCJjYWxsYmFjayIsInRyYXZlcnNlIiwidHJhdmVyc2VWaXNpYmxlIiwidHJhdmVyc2VBbmNlc3RvcnMiLCJ0cmF2ZXJzZVJlbmRlcmFibGUiLCJhcmdzIiwiZXZlbnQiLCJzZXRGcm9tTWF0cml4UG9zaXRpb24iLCJFdWxlciIsImlzRXVsZXIiLCJzZXRGcm9tRXVsZXIiLCJpc1F1YXRlcm5pb24iLCJpc01hdHJpeDQiLCJzZXRGcm9tTWF0cml4Iiwid2FybiIsIm9yZGVyIiwicmVzdWx0IiwiT2JzZXJ2ZXIiLCJpc1BlcnNwZWN0aXZlQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJmb3YiLCJhc3BlY3QiLCJuZWFyIiwiZmFyIiwiem9vbSIsImZvY3VzIiwidmlldyIsImZpbG1HYXVnZSIsImZpbG1PZmZzZXQiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYXRhbiIsInRhbiIsInRvcCIsIkRFRzJSQUQiLCJsZWZ0IiwiZW5hYmxlZCIsImZ1bGxXaWR0aCIsImZ1bGxIZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInNrZXciLCJmaWxtV2lkdGgiLCJtYWtlUGVyc3BlY3RpdmUiLCJyb3RhdGlvbk1hdHJpeCIsIkxldHNlZUVuZ2luZSIsInJlbmRlcmVyIiwicmVuZGVyIiwiZm9jYWxMZW5ndGgiLCJ2RXh0ZW50U2xvcGUiLCJmaWxtSGVpZ2h0IiwibWluIiwibWF4IiwiX2lzU2NlbmUiLCJTY2VuZSIsIl9lbnRpdGllcyIsIlRyYWNrYWJsZU1hbmFnZXIiLCJlbnRpdHkiLCJFbnRpdHkiLCJfbmF0aXZlIiwibG9hZEVudGl0eSIsInVyaSIsInZhbHVlcyIsInBhcmFtIiwiaGFzRW50aXR5IiwicmVtb3ZlUmVuZGVyYWJsZXMiLCJzZXREYXRhIiwib2JqZWN0cyIsImN1cnJlbnRFbnRpdHkiLCJhZGRFbnRpdHkiLCJyZW5kZXJhYmxlcyIsInNlbGVjdG9yIiwidHJhbnNsYXRlIiwiZWxlbXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWxlbSIsInJlbmRlcmFibGUiLCJET01SZW5kZXJhYmxlIiwiYWRkUmVuZGVyYWJsZSIsInRyYWNrYWJsZU1hbmFnZXIiLCJfaW5zdGFuY2UiLCJFbmdpbmUiLCJfY29uZmlnIiwiY2FtZXJhIiwicHJvamVjdGlvblBhcmFtZXRlciIsInNldENvbmZpZyIsImRvbVJlbmRlcmVyIiwiaW5pdFJlbmRlcmVyIiwiZG9tUmVuZGVyZXJJZCIsInpJbmRleCIsInpJbmRleEluY3JlbWVudCIsIm9iamVjdFRyYWNrZXIiLCJ0aHJlZVJlbmRlcmVyIiwiZXh0ZXJuYWwiLCJMZXRzZWVUaHJlZSIsInNldERhdGFzIiwibWFyZ2luIiwicGFkZGluZyIsIm5ld0NvbmZpZyIsInVwZGF0ZU9yaWVudGF0aW9uIiwiZ2V0RW50aXR5IiwiZ2V0RW50aXRpZXMiLCJyZW1vdmVFbnRpdHkiLCJyZXNldEVsZW1lbnQiLCJhcHBlbmRFbGVtZW50IiwiYXBwZW5kQWxsRWxlbWVudHMiLCJFTlRJVFlfRVZFTlQiLCJUUkFDS19TVEFSVCIsIlRSQUNLX01PVkUiLCJUUkFDS19FTkQiLCJFcnJvciIsImltYWdlIiwic2l6ZSIsImRlcHRoIiwidW5pdCIsIl92aXNpYmxlIiwiX3RyYWNrIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ0cmFuc2xhdGVaIiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwib2JqIiwiZGlzcGxheSIsInV1aWQiLCJjYW1lcmFQb3NlIiwibG9vdEF0UmVuZGVyYWJsZXMiLCJFbnRpdHlFdmVudCIsInNldFNjYWxhciIsInBpeGVsU2l6ZSIsIkV2ZW50VHlwZSIsIl9yZW5kZXJlciIsIl9jYW1lcmEiLCJfc2NlbmUiLCJfYXV0b1JlbmRlciIsIl9jYW52YXMiLCJMRVRTRUVfVEhSRUUiLCJlbnRpdHlHcm91cCIsInJlbmRlclNjZW5lIiwic3RhdGUiLCJyZXNldCIsImdldFRocmVlR3JvdXAiLCJncm91cCIsIkdyb3VwIiwiX2FkZE9iamVjdFRvRW50aXR5IiwicmVtb3ZlT2JqZWN0RnJvbUVudGl0eSIsIm9uVHJhY2tTdGFydENhbGxiYWNrIiwib25UcmFja01vdmVDYWxsYmFjayIsIm9uVHJhY2tFbmRDYWxsYmFjayIsIm9uVHJhY2tNb3ZlIiwiaWRlbnRpdHkiLCJhcHBseU1hdHJpeCIsIm9uVHJhY2tTdGFydCIsIm9uVHJhY2tFbmQiLCJpbml0IiwiY2FtZXJhUGFyYW0iLCJUSFJFRSIsImNsYXNzTmFtZSIsIldlYkdMUmVuZGVyZXIiLCJhbHBoYSIsInNldFNpemUiLCJzY3JlZW5XaWR0aCIsInNjcmVlbkhlaWdodCIsInN1YnNjcmliZSIsIkVudGl0eU9ic2VydmVyIiwiX2xldHNlZUVuZ2luZUNvbmZpZyIsInJ1blR5cGUiLCJ2YWxpZGF0ZUNvbmZpZyIsImFwcEtleSIsIkFQUF9LRVkiLCJ0cmFja2VyVHlwZSIsImNhbWVyYVBhcmFtZXRlciIsIl9fTE9DQUxfXyIsInZpZGVvVXJsIiwiZGVidWciLCJib2R5SWQiLCJ2aWRlb0lkIiwidmlkZW9Db250YWluZXJJZCIsIkxldHNlZSIsIlZFUlNJT04iLCJWRVJTSU9OX1NUUklORyIsIl9fREVWX18iLCJyZWZJbWFnZURhdGEiLCJfaXNQYXVzZSIsIl91cGRhdGVGbGFnIiwidmlkZW9Mb2FkRmxhZyIsImZpcnN0TG9hZEZsYWciLCJiYXJjb2RlUmVhZEZsYWciLCJjc3NEYXRhIiwicHJvbWlzZUNoYWluIiwiYXJTY3JlZW4iLCJlbnRpdHlNYW5hZ2VyIiwiQVIzRFJlbmRlck1vZHVsZU1hbmFnZXIiLCJlbnRpdHlPYnNlcnZlciIsImV2ZW50TWFuYWdlciIsInRyYWNrZXIiLCJmcHMiLCJmcHNJbnRlcnZhbCIsImVsYXBzZWQiLCJNYXRyaXgzIiwiVmVjdG9yMiIsIkVudGl0eVBhcnNlciIsIlZpZGVvTWFuYWdlciIsIkxFVFNFRV9FVkVOVCIsIk9OX1NUQVRVUyIsImNvZGUiLCJzdGF0dXMiLCJFdmVudE1hbmFnZXIiLCJxdWVyeVNlbGVjdG9yIiwiQVJfTU9ERV9PTiIsImRvbVBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXJJZCIsInNldFByb3BlcnR5IiwiY3NzUGFyc2VyIiwicGFyc2UiLCJjaGVja0VudGl0eSIsImluaXRFbnRpdHkiLCJjaGVja0VudiIsIl9zY3JlZW5TaXplIiwic2NyZWVuQXNwZWN0UmF0aW8iLCJlbmdpbmUiLCJhZGRFbmdpbmUiLCJjaGVja1NjcmlwdCIsInNjcmlwdCIsIlRSQUNLRVJfVVJMIiwiSU1BR0VfVFJBQ0tFUl9GSUxFX05BTUUiLCJNQVJLRVJfVFJBQ0tFUl9GSUxFX05BTUUiLCJRUkNPREVfVFJBQ0tFUl9GSUxFX05BTUUiLCJUcmFja2VyIiwib25lcnJvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJldiIsInNjcmVlbiIsIm9uTG9hZCIsImFsbCIsImluaXRUcmFja2VyIiwidmlkZW9FbGVtZW50Iiwic2V0UmVmSW1hZ2UiLCJjcmVhdGVNYXJrZXJTdGF0ZSIsIm1hcmtlckxpc3QiLCJjb2RlTGlzdCIsInJlbmRlckFsbFRhc2siLCJBUl9NT0RFX09GRiIsImNvbnRhaW5lciIsImRvQ2FwdHVyZSIsInByb2Nlc3NGcmFtZSIsIkxFVFNFRV9MT0FERUQiLCJjaGVja0xvYWRlciIsInNldFRpbWVvdXQiLCJFVkVOVF9BUFBfT05MT0FEIiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaHRtbCIsImNzcyIsImxldHNlZSIsInByZXBhcmUiLCJyZW5kZXJNb2R1bGUiLCJfZW5naW5lIiwibW9kdWxlT2JqZWN0Iiwib25SZW5kZXIiLCJoYXMiLCJmbGFnIiwiY2xlYXIiLCJyZW5kZXJNb2R1bGVNYXAiLCJ2IiwiayIsIkFUVFJfVFJBTlNMQVRFIiwiQVRUUl9ST1RBVEUiLCJQUk9QRVJUWV9UQVJHRVQiLCJQUk9QRVJUWV9UUkFOU0ZPUk0iLCJBTkdMRV9VTklUIiwiZGVncmVlIiwicmFkaWFuIiwidHVybiIsImdyYWRpYW4iLCJUUkFOU0xBVEVfUkVHIiwiUmVnRXhwIiwiUk9UQVRFX1JFRyIsIlVSSV9SRUciLCJDU1NQYXJzZXIiLCJkYXRhTWFwIiwic3R5bGVUYWdzIiwidGFnIiwibWVkaWEiLCJyZW1vdmVDb21tZW50IiwicGFyc2VEYXRhIiwicmVtb3ZlTWVkaWEiLCJ0ZXh0Iiwic3R5bGVzIiwicG9wIiwic2VwZXJhdGVTdHlsZSIsInRyaW0iLCJwcm9wZXJ0eVZhbHVlcyIsInByb3AiLCJrZXkiLCJwYXJzZVZhbHVlIiwicGFyc2VUYXJnZXQiLCJwYXJzZVBvc2l0aW9uIiwicm90YXRlIiwic3RyIiwicHJvcFBvc2l0aW9uIiwicHJvcFJvdGF0aW9uIiwiZ2V0VHJhbnNsYXRlIiwiZ2V0Um90YXRpb24iLCJQSSIsInNlcGFyYXRvcm0iLCJ0ZW1wQXJyYXkiLCJzZXBhcmF0b3IiLCJ1cmwiLCJwYXRoQXJyYXkiLCJsYXN0IiwiYmFzZSIsImpvaW4iLCJzdWJzdHIiLCJ0YWdFbGVtIiwibmV3U3R5bGUiLCJtb2RpZmllZFN0eWxlIiwicGxhY2VTdHlsZSIsIm5ld1NlbGVjdG9yIiwic2VsIiwidW5zaGlmdCIsImNyZWF0ZVRleHROb2RlIiwicmVwbGFjZUNoaWxkIiwiaW5zdGFuY2UiLCJ0ZW1wbGF0ZSIsImxldHNlZU1hcmtlcklkIiwiY29kZVN0cmluZyIsIl9lbnRpdHlTdGF0ZSIsIl9tYXJrZXJMaXN0IiwiX2NvZGVMaXN0IiwiRmV0Y2hlciIsImZldGNoIiwicmVzcG9uc2UiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsImVudGl0eUxpc3QiLCJmZXRjaEVudGl0eSIsImN1cnJlbnRTdGF0ZSIsIm5ld1N0YXRlIiwiU1RBVEVfUkVDT0dOSVpFIiwidXBkYXRlU3RhdGUiLCJtYXJrZXJJZCIsImZpbHRlciIsImluY2x1ZGVzIiwiUkVDT0dOSVpFIiwiT05fTE9BRCIsIlJPVEFUSU9OX0NIQU5HRSIsInVuc3Vic2NyaWJlIiwiTGV0c2VlT2JzZXJ2ZXIiLCJFVkVOVF9BUFBfU1RBVFVTIiwiRVZFTlRfQVBQX1JPVEFUSU9OQ0hBTkdFIiwiU1RBVEVfVFJBQ0tfU1RBUlQiLCJTVEFURV9UUkFDS19NT1ZFIiwiU1RBVEVfVFJBQ0tfRU5EIiwiVEFSR0VUIiwidHJhbnNsYXRlTWF0cml4IiwiT2JqZWN0VHJhY2tlciIsInRhcmdldHMiLCJ1c2VDYW1lcmEiLCJrZXlzIiwiZnJvbUFycmF5IiwiZW50aXR5RXZlbnQiLCJhZGRUYXJnZXQiLCJlbnRpdHlPYmplY3QiLCJyb3RhdGVNIiwibWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJkZWNvbXBvc2VkVmFsdWUiLCJtYWtlVHJhbnNsYXRpb24iLCJ0b0FycmF5IiwicmVtb3ZlVGFyZ2V0IiwiX2NvbnRhaW5lciIsIl92aWRlb0VsZW1lbnQiLCJfc2NlbmVDYW52YXMiLCJfc2NyZWVuV2lkdGgiLCJfc2NyZWVuSGVpZ2h0IiwiX2FuZ2xlIiwiX3NjcmVlbkFzcGVjdFJhdGlvIiwiX2Jyb3dzZXIiLCJfdmlkZW9BdHRhY2hlZCIsImlzRmlyc3RDYW1lcmFJbml0IiwiZ2V0VXNlck1lZGlhQ29uc3RyYWludHMiLCJjb25zdHJhaW50cyIsImF1ZGlvIiwidmlkZW8iLCJmYWNpbmdNb2RlIiwiZXhjZXB0aW9uRGV2aWNlcyIsImxhYmVsIiwiaWRlYWwiLCJnZXRNZWRpYSIsInN0cmVhbSIsImdldFRyYWNrcyIsInN0b3AiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJjaGVja0NhbWVyYSIsImdvdFN0cmVhbSIsIm1lZGlhU3RyZWFtIiwic3JjT2JqZWN0IiwicmVtb3ZlU3RyZWFtIiwiX2luaXRDYW1lcmFDb250YWluZXIiLCJhdXRvcGxheSIsIm11dGVkIiwiYm9yZGVyIiwicmlnaHQiLCJib3R0b20iLCJfYXR0YWNoU291cmNlVG9WaWRlbyIsInNvdXJjZU1QNCIsIl9zZXRBc3BlY3RSYXRpbyIsInRyYW5zZm9ybSIsIl9pbml0Q2FudmFzIiwiY29udGFpbmVySWQiLCJlbnVtZXJhdGVEZXZpY2VzIiwiZ2V0QXR0YWNoZWRWaWRlbyIsImJyb3dzZXJJbmZvIiwicmVjb25uZWN0TWVkaWFTdHJlYW0iLCJvbkNoYW5nZUNhbGxiYWNrIiwiX2lzRXVsZXIiLCJEZWZhdWx0T3JkZXIiLCJSb3RhdGlvbk9yZGVycyIsInNldEZyb21RdWF0ZXJuaW9uUSIsInJlb3JkZXJRIiwiX3giLCJfeSIsIl96IiwiX29yZGVyIiwidXBkYXRlIiwidGUiLCJlbGVtZW50cyIsIm0xMSIsIm0yMSIsIm0zMSIsIm00MSIsIm0xMiIsIm0yMiIsIm0zMiIsIm00MiIsIm0xMyIsIm0yMyIsIm0zMyIsIm00MyIsImFzaW4iLCJhYnMiLCJhdGFuMiIsIm5ld09yZGVyIiwiZXVsZXIiLCJvZmZzZXQiLCJvcHRpb25hbFJlc3VsdCIsIlJBRDJERUciLCJkZWdUb1JhZCIsImRlZ3JlZXMiLCJyYWRUb0RlZyIsInJhZGlhbnMiLCJ3b3JsZFRvU2NyZWVuIiwicHJvamVjdCIsImNsYW1wIiwiZXVjbGlkZWFuTW9kdWxvIiwibiIsIm1hcExpbmVhciIsImExIiwiYTIiLCJiMSIsImIyIiwibGVycCIsInQiLCJzbW9vdGhzdGVwIiwic21vb3RoZXJzdGVwIiwicmFuZEludCIsImxvdyIsImhpZ2giLCJyYW5kRmxvYXQiLCJyYW5kRmxvYXRTcHJlYWQiLCJyYW5nZSIsImlzUG93ZXJPZlR3byIsIm5lYXJlc3RQb3dlck9mVHdvIiwicm91bmQiLCJMTjIiLCJuZXh0UG93ZXJPZlR3byIsIk1hdGhVdGlsIiwiX2lzTWF0cml4MyIsIl9lbGVtZW50cyIsIkZsb2F0MzJBcnJheSIsIm4xMSIsIm4xMiIsIm4xMyIsIm4yMSIsIm4yMiIsIm4yMyIsIm4zMSIsIm4zMiIsIm4zMyIsIm1lIiwiYXR0cmlidXRlIiwidjEiLCJjb3VudCIsImdldFgiLCJnZXRZIiwiZ2V0WiIsImFwcGx5TWF0cml4MyIsInNldFhZWiIsInMiLCJhIiwiYiIsImYiLCJnIiwiaCIsInRocm93T25EZWdlbmVyYXRlIiwidDExIiwidDEyIiwidDEzIiwiZGV0IiwibXNnIiwiZGV0SW52IiwibWF0cml4NCIsInNldEZyb21NYXRyaXg0IiwidHJhbnNwb3NlIiwiZXh0cmFjdFJvdGF0aW9uViIsImxvb2tBdFgiLCJsb29rQXRZIiwibG9va0F0WiIsImRlY29tcG9zZVYiLCJkZWNvbXBvc2VNIiwiX2lzTWF0cml4NCIsIm4xNCIsIm4yNCIsIm4zNCIsIm40MSIsIm40MiIsIm40MyIsIm40NCIsInNldEZyb21NYXRyaXhDb2x1bW4iLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZVoiLCJjeCIsImNvcyIsInN4Iiwic2luIiwiY3kiLCJzeSIsImN6Iiwic3oiLCJ3IiwieDIiLCJ5MiIsInoyIiwieHgiLCJ4eSIsInh6IiwieXkiLCJ5eiIsInp6Iiwid3giLCJ3eSIsInd6IiwiZXllIiwic3ViVmVjdG9ycyIsImxlbmd0aFNxIiwibm9ybWFsaXplIiwiY3Jvc3NWZWN0b3JzIiwiYWUiLCJiZSIsImExMSIsImEyMSIsImEzMSIsImE0MSIsImExMiIsImEyMiIsImEzMiIsImE0MiIsImExMyIsImEyMyIsImEzMyIsImE0MyIsImExNCIsImEyNCIsImEzNCIsImE0NCIsImIxMSIsImIyMSIsImIzMSIsImI0MSIsImIxMiIsImIyMiIsImIzMiIsImI0MiIsImIxMyIsImIyMyIsImIzMyIsImI0MyIsImIxNCIsImIyNCIsImIzNCIsImI0NCIsInQxNCIsInNjYWxlWFNxIiwic2NhbGVZU3EiLCJzY2FsZVpTcSIsInNxcnQiLCJ0aGV0YSIsInR4IiwidHkiLCJzZXRQb3NpdGlvbiIsImRldGVybWluYW50IiwiaW52U1giLCJpbnZTWSIsImludlNaIiwieW1pbiIsInltYXgiLCJ4bWluIiwieG1heCIsIm1ha2VGcnVzdHVtIiwicCIsIkVQU0lMT04iLCJOdW1iZXIiLCJwb3ciLCJzZXRGcm9tVW5pdFZlY3RvcnNFUFMiLCJzZXRGcm9tVW5pdFZlY3RvcnNWIiwiX2lzUXVhdGVybmlvbiIsImMxIiwiYzIiLCJjMyIsInMxIiwiczIiLCJzMyIsImhhbGZBbmdsZSIsInRyYWNlIiwidkZyb20iLCJ2VG8iLCJkb3QiLCJjb25qdWdhdGUiLCJtdWx0aXBseVF1YXRlcm5pb25zIiwicWF4IiwicWF5IiwicWF6IiwicWF3IiwicWJ4IiwicWJ5IiwicWJ6IiwicWJ3IiwicWIiLCJjb3NIYWxmVGhldGEiLCJzaW5IYWxmVGhldGEiLCJoYWxmVGhldGEiLCJyYXRpb0EiLCJyYXRpb0IiLCJxU3RhcnQiLCJxRW5kIiwicVRhcmdldCIsInNsZXJwIiwiZHN0IiwiZHN0T2Zmc2V0Iiwic3JjMCIsInNyY09mZnNldDAiLCJzcmMxIiwic3JjT2Zmc2V0MSIsIngwIiwieTAiLCJ6MCIsIncwIiwieDEiLCJ5MSIsInoxIiwidzEiLCJkaXIiLCJzcXJTaW4iLCJsZW4iLCJ0RGlyIiwiX2lzVmVjdG9yMiIsInNjYWxhciIsImlzRmluaXRlIiwibWluVmFsIiwibWF4VmFsIiwiY2VpbCIsImRpdmlkZVNjYWxhciIsImRpc3RhbmNlVG9TcXVhcmVkIiwiZHgiLCJkeSIsInYyIiwiY2VudGVyIiwiYXBwbHlFdWxlclEiLCJhcHBseUF4aXNBbmdsZVEiLCJwcm9qZWN0T25QbGFuZVYiLCJyZWZsZWN0ViIsIl9pc1ZlY3RvcjMiLCJxeCIsInF5IiwicXoiLCJxdyIsIml5IiwiaXoiLCJpdyIsImF4IiwiYXkiLCJheiIsImJ4IiwiYnkiLCJieiIsInBsYW5lTm9ybWFsIiwicHJvamVjdE9uVmVjdG9yIiwic3ViIiwibm9ybWFsIiwiYWNvcyIsImR6IiwiZ2V0VGFyZ2V0IiwiYWRkSGFuZGxlciIsImhhbmRsZXIiLCJnZXRIYW5kbGVyIiwiX3RhcmdldCIsIl9ldmVudCIsIkVudGl0eVR5cGUiLCJfaXNET01SZW5kZXJhYmxlIiwiZ2hvc3RJZCIsInBhcmVudEVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsIm9yaWdpbmFsRWxlbWVudCIsImNsb25lTm9kZSIsImdob3N0RWxlbWVudCIsImFkZEVsZW1lbnQiLCJ3aWxsQ2hhbmdlIiwiaXNBZGRlZFRvQ2FtZXJhIiwiaXNET01SZW5kZXJhYmxlIiwiYWRkZWQiLCJyZW1vdmVkIiwiaXNTY2VuZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVwc2lsb24iLCJnZXRDYW1lcmFDU1NNYXRyaXgiLCJjYW1lcmFNYXRyaXgiLCJnZXRPYmplY3RDU1NNYXRyaXgiLCJvYmplY3RNYXRyaXgiLCJfY2FjaGVkU3R5bGVzIiwiX2RvbUVsZW1lbnQiLCJfY2FtZXJhRWxlbWVudCIsIkRPTVJlbmRlcmVyIiwib3ZlcmZsb3ciLCJXZWJraXRUcmFuc2Zvcm1TdHlsZSIsInRyYW5zZm9ybVN0eWxlIiwiZ2V0RWxlbWVudCIsImdob3N0Iiwib3JpZ2luYWwiLCJnZXRBbGxFbGVtZW50cyIsImdldEVmZmVjdGl2ZUZPViIsImNhbWVyYUNTU01hdHJpeCIsImNhbWVyYVRyYW5zZm9ybSIsIldlYmtpdFBlcnNwZWN0aXZlIiwicGVyc3BlY3RpdmUiLCJXZWJraXRUcmFuc2Zvcm0iLCJjYWNoZWRTdHlsZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJvIiwicmVxdWlyZSIsInUiLCJjYWxsIiwiX2FkYXB0ZXJfZmFjdG9yeSIsImFkYXB0ZXIiLCJhZGFwdGVyRmFjdG9yeSIsIl91dGlscyIsInV0aWxzIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQiLCJfY2hyb21lX3NoaW0iLCJjaHJvbWVTaGltIiwiX2VkZ2Vfc2hpbSIsImVkZ2VTaGltIiwiX2ZpcmVmb3hfc2hpbSIsImZpcmVmb3hTaGltIiwiX3NhZmFyaV9zaGltIiwic2FmYXJpU2hpbSIsIl9jb21tb25fc2hpbSIsImNvbW1vblNoaW0iLCJfX2VzTW9kdWxlIiwibmV3T2JqIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfcmVmIiwib3B0aW9ucyIsInNoaW1DaHJvbWUiLCJzaGltRmlyZWZveCIsInNoaW1FZGdlIiwic2hpbVNhZmFyaSIsImxvZ2dpbmciLCJicm93c2VyRGV0YWlscyIsImRldGVjdEJyb3dzZXIiLCJleHRyYWN0VmVyc2lvbiIsImRpc2FibGVMb2ciLCJkaXNhYmxlV2FybmluZ3MiLCJicm93c2VyIiwic2hpbVBlZXJDb25uZWN0aW9uIiwiYnJvd3NlclNoaW0iLCJzaGltR2V0VXNlck1lZGlhIiwic2hpbU1lZGlhU3RyZWFtIiwic2hpbU9uVHJhY2siLCJzaGltQWRkVHJhY2tSZW1vdmVUcmFjayIsInNoaW1HZXRTZW5kZXJzV2l0aER0bWYiLCJzaGltR2V0U3RhdHMiLCJzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyIsImZpeE5lZ290aWF0aW9uTmVlZGVkIiwic2hpbVJUQ0ljZUNhbmRpZGF0ZSIsInNoaW1Db25uZWN0aW9uU3RhdGUiLCJzaGltTWF4TWVzc2FnZVNpemUiLCJzaGltU2VuZFRocm93VHlwZUVycm9yIiwicmVtb3ZlQWxsb3dFeHRtYXBNaXhlZCIsInNoaW1SZW1vdmVTdHJlYW0iLCJzaGltU2VuZGVyR2V0U3RhdHMiLCJzaGltUmVjZWl2ZXJHZXRTdGF0cyIsInNoaW1SVENEYXRhQ2hhbm5lbCIsInNoaW1BZGRUcmFuc2NlaXZlciIsInNoaW1DcmVhdGVPZmZlciIsInNoaW1DcmVhdGVBbnN3ZXIiLCJzaGltR2V0RGlzcGxheU1lZGlhIiwic2hpbVJlcGxhY2VUcmFjayIsInNoaW1SVENJY2VTZXJ2ZXJVcmxzIiwic2hpbUNyZWF0ZU9mZmVyTGVnYWN5Iiwic2hpbUNhbGxiYWNrc0FQSSIsInNoaW1Mb2NhbFN0cmVhbXNBUEkiLCJzaGltUmVtb3RlU3RyZWFtc0FQSSIsInNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsIl9nZXR1c2VybWVkaWEiLCJlbnVtZXJhYmxlIiwiX2dldGRpc3BsYXltZWRpYSIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsIl9kZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiTWVkaWFTdHJlYW0iLCJ3ZWJraXRNZWRpYVN0cmVhbSIsIlJUQ1BlZXJDb25uZWN0aW9uIiwiX29udHJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfdGhpcyIsIl9vbnRyYWNrcG9seSIsInJlY2VpdmVyIiwiZ2V0UmVjZWl2ZXJzIiwiZmluZCIsIkV2ZW50IiwidHJhbnNjZWl2ZXIiLCJzdHJlYW1zIiwiZGlzcGF0Y2hFdmVudCIsImFwcGx5Iiwid3JhcFBlZXJDb25uZWN0aW9uRXZlbnQiLCJzaGltU2VuZGVyV2l0aER0bWYiLCJwYyIsImR0bWYiLCJfZHRtZiIsImNyZWF0ZURUTUZTZW5kZXIiLCJfcGMiLCJnZXRTZW5kZXJzIiwiX3NlbmRlcnMiLCJzbGljZSIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwiX3RoaXMyIiwib3JpZ1JlbW92ZVN0cmVhbSIsIl90aGlzMyIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwiX3RoaXM0Iiwic2VuZGVycyIsIm9yaWdHZXRTdGF0cyIsImdldFN0YXRzIiwiX3RoaXM1IiwiX2FyZ3VtZW50cyIsIkFycmF5Iiwib25TdWNjIiwib25FcnIiLCJmaXhDaHJvbWVTdGF0c18iLCJzdGFuZGFyZFJlcG9ydCIsInJlcG9ydHMiLCJyZXBvcnQiLCJzdGFuZGFyZFN0YXRzIiwidGltZXN0YW1wIiwibG9jYWxjYW5kaWRhdGUiLCJyZW1vdGVjYW5kaWRhdGUiLCJuYW1lcyIsInN0YXQiLCJtYWtlTWFwU3RhdHMiLCJzdGF0cyIsInN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfIiwiUlRDUnRwUmVjZWl2ZXIiLCJfdGhpczYiLCJmaWx0ZXJTdGF0cyIsIm9yaWdHZXRSZWNlaXZlcnMiLCJfdGhpczciLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50IiwiTWVkaWFTdHJlYW1UcmFjayIsIkRPTUV4Y2VwdGlvbiIsImdldExvY2FsU3RyZWFtcyIsIl90aGlzOCIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJfdGhpczkiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsImNvbmNhdCIsIl90aGlzMTAiLCJ2ZXJzaW9uIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIl90aGlzMTEiLCJuYXRpdmVTdHJlYW1zIiwiX3JldmVyc2VTdHJlYW1zIiwiX3RoaXMxMiIsIl9zdHJlYW1zIiwibmV3U3RyZWFtIiwiX3RoaXMxMyIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJtZXRob2QiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJfdGhpczE0IiwiaXNMZWdhY3lDYWxsIiwiZGVzYyIsIm9yaWdTZXRMb2NhbERlc2NyaXB0aW9uIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsIm9yaWdMb2NhbERlc2NyaXB0aW9uIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX3RoaXMxNSIsImlzTG9jYWwiLCJzdHJlYW1pZCIsImhhc1RyYWNrIiwid2Via2l0UlRDUGVlckNvbm5lY3Rpb24iLCJSVENJY2VDYW5kaWRhdGUiLCJuYXRpdmVBZGRJY2VDYW5kaWRhdGUiLCJhZGRJY2VDYW5kaWRhdGUiLCJjYW5kaWRhdGUiLCJnZXRTb3VyY2VJZCIsImdldERpc3BsYXlNZWRpYSIsInNvdXJjZUlkIiwid2lkdGhTcGVjaWZpZWQiLCJoZWlnaHRTcGVjaWZpZWQiLCJmcmFtZVJhdGVTcGVjaWZpZWQiLCJmcmFtZVJhdGUiLCJtYW5kYXRvcnkiLCJjaHJvbWVNZWRpYVNvdXJjZSIsImNocm9tZU1lZGlhU291cmNlSWQiLCJtYXhGcmFtZVJhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsImNvbnN0cmFpbnRzVG9DaHJvbWVfIiwib3B0aW9uYWwiLCJjYyIsImV4YWN0Iiwib2xkbmFtZV8iLCJwcmVmaXgiLCJjaGFyQXQiLCJvYyIsIm1peCIsImFkdmFuY2VkIiwic2hpbUNvbnN0cmFpbnRzXyIsImZ1bmMiLCJyZW1hcCIsImZhY2UiLCJnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyIsImdldFN1cHBvcnRlZENvbnN0cmFpbnRzIiwibWF0Y2hlcyIsImRldiIsInNvbWUiLCJzaGltRXJyb3JfIiwiUGVybWlzc2lvbkRlbmllZEVycm9yIiwiUGVybWlzc2lvbkRpc21pc3NlZEVycm9yIiwiSW52YWxpZFN0YXRlRXJyb3IiLCJEZXZpY2VzTm90Rm91bmRFcnJvciIsIkNvbnN0cmFpbnROb3RTYXRpc2ZpZWRFcnJvciIsIlRyYWNrU3RhcnRFcnJvciIsIk1lZGlhRGV2aWNlRmFpbGVkRHVlVG9TaHV0ZG93biIsIk1lZGlhRGV2aWNlS2lsbFN3aXRjaE9uIiwiVGFiQ2FwdHVyZUVycm9yIiwiU2NyZWVuQ2FwdHVyZUVycm9yIiwiRGV2aWNlQ2FwdHVyZUVycm9yIiwiY29uc3RyYWludCIsImNvbnN0cmFpbnROYW1lIiwiZ2V0VXNlck1lZGlhXyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJiaW5kIiwib3JpZ0dldFVzZXJNZWRpYSIsImNzIiwiZ2V0QXVkaW9UcmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsIl9zZHAiLCJfc2RwMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJOYXRpdmVSVENJY2VDYW5kaWRhdGUiLCJuYXRpdmVDYW5kaWRhdGUiLCJwYXJzZWRDYW5kaWRhdGUiLCJwYXJzZUNhbmRpZGF0ZSIsImF1Z21lbnRlZENhbmRpZGF0ZSIsImFzc2lnbiIsInRvSlNPTiIsInNkcE1pZCIsInNkcE1MaW5lSW5kZXgiLCJ1c2VybmFtZUZyYWdtZW50IiwiX3NjdHAiLCJzY3RwSW5EZXNjcmlwdGlvbiIsInNlY3Rpb25zIiwic3BsaXRTZWN0aW9ucyIsInNoaWZ0IiwibWVkaWFTZWN0aW9uIiwibUxpbmUiLCJwYXJzZU1MaW5lIiwicHJvdG9jb2wiLCJnZXRSZW1vdGVGaXJlZm94VmVyc2lvbiIsImdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSIsInJlbW90ZUlzRmlyZWZveCIsImNhblNlbmRNYXhNZXNzYWdlU2l6ZSIsImdldE1heE1lc3NhZ2VTaXplIiwibWF4TWVzc2FnZVNpemUiLCJtYXRjaFByZWZpeCIsIl9nZXRDb25maWd1cmF0aW9uIiwiZ2V0Q29uZmlndXJhdGlvbiIsInNkcFNlbWFudGljcyIsImNhblNlbmRNTVMiLCJyZW1vdGVNTVMiLCJQT1NJVElWRV9JTkZJTklUWSIsInNjdHAiLCJ3cmFwRGNTZW5kIiwiZGMiLCJvcmlnRGF0YUNoYW5uZWxTZW5kIiwic2VuZCIsImJ5dGVMZW5ndGgiLCJyZWFkeVN0YXRlIiwiVHlwZUVycm9yIiwib3JpZ0NyZWF0ZURhdGFDaGFubmVsIiwiY3JlYXRlRGF0YUNoYW5uZWwiLCJkYXRhQ2hhbm5lbCIsImNoYW5uZWwiLCJwcm90byIsImNvbXBsZXRlZCIsImNoZWNraW5nIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwiX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwiY2IiLCJvcmlnTWV0aG9kIiwiX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkiLCJfbGFzdENvbm5lY3Rpb25TdGF0ZSIsImNvbm5lY3Rpb25TdGF0ZSIsIm5ld0V2ZW50IiwibmF0aXZlU1JEIiwibGluZSIsIlJUQ1RyYWNrRXZlbnQiLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIm1vZGVyblN0YXRzVHlwZXMiLCJpbmJvdW5kcnRwIiwib3V0Ym91bmRydHAiLCJjYW5kaWRhdGVwYWlyIiwibmF0aXZlR2V0U3RhdHMiLCJkZXByZWNhdGVkIiwiRGF0YUNoYW5uZWwiLCJSVENEYXRhQ2hhbm5lbCIsIm9yaWdBZGRUcmFuc2NlaXZlciIsImFkZFRyYW5zY2VpdmVyIiwic2V0UGFyYW1ldGVyc1Byb21pc2VzIiwiaW5pdFBhcmFtZXRlcnMiLCJzaG91bGRQZXJmb3JtQ2hlY2siLCJzZW5kRW5jb2RpbmdzIiwiZW5jb2RpbmdQYXJhbSIsInJpZFJlZ2V4IiwicmlkIiwic2NhbGVSZXNvbHV0aW9uRG93bkJ5IiwiUmFuZ2VFcnJvciIsIm1heEZyYW1lcmF0ZSIsInBhcmFtcyIsImdldFBhcmFtZXRlcnMiLCJlbmNvZGluZ3MiLCJzZXRQYXJhbWV0ZXJzIiwib3JpZ0NyZWF0ZU9mZmVyIiwiY3JlYXRlT2ZmZXIiLCJfYXJndW1lbnRzMiIsIm9yaWdDcmVhdGVBbnN3ZXIiLCJjcmVhdGVBbnN3ZXIiLCJfYXJndW1lbnRzMyIsInByZWZlcnJlZE1lZGlhU291cmNlIiwibWVkaWFTb3VyY2UiLCJuYXRpdmVHZXRVc2VyTWVkaWEiLCJnZXRTZXR0aW5ncyIsIm5hdGl2ZUdldFNldHRpbmdzIiwiYXBwbHlDb25zdHJhaW50cyIsIm5hdGl2ZUFwcGx5Q29uc3RyYWludHMiLCJzaGltQ29uc3RyYWludHMiLCJfbG9jYWxTdHJlYW1zIiwiX2FkZFRyYWNrIiwidHJhY2tzIiwiZ2V0UmVtb3RlU3RyZWFtcyIsIl9yZW1vdGVTdHJlYW1zIiwiX29uYWRkc3RyZWFtIiwiX29uYWRkc3RyZWFtcG9seSIsInN1Y2Nlc3NDYWxsYmFjayIsImZhaWx1cmVDYWxsYmFjayIsInByb21pc2UiLCJ3aXRoQ2FsbGJhY2siLCJfZ2V0VXNlck1lZGlhIiwiZXJyY2IiLCJjb21wYWN0T2JqZWN0IiwiT3JpZ1BlZXJDb25uZWN0aW9uIiwicGNDb25maWciLCJwY0NvbnN0cmFpbnRzIiwiaWNlU2VydmVycyIsIm5ld0ljZVNlcnZlcnMiLCJzZXJ2ZXIiLCJ1cmxzIiwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZSIsIm9mZmVyT3B0aW9ucyIsIm9mZmVyVG9SZWNlaXZlQXVkaW8iLCJhdWRpb1RyYW5zY2VpdmVyIiwiZ2V0VHJhbnNjZWl2ZXJzIiwiZGlyZWN0aW9uIiwic2V0RGlyZWN0aW9uIiwib2ZmZXJUb1JlY2VpdmVWaWRlbyIsInZpZGVvVHJhbnNjZWl2ZXIiLCJ3YWxrU3RhdHMiLCJsb2dEaXNhYmxlZF8iLCJkZXByZWNhdGlvbldhcm5pbmdzXyIsInVhc3RyaW5nIiwiZXhwciIsInBvcyIsImV2ZW50TmFtZVRvV3JhcCIsIndyYXBwZXIiLCJuYXRpdmVBZGRFdmVudExpc3RlbmVyIiwibmF0aXZlRXZlbnROYW1lIiwid3JhcHBlZENhbGxiYWNrIiwibW9kaWZpZWRFdmVudCIsIl9ldmVudE1hcCIsIm5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1bndyYXBwZWRDYiIsImJvb2wiLCJvbGRNZXRob2QiLCJuZXdNZXRob2QiLCJtb3pHZXRVc2VyTWVkaWEiLCJpc1NlY3VyZUNvbnRleHQiLCJSVENJY2VHYXRoZXJlciIsInN1cHBvcnRzVW5pZmllZFBsYW4iLCJSVENSdHBUcmFuc2NlaXZlciIsImlzT2JqZWN0IiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpc09iaiIsImlzRW1wdHlPYmplY3QiLCJyZXN1bHRTZXQiLCJlbmRzV2l0aCIsIm91dGJvdW5kIiwic3RyZWFtU3RhdHNUeXBlIiwiZmlsdGVyZWRSZXN1bHQiLCJ0cmFja1N0YXRzIiwidHJhY2tJZGVudGlmaWVyIiwidHJhY2tTdGF0IiwidHJhY2tJZCIsIlNEUFV0aWxzIiwiZ2VuZXJhdGVJZGVudGlmaWVyIiwibG9jYWxDTmFtZSIsInNwbGl0TGluZXMiLCJibG9iIiwicGFydHMiLCJwYXJ0IiwiZ2V0RGVzY3JpcHRpb24iLCJnZXRNZWRpYVNlY3Rpb25zIiwiZm91bmRhdGlvbiIsImNvbXBvbmVudCIsInByaW9yaXR5IiwiaXAiLCJhZGRyZXNzIiwicG9ydCIsInJlbGF0ZWRBZGRyZXNzIiwicmVsYXRlZFBvcnQiLCJ0Y3BUeXBlIiwidWZyYWciLCJ3cml0ZUNhbmRpZGF0ZSIsInBhcnNlSWNlT3B0aW9ucyIsInBhcnNlUnRwTWFwIiwicGFyc2VkIiwicGF5bG9hZFR5cGUiLCJjbG9ja1JhdGUiLCJjaGFubmVscyIsIm51bUNoYW5uZWxzIiwid3JpdGVSdHBNYXAiLCJjb2RlYyIsInB0IiwicHJlZmVycmVkUGF5bG9hZFR5cGUiLCJwYXJzZUV4dG1hcCIsIndyaXRlRXh0bWFwIiwiaGVhZGVyRXh0ZW5zaW9uIiwicHJlZmVycmVkSWQiLCJwYXJzZUZtdHAiLCJrdiIsImoiLCJ3cml0ZUZtdHAiLCJwYXJhbWV0ZXJzIiwicGFyc2VSdGNwRmIiLCJwYXJhbWV0ZXIiLCJ3cml0ZVJ0Y3BGYiIsImxpbmVzIiwicnRjcEZlZWRiYWNrIiwiZmIiLCJwYXJzZVNzcmNNZWRpYSIsInNwIiwic3NyYyIsImNvbG9uIiwicGFyc2VTc3JjR3JvdXAiLCJzZW1hbnRpY3MiLCJzc3JjcyIsImdldE1pZCIsIm1pZCIsInBhcnNlRmluZ2VycHJpbnQiLCJhbGdvcml0aG0iLCJnZXREdGxzUGFyYW1ldGVycyIsInNlc3Npb25wYXJ0Iiwicm9sZSIsImZpbmdlcnByaW50cyIsIndyaXRlRHRsc1BhcmFtZXRlcnMiLCJzZXR1cFR5cGUiLCJmcCIsImdldEljZVBhcmFtZXRlcnMiLCJpY2VQYXJhbWV0ZXJzIiwicGFzc3dvcmQiLCJ3cml0ZUljZVBhcmFtZXRlcnMiLCJwYXJzZVJ0cFBhcmFtZXRlcnMiLCJjb2RlY3MiLCJoZWFkZXJFeHRlbnNpb25zIiwiZmVjTWVjaGFuaXNtcyIsInJ0Y3AiLCJtbGluZSIsInJ0cG1hcGxpbmUiLCJmbXRwcyIsIndyaXRlUnRwRGVzY3JpcHRpb24iLCJjYXBzIiwibWF4cHRpbWUiLCJleHRlbnNpb24iLCJwYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyIsImVuY29kaW5nUGFyYW1ldGVycyIsImhhc1JlZCIsImhhc1VscGZlYyIsInByaW1hcnlTc3JjIiwic2Vjb25kYXJ5U3NyYyIsImZsb3dzIiwiYXB0IiwiZW5jUGFyYW0iLCJjb2RlY1BheWxvYWRUeXBlIiwicnR4IiwiZmVjIiwibWVjaGFuaXNtIiwiYmFuZHdpZHRoIiwibWF4Qml0cmF0ZSIsInBhcnNlUnRjcFBhcmFtZXRlcnMiLCJydGNwUGFyYW1ldGVycyIsInJlbW90ZVNzcmMiLCJjbmFtZSIsInJzaXplIiwicmVkdWNlZFNpemUiLCJjb21wb3VuZCIsIm11eCIsInBhcnNlTXNpZCIsInNwZWMiLCJwbGFuQiIsIm1zaWRQYXJ0cyIsInBhcnNlU2N0cERlc2NyaXB0aW9uIiwibWF4U2l6ZUxpbmUiLCJzY3RwUG9ydCIsImZtdCIsInNjdHBNYXBMaW5lcyIsIndyaXRlU2N0cERlc2NyaXB0aW9uIiwib3V0cHV0IiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJ3cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSIsInNlc3NJZCIsInNlc3NWZXIiLCJzZXNzVXNlciIsInNlc3Npb25JZCIsInVzZXIiLCJ3cml0ZU1lZGlhU2VjdGlvbiIsImljZUdhdGhlcmVyIiwiZ2V0TG9jYWxQYXJhbWV0ZXJzIiwiZHRsc1RyYW5zcG9ydCIsInJ0cFNlbmRlciIsInJ0cFJlY2VpdmVyIiwibXNpZCIsInNlbmRFbmNvZGluZ1BhcmFtZXRlcnMiLCJnZXREaXJlY3Rpb24iLCJnZXRLaW5kIiwiaXNSZWplY3RlZCIsInBhcnNlT0xpbmUiLCJ1c2VybmFtZSIsInNlc3Npb25WZXJzaW9uIiwibmV0VHlwZSIsImFkZHJlc3NUeXBlIiwiaXNWYWxpZFNEUCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtR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QUFLLENBQUNwdEMsQ0FBRCxDQUFMLENBQVM1RSxNQUFULEdBQWtCLENBQWxCLElBQXVCZ3lDLEtBQUssQ0FBQ3B0QyxDQUFELENBQUwsQ0FBUzg5QixNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQWxELEVBQXVEO0FBQ3JELHFCQUFPLEtBQVA7QUFDRCxhQUhvQyxDQUlyQzs7QUFDRDs7QUFDRCxpQkFBTyxJQUFQO0FBQ0QsU0FaRCxDQWx2QjBDLENBZ3dCMUM7OztBQUNBLFlBQUksU0FBTzFOLE1BQVAsTUFBa0IsUUFBdEIsRUFBZ0M7QUFDOUJBLGdCQUFNLENBQUNELE9BQVAsR0FBaUJzYSxRQUFqQjtBQUNEO0FBRUEsT0Fyd0JRLEVBcXdCUCxFQXJ3Qk87QUExakZrekIsS0FBNWMsRUErekd4VyxFQS96R3dXLEVBK3pHclcsQ0FBQyxDQUFELENBL3pHcVcsRUErekdoVyxDQS96R2dXLENBQVA7QUFnMEd2VyxHQWgwR0QiLCJmaWxlIjoibGV0c2VlLTAuOS4yMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiTGV0c2VlXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkxldHNlZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJMZXRzZWVcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIuL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LmpzXCIpO1xuIiwiaW1wb3J0IHtVVUlEfSBmcm9tICcuL1V0aWwnO1xuXG5sZXQgX29zID0gbnVsbDtcbmxldCBfd2lkdGggPSBudWxsO1xubGV0IF9oZWlnaHQgPSBudWxsO1xubGV0IF9vcmllbnRhdGlvbiA9IG51bGw7XG5sZXQgX2lzUG9ydHJhaXQgPSBudWxsO1xuXG5sZXQgQm9keUlkID0gYGJvZHktJHtVVUlEKCl9YDtcbmxldCBEb21SZW5kZXJlcklkID0gYGRvbS0ke1VVSUQoKX1gO1xubGV0IFZpZGVvQ29udGFpbmVySWQgPSBgdmlkZW8tJHtVVUlEKCl9YDtcbmxldCBQbGFjZWhvbGRlcklkID0gYHBsYWNlaG9sZGVyLSR7VVVJRCgpfWA7XG5cbmNsYXNzIENvbnRleHQge1xuICBjb25zdHJ1Y3RvcigpIHtcblxuICB9XG4gIHNldENvbmZpZyhjb25maWcpIHtcbiAgICBfd2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgX2hlaWdodCA9IGNvbmZpZy5oZWlnaHQ7XG4gICAgX29yaWVudGF0aW9uID0gY29uZmlnLm9yaWVudGF0aW9uO1xuICAgIF9pc1BvcnRyYWl0ID0gX29yaWVudGF0aW9uID09PSAwIHx8IF9vcmllbnRhdGlvbiA9PT0gMTgwO1xuICB9XG4gIGdldCBib2R5SWQoKSB7XG4gICAgcmV0dXJuIEJvZHlJZDtcbiAgfVxuICBzZXQgYm9keUlkKHZhbHVlKSB7XG4gICAgQm9keUlkID0gdmFsdWU7XG4gIH1cblxuICBnZXQgZG9tUmVuZGVyZXJJZCgpIHtcbiAgICByZXR1cm4gRG9tUmVuZGVyZXJJZDtcbiAgfVxuXG4gIGdldCB2aWRlb0NvbnRhaW5lcklkKCkge1xuICAgIHJldHVybiBWaWRlb0NvbnRhaW5lcklkO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVySWQoKSB7XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVySWQ7XG4gIH1cblxuICBnZXQgb3MoKSB7XG4gICAgcmV0dXJuIF9vcztcbiAgfVxuICBzZXQgb3ModmFsdWUpIHtcbiAgICBfb3MgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gX29yaWVudGF0aW9uO1xuICB9XG4gIHNldCBvcmllbnRhdGlvbih2YWx1ZSkge1xuICAgIF9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiBfd2lkdGg7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgX3dpZHRoID0gdmFsdWU7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiBfaGVpZ2h0O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBfaGVpZ2h0ID0gdmFsdWU7XG4gIH1cblxuICBnZXQgaXNQb3J0cmFpdCgpIHtcbiAgICByZXR1cm4gX2lzUG9ydHJhaXQ7XG4gIH1cblxuICBnZXQgc2NyZWVuV2lkdGgoKSB7XG4gICAgcmV0dXJuIF93aWR0aDtcbiAgfVxuICBnZXQgc2NyZWVuSGVpZ2h0KCkge1xuICAgIHJldHVybiBfaGVpZ2h0O1xuICB9XG59XG5cbmV4cG9ydCBsZXQgY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTY3JlZW4ge1xuICBjb25zdHJ1Y3Rvcihfd2lkdGgsIF9oZWlnaHQsIF92aWRlb01hbmFnZXIpIHtcbiAgICB0aGlzLndpZHRoID0gX3dpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gX2hlaWdodDtcbiAgICB0aGlzLnZpZGVvTWFuYWdlciA9IF92aWRlb01hbmFnZXI7XG4gIH1cblxuICAvKipcbiAgICogRml0IHRoZSBjYW52YXMgc2l6ZSB3aGVuIGZ1bGxzY3JlZW4gYW5kIGV4aXQgZnVsbHNjcmVlbiByZXF1ZXN0LlxuICAgKi9cbiAgZml0V2lkdGhBbmRIZWlnaHQoKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAgIGBmaXQgd2luZG93LmlubmVyV2lkdGg6ICR7d2luZG93LmlubmVyV2lkdGh9IC8gd2luZG93LmlubmVySGVpZ2h0OiAke3dpbmRvdy5pbm5lckhlaWdodH0gdG8gc2NyZWVuYCk7XG5cbiAgICAvLyBTZXQgY2FudmFzIHNpemUgd2l0aCBjdXJyZW50IHdpbmRvdyB3aWR0aCAmIGhlaWdodC5cbiAgICB0aGlzLnZpZGVvTWFuYWdlci5jYW52YXNFbGVtZW50LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdGhpcy52aWRlb01hbmFnZXIuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAvLyBTZW5kIHNjcmVlbiBzaXplIHRvIHRyYWNrZXIuXG4gICAgdGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8uaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIC8qIOydtOqyg+uPhOyalC4uc2NyZWVuIG9iamVjdCDthrXtlbTshJwg7Zi47Lac7ZWY66m0IOuQmOyWtOyalC4gYnkgYWhuICovXG4gIHJlcXVlc3RGdWxsc2NyZWVuKCkge1xuICAgIC8vIEZpbmQgPGFyLXJlbmRlcmVyPiBlbGVtZW50XG4gICAgbGV0IF9hclJlbmRlcmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYXItcmVuZGVyZXInKTtcblxuICAgIC8vIFNldCBmdWxsc2NyZWVuIGZvciBhci1yZW5kZXJlciBlbGVtZW50XG4gICAgaWYgKF9hclJlbmRlcmVyWzBdICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgaWYgKF9hclJlbmRlcmVyWzBdLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIF9hclJlbmRlcmVyWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkudGhlbigoZSkgPT4ge1xuICAgICAgICAgIC8vXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICBfYXJSZW5kZXJlclswXS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICBfYXJSZW5kZXJlclswXS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIF9hclJlbmRlcmVyWzBdLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyog7J206rKD64+EIHNjcmVlbiBvYmplY3Tsl5DshJwg7KCc6rO17ZWY66m0IOuQqeuLiOuLpC4gbGV0c2VlLnNjcmVlbi5leGl0RnVsbHNjcmVlbigpIOydtOugh+qyjCBieSBhaG4gKi9cbiAgZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgaWYgKGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBTZXQgY3VycmVudCBjYW52YXMgc2l6ZSB3aGVuIGV4aXQgZnVsbHNjcmVlblxuICAgICAgICB0aGlzLmZpdFdpZHRoQW5kSGVpZ2h0KCk7XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7IC8qIEZpcmVmb3ggKi9cbiAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7IC8qIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYSAqL1xuICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4pIHsgLyogSUUvRWRnZSAqL1xuICAgICAgZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gaW1wb3J0IGFkYXB0ZXIgZnJvbSAnd2VicnRjLWFkYXB0ZXInO1xuLy8gaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZSBmcm9tICcuL2xpYnMvTWVzc2FnZVR5cGVzJztcblxuY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuY29uc3QgbGV0c2VlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuY29uc3QgbGV0c2VlTG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb25zdCBsZXRzZWVTdGF0dXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnN0IGRlZmF1bHRMb2FkZXJDb250ZW50ID0gJzxkaXYgY2xhc3M9XCJsZXRzZWVMb2FkZXJcIj48aW1nIHNyYz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5EUWlJR2hsYVdkb2REMGlORFFpSUhacFpYZENiM2c5SWpBZ01DQTBOQ0EwTkNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlCemRISnZhMlU5SWlObVptWWlQaUFnUEdjZ1ptbHNiRDBpYm05dVpTSWdjM1J5YjJ0bFBTSWpNREJpTVdNM0lpQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJSE4wY205clpTMTNhV1IwYUQwaU1pSStJQ0FnSUR4amFYSmpiR1VnWTNnOUlqSXlJaUJqZVQwaU1qSWlJSEk5SWpFaVBpQWdJQ0FnSUR4aGJtbHRZWFJsSUdGMGRISnBZblYwWlU1aGJXVTlJbklpSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbVZuYVc0OUlqQnpJaUJrZFhJOUlqRXVPSE1pSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZzZFdWelBTSXhPeUF5TUNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVd4alRXOWtaVDBpYzNCc2FXNWxJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHdGxlVlJwYldWelBTSXdPeUF4SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVZOd2JHbHVaWE05SWpBdU1UWTFMQ0F3TGpnMExDQXdMalEwTENBeElpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGNHVmhkRU52ZFc1MFBTSnBibVJsWm1sdWFYUmxJaUF2UGlBZ0lDQWdJRHhoYm1sdFlYUmxJR0YwZEhKcFluVjBaVTVoYldVOUluTjBjbTlyWlMxdmNHRmphWFI1SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0psWjJsdVBTSXdjeUlnWkhWeVBTSXhMamh6SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoYkhWbGN6MGlNVHNnTUNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVd4alRXOWtaVDBpYzNCc2FXNWxJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHdGxlVlJwYldWelBTSXdPeUF4SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVZOd2JHbHVaWE05SWpBdU15d2dNQzQyTVN3Z01DNHpOVFVzSURFaUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21Wd1pXRjBRMjkxYm5ROUltbHVaR1ZtYVc1cGRHVWlJQzgrSUNBZ0lEd3ZZMmx5WTJ4bFBpQWdJQ0E4WTJseVkyeGxJR040UFNJeU1pSWdZM2s5SWpJeUlpQnlQU0l4SWo0Z0lDQWdJQ0E4WVc1cGJXRjBaU0JoZEhSeWFXSjFkR1ZPWVcxbFBTSnlJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHSmxaMmx1UFNJdE1DNDVjeUlnWkhWeVBTSXhMamh6SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoYkhWbGN6MGlNVHNnTWpBaUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTJGc1kwMXZaR1U5SW5Od2JHbHVaU0lnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnJaWGxVYVcxbGN6MGlNRHNnTVNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JyWlhsVGNHeHBibVZ6UFNJd0xqRTJOU3dnTUM0NE5Dd2dNQzQwTkN3Z01TSWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYQmxZWFJEYjNWdWREMGlhVzVrWldacGJtbDBaU0lnTHo0Z0lDQWdJQ0E4WVc1cGJXRjBaU0JoZEhSeWFXSjFkR1ZPWVcxbFBTSnpkSEp2YTJVdGIzQmhZMmwwZVNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpWldkcGJqMGlMVEF1T1hNaUlHUjFjajBpTVM0NGN5SWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllXeDFaWE05SWpFN0lEQWlJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyRnNZMDF2WkdVOUluTndiR2x1WlNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JyWlhsVWFXMWxjejBpTURzZ01TSWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCclpYbFRjR3hwYm1WelBTSXdMak1zSURBdU5qRXNJREF1TXpVMUxDQXhJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjR1ZoZEVOdmRXNTBQU0pwYm1SbFptbHVhWFJsSWlBdlBpQWdJQ0E4TDJOcGNtTnNaVDRnSUR3dlp6NDhMM04yWno0PVwiPjwvZGl2Pic7XG5jb25zdCBsZXRzZWVTdHlsZSA9IFtcblx0YEBmb250LWZhY2V7Zm9udC1mYW1pbHk6Um9ib3RvO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtzcmM6dXJsKGh0dHBzOi8vY2RuLmxldHNlZS5pby9mb250L3JvYm90by00MDAud29mZikgZm9ybWF0KCd3b2ZmJyl9YCxcblx0YC5sZXRzZWVTdGF0dXMsLmxldHNlZUxvYWRlcntmb250LWZhbWlseTogJ1JvYm90bycsIHNhbnMtc2VyaWY7fWAsXG5cdGAjbGV0c2VlV3JhcHBlcj5kaXZ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmZpeGVkIWltcG9ydGFudDt3aWR0aDoxMDAlIWltcG9ydGFudDtoZWlnaHQ6MTAwJSFpbXBvcnRhbnQ7ei1pbmRleDoxMDAwMDAwMCFpbXBvcnRhbnQ7YmFja2dyb3VuZDojZmZmIWltcG9ydGFudDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDt0ZXh0LWFsaWduOmNlbnRlcn1gLFxuXHRgLmxldHNlZUxvYWRlciBpbWd7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O2xlZnQ6NTAlIWltcG9ydGFudDt0b3A6NTAlIWltcG9ydGFudDt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSkhaW1wb3J0YW50O3dpZHRoOjUwcHghaW1wb3J0YW50O2hlaWdodDo1MHB4IWltcG9ydGFudH1gLFxuXHRgLmxldHNlZS1sb2FkaW5nICNsZXRzZWVXcmFwcGVyIC5sZXRzZWVMb2FkZXJ7ZGlzcGxheTpibG9ja31gLFxuXHRgLmxldHNlZS1zdGF0dXMgI2xldHNlZVdyYXBwZXIgLmxldHNlZVN0YXR1c3tkaXNwbGF5OmJsb2NrfWAsXG5cdGBib2R5LmFyLW1vZGUtb2ZmIC5hci1yZW5kZXJlcntkaXNwbGF5Om5vbmUhaW1wb3J0YW50O31gXG5dO1xuY29uc3Qgc3RhdHVzSHRtbCA9ICh0eXBlKSA9PiB7XG5cdGxldCBfaHRtbDtcblx0XG5cdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgMTAxOlxuXHRcdFx0X2h0bWwgPSBgPGRpdiBjbGFzcz1cInRpdGxlXCI+PGgyPlVzZSBzYWZhcmkgZm9yIGF3ZXNvbWUgQVIgYXBwIHdpdGggaVBob25lPC9oMj48L2Rpdj48ZGl2IGNsYXNzPVwiYm9keVwiPjxwIGlkPVwiY29weVRleHRcIiBjbGFzcz1cInVybFwiPiR7d2luZG93LmxvY2F0aW9uLmhyZWZ9PC9wPjxwIGNsYXNzPVwidGV4dFwiPkNvcHkgdXJsIGFuZCBwYXN0ZSB0byBzYWZhcmkuPC9wPjwvZGl2PjxzY3JpcHQ+ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb3B5VGV4dFwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpeyFmdW5jdGlvbihlKXtjb25zdCB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0QXJlYVwiKTtsZXQgbixvO3QudmFsdWU9ZSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpLG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lwYWR8aXBob25lL2kpPygobj1kb2N1bWVudC5jcmVhdGVSYW5nZSgpKS5zZWxlY3ROb2RlQ29udGVudHModCksKG89d2luZG93LmdldFNlbGVjdGlvbigpKS5yZW1vdmVBbGxSYW5nZXMoKSxvLmFkZFJhbmdlKG4pLHQuc2V0U2VsZWN0aW9uUmFuZ2UoMCw5OTk5OTkpKTp0LnNlbGVjdCgpLGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKSxkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHQpfShlLnRhcmdldC50ZXh0Q29udGVudCl9KTs8L3NjcmlwdD5gOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDEwMjpcblx0XHRcdF9odG1sID0gJzxkaXYgY2xhc3M9XCJ0aXRsZVwiPjxoMj5VbnN1cHBvcnRlZCBicm93c2VyPC9oMj48L2Rpdj48ZGl2IGNsYXNzPVwiYm9keVwiPjxwIGNsYXNzPVwidGV4dFwiPlBsZWFzZSB1c2UgQ2hyb21lLCBGaXJlZm94LCBpT1MgMTEsIEFuZHJvaWQgNSBvciBoaWdoZXIsIFNhZmFyaSAxMSBvciBoaWdoZXI8L3A+PC9kaXY+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDM6XG5cdFx0XHRfaHRtbCA9ICc8ZGl2IGNsYXNzPVwidGl0bGVcIj48aDI+Tm8gY2FtZXJhIGRldGVjdGVkPC9oMj48L2Rpdj48ZGl2IGNsYXNzPVwiYm9keVwiPjxwIGNsYXNzPVwidGV4dFwiPlBsZWFzZSBpbnN0YWxsIGFuIGV4dGVybmFsIHdlYmNhbSBkZXZpY2UuPC9wPjwvZGl2Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMTA0OlxuXHRcdFx0X2h0bWwgPSAnPGRpdiBjbGFzcz1cInRpdGxlXCI+PGgyPk5vIG1vYmlsZSBkZXZpY2UgZGV0ZWN0ZWQ8L2gyPjwvZGl2PjxkaXYgY2xhc3M9XCJib2R5XCI+PHAgY2xhc3M9XCJ0ZXh0XCI+UGxlYXNlIHVzZSBtb2JpbGUgYnJvd3Nlci48L3A+PC9kaXY+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDU6XG5cdFx0XHRfaHRtbCA9ICc8ZGl2IGNsYXNzPVwidGl0bGVcIj48aDI+Q2FtZXJhIGRlbmllZDwvaDI+PC9kaXY+PGRpdiBjbGFzcz1cImJvZHlcIj48cCBjbGFzcz1cInRleHRcIj5QbGVhc2UgYWxsb3cgY2FtZXJhIHBlcm1pc3Npb24uPC9wPjwvZGl2Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRfaHRtbCA9ICc8ZGl2IGNsYXNzPVwidGl0bGVcIj48aDI+R2VuZXJhbCBlcnJvcjwvaDI+PC9kaXY+PGRpdiBjbGFzcz1cImJvZHlcIj48cCBjbGFzcz1cInRleHRcIj5HZW5lcmFsIGVycm9yPC9wPjwvZGl2Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0fVxuXHRyZXR1cm4gX2h0bWw7XG59O1xuXG5jb25zdCBzdGF0dXNDc3MgPSAodHlwZSkgPT4ge1xuXHRsZXQgX2Nzcztcblx0XG5cdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgMTAxOlxuXHRcdFx0X2NzcyA9IFtdO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDI6XG5cdFx0XHRfY3NzID0gW107XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDEwMzpcblx0XHRcdF9jc3MgPSBbXTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMTA0OlxuXHRcdFx0X2NzcyA9IFtdO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDU6XG5cdFx0XHRfY3NzID0gW107XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0X2NzcyA9IFtdO1xuXHR9XG5cdHJldHVybiBfY3NzO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxldHNlZVdyYXBwZXIgPSAoKSA9PiB7XG5cdHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHRkb2N1bWVudC5oZWFkLmFwcGVuZChzdHlsZSk7XG5cdGxldHNlZVN0eWxlLmZvckVhY2goKHZhbCwgaW5kZXgpID0+IHtcblx0XHRzdHlsZS5zaGVldC5pbnNlcnRSdWxlKHZhbCwgaW5kZXgpO1xuXHR9KTtcblx0bGV0c2VlV3JhcHBlci5pZCA9ICdsZXRzZWVXcmFwcGVyJztcblx0XG5cdGxldHNlZUxvYWRlci5jbGFzc0xpc3QuYWRkKCdsZXRzZWVMb2FkZXInKTtcblx0bGV0c2VlU3RhdHVzLmNsYXNzTGlzdC5hZGQoJ2xldHNlZVN0YXR1cycpO1xuXHRsZXRzZWVXcmFwcGVyLmFwcGVuZENoaWxkKGxldHNlZUxvYWRlcik7XG5cdGxldHNlZVdyYXBwZXIuYXBwZW5kQ2hpbGQobGV0c2VlU3RhdHVzKTtcblx0XG5cdGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKGxldHNlZVdyYXBwZXIsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTG9hZGVyID0gKF9odG1sID0gZGVmYXVsdExvYWRlckNvbnRlbnQsIF9jc3MgPSBudWxsKSA9PiB7XG5cdGlmIChfY3NzKSB7XG5cdFx0X2Nzcy5mb3JFYWNoKCh2YWwsIGluZGV4KSA9PiB7XG5cdFx0XHRzdHlsZS5zaGVldC5pbnNlcnRSdWxlKHZhbCwgaW5kZXgpO1xuXHRcdH0pO1xuXHR9XG5cdGxldHNlZUxvYWRlci5pbm5lckhUTUwgPSAnJztcblx0bGV0c2VlTG9hZGVyLmlubmVySFRNTCA9IF9odG1sO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YXR1c1NjcmVlbiA9ICh0eXBlKSA9PiB7XG5cdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShNZXNzYWdlLkxFVFNFRV9DU1MuTEVUU0VFX0xPQURJTkcpO1xuXHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoTWVzc2FnZS5MRVRTRUVfQ1NTLkxFVFNFRV9TVEFUVVMpO1xuXHRsZXRzZWVTdGF0dXMuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXR1cy1jb2RlJywgdHlwZSk7XG5cdGxldHNlZVN0YXR1cy5pbm5lckhUTUwgPSBzdGF0dXNIdG1sKHR5cGUpO1xuXHRcblx0c3RhdHVzQ3NzKHR5cGUpLmZvckVhY2goKHZhbCwgaW5kZXgpID0+IHtcblx0XHRzdHlsZS5zaGVldC5pbnNlcnRSdWxlKHZhbCwgaW5kZXgpO1xuXHR9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRWaWV3cG9ydCA9ICgpID0+IHtcblx0Y29uc3Qgdmlld1BvcnRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG5cdFxuXHR2aWV3UG9ydFRhZy5pZCA9ICd2aWV3cG9ydCc7XG5cdHZpZXdQb3J0VGFnLm5hbWUgPSAndmlld3BvcnQnO1xuXHR2aWV3UG9ydFRhZy5jb250ZW50ID0gJ21pbmltdW0tc2NhbGU9MS4wLCB3aWR0aD1kZXZpY2Utd2lkdGgsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ubywgdmlld3BvcnQtZml0PWNvdmVyJztcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZCh2aWV3UG9ydFRhZyk7XG59O1xuZXhwb3J0IGNvbnN0IGxvYWRJbWFnZSA9IHBhdGggPT4ge1xuXHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblx0XG5cdGltZy5zcmMgPSBwYXRoO1xuXHRpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpbWcub25sb2FkID0gKCkgPT4ge1xuXHRcdFx0aWYgKChpbWcubmF0dXJhbFdpZHRoICogaW1nLm5hdHVyYWxIZWlnaHQpID4gNjQwMDAwKSB7XG5cdFx0XHRcdHJlamVjdCgnVG9vIGxhcmdlIHJlZmZlcmVuY2UgaW1hZ2UnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRcdFx0Y29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYW52YXMud2lkdGggPSBpbWcubmF0dXJhbFdpZHRoO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaW1nLm5hdHVyYWxIZWlnaHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cdFx0XHRcdGxldCB7d2lkdGgsIGhlaWdodCwgZGF0YX0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXNvbHZlKHtcblx0XHRcdFx0XHQvLyB1cmk6IHVyaSxcblx0XHRcdFx0XHRpbWc6IHtcblx0XHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0XHRcdFx0ZGF0YTogZGF0YVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG59O1xuXG5leHBvcnQgY29uc3QgVVVJRCA9ICgpID0+IHtcblx0bGV0IGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XG5cdGlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcblx0XHRkICs9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyB1c2UgaGlnaC1wcmVjaXNpb24gdGltZXIgaWYgYXZhaWxhYmxlXG5cdH1cblx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRsZXQgciA9IChkICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcblx0XHRcblx0XHRkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuXHRcdHJldHVybiAoYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KSkudG9TdHJpbmcoMTYpO1xuXHR9KTtcbn07XG5cbmNvbnN0IGlzV2ViUlRDU3VwcG9ydGVkID0gKCkgPT4ge1xuXHQvLyAtLS0tLS0tLS0gRGV0ZWN0IGlmIHN5c3RlbSBzdXBwb3J0cyBXZWJSVEMgMS4wIG9yIFdlYlJUQyAxLjEuXG5cdGxldCBpc1dlYlJUQ1N1cHBvcnRlZCA9IGZhbHNlO1xuXHRcblx0WydSVENQZWVyQ29ubmVjdGlvbicsICd3ZWJraXRSVENQZWVyQ29ubmVjdGlvbicsICdtb3pSVENQZWVyQ29ubmVjdGlvbicsICdSVENJY2VHYXRoZXJlciddLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0aWYgKGlzV2ViUlRDU3VwcG9ydGVkKSByZXR1cm47XG5cdFx0aWYgKGl0ZW0gaW4gd2luZG93KSBpc1dlYlJUQ1N1cHBvcnRlZCA9IHRydWU7XG5cdH0pO1xuXHRyZXR1cm4gaXNXZWJSVENTdXBwb3J0ZWQ7XG59O1xuXG5jb25zdCBpc01vYmlsZSA9IHtcblx0QW5kcm9pZDogKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKSxcblx0QmxhY2tCZXJyeTogKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQmxhY2tCZXJyeXxCQjEwL2kpLFxuXHRpT1M6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvaSksXG5cdE9wZXJhOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9PcGVyYSBNaW5pL2kpLFxuXHRXaW5kb3dzOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9JRU1vYmlsZS9pKSxcblx0YW55OiAoKSA9PiAoaXNNb2JpbGUuQW5kcm9pZCgpIHx8IGlzTW9iaWxlLkJsYWNrQmVycnkoKSB8fCBpc01vYmlsZS5pT1MoKSB8fCBpc01vYmlsZS5PcGVyYSgpIHx8IGlzTW9iaWxlLldpbmRvd3MoKSksXG5cdGdldE9zTmFtZTogKCkgPT4ge1xuXHRcdGxldCBvc05hbWUgPSAnVW5rbm93biBPUyc7XG5cdFx0XG5cdFx0aWYgKGlzTW9iaWxlLkFuZHJvaWQoKSkgb3NOYW1lID0gJ0FuZHJvaWQnO1xuXHRcdGlmIChpc01vYmlsZS5CbGFja0JlcnJ5KCkpIG9zTmFtZSA9ICdCbGFja0JlcnJ5Jztcblx0XHRpZiAoaXNNb2JpbGUuaU9TKCkpIG9zTmFtZSA9ICdpT1MnO1xuXHRcdGlmIChpc01vYmlsZS5PcGVyYSgpKSBvc05hbWUgPSAnT3BlcmEgTWluaSc7XG5cdFx0aWYgKGlzTW9iaWxlLldpbmRvd3MoKSkgb3NOYW1lID0gJ1dpbmRvd3MnO1xuXHRcdHJldHVybiBvc05hbWU7XG5cdH1cbn07XG5cbi8vIGh0dHBzOi8vd3d3LndlYnNvY2tldC5vcmcvanMvc3R1ZmYuanMgKERldGVjdEJyb3dzZXIuanMpXG5leHBvcnQgY29uc3QgZ2V0QnJvd3NlckluZm8gPSAoKSA9PiB7XG5cdGNvbnN0IG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cdFxuXHRsZXQgaXNNb2JpbGVEZXZpY2UgPSAhISgvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJCMTB8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pfE1vYmlsZXxtb2JpbGUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcblx0bGV0IGlzRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpICE9PSAtMSAmJiAoISFuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiB8fCAhIW5hdmlnYXRvci5tc1NhdmVCbG9iKTtcblx0XG5cdGxldCBpc09wZXJhID0gISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDA7XG5cdGxldCBpc0ZpcmVmb3ggPSB0eXBlb2Ygd2luZG93Lkluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblx0bGV0IGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblx0bGV0IGlzQ2hyb21lID0gISF3aW5kb3cuY2hyb21lICYmICFpc09wZXJhO1xuXHRsZXQgaXNJRSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgIWlzRWRnZTtcblx0XG5cdGxldCBuVmVyID0gbmF2aWdhdG9yLmFwcFZlcnNpb247IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0bGV0IG5BZ3QgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHRsZXQgYnJvd3Nlck5hbWUgPSBuYXZpZ2F0b3IuYXBwTmFtZTtcblx0bGV0IGZ1bGxWZXJzaW9uID0gJycgKyBwYXJzZUZsb2F0KG5hdmlnYXRvci5hcHBWZXJzaW9uKTtcblx0bGV0IG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG5hdmlnYXRvci5hcHBWZXJzaW9uLCAxMCk7XG5cdGxldCBuYW1lT2Zmc2V0LCB2ZXJPZmZzZXQsIGl4O1xuXHRcblx0Ly8gYm90aCBhbmQgc2FmcmkgYW5kIGNocm9tZSBoYXMgc2FtZSB1c2VyQWdlbnRcblx0aWYgKGlzU2FmYXJpICYmICFpc0Nocm9tZSAmJiBuQWd0LmluZGV4T2YoJ0NyaU9TJykgIT09IC0xKSB7XG5cdFx0aXNTYWZhcmkgPSBmYWxzZTtcblx0XHRpc0Nocm9tZSA9IHRydWU7XG5cdH1cblx0XG5cdC8vIEluIE9wZXJhLCB0aGUgdHJ1ZSB2ZXJzaW9uIGlzIGFmdGVyICdPcGVyYScgb3IgYWZ0ZXIgJ1ZlcnNpb24nXG5cdGlmIChpc09wZXJhKSB7XG5cdFx0YnJvd3Nlck5hbWUgPSAnT3BlcmEnO1xuXHRcdHRyeSB7XG5cdFx0XHRmdWxsVmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQuc3BsaXQoJ09QUi8nKVsxXS5zcGxpdCgnICcpWzBdO1xuXHRcdFx0bWFqb3JWZXJzaW9uID0gZnVsbFZlcnNpb24uc3BsaXQoJy4nKVswXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRmdWxsVmVyc2lvbiA9ICcwLjAuMC4wJztcblx0XHRcdG1ham9yVmVyc2lvbiA9IDA7XG5cdFx0fVxuXHRcdC8vIEluIE1TSUUgdmVyc2lvbiA8PTEwLCB0aGUgdHJ1ZSB2ZXJzaW9uIGlzIGFmdGVyICdNU0lFJyBpbiB1c2VyQWdlbnQgLy8gSW4gSUUgMTEsIGxvb2sgZm9yIHRoZSBzdHJpbmcgYWZ0ZXIgJ3J2Oidcblx0fSBlbHNlIGlmIChpc0lFKSB7XG5cdFx0dmVyT2Zmc2V0ID0gbkFndC5pbmRleE9mKCdydjonKTtcblx0XHRpZiAodmVyT2Zmc2V0ID4gMCkgeyAvLyBJRSAxMVxuXHRcdFx0ZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyAzKTtcblx0XHR9IGVsc2UgeyAvLyBJRSAxMCBvciBlYXJsaWVyXG5cdFx0XHR2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ01TSUUnKTtcblx0XHRcdGZ1bGxWZXJzaW9uID0gbkFndC5zdWJzdHJpbmcodmVyT2Zmc2V0ICsgNSk7XG5cdFx0fVxuXHRcdGJyb3dzZXJOYW1lID0gJ0lFJztcblx0fSBlbHNlIGlmIChpc0Nocm9tZSkgeyAvLyBJbiBDaHJvbWUsIHRoZSB0cnVlIHZlcnNpb24gaXMgYWZ0ZXIgJ0Nocm9tZSdcblx0XHR2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ0Nocm9tZScpO1xuXHRcdGJyb3dzZXJOYW1lID0gJ0Nocm9tZSc7XG5cdFx0ZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyA3KTtcblx0fSBlbHNlIGlmIChpc1NhZmFyaSkgeyAvLyBJbiBTYWZhcmksIHRoZSB0cnVlIHZlcnNpb24gaXMgYWZ0ZXIgJ1NhZmFyaScgb3IgYWZ0ZXIgJ1ZlcnNpb24nXG5cdFx0dmVyT2Zmc2V0ID0gbkFndC5pbmRleE9mKCdTYWZhcmknKTtcblx0XHRcblx0XHRicm93c2VyTmFtZSA9ICdTYWZhcmknO1xuXHRcdGZ1bGxWZXJzaW9uID0gbkFndC5zdWJzdHJpbmcodmVyT2Zmc2V0ICsgNyk7XG5cdFx0XG5cdFx0aWYgKCh2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ1ZlcnNpb24nKSkgIT09IC0xKSB7XG5cdFx0XHRmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDgpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdWZXJzaW9uLycpICE9PSAtMSkge1xuXHRcdFx0ZnVsbFZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50LnNwbGl0KCdWZXJzaW9uLycpWzFdLnNwbGl0KCcgJylbMF07XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGlzRmlyZWZveCkgeyAvLyBJbiBGaXJlZm94LCB0aGUgdHJ1ZSB2ZXJzaW9uIGlzIGFmdGVyICdGaXJlZm94J1xuXHRcdHZlck9mZnNldCA9IG5BZ3QuaW5kZXhPZignRmlyZWZveCcpO1xuXHRcdGJyb3dzZXJOYW1lID0gJ0ZpcmVmb3gnO1xuXHRcdGZ1bGxWZXJzaW9uID0gbkFndC5zdWJzdHJpbmcodmVyT2Zmc2V0ICsgOCk7XG5cdFx0Ly8gSW4gbW9zdCBvdGhlciBicm93c2VycywgJ25hbWUvdmVyc2lvbicgaXMgYXQgdGhlIGVuZCBvZiB1c2VyQWdlbnRcblx0fSBlbHNlIGlmICgobmFtZU9mZnNldCA9IG5BZ3QubGFzdEluZGV4T2YoJyAnKSArIDEpIDwgKHZlck9mZnNldCA9IG5BZ3QubGFzdEluZGV4T2YoJy8nKSkpIHtcblx0XHRicm93c2VyTmFtZSA9IG5BZ3Quc3Vic3RyaW5nKG5hbWVPZmZzZXQsIHZlck9mZnNldCk7XG5cdFx0ZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyAxKTtcblx0XHRcblx0XHRpZiAoYnJvd3Nlck5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYnJvd3Nlck5hbWUudG9VcHBlckNhc2UoKSkge1xuXHRcdFx0YnJvd3Nlck5hbWUgPSBuYXZpZ2F0b3IuYXBwTmFtZTtcblx0XHR9XG5cdH1cblx0XG5cdGlmIChpc0VkZ2UpIHtcblx0XHRicm93c2VyTmFtZSA9ICdFZGdlJztcblx0XHRmdWxsVmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQuc3BsaXQoJ0VkZ2UvJylbMV07XG5cdFx0Ly8gZnVsbFZlcnNpb24gPSBwYXJzZUludChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLihcXGQrKSQvKVsyXSwgMTApLnRvU3RyaW5nKCk7XG5cdH1cblx0XG5cdC8vIHRyaW0gdGhlIGZ1bGxWZXJzaW9uIHN0cmluZyBhdCBzZW1pY29sb24vc3BhY2UvYnJhY2tldCBpZiBwcmVzZW50XG5cdGlmICgoaXggPSBmdWxsVmVyc2lvbi5zZWFyY2goL1s7IFxcKV0vKSkgIT09IC0xKSB7XG5cdFx0ZnVsbFZlcnNpb24gPSBmdWxsVmVyc2lvbi5zdWJzdHJpbmcoMCwgaXgpO1xuXHR9XG5cdFxuXHRtYWpvclZlcnNpb24gPSBwYXJzZUludCgnJyArIGZ1bGxWZXJzaW9uLCAxMCk7XG5cdFxuXHRpZiAoaXNOYU4obWFqb3JWZXJzaW9uKSkge1xuXHRcdGZ1bGxWZXJzaW9uID0gJycgKyBwYXJzZUZsb2F0KG5hdmlnYXRvci5hcHBWZXJzaW9uKTtcblx0XHRtYWpvclZlcnNpb24gPSBwYXJzZUludChuYXZpZ2F0b3IuYXBwVmVyc2lvbiwgMTApO1xuXHR9XG5cdFxuXHRyZXR1cm4ge1xuXHRcdCdmdWxsVmVyc2lvbic6IGZ1bGxWZXJzaW9uLFxuXHRcdCd2ZXJzaW9uJzogbWFqb3JWZXJzaW9uLFxuXHRcdCduYW1lJzogYnJvd3Nlck5hbWUsXG5cdFx0J2lzUHJpdmF0ZUJyb3dzaW5nJzogZmFsc2UsXG5cdFx0J2lzTW9iaWxlRGV2aWNlJzogaXNNb2JpbGVEZXZpY2UsXG5cdFx0J2lzV2ViUlRDU3VwcG9ydGVkJzogaXNXZWJSVENTdXBwb3J0ZWQoKSxcblx0XHQnb3NOYW1lJzogaXNNb2JpbGUuZ2V0T3NOYW1lKClcblx0fTtcbn07XG5cbmV4cG9ydCBjb25zdCBoYXNXYmNhbSA9IChkZXZpY2VzKSA9PiB7XG5cdGxldCBoYXNXZWJjYW0gPSBmYWxzZTtcblx0bGV0IGRldmljZUxpc3QgPSBbXTtcblx0XG5cdGRldmljZXMuZm9yRWFjaChkZXZpY2UgPT4ge1xuXHRcdGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG5cdFx0XHRoYXNXZWJjYW0gPSB0cnVlO1xuXHRcdFx0ZGV2aWNlTGlzdC5wdXNoKGRldmljZS5kZXZpY2VJZCk7XG5cdFx0fVxuXHR9KTtcblx0XG5cdC8vIHJldHVybiB7aGFzV2ViY2FtOiBoYXNXZWJjYW0sIGRldmljZUxpc3Q6IGRldmljZUxpc3R9O1xuXHRyZXR1cm4gaGFzV2ViY2FtO1xuXHRcblx0Ly8gZGV2aWNlcy5mb3JFYWNoKChfZGV2aWNlKSA9PiB7XG5cdC8vICAgY29uc3QgZGV2aWNlID0ge307XG5cdC8vXG5cdC8vICAgZm9yIChjb25zdCBkIGluIF9kZXZpY2UpIHtcblx0Ly8gICAgIHRyeSB7XG5cdC8vICAgICAgIGlmICh0eXBlb2YgX2RldmljZVtkXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHQvLyAgICAgICAgIGRldmljZVtkXSA9IF9kZXZpY2VbZF07XG5cdC8vICAgICAgIH1cblx0Ly8gICAgIH0gY2F0Y2ggKGUpIHt9XG5cdC8vICAgfVxuXHQvL1xuXHQvL1xuXHQvLyAgIC8vIGlmIGl0IGlzIE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlc1xuXHQvLyAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ2F1ZGlvJykge1xuXHQvLyAgICAgZGV2aWNlLmtpbmQgPSAnYXVkaW9pbnB1dCc7XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvJykge1xuXHQvLyAgICAgZGV2aWNlLmtpbmQgPSAndmlkZW9pbnB1dCc7XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmICghZGV2aWNlLmRldmljZUlkKSB7XG5cdC8vICAgICBkZXZpY2UuZGV2aWNlSWQgPSBkZXZpY2UuaWQ7XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmICghZGV2aWNlLmlkKSB7XG5cdC8vICAgICBkZXZpY2UuaWQgPSBkZXZpY2UuZGV2aWNlSWQ7XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmICghZGV2aWNlLmxhYmVsKSB7XG5cdC8vICAgICBkZXZpY2UuaXNDdXN0b21MYWJlbCA9IHRydWU7XG5cdC8vXG5cdC8vICAgICBpZiAoZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuXHQvLyAgICAgICBkZXZpY2UubGFiZWwgPSAnQ2FtZXJhICcgKyAodmlkZW9JbnB1dERldmljZXMubGVuZ3RoICsgMSk7XG5cdC8vICAgICB9IGVsc2UgaWYgKGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCcpIHtcblx0Ly8gICAgICAgZGV2aWNlLmxhYmVsID0gJ01pY3JvcGhvbmUgJyArIChhdWRpb0lucHV0RGV2aWNlcy5sZW5ndGggKyAxKTtcblx0Ly8gICAgIH0gZWxzZSBpZiAoZGV2aWNlLmtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcblx0Ly8gICAgICAgZGV2aWNlLmxhYmVsID0gJ1NwZWFrZXIgJyArIChhdWRpb091dHB1dERldmljZXMubGVuZ3RoICsgMSk7XG5cdC8vICAgICB9IGVsc2Uge1xuXHQvLyAgICAgICBkZXZpY2UubGFiZWwgPSAnUGxlYXNlIGludm9rZSBnZXRVc2VyTWVkaWEgb25jZS4nO1xuXHQvLyAgICAgfVxuXHQvL1xuXHQvLyAgICAgaWYgKHR5cGVvZiBEZXRlY3RSVEMgIT09ICd1bmRlZmluZWQnICYmIERldGVjdFJUQy5icm93c2VyLmlzQ2hyb21lICYmIERldGVjdFJUQy5icm93c2VyLnZlcnNpb24gPj0gNDYgJiYgIS9eKGh0dHBzOnxjaHJvbWUtZXh0ZW5zaW9uOikkL2cudGVzdChsb2NhdGlvbi5wcm90b2NvbCB8fCAnJykpIHtcblx0Ly8gICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmRvbWFpbiA9PT0gJ3N0cmluZycgJiYgZG9jdW1lbnQuZG9tYWluLnNlYXJjaCAmJiBkb2N1bWVudC5kb21haW4uc2VhcmNoKC9sb2NhbGhvc3R8MTI3LjAuL2cpID09PSAtMSkge1xuXHQvLyAgICAgICAgIGRldmljZS5sYWJlbCA9ICdIVFRQcyBpcyByZXF1aXJlZCB0byBnZXQgbGFiZWwgb2YgdGhpcyAnICsgZGV2aWNlLmtpbmQgKyAnIGRldmljZS4nO1xuXHQvLyAgICAgICB9XG5cdC8vICAgICB9XG5cdC8vICAgfSBlbHNlIHtcblx0Ly8gICAgIC8vIEZpcmVmb3ggb24gQW5kcm9pZCBzdGlsbCByZXR1cm5zIGVtcHR5IGxhYmVsXG5cdC8vICAgICBpZiAoZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0JyAmJiAhaXNXZWJzaXRlSGFzV2ViY2FtUGVybWlzc2lvbnMpIHtcblx0Ly8gICAgICAgaXNXZWJzaXRlSGFzV2ViY2FtUGVybWlzc2lvbnMgPSB0cnVlO1xuXHQvLyAgICAgfVxuXHQvL1xuXHQvLyAgICAgaWYgKGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCcgJiYgIWlzV2Vic2l0ZUhhc01pY3JvcGhvbmVQZXJtaXNzaW9ucykge1xuXHQvLyAgICAgICBpc1dlYnNpdGVIYXNNaWNyb3Bob25lUGVybWlzc2lvbnMgPSB0cnVlO1xuXHQvLyAgICAgfVxuXHQvLyAgIH1cblx0Ly9cblx0Ly8gICBpZiAoZGV2aWNlLmtpbmQgPT09ICdhdWRpb2lucHV0Jykge1xuXHQvLyAgICAgaGFzTWljcm9waG9uZSA9IHRydWU7XG5cdC8vXG5cdC8vICAgICBpZiAoYXVkaW9JbnB1dERldmljZXMuaW5kZXhPZihkZXZpY2UpID09PSAtMSkge1xuXHQvLyAgICAgICBhdWRpb0lucHV0RGV2aWNlcy5wdXNoKGRldmljZSk7XG5cdC8vICAgICB9XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuXHQvLyAgICAgaGFzU3BlYWtlcnMgPSB0cnVlO1xuXHQvL1xuXHQvLyAgICAgaWYgKGF1ZGlvT3V0cHV0RGV2aWNlcy5pbmRleE9mKGRldmljZSkgPT09IC0xKSB7XG5cdC8vICAgICAgIGF1ZGlvT3V0cHV0RGV2aWNlcy5wdXNoKGRldmljZSk7XG5cdC8vICAgICB9XG5cdC8vICAgfVxuXHQvL1xuXHQvLyAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG5cdC8vICAgICBoYXNXZWJjYW0gPSB0cnVlO1xuXHQvL1xuXHQvLyAgICAgaWYgKHZpZGVvSW5wdXREZXZpY2VzLmluZGV4T2YoZGV2aWNlKSA9PT0gLTEpIHtcblx0Ly8gICAgICAgdmlkZW9JbnB1dERldmljZXMucHVzaChkZXZpY2UpO1xuXHQvLyAgICAgfVxuXHQvLyAgIH1cblx0Ly9cblx0Ly8gICAvLyB0aGVyZSBpcyBubyAndmlkZW9vdXB1dCcgaW4gdGhlIHNwZWMuXG5cdC8vICAgTWVkaWFEZXZpY2VzLnB1c2goZGV2aWNlKTtcblx0Ly9cblx0Ly8gICBhbHJlYWR5VXNlZERldmljZXNbZGV2aWNlLmRldmljZUlkICsgZGV2aWNlLmxhYmVsICsgZGV2aWNlLmtpbmRdID0gZGV2aWNlO1xuXHQvLyB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjaHVuayA9IChhcnIsIGNodW5rU2l6ZSA9IDEsIGNhY2hlID0gW10pID0+IHtcblx0Y29uc3QgdG1wID0gWy4uLmFycl07XG5cdFxuXHRpZiAoY2h1bmtTaXplIDw9IDApIHJldHVybiBjYWNoZTtcblx0d2hpbGUgKHRtcC5sZW5ndGgpIGNhY2hlLnB1c2godG1wLnNwbGljZSgwLCBjaHVua1NpemUpKTtcblx0cmV0dXJuIGNhY2hlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBhcmUgZXF1YWwgdG8gYGVsZW1lbnRgLiBUaGUgYGFycmF5YFxuICogcGFyYW1ldGVyIGlzIG1vZGlmaWVkIGFmdGVyIHRoaXMgZXhwb3J0IGZ1bmN0aW9uIGNhbGwuXG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBtZXRob2QgcmVtb3ZlQXJyYXlJdGVtXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHBhcmFtIHsqfSBlbGVtZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKiBsZXQgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gKiByZW1vdmVBcnJheUl0ZW0oYXJyYXksIDEpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsyLCAzLCA0XVxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXJyYXlJdGVtID0gKGFycmF5LCBlbGVtZW50KSA9PiB7XG5cdGxldCBpZHggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xuXHRcblx0aWYgKGlkeCA+IC0xKSBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc051bGwgPSAodmFsdWUpID0+IHZhbHVlID09PSBudWxsO1xuZXhwb3J0IGNvbnN0IGlzTmlsID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuLy9cbi8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3B5VGV4dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbiAoKSB7XG4vLyAgIChmdW5jdGlvbih0ZXh0KSB7XG4vLyAgICAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0QXJlYScpO1xuLy8gICAgIGxldCByYW5nZSxcbi8vICAgICAgIHNlbGVjdGlvbjtcbi8vXG4vLyAgICAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xuLy8gICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpO1xuLy8gICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pcGFkfGlwaG9uZS9pKSkge1xuLy8gICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuLy8gICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHRBcmVhKTtcbi8vICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbi8vICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbi8vICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4vLyAgICAgICB0ZXh0QXJlYS5zZXRTZWxlY3Rpb25SYW5nZSgwLCA5OTk5OTkpO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICB0ZXh0QXJlYS5zZWxlY3QoKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4vLyAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XG4vLyAgIH0pKGUudGFyZ2V0LnRleHRDb250ZW50KTtcbi8vIH0pXG5cbi8qXG5mdW5jdGlvbiBjbGlwYm9hcmQodGV4dCkge1xuICBjb25zdCB0ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRBcmVhJyk7XG4gIGxldCByYW5nZSxcbiAgICBzZWxlY3Rpb247XG5cbiAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKTtcbiAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lwYWR8aXBob25lL2kpKSB7XG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0QXJlYSk7XG4gICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHRleHRBcmVhLnNldFNlbGVjdGlvblJhbmdlKDAsIDk5OTk5OSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dEFyZWEuc2VsZWN0KCk7XG4gIH1cblxuICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKTtcbn07Ki9cbiIsImltcG9ydCBPYmplY3QzRCBmcm9tICcuL09iamVjdDNEJztcbmltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi9tYXRoL1ZlY3RvcjMnO1xuXG5jb25zdCBfdHlwZSA9ICdDYW1lcmEnO1xuXG4vKipcbiAqIFVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGlzIG9yIGRlcml2ZWQgY2xhc3NlcyBhcmUgY2FtZXJhcy4gWW91IHNob3VsZCBub3RcbiAqIGNoYW5nZSB0aGlzLCBhcyBpdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIGZvciBvcHRpbWlzYXRpb24uXG4gKiBAbWVtYmVyIHtib29sZWFufSBpc0NhbWVyYVxuICogQG1lbWJlcm9mIENhbWVyYS5wcm90b3R5cGVcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuY29uc3QgX2lzQ2FtZXJhID0gdHJ1ZTtcblxuXG4vKipcbiAqIEBpZ25vcmVcbiAqIEBjbGFzcyBDYW1lcmFcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNhbWVyYXMuIFRoaXMgY2xhc3Mgc2hvdWxkIGFsd2F5cyBiZSBpbmhlcml0ZWQgd2hlblxuICogeW91IGJ1aWxkIGEgbmV3IGNhbWVyYS4gTm90ZSB0aGF0IHRoaXMgY2xhc3MgaXMgbm90IGludGVuZGVkIHRvIGJlIGNhbGxlZFxuICogZGlyZWN0bHk7IFlvdSBwcm9iYWJseSB3YW50IGEge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhfSBvclxuICoge0BsaW5rIE9ydGhvZ3JhcGhpY0NhbWVyYX0gaW5zdGVhZC5cbiAqIEBleHRlbmRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfdHlwZTtcbiAgfVxuXG4gIGdldCBpc0NhbWVyYSgpIHtcbiAgICByZXR1cm4gX2lzQ2FtZXJhO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGludmVyc2Ugb2Yge0BsaW5rIE9iamVjdDNEI21hdHJpeFdvcmxkfS5cbiAgICoge0BsaW5rIE9iamVjdDNEI21hdHJpeFdvcmxkfSBjb250YWlucyB0aGUge0BsaW5rIE1hdHJpeDR9IHdoaWNoIGhhcyB0aGVcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgQ2FtZXJhfS5cbiAgICogQG1lbWJlciB7TWF0cml4NH0gbWF0cml4V29ybGRJbnZlcnNlXG4gICAqIEBtZW1iZXJvZiBDYW1lcmEjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgLy8gZ2V0IG1hdHJpeFdvcmxkSW52ZXJzZSgpIHtcbiAgLy8gICByZXR1cm4gbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIG1hdHJpeCB3aGljaCBjb250YWlucyB0aGUgcHJvamVjdGlvbi5cbiAgICogQG1lbWJlciB7TWF0cml4NH0gcHJvamVjdGlvbk1hdHJpeFxuICAgKiBAbWVtYmVyb2YgQ2FtZXJhI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIC8vIGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuICAvLyAgIHJldHVybiB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gIC8vIH1cbiAgLy9cbiAgLy8gc2V0IHByb2plY3Rpb25NYXRyaXgodmFsdWUpIHtcbiAgLy8gICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSB2YWx1ZTtcbiAgLy8gfVxuXG4gIC8vIGdldCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgLy8gfVxuICAvL1xuICAvLyBzZXQgcHJvamVjdGlvbk1hdHJpeEludmVyc2UodmFsdWUpIHtcbiAgLy8gICB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gdmFsdWU7XG4gIC8vIH1cblxuICBnZXQgd29ybGRaKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygwLCAwLCAtMSkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMud29ybGRRdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIHRoZSBjYW1lcmEgbG9vayBhdCB0aGUgdmVjdG9yIHBvc2l0aW9uIGluIHRoZSBnbG9iYWwgc3BhY2UgYXNcbiAgICogbG9uZyBhcyB0aGUgcGFyZW50IG9mIHRoaXMgY2FtZXJhIGlzIHRoZSBzY2VuZSBvciBhdCBwb3NpdGlvbiBgKDAsIDAsIDApYC5cbiAgICogQG1ldGhvZCBsb29rQXRcbiAgICogQG1lbWJlcm9mIENhbWVyYS5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gdGFyZ2V0IFBvc2l0aW9uIGluIDNEIHNwYWNlIGZvciB0aGUgY2FtZXJhIHRvIHBvaW50IHRvd2FyZHNcbiAgICovXG4gIGxvb2tBdCh0YXJnZXQpIHtcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIG0ubG9va0F0KHRoaXMucG9zaXRpb24sIHRhcmdldCwgdGhpcy51cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmE7XG4iLCJpbXBvcnQge2lzTmlsfSBmcm9tICcuLi9VdGlsJztcblxuLy8gT2JzZXJ2ZXIgRGF0YSBPYmplY3RcbmNvbnN0IEV2ZW50RGF0YSA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNsYXNzIEV2ZW50RGF0YU9iamVjdCB7XG4gIHN0YXRpYyBhZGRIYW5kbGVyKHRhcmdldCwgaGFuZGxlcnMpIHtcbiAgICBFdmVudERhdGEuc2V0KHRhcmdldCwgaGFuZGxlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIEV2ZW50RGF0YS5nZXQodGFyZ2V0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRIYW5kbGVyKHRhcmdldCwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gRXZlbnREYXRhLmdldCh0YXJnZXQpO1xuXG4gICAgaWYgKGlzTmlsKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSBkb2VzIG5vdCBleGlzdGA7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gY3VycmVudFRhcmdldC5nZXQodHlwZSk7XG5cbiAgICByZXR1cm4gKGlzTmlsKGV2ZW50SGFuZGxlcikpID8gYCR7dGFyZ2V0fSBkb2VzIG5vdCBoYXZlICR7ZXZlbnROYW1lfWAgOiBldmVudEhhbmRsZXI7XG4gIH1cbn1cblxuLy8gRW50aXR5IERhdGEgT2JqZWN0XG5jb25zdCBFbnRpdHlEYXRhID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY2xhc3MgRW50aXR5RGF0YU9iamVjdCB7XG4gIHN0YXRpYyBhZGRFbGVtZW50KGVsZW1lbnQsIG1hcCkge1xuICAgIEVudGl0eURhdGEuc2V0KGVsZW1lbnQsIG1hcCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RWxlbWVudChlbGUpIHtcbiAgICByZXR1cm4gRW50aXR5RGF0YS5nZXQoZWxlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBbGxFbGVtZW50cygpIHtcbiAgICByZXR1cm4gRW50aXR5RGF0YTtcbiAgfVxufVxuIiwiLy8gaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi9tYXRoL1ZlY3RvcjMnO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uJztcbmltcG9ydCBFdWxlciBmcm9tICcuLi9tYXRoL0V1bGVyJztcbmltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG5pbXBvcnQgT2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL09ic2VydmVyJztcbmltcG9ydCB7T0JKRUNUX0VWRU5UfSBmcm9tICcuLi9saWJzL01lc3NhZ2VUeXBlcyc7XG4vLyBpbXBvcnQge0VOVElUWV9FVkVOVH0gZnJvbSAnLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuLy8gaW1wb3J0IEVudGl0eUV2ZW50IGZyb20gJy4uL2V2ZW50L0VudGl0eUV2ZW50JztcblxubGV0IG9iamVjdElkID0gMDtcblxuLyoqXG4gKiBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgdGhpcyBvciBkZXJpdmVkIGNsYXNzZXMgYXJlIHtAbGluayBPYmplY3QzRH1zLiBZb3VcbiAqIHNob3VsZCBub3QgY2hhbmdlIHRoaXMsIGFzIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBmb3Igb3B0aW1pc2F0aW9uLlxuICogQG1lbWJlciB7Ym9vbGVhbn0gaXNPYmplY3QzRFxuICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5jb25zdCBfaXNPYmplY3QzRCA9IHRydWU7XG5cbmNvbnN0IF90eXBlID0gJ09iamVjdDNEJztcblxuY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKFxuICBbXG4gICAgW09CSkVDVF9FVkVOVC5PQkpFQ1RfQURERUQsIG5ldyBTZXQoKV0sXG4gICAgW09CSkVDVF9FVkVOVC5PQkpFQ1RfUkVNT1ZFRCwgbmV3IFNldCgpXVxuICBdKTtcblxuLyoqXG4gKiBAY2xhc3MgT2JqZWN0M0RcbiAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuICogQGNsYXNzZGVzY1xuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbW9zdCBvYmplY3RzIGFuZCBwcm92aWRlcyBhIHNldCBvZiBwcm9wZXJ0aWVzIGFuZFxuICogbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIG9iamVjdHMgaW4gM0Qgc3BhY2UuIE5vdGUgdGhhdCB0aGlzIGNhbiBiZSB1c2VkIGZvclxuICogZ3JvdXBpbmcgb2JqZWN0cyB2aWEgdGhlIHtAbGluayBPYmplY3QzRCNhZGR9IG1ldGhvZCB3aGljaCBhZGRzIHRoZSBvYmplY3RcbiAqIGFzIGEgY2hpbGQsIGhvd2V2ZXIgaXQgaXMgYmV0dGVyIHRvIHVzZSB7QGxpbmsgR3JvdXB9IGZvciB0aGlzLlxuICovXG4vLyBjbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYG9iamVjdF8ke29iamVjdElkfWAsIGhhbmRsZXJzKTtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbnVtYmVyIGZvciB0aGlzIG9iamVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGlkXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIC8vIHRoaXMuaWQgPSBvYmplY3RJZDtcblxuICAgIC8vIFRPRE8gQGRlZmF1bHRcbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0J3MgbG9jYWwgcG9zaXRpb24uXG4gICAgICogQG1lbWJlciB7VmVjdG9yM30gcG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgKDAsIDAsIDApXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0J3MgbG9jYWwgcm90YXRpb24gYXMgYSB7QGxpbmsgUXVhdGVybmlvbn0uXG4gICAgICogQG1lbWJlciB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICAgKi9cbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCdzIGxvY2FsIHNjYWxlLlxuICAgICAqIEBtZW1iZXIge1ZlY3RvcjN9IHNjYWxlXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEBkZWZhdWx0ICgxLCAxLCAxKVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUge0BsaW5rIE9iamVjdDNEI2xvb2tBdH0gbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG9cbiAgICAgKiBkZXRlcm1pbmUgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSByZXN1bHQuXG4gICAgICogQG1lbWJlciB7VmVjdG9yM30gdXBcbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgKDAsIDEsIDApXG4gICAgICovXG4gICAgdGhpcy51cCA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGdldHMgcmVuZGVyZWQgaWYgYHRydWVgLlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHZpc2libGVcbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy50cmFjayA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0J3MgcGFyZW50IGluIHRoZVxuICAgICAqIFtzY2VuZSBncmFwaF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NlbmVfZ3JhcGgpLlxuICAgICAqIEBtZW1iZXIge09iamVjdDNEfG51bGx9IHBhcmVudFxuICAgICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgd2l0aCBvYmplY3QncyBjaGlsZHJlbi4gU2VlIHtAbGluayBHcm91cH0gZm9yIGluZm8gb24gbWFudWFsbHlcbiAgICAgKiBncm91cGluZyBvYmplY3RzLlxuICAgICAqIEBtZW1iZXIge09iamVjdDNEW119IGNoaWxkcmVuXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIC8vIHRoaXMucm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuICAgIC8vIHRoaXMuaWQgPSBvYmplY3RJZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGBvYmplY3RfJHtvYmplY3RJZH1gXG4gICAgfSk7XG4gICAgb2JqZWN0SWQrKztcblxuICB9XG5cbiAgLy8gZ2V0IGlkKCkge1xuICAvLyAgIHJldHVybiBvYmplY3RJZDtcbiAgLy8gfTtcbiAgLy8gZ2V0IHBhcmVudCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIC8vIH07XG4gIC8vXG4gIC8vIHNldCBwYXJlbnQodmFsdWUpIHtcbiAgLy8gICB0aGlzLnBhcmVudCA9IHZhbHVlO1xuICAvLyB9XG4gIC8vXG4gIC8vIGdldCBjaGlsZHJlbigpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgLy8gfTtcblxuICAvLyBnZXQgcG9zaXRpb24oKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIC8vIH07XG4gIC8vIGdldCBxdWF0ZXJuaW9uKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnF1YXRlcm5pb247XG4gIC8vIH07XG4gIC8vIGdldCBzY2FsZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgLy8gfTtcbiAgLy8gZ2V0IHVwKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnVwO1xuICAvLyB9O1xuICAvLyBnZXQgdmlzaWJsZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAvLyB9O1xuICAvLyBnZXQgdHJhY2soKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gIC8vIH07XG4gIC8vXG4gIC8vIHNldCB0cmFjayh2YWx1ZSkge1xuICAvLyAgIHRoaXMudHJhY2sgPSB2YWx1ZTtcbiAgLy8gfVxuICBnZXQgaXNPYmplY3QzRCgpIHtcbiAgICByZXR1cm4gX2lzT2JqZWN0M0Q7XG4gIH07XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZCBzcGFjZS5cbiAgICogQG1lbWJlciB7VmVjdG9yM30gd29ybGRQb3NpdGlvblxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHpcbiAgICovXG4gIHRyYW5zbGF0ZSh4LCB5LCB6KSB7XG4gICAgY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICBjb25zdCB5QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuICAgIGNvbnN0IHpBeGlzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG4gICAgeEF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgeUF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgekF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgdGhpcy5wb3NpdGlvbi5hZGQoeEF4aXMubXVsdGlwbHlTY2FsYXIoeCkpO1xuICAgIHRoaXMucG9zaXRpb24uYWRkKHlBeGlzLm11bHRpcGx5U2NhbGFyKHkpKTtcbiAgICB0aGlzLnBvc2l0aW9uLmFkZCh6QXhpcy5tdWx0aXBseVNjYWxhcih6KSk7XG4gIH1cblxuICB0cmFuc2xhdGVYKHZhbHVlKSB7XG4gICAgY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICB4QXhpcy5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLnBvc2l0aW9uLmFkZCh4QXhpcy5tdWx0aXBseVNjYWxhcih2YWx1ZSkpO1xuICB9XG5cbiAgdHJhbnNsYXRlWSh2YWx1ZSkge1xuICAgIGNvbnN0IHlBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgeUF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgdGhpcy5wb3NpdGlvbi5hZGQoeUF4aXMubXVsdGlwbHlTY2FsYXIodmFsdWUpKTtcbiAgfVxuXG4gIHRyYW5zbGF0ZVoodmFsdWUpIHtcbiAgICBjb25zdCB6QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuICAgIHpBeGlzLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHRoaXMucG9zaXRpb24uYWRkKHpBeGlzLm11bHRpcGx5U2NhbGFyKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICBzZXQgcm90YXRpb24ocm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24uaXNFdWxlcikge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihyb3RhdGlvbik7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvbi5pc1F1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KHJvdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uLmlzTWF0cml4NCkge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21NYXRyaXgocm90YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JvdGF0aW9uIG11c3QgYmUgb25lIG9mIEV1bGVyLCBRdWF0ZXJuaW9uIG9yIE1hdHJpeDQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXVsZXIgYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZFxuICAgKiBzcGFjZS5cbiAgICogQG1lbWJlciB7RXVsZXJ9IHdvcmxkUm90YXRpb25cbiAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB3b3JsZFJvdGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbih0aGlzLndvcmxkUXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZFxuICAgKiBzcGFjZS5cbiAgICogQG1lbWJlciB7UXVhdGVybmlvbn0gd29ybGRRdWF0ZXJuaW9uXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd29ybGRRdWF0ZXJuaW9uKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UobmV3IFZlY3RvcjMoKSwgcmVzdWx0LCBuZXcgVmVjdG9yMygpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0IHdvcmxkWCgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoMSwgMCwgMCkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMud29ybGRRdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIGdldCB3b3JsZFkoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAsIDEsIDApLmFwcGx5UXVhdGVybmlvbih0aGlzLndvcmxkUXVhdGVybmlvbik7XG4gIH1cblxuICBnZXQgd29ybGRaKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24odGhpcy53b3JsZFF1YXRlcm5pb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZXMgdGhlIG9iamVjdCBhcm91bmQgeCBheGlzIGluIGxvY2FsIHNwYWNlLlxuICAgKiBAbWV0aG9kIHJvdGF0ZVhcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgcm90YXRlWChhbmdsZSkge1xuICAgIGNvbnN0IGF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KHEpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVzIHRoZSBvYmplY3QgYXJvdW5kIHkgYXhpcyBpbiBsb2NhbCBzcGFjZS5cbiAgICogQG1ldGhvZCByb3RhdGVZXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgaW4gcmFkaWFucy5cbiAgICovXG4gIHJvdGF0ZVkoYW5nbGUpIHtcbiAgICBjb25zdCBheGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgY29uc3QgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBxLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShxKTtcbiAgICB0aGlzLnJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlcyB0aGUgb2JqZWN0IGFyb3VuZCB6IGF4aXMgaW4gbG9jYWwgc3BhY2UuXG4gICAqIEBtZXRob2Qgcm90YXRlWlxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGluIHJhZGlhbnMuXG4gICAqL1xuICByb3RhdGVaKGFuZ2xlKSB7XG4gICAgY29uc3QgYXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgcS5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKTtcbiAgICB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkocSk7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIHNjYWxpbmcgZmFjdG9ycyBhcHBsaWVkIHRvIHRoZSBvYmplY3QgZm9yIGVhY2ggYXhpc1xuICAgKiBpbiB3b3JsZCBzcGFjZS5cbiAgICogQG1lbWJlciB7VmVjdG9yM30gd29ybGRTY2FsZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkU2NhbGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShuZXcgVmVjdG9yMygpLCBuZXcgUXVhdGVybmlvbigpLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXguXG4gICAqIEBtZW1iZXIge01hdHJpeDR9IG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgLy8gZ2V0IG1hdHJpeCgpIHtcbiAgLy8gICByZXR1cm4gbmV3IE1hdHJpeDQoKS5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gIC8vIH1cblxuICAvKipcbiAgICogVGhlIGdsb2JhbCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdC4gSWYgdGhlIG9iamVjdCBoYXMgbm8gcGFyZW50LCB0aGVuIGl0J3NcbiAgICogaWRlbnRpY2FsIHRvIHRoZSBsb2NhbCB0cmFuc2Zvcm0ge0BsaW5rIE9iamVjdDNEI21hdHJpeH0uXG4gICAqIEBtZW1iZXIge01hdHJpeDR9IG1hdHJpeFdvcmxkXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICAvLyBnZXQgbWF0cml4V29ybGQoKSB7XG4gIC8vICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIC8vICAgY29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gIC8vXG4gIC8vICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAvLyAgICAgcmV0dXJuIG1hdHJpeDtcbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIG1hdHJpeCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHZlY3RvciBmcm9tIGxvY2FsIHNwYWNlIHRvIHdvcmxkIHNwYWNlLlxuICAgKiBAbWV0aG9kIGxvY2FsVG9Xb3JsZFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHZlY3RvciBBIHZlY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBpbiBsb2NhbCAob2JqZWN0KSBzcGFjZS5cbiAgICogQHJldHVybiB7VmVjdG9yM31cbiAgICovXG4gIGxvY2FsVG9Xb3JsZCh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2ZWN0b3IgZnJvbSB3b3JsZCBzcGFjZSB0byBsb2NhbCBzcGFjZS5cbiAgICogQG1ldGhvZCB3b3JsZFRvTG9jYWxcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSB2ZWN0b3IgQSB3b3JsZCB2ZWN0b3IuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjN9XG4gICAqL1xuICB3b3JsZFRvTG9jYWwodmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQobmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGBvYmplY3RgIGFzIGNoaWxkIG9mIHRoaXMgb2JqZWN0LiBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG9iamVjdHMgbWF5XG4gICAqIGJlIGFkZGVkLiBTZWUge0BsaW5rIEdyb3VwfSBmb3IgaW5mbyBvbiBtYW51YWxseSBncm91cGluZyBvYmplY3RzLlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdFxuICAgKi9cbiAgYWRkKG9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMZXRzZWUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCkge1xuICAgICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgb2JqZWN0Lm5vdGlmeShPQkpFQ1RfRVZFTlQuT0JKRUNUX0FEREVEKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMZXRzZWUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIExldHNlZS5PYmplY3QzRC4nLCBvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIGlmIChvYmplY3QgJiYgb2JqZWN0ICE9PSB0aGlzICYmIG9iamVjdC5pc09iamVjdDNEKSB7XG4gICAgLy8gICBpZiAob2JqZWN0LnBhcmVudCkge1xuICAgIC8vICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgIC8vICAgfVxuICAgIC8vXG4gICAgLy8gICBpZiAoIXRoaXMuaXNTY2VuZSkge1xuICAgIC8vICAgICBvYmplY3QudHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIC8vICAgfVxuICAgIC8vXG4gICAgLy8gICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAvLyAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnYWRkZWQnfSk7XG4gICAgLy9cbiAgICAvLyAgIC8vIHRoaXMuY2hpbGRyZW4gPSBbXG4gICAgLy8gICAvLyAgIC4uLnRoaXMuY2hpbGRyZW4sXG4gICAgLy8gICAvLyAgIG9iamVjdCxcbiAgICAvLyAgIC8vIF07XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyAgIHRoaXMuYWRkKG9iamVjdFtpXSk7XG4gICAgLy8gfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9iamVjdGAgYXMgY2hpbGQgb2YgdGhpcyBvYmplY3QuIEFuIGFyYml0cmFyeSBudW1iZXIgb2Ygb2JqZWN0c1xuICAgKiBtYXkgYmUgZXJlbW92ZWQuXG4gICAqIEBtZXRob2QgcmVtb3ZlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG9iamVjdFxuICAgKi9cbiAgcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihvYmplY3QpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICBvYmplY3Qubm90aWZ5KE9CSkVDVF9FVkVOVC5PQkpFQ1RfUkVNT1ZFRCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2Yob2JqZWN0KTtcbiAgICAvL1xuICAgIC8vIGlmIChpbmRleCA+IC0xKSB7XG4gICAgLy8gICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAvLyAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KHt0eXBlOiAncmVtb3ZlZCd9KTtcbiAgICAvL1xuICAgIC8vICAgZm9yIChsZXQgY2hpbGQgb2Ygb2JqZWN0LmNoaWxkcmVuKSB7XG4gICAgLy8gICBvYmplY3QucmVtb3ZlKGNoaWxkKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyB0aGlzLmNoaWxkcmVuID0gW1xuICAgIC8vICAgLi4udGhpcy5jaGlsZHJlbi5zbGljZSgwLCBpbmRleCksXG4gICAgLy8gICAuLi50aGlzLmNoaWxkcmVuLnNsaWNlKGluZGV4ICsgMSksXG4gICAgLy8gXTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgLy8gICB0aGlzLnJlbW92ZShvdGhlcltpXSk7XG4gICAgLy8gfVxuICB9XG5cbiAgdXBkYXRlTWF0cml4KCkge1xuICAgIHRoaXMubWF0cml4LmNvbXBvc2UodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIGlmICh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2hpbGRyZW5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0udXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVdvcmxkTWF0cml4KHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKHVwZGF0ZVBhcmVudHMgPT09IHRydWUgJiYgcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNoaWxkcmVuXG5cbiAgICBpZiAodXBkYXRlQ2hpbGRyZW4gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbG9va0F0KHZlY3RvcjMpIHtcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIG0ubG9va0F0KHZlY3RvcjMsIHRoaXMucG9zaXRpb24sIHRoaXMudXApO1xuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgobSk7XG4gIH1cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG5cbiAgICB0aGlzLm1hdHJpeC5wcmVtdWx0aXBseShtYXRyaXgpO1xuXG4gICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG5cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgb2JqZWN0IGFuZCBvcHRpb25hbGx5IGFsbCBkZXNjZW5kYW50cy5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWN1cnNpdmU9dHJ1ZV0gSWYgdHJ1ZSwgZGVzY2VuZGFudHMgb2YgdGhlIG9iamVjdCBhcmUgYWxzbyBjbG9uZWQuXG4gICAqIEByZXR1cm4ge09iamVjdDNEfVxuICAgKi9cbiAgY2xvbmUocmVjdXJzaXZlID0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0M0QoKS5jb3B5KHRoaXMsIHJlY3Vyc2l2ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29weSB0aGUgZ2l2ZW4gYHNvdXJjZWAgb2JqZWN0IGludG8gdGhpcyBvYmplY3QuXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBzb3VyY2VcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT10cnVlXSBJZiB0cnVlLCBkZXNjZW5kYW50cyBvZiB0aGUgb2JqZWN0IGFyZSBhbHNvIGNvcGllZC5cbiAgICovXG4gIGNvcHkoc291cmNlLCByZWN1cnNpdmUgPSB0cnVlKSB7XG4gICAgdGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoc291cmNlLnF1YXRlcm5pb24pO1xuICAgIHRoaXMuc2NhbGUuY29weShzb3VyY2Uuc2NhbGUpO1xuICAgIHRoaXMudXAuY29weShzb3VyY2UuY29weSk7XG4gICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICBpZiAocmVjdXJzaXZlID09PSB0cnVlIHx8IHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlbltpXTtcblxuICAgICAgICB0aGlzLmFkZChjaGlsZC5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYGNhbGxiYWNrYCBvbiB0aGlzIG9iamVjdCBhbmQgYWxsIGRlc2NlbmRhbnRzLlxuICAgKiBAbWV0aG9kIHRyYXZlcnNlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gd2l0aCBhcyBmaXJzdCBhcmd1bWVudCBhbiB7QGxpbmsgT2JqZWN0M0R9IG9iamVjdC5cbiAgICovXG4gIHRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGhpcyk7XG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC50cmF2ZXJzZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSB7QGxpbmsgT2JqZWN0M0QjdHJhdmVyc2V9LCBidXQgdGhlIGBjYWxsYmFja2Agd2lsbCBvbmx5IGJlIGV4ZWN1dGVkXG4gICAqIGZvciB2aXNpYmxlIG9iamVjdHMuIERlc2NlbmRhbnRzIG9mIGludmlzaWJsZSBvYmplY3RzIGFyZSBub3QgdHJhdmVyc2VkLlxuICAgKiBAbWV0aG9kIHRyYXZlcnNlVmlzaWJsZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHdpdGggYXMgZmlyc3QgYXJndW1lbnQgYW4ge0BsaW5rIE9iamVjdDNEfSBvYmplY3QuXG4gICAqL1xuICB0cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBgY2FsbGJhY2tgIG9uIGFsbCBhbmNlc3RvcnMuXG4gICAqIEBtZXRob2QgdHJhdmVyc2VBbmNlc3RvcnNcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB3aXRoIGFzIGZpcnN0IGFyZ3VtZW50IGFuIHtAbGluayBPYmplY3QzRH0gb2JqZWN0LlxuICAgKi9cbiAgdHJhdmVyc2VBbmNlc3RvcnMoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKHBhcmVudCk7XG4gICAgICBwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHRyYXZlcnNlUmVuZGVyYWJsZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy50cmFjaykge1xuICAgICAgY2FsbGJhY2sodGhpcyk7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2VSZW5kZXJhYmxlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaywgLi4uYXJncykge1xuICAgIHN1cGVyLnN1YnNjcmliZSh0aGlzLmlkLCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRoaXMuaWQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG5vdGlmeSh0eXBlLCBldmVudCkge1xuICAgIGNvbnN0IGUgPSAoZXZlbnQpID8gZXZlbnQgOiB7fTtcblxuICAgIGUudGFyZ2V0ID0gdGhpcztcbiAgICBlLnR5cGUgPSB0eXBlO1xuICAgIHN1cGVyLm5vdGlmeSh0aGlzLmlkLCB0eXBlLCBlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDtcbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgZGVnVG9SYWQsIHJhZFRvRGVnLCBERUcyUkFELCBSQUQyREVHIH0gZnJvbSAnLi4vbWF0aC9NYXRoJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJzcGVjdGl2ZUNhbWVyYVZpZXdPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmdWxsV2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmdWxsSGVpZ2h0XG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0WFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxuICovXG4vLyB0eXBlIFBlcnNwZWN0aXZlQ2FtZXJhVmlld09mZnNldCA9IHtcbi8vICAgZnVsbFdpZHRoLFxuLy8gICBmdWxsSGVpZ2h0LFxuLy8gICBvZmZzZXRYLFxuLy8gICBvZmZzZXRZLFxuLy8gICB3aWR0aCxcbi8vICAgaGVpZ2h0LFxuLy8gfTtcbi8qXG5cblxuLyEqKlxuICogQ2FtZXJhIGZydXN0dW0gdmVydGljYWwgZmllbGQgb2YgdmlldywgZnJvbSBib3R0b20gdG8gdG9wIG9mIHZpZXcsIGluXG4gKiBkZWdyZWVzLlxuICogQG1lbWJlciB7bnVtYmVyfSBmb3ZcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IDUwXG4gKiEvXG5sZXQgdGhpcy5mb3YgPSA1MDtcbi8hKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgem9vbSBmYWN0b3Igb2YgdGhlIGNhbWVyYS5cbiAqIEBtZW1iZXIge251bWJlcn0gem9vbVxuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMVxuICohL1xubGV0IHRoaXMuem9vbSA9IDE7XG5cbi8hKipcbiAqIENhbWVyYSBmcnVzdHVtIG5lYXIgcGxhbmUuIFRoZSB2YWxpZCByYW5nZSBpcyBncmVhdGVyIHRoYW4gYDBgIGFuZCBsZXNzXG4gKiB0aGFuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjZmFyfSBwbGFuZS4gTm90ZVxuICogdGhhdCwgdW5saWtlIGZvciB0aGUge0BsaW5rIE9ydGhvZ3JhcGhpY0NhbWVyYX0sIGAwYCBpcyBfbm90XyBhIHZhbGlkIHZhbHVlXG4gKiBmb3IgYSB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmF9J3MgbmVhciBwbGFuZS5cbiAqIEBtZW1iZXIge251bWJlcn0gbmVhclxuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMC4xXG4gKiEvXG5sZXQgdGhpcy5uZWFyID0gMC4xO1xuXG4vISoqXG4gKiBDYW1lcmEgZnJ1c3R1bSBmYXIgcGxhbmUuIFRoZSB2YWxpZCByYW5nZSBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IHZhbHVlIG9mXG4gKiB0aGUge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI25lYXJ9IHBsYW5lIGFuZCBpbmZpbml0eS5cbiAqIEBtZW1iZXIge251bWJlcn0gZmFyXG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAyMDAwXG4gKiEvXG5sZXQgdGhpcy5mYXIgPSAyMDAwO1xuXG4vISoqXG4gKiBPYmplY3QgZGlzdGFuY2UgdXNlZCBmb3Igc3RlcmVvc2NvcHkgYW5kIGRlcHRoLW9mLWZpZWxkIGVmZmVjdHMuIFRoaXNcbiAqIHBhcmFtZXRlciBkb2VzIG5vdCBpbmZsdWVuY2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHVubGVzcyBhXG4gKiB7QGxpbmsgU3RlcmVvQ2FtZXJhfSBpcyBiZWluZyB1c2VkLlxuICogQG1lbWJlciB7bnVtYmVyfSBmb2N1c1xuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMTBcbiAqIS9cbmxldCB0aGlzLmZvY3VzID0gMTA7XG5cbi8hKipcbiAqIENhbWVyYSBmcnVzdHVtIGFzcGVjdCByYXRpbywgdXN1YWxseSB0aGUgY2FudmFzIHdpZHRoIC8gY2FudmFzIGhlaWdodC5cbiAqIEBtZW1iZXIge251bWJlcn0gYXNwZWN0XG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAxIChzcXVhcmUgY2FudmFzKVxuICohL1xubGV0IHRoaXMuYXNwZWN0ID0gMTtcblxuLyEqKlxuICogRnJ1c3R1bSB3aW5kb3cgc3BlY2lmaWNhdGlvbiBvciBgbnVsbGAuIFRoaXMgaXMgc2V0IHVzaW5nIHRoZVxuICoge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI3NldFZpZXdPZmZzZXR9IG1ldGhvZCBhbmQgY2xlYXJlZCB1c2luZ1xuICoge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2NsZWFyVmlld09mZnNldH0uXG4gKiBAbWVtYmVyIHtQZXJzcGVjdGl2ZUNhbWVyYVZpZXdPZmZzZXR9IHZpZXdcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IG51bGxcbiAqIS9cbmxldCB0aGlzLnZpZXcgPSBudWxsO1xuXG4vISoqXG4gKiBGaWxtIHNpemUgdXNlZCBmb3IgdGhlIGxhcmdlciBheGlzLiBUaGlzIHBhcmFtZXRlciBkb2VzIG5vdCBpbmZsdWVuY2UgdGhlXG4gKiBwcm9qZWN0aW9uIG1hdHJpeCB1bmxlc3Mge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2ZpbG1PZmZzZXR9IGlzIHNldCB0byBhXG4gKiBub256ZXJvIHZhbHVlLlxuICogQG1lbWJlciB7bnVtYmVyfSBmaWxtR2F1Z2VcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IDM1IChtaWxsaW1ldGVycylcbiAqIS9cbmxldCB0aGlzLmZpbG1HYXVnZSA9IDM1O1xuXG4vISoqXG4gKiBIb3Jpem9udGFsIG9mZi1jZW50ZXIgb2Zmc2V0IGluIHRoZSBzYW1lIHVuaXQgYXNcbiAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICogQG1lbWJlciB7bnVtYmVyfSBmaWxtT2Zmc2V0XG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAwXG4gKiEvXG5sZXQgdGhpcy5maWxtT2Zmc2V0ID0gMDtcblxuLyEqKlxuICogQ2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG4gKiBAbWVtYmVyIHtNYXRyaXg0fSBwcm9qZWN0aW9uTWF0cml4XG4gKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLmNhbWVyYVxuICohL1xuLy8gbGV0IF9wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuLyEqKlxuICogVXNlZCB0byB0ZXN0IHdoZXRoZXIgdGhpcyBvciBkZXJpdmVkIGNsYXNzZXMgYXJlXG4gKiB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmF9cy4gVGhpcyBzaG91bGQgbm90IGJlIGNoYW5nZWQgYXMgaXQgaXMgdXNlZFxuICogaW50ZXJuYWxseSBieSB0aGUgcmVuZGVyZXIgZm9yIG9wdGltaXNhdGlvbi5cbiAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUGVyc3BlY3RpdmVDYW1lcmFcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGVcbiAqIEBkZWZhdWx0IHRydWVcbiAqIS8qL1xuY29uc3QgaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5jb25zdCBfdHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBjYW1lcmFcbiAqIEBtZW1iZXJvZiBsZXRzZWVcbiAqIEBjbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYVxuICogQGNsYXNzZGVzY1xuICogQ2FtZXJhIHRoYXQgdXNlc1xuICogW3BlcnNwZWN0aXZlIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcnNwZWN0aXZlXyhncmFwaGljYWwpKS5cbiAqIFRoaXMgcHJvamVjdGlvbiBtb2RlIGlzIGRlc2lnbmVkIHRvIG1pbWljIHRoZSB3YXkgdGhlIGh1bWFuIGV5ZSBzZWVzLiBJdCBpc1xuICogdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gbW9kZSB1c2VkIGZvciByZW5kZXJpbmcgYSAzRCBzY2VuZS5cbiAqIEBleHRlbmRzIENhbWVyYVxuICogQGV4YW1wbGVcbiAqIHZhciBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHdpZHRoL2hlaWdodCwgMSwgMTAwMCk7XG4gKiBzY2VuZS5hZGQoY2FtZXJhKTtcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtICB7bnVtYmVyfSBbZm92XSAgICBDYW1lcmEgZnJ1c3R1bSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICogQHBhcmFtICB7bnVtYmVyfSBbYXNwZWN0XSBDYW1lcmEgZnJ1c3R1bSBhc3BlY3QgcmF0aW8uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtuZWFyXSAgIENhbWVyYSBmcnVzdHVtIG5lYXIgcGxhbmUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmYXJdICAgIENhbWVyYSBmcnVzdHVtIGZhciBwbGFuZS5cbiAqL1xuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuICBjb25zdHJ1Y3Rvcihmb3YsIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcbiAgICB0aGlzLnpvb20gPSAxO1xuICAgIHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG4gICAgdGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XG4gICAgdGhpcy5mb2N1cyA9IDEwO1xuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuICAgIHRoaXMudmlldyA9IG51bGw7XG4gICAgdGhpcy5maWxtR2F1Z2UgPSAzNTtcbiAgICB0aGlzLmZpbG1PZmZzZXQgPSAwO1xuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIC8vXG4gIC8vIGdldCBmb3YoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZm92O1xuICAvLyB9XG4gIC8vXG4gIC8vIGdldCB6b29tKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnpvb207XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IG5lYXIoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMubmVhcjtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmFyKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmZhcjtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZm9jdXMoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IGFzcGVjdCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5hc3BlY3Q7XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IHZpZXcoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudmlldztcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmlsbUdhdWdlKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmZpbG1HYXVnZTtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmlsbU9mZnNldCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5maWxtT2Zmc2V0O1xuICAvLyB9XG5cbiAgY29weShzb3VyY2UpIHtcbiAgICBzdXBlci5jb3B5KHNvdXJjZSk7XG5cbiAgICB0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuICAgIHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG4gICAgdGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuICAgIHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IHsuLi5zb3VyY2Uudmlld307XG4gICAgdGhpcy5maWxtR2F1Z2UgPSBzb3VyY2UuZmlsbUdhdWdlO1xuICAgIHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuICAgIC8vIF9wcm9qZWN0aW9uTWF0cml4ID0gc291cmNlLnByb2plY3Rpb25NYXRyaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQgZm9jYWxMZW5ndGgoZm9jYWxMZW5ndGgpIHtcbiAgICBjb25zdCB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmZpbG1IZWlnaHQgLyBmb2NhbExlbmd0aDtcbiAgICB0aGlzLmZvdiA9IDIgKiByYWRUb0RlZyhNYXRoLmF0YW4odkV4dGVudFNsb3BlKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aCBvZiB0aGUgY3VycmVudCB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjZm92fSBpbiByZXNwZWN0IHRvXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvY2FsTGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAgICovXG4gIGdldCBmb2NhbExlbmd0aCgpIHtcbiAgICBjb25zdCB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbigwLjUgKiBkZWdUb1JhZCh0aGlzLmZvdikpO1xuICAgIHJldHVybiAwLjUgKiB0aGlzLmZpbG1IZWlnaHQgLyB2RXh0ZW50U2xvcGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBpbWFnZSBvbiB0aGUgZmlsbS4gSWYge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2FzcGVjdH0gaXNcbiAgICogZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAxYCAobGFuZHNjYXBlIGZvcm1hdCksIHRoZSByZXN1bHQgZXF1YWxzXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbG1XaWR0aFxuICAgKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGZpbG1XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgaW1hZ2Ugb24gdGhlIGZpbG0uIElmIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNhc3BlY3R9IGlzXG4gICAqIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgMWAgKHBvcnRyYWl0IGZvcm1hdCksIHRoZSByZXN1bHQgZXF1YWxzXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbG1IZWlnaHRcbiAgICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmaWxtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KHRoaXMuYXNwZWN0LCAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgYW5nbGUgaW4gZGVncmVlcyBjb25zaWRlcmluZ1xuICAgKiB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjem9vbX0uXG4gICAqIEBtZW1iZXIge251bWJlcn0gZWZmZWN0aXZlRk9WXG4gICAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXRFZmZlY3RpdmVGT1YoKSB7XG4gICAgcmV0dXJuIDIgKiByYWRUb0RlZyhNYXRoLmF0YW4oTWF0aC50YW4oMC41ICogZGVnVG9SYWQodGhpcy5mb3YpKSAvIHRoaXMuem9vbSkpO1xuICB9XG5cbiAgc2V0IHZpZXdPZmZzZXQodmlldykge1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFzcGVjdCA9IHRoaXMudmlldy5mdWxsV2lkdGggLyB0aGlzLnZpZXcuZnVsbEhlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgcHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgLy8gICByZXR1cm4gX3Byb2plY3Rpb25NYXRyaXg7XG4gIC8vIH1cblxuICB1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIGxldCBuZWFyID0gdGhpcy5uZWFyLFxuICAgICAgdG9wID0gbmVhciAqIE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb20sXG4gICAgICBoZWlnaHQgPSAyICogdG9wLFxuICAgICAgd2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodCxcbiAgICAgIGxlZnQgPSAtMC41ICogd2lkdGgsXG4gICAgICB2aWV3ID0gdGhpcy52aWV3O1xuXG4gICAgaWYgKHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCkge1xuICAgICAgbGV0IGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxuICAgICAgICBmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXG4gICAgICBsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgdG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XG4gICAgICB3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgaGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcblxuICAgIH1cblxuICAgIGxldCBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG4gICAgaWYgKHNrZXcgIT09IDApIGxlZnQgKz0gbmVhciAqIHNrZXcgLyB0aGlzLmZpbG1XaWR0aCgpO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoXG4gICAgICBsZWZ0LFxuICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgdG9wLFxuICAgICAgdG9wIC0gaGVpZ2h0LFxuICAgICAgbmVhcixcbiAgICAgIHRoaXMuZmFyKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgfVxuXG4gIHNldFZpZXdQb3J0KHJvdGF0aW9uTWF0cml4KSB7XG4gICAgaWYgKHJvdGF0aW9uTWF0cml4LmlzTWF0cml4NCkge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICBMZXRzZWVFbmdpbmUucmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlcnNwZWN0aXZlQ2FtZXJhO1xuIiwiaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vT2JqZWN0M0QnO1xuXG4vKipcbiAqIEBjbGFzcyBTY2VuZVxuICogQGNsYXNzZGVzY1xuICogU2NlbmVzIGFsbG93IHlvdSB0byBzZXQgdXAgd2hhdCBhbmQgd2hlcmUgaXMgdG8gYmUgcmVuZGVyZWQuIFRoaXMgaXMgd2hlcmVcbiAqIHlvdSBwbGFjZSBvYmplY3RzLCBsaWdodHMsIGFuZCBjYW1lcmFzLlxuICogQGV4dGVuZHMgT2JqZWN0M0RcbiAqL1xuXG5jb25zdCBfdHlwZSA9ICdTY2VuZSc7XG5jb25zdCBfaXNTY2VuZSA9IHRydWU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnRyYWNrID0gdHJ1ZTtcbiAgfVxuICBnZXQgaXNTY2VuZSgpIHtcbiAgICByZXR1cm4gX2lzU2NlbmU7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gX3R5cGU7XG4gIH1cbn1cblxuIiwiaW1wb3J0IEVudGl0eSBmcm9tICcuLi9lbnRpdHkvRW50aXR5JztcbmltcG9ydCBET01SZW5kZXJhYmxlIGZyb20gJy4uL3JlbmRlcmVyL0RPTVJlbmRlcmFibGUnO1xuaW1wb3J0IEV1bGVyIGZyb20gJy4uL21hdGgvRXVsZXInO1xuXG5sZXQgX2VudGl0aWVzO1xuXG5jbGFzcyBUcmFja2FibGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2VudGl0aWVzID0ge307XG4gIH1cblxuICBsb2FkKGVudGl0eSkge1xuICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHJldHVybiB3aW5kb3cuX25hdGl2ZS5sb2FkRW50aXR5KGVudGl0eS51cmkpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlamVjdCgncGFyYW1ldGVyIGlzIG5vdCBlbnRpdHknKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEVudGl0eSh1cmkpIHtcbiAgICBpZiAoX2VudGl0aWVzW3VyaV0pIHJldHVybiBfZW50aXRpZXNbdXJpXTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEVudGl0aWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKF9lbnRpdGllcyk7XG4gIH1cblxuICBoYXNFbnRpdHkodXJpKSB7XG4gICAgaWYgKF9lbnRpdGllc1t1cmldKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhZGRFbnRpdHkoZW50aXR5KSB7XG4gICAgX2VudGl0aWVzW2VudGl0eS51cmldID0gZW50aXR5O1xuXG4gICAgLy8gaWYgKGVudGl0eS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy8gICAgIFBsYWNlQ29udHJvbGxlci5hZGRFbnRpdHkoZW50aXR5KTtcbiAgICAvLyB9XG4gIH1cblxuICByZW1vdmVFbnRpdHkocGFyYW0pIHtcbiAgICBsZXQgdXJpID0gcGFyYW07XG5cbiAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBFbnRpdHkpIHtcbiAgICAgIHVyaSA9IHBhcmFtLnVyaTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNFbnRpdHkodXJpKSkge1xuICAgICAgY29uc3QgZW50aXR5ID0gX2VudGl0aWVzW3VyaV07XG5cbiAgICAgIGlmIChlbnRpdHkudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gUGxhY2VDb250cm9sbGVyLnJlbW92ZUVudGl0eShlbnRpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZW50aXRpZXNbdXJpXS5yZW1vdmVSZW5kZXJhYmxlcygpO1xuICAgICAgZGVsZXRlIF9lbnRpdGllc1t1cmldO1xuICAgIH1cbiAgfVxuXG4gIHNldEVudGl0eShlbnRpdHkpIHtcbiAgICBjb25zdCB1cmkgPSBlbnRpdHkudXJpO1xuXG4gICAgaWYgKF9lbnRpdGllc1t1cmldKSB7XG4gICAgICBfZW50aXRpZXNbdXJpXS5zZXREYXRhKGVudGl0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbnRpdGllc1t1cmldID0gZW50aXR5O1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyYXZlcnNlRW50aXR5KGNhbGxiYWNrOiAoZW50aXR5OiBFbnRpdHkpID0+IHZvaWQpIHtcbiAgLy8gICBmb3IgKGxldCBlbnRpdHkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmVudGl0aWVzKSkge1xuICAvLyAgICAgY2FsbGJhY2soZW50aXR5KTtcbiAgLy8gICB9XG4gIC8vIH1cblxuICBzZXREYXRhcyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICBjb25zdCBvYmplY3RzID0gZGF0YTtcbiAgICAvLyBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGlmIChvYmplY3RzICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSBvYmplY3QuZW50aXR5O1xuICAgICAgICBjb25zdCBjdXJyZW50RW50aXR5ID0gbmV3IEVudGl0eShlLnVyaSwgZSk7XG5cbiAgICAgICAgdGhpcy5hZGRFbnRpdHkoY3VycmVudEVudGl0eSk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmFibGVzID0gb2JqZWN0LnJlbmRlcmFibGVzO1xuXG4gICAgICAgIHJlbmRlcmFibGVzLmZvckVhY2gociA9PiB7XG4gICAgICAgICAgY29uc3Qge3NlbGVjdG9yLCB0cmFuc2xhdGUsIHJvdGF0aW9ufSA9IHI7XG4gICAgICAgICAgY29uc3QgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICAgIGVsZW1zLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJhYmxlID0gbmV3IERPTVJlbmRlcmFibGUoZWxlbSk7XG5cbiAgICAgICAgICAgIHJlbmRlcmFibGUucG9zaXRpb24uc2V0KC4uLnRyYW5zbGF0ZSk7XG4gICAgICAgICAgICByZW5kZXJhYmxlLnJvdGF0aW9uID0gbmV3IEV1bGVyKC4uLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRFbnRpdHkuYWRkUmVuZGVyYWJsZShyZW5kZXJhYmxlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb25zdCBwbGFjZXMgPSBkYXRhLnBsYWNlO1xuICAgIC8vXG4gICAgLy8gaWYgKHBsYWNlcyAmJiBwbGFjZXMubGVuZ3RoID4gMCkge1xuICAgIC8vICAgcGxhY2VzLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlKSB7XG4gICAgLy8gICAgIGNvbnN0IGUgPSBwbGFjZS5lbnRpdHk7XG4gICAgLy8gICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkoZS51cmksIGUpO1xuICAgIC8vICAgICBjb25zdCByZW5kZXJhYmxlcyA9IHBsYWNlLnJlbmRlcmFibGVzO1xuICAgIC8vXG4gICAgLy8gICAgIGlmIChlbnRpdHkudXJpID09PSAnZ2VvbG9jYXRpb24nKSB7XG4gICAgLy8gICAgICAgZW50aXR5LnRyYWNrID0gdHJ1ZTtcbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVuZGVyYWJsZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAvLyAgICAgICBjb25zdCByID0gcmVuZGVyYWJsZXNbal07XG4gICAgLy8gICAgICAgY29uc3Qgc2VsZWN0b3IgPSByLnNlbGVjdG9yO1xuICAgIC8vICAgICAgIGNvbnN0IHBvc2UgPSByLnBvc2U7XG4gICAgLy8gICAgICAgY29uc3QgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAvL1xuICAgIC8vICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZWxlbXMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAvLyAgICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtc1trXTtcbiAgICAvLyAgICAgICAgIGxldCByZW5kZXJhYmxlID0gbmV3IEdlb1JlbmRlcmFibGUoZWxlbSk7XG4gICAgLy9cbiAgICAvLyAgICAgICAgIHJlbmRlcmFibGUuc2V0TG9jYXRpb24ocG9zZVswXSwgcG9zZVsxXSwgcG9zZVsyXSk7XG4gICAgLy9cbiAgICAvLyAgICAgICAgIGVudGl0eS5hZGRSZW5kZXJhYmxlKHJlbmRlcmFibGUpO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuICB9XG59XG5cbi8vIGV4cG9ydCBkZWZhdWx0IG5ldyBUcmFja2FibGVNYW5hZ2VyKCk7XG4vLyBleHBvcnQgZGVmYXVsdCBUcmFja2FibGVNYW5hZ2VyO1xuZXhwb3J0IGxldCB0cmFja2FibGVNYW5hZ2VyID0gbmV3IFRyYWNrYWJsZU1hbmFnZXIoKTtcbiIsImltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7ZG9tUmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXIvRE9NUmVuZGVyZXInO1xuaW1wb3J0IHtvYmplY3RUcmFja2VyfSBmcm9tICcuL2xpYnMvT2JqZWN0VHJhY2tlcic7XG5pbXBvcnQge3RyYWNrYWJsZU1hbmFnZXJ9IGZyb20gJy4vY29yZS9UcmFja2FibGVNYW5hZ2VyJztcbi8vIGltcG9ydCB7ZXZlbnRNYW5hZ2VyfSBmcm9tICcuL2V2ZW50L0V2ZW50TWFuYWdlcic7XG5pbXBvcnQgUGVyc3BlY3RpdmVDYW1lcmEgZnJvbSAnLi9jb3JlL1BlcnNwZWN0aXZlQ2FtZXJhJztcbmltcG9ydCBMZXRzZWVUaHJlZSBmcm9tICcuL2V4dGVybmFsL1RIUkVFJztcblxubGV0IF9pbnN0YW5jZTtcbi8vIGxldCBfY29uZmlnID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKF9jb25maWcpIHtcbiAgICBpZiAoX2luc3RhbmNlKSByZXR1cm4gX2luc3RhbmNlO1xuXG4gICAgdGhpcy5jb25maWcgPSB7Li4uX2NvbmZpZ307XG4gICAgY29uc29sZS5sb2codGhpcy5jb25maWcpO1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKC4uLnRoaXMuY29uZmlnLnByb2plY3Rpb25QYXJhbWV0ZXIpO1xuXG4gICAgY29udGV4dC5zZXRDb25maWcodGhpcy5jb25maWcpO1xuICAgIGRvbVJlbmRlcmVyLmluaXRSZW5kZXJlcih0aGlzLmNhbWVyYSwgdGhpcy5jb25maWcuZG9tUmVuZGVyZXJJZCwgdGhpcy5jb25maWcuekluZGV4LCB0aGlzLmNvbmZpZy56SW5kZXhJbmNyZW1lbnQpO1xuXG4gICAgb2JqZWN0VHJhY2tlci5jYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICB0aGlzLnRocmVlUmVuZGVyZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLmNvbmZpZy5leHRlcm5hbCA9PT0gJ1RIUkVFJykge1xuICAgICAgdGhpcy50aHJlZVJlbmRlcmVyID0gbmV3IExldHNlZVRocmVlKFxuICAgICAgICB0aGlzLmNvbmZpZy5wcm9qZWN0aW9uUGFyYW1ldGVyLFxuICAgICAgICB0aGlzLmNvbmZpZy56SW5kZXgsXG4gICAgICAgIHRoaXMuY29uZmlnLnpJbmRleEluY3JlbWVudCk7XG4gICAgfVxuICAgIHRyYWNrYWJsZU1hbmFnZXIuc2V0RGF0YXModGhpcy5jb25maWcuZGF0YSk7XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgc3R5bGUubWFyZ2luID0gMDtcbiAgICBzdHlsZS5wYWRkaW5nID0gMDtcblxuICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIF9pbnN0YW5jZSA9IHRoaXM7XG4gIH1cblxuICBvbkNvbmZpZ3VyYXRpb25DaGFuZ2VkKG5ld0NvbmZpZykge1xuICAgIGNvbnRleHQuc2V0Q29uZmlnKG5ld0NvbmZpZyk7XG4gICAgZG9tUmVuZGVyZXIudXBkYXRlT3JpZW50YXRpb24obmV3Q29uZmlnKTtcbiAgICBpZiAoY29uZmlnLmV4dGVybmFsID09PSAnVEhSRUUnICYmIHRoaXMudGhyZWVSZW5kZXJlcikgdGhpcy50aHJlZVJlbmRlcmVyLnVwZGF0ZU9yaWVudGF0aW9uKG5ld0NvbmZpZyk7XG4gIH1cblxuICBnZXQgb2JqZWN0VHJhY2tlcigpIHtcbiAgICByZXR1cm4gb2JqZWN0VHJhY2tlcjtcbiAgfVxuXG4gIGdldCBkb21SZW5kZXJlcigpIHtcbiAgICByZXR1cm4gZG9tUmVuZGVyZXI7XG4gIH1cbiAgZ2V0RW50aXR5KHVyaSkge1xuICAgIHJldHVybiB0cmFja2FibGVNYW5hZ2VyLmdldEVudGl0eSh1cmkpO1xuICB9XG4gIGdldEVudGl0aWVzKCkge1xuICAgIHJldHVybiB0cmFja2FibGVNYW5hZ2VyLmdldEVudGl0aWVzKCk7XG4gIH1cbiAgcmVtb3ZlRW50aXR5KHVyaSkge1xuICAgIHRyYWNrYWJsZU1hbmFnZXIucmVtb3ZlRW50aXR5KHVyaSk7XG4gIH1cblxuICBoYXNFbnRpdHkodXJpKSB7XG4gICAgcmV0dXJuIHRyYWNrYWJsZU1hbmFnZXIuaGFzRW50aXR5KHVyaSk7XG4gIH1cblxuICByZXNldERvbVJlbmRlcmFibGUoKSB7XG4gICAgdGhpcy5kb21SZW5kZXJlci5yZXNldEVsZW1lbnQoKTtcbiAgfVxuICBhcHBlbmREb21SZW5kZXJhYmxlKGVsZW1lbnQpIHtcbiAgICB0aGlzLmRvbVJlbmRlcmVyLmFwcGVuZEVsZW1lbnQoZWxlbWVudCk7XG4gIH1cbiAgYXBwZW5kQWxsRG9tUmVuZGVyYWJsZXMoKSB7XG4gICAgdGhpcy5kb21SZW5kZXJlci5hcHBlbmRBbGxFbGVtZW50cygpO1xuICB9XG5cbiAgZ2V0VGhyZWVyZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy50aHJlZVJlbmRlcmVyO1xuICB9XG59XG4iLCIvLyBpbXBvcnQge2V2ZW50TWFuYWdlcn0gZnJvbSAnLi4vZXZlbnQvRXZlbnRNYW5hZ2VyJztcbi8vIGltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG4vLyBpbXBvcnQgVmVjdG9yMyBmcm9tICcuLi9tYXRoL1ZlY3RvcjMnO1xuLy8gaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uJztcbmltcG9ydCB7cmVtb3ZlQXJyYXlJdGVtfSBmcm9tICcuLi9VdGlsJztcbmltcG9ydCBPYmplY3QzRCBmcm9tICcuLi9jb3JlL09iamVjdDNEJztcbmltcG9ydCB7ZG9tUmVuZGVyZXJ9IGZyb20gJy4uL3JlbmRlcmVyL0RPTVJlbmRlcmVyJztcbmltcG9ydCB7RU5USVRZX0VWRU5UfSBmcm9tICcuLi9saWJzL01lc3NhZ2VUeXBlcyc7XG5pbXBvcnQgT2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL09ic2VydmVyJztcbmltcG9ydCBFbnRpdHlFdmVudCBmcm9tICcuL0VudGl0eUV2ZW50JztcblxuY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKFxuICBbXG4gICAgW0VOVElUWV9FVkVOVC5UUkFDS19TVEFSVCwgbmV3IFNldCgpXSxcbiAgICBbRU5USVRZX0VWRU5ULlRSQUNLX01PVkUsIG5ldyBTZXQoKV0sXG4gICAgW0VOVElUWV9FVkVOVC5UUkFDS19FTkQsIG5ldyBTZXQoKV1cbiAgXSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgcmVhbCB3b3JsZCBvYmplY3QgdGhhdCBjYW4gYmUgZGV0ZWN0ZWQgYW5kIGJlIGFzc29jaWF0ZWQgd2l0aCBIVE1MIGVsZW1lbnRzLlxuICogQGNsYXNzXG4gKiBAbmFtZSBFbnRpdHlcbiAqIEBoaWRlY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5IGV4dGVuZHMgT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmksIGRhdGEpIHtcbiAgICBpZiAoIXVyaSkgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHkgcmVxdWlyZXMgYW4gZW50aXR5IHVyaScpO1xuICAgIHN1cGVyKHVyaSwgaGFuZGxlcnMpO1xuXG4gICAgdGhpcy51cmkgPSB1cmk7XG4gICAgdGhpcy50eXBlID0gKGRhdGEgJiYgZGF0YS50eXBlKSA/IGRhdGEudHlwZSA6ICdvYmplY3QnO1xuICAgIHRoaXMubmFtZSA9IChkYXRhICYmIGRhdGEubmFtZSkgPyBkYXRhLm5hbWUgOiAnJztcbiAgICB0aGlzLmltYWdlID0gKGRhdGEgJiYgZGF0YS5pbWFnZSkgPyBkYXRhLmltYWdlIDogJyc7XG4gICAgdGhpcy5zaXplID0gKGRhdGEgJiYgZGF0YS5zaXplKSA/IGRhdGEuc2l6ZSA6IHt3aWR0aDogMCwgaGVpZ2h0OiAwLCBkZXB0aDogMCwgdW5pdDogJ21tJ307XG4gICAgdGhpcy5yZW5kZXJhYmxlcyA9IFtdO1xuICAgIHRoaXMub2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5fdHJhY2sgPSBmYWxzZTtcbiAgfVxuXG4gIHNldERhdGEoZGF0YSkge1xuICAgIHRoaXMudHlwZSA9IChkYXRhICYmIGRhdGEudHlwZSkgPyBkYXRhLnR5cGUgOiAnb2JqZWN0JztcbiAgICB0aGlzLm5hbWUgPSAoZGF0YSAmJiBkYXRhLm5hbWUpID8gZGF0YS5uYW1lIDogJyc7XG4gICAgdGhpcy5pbWFnZSA9IChkYXRhICYmIGRhdGEuaW1hZ2UpID8gZGF0YS5pbWFnZSA6ICcnO1xuICAgIHRoaXMuc2l6ZSA9IChkYXRhICYmIGRhdGEuc2l6ZSkgPyBkYXRhLnNpemUgOiB7d2lkdGg6IDAsIGhlaWdodDogMCwgZGVwdGg6IDAsIHVuaXQ6ICdtbSd9O1xuICB9XG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cblxuICBzZXQgdmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XG4gICAgdGhpcy5vYmplY3QudHJhdmVyc2UoKG9iaikgPT4ge1xuICAgICAgb2JqLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgICBpZiAob2JqLmVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBvYmouZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgfVxuXG4gIHNldCB0cmFjayh0cmFjaykge1xuICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG5cbiAgICB0aGlzLm9iamVjdC50cmF2ZXJzZSgob2JqKSA9PiB7XG4gICAgICBvYmoudHJhY2sgPSB0cmFjaztcblxuICAgICAgaWYgKG9iai5lbGVtZW50KSB7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIG9iai5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmouZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0LnBvc2l0aW9uO1xuICB9XG5cbiAgZ2V0IG1hdHJpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QubWF0cml4O1xuICB9XG5cbiAgZ2V0IG1hdHJpeFdvcmxkKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcbiAgfVxuXG4gIGdldCBxdWF0ZXJuaW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdC5xdWF0ZXJuaW9uO1xuICB9XG5cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdC5yb3RhdGlvbjtcbiAgfVxuXG4gIGdldCBzY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Quc2NhbGU7XG4gIH1cblxuICBzZXQgc2NhbGUoc2NhbGUpIHtcbiAgICBpZiAoc2NhbGUpIHRoaXMub2JqZWN0LnNjYWxlLnNldFNjYWxhcihzY2FsZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cmFuc2xhdGVYKHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3QudHJhbnNsYXRlWCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdHJhbnNsYXRlWSh2YWx1ZSkge1xuICAgIHRoaXMub2JqZWN0LnRyYW5zbGF0ZVkodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zbGF0ZVoodmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdC50cmFuc2xhdGVaKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVgodmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdC5yb3RhdGVYKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVkodmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdC5yb3RhdGVZKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVoodmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdC5yb3RhdGVaKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZGF0ZU1hdHJpeCgpIHtcbiAgICB0aGlzLm9iamVjdC51cGRhdGVNYXRyaXgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiDsoITri6zrkJwgYFJlbmRlcmFibGVg7J2EIOyXlO2EsO2LsOyXkCDrk7HroZ3tlanri4jri6QuIGBSZW5kZXJhYmxlYOydgCDsl5TthLDti7DqsIAg7Kad6rCV65CY66m0IO2ZlOuptOyXkCDrs7Tsl6zsp5Hri4jri6QuXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gYFJlbmRlcmFibGVgIHRvIHRoaXMgZW50aXR5LiBUaGUgYFJlbmRlcmFibGVgIHdpbGwgYmVcbiAgICogcmVuZGVyZWQgd2hlbiB0aGlzIGVudGl0eSBpcyB0cmFja2VkLlxuICAgKiBAbWV0aG9kIEVudGl0eSNhZGRSZW5kZXJhYmxlXG4gICAqIEBwYXJhbSB7UmVuZGVyYWJsZX0gcmVuZGVyYWJsZVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDcmVhdGUgYSByZW5kZXJhYmxlIEhUTUwgZWxlbWVudFxuICAgKiAvLyBodG1s66GcIOunjOuTpOyWtOynhCByZW5kZXJhYmxl7J2EIOyDneyEse2VqeuLiOuLpC5cbiAgICogdmFyIGhlbGxvV29ybGRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcbiAgICogaGVsbG9Xb3JsZEVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0hlbGxvIFdvcmxkIScpKTtcbiAgICogdmFyIGhlbGxvV29ybGQgPSBuZXcgRE9NUmVuZGVyYWJsZShoZWxsb1dvcmxkRWxlbSk7XG4gICAqXG4gICAqIC8vIFJlZ2lzdGVyIHRoZSByZW5kZXJhYmxlIHRvIHRoZSBlbnRpdHlcbiAgICogLy8gcmVuZGVyYWJsZeydhCDsl5TthLDti7Dsl5Ag65Ox66Gd7ZWp64uI64ukLlxuICAgKiBlbnRpdHkuYWRkUmVuZGVyYWJsZShoZWxsb1dvcmxkKTtcbiAgICovXG4gIGFkZFJlbmRlcmFibGUocmVuZGVyYWJsZSkge1xuICAgIGlmIChyZW5kZXJhYmxlKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9tUmVuZGVyZXIuYWRkKHRoaXMub2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJhYmxlcy5wdXNoKHJlbmRlcmFibGUpO1xuICAgICAgdGhpcy5vYmplY3QuYWRkKHJlbmRlcmFibGUpO1xuXG4gICAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2s7XG5cbiAgICAgICAgcmVuZGVyYWJsZS50cmF2ZXJzZSgob2JqKSA9PiB7XG4gICAgICAgICAgb2JqLnRyYWNrID0gdHJhY2s7XG5cbiAgICAgICAgICBpZiAob2JqLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIG9iai5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDsoITri6zrkJwgYFJlbmRlcmFibGVg7J2EIOyXlO2EsO2LsOyXkOyEnCDsgq3soJztlanri4jri6QuIOyCreygnOuQnCBgUmVuZGVyYWJsZWDsnYAg642U7J207IOBIO2ZlOuptOyXkCDtkZzsi5zrkJjsp4Ag7JWK7Iq164uI64ukLlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBgUmVuZGVyYWJsZWAgZnJvbSB0aGlzIGVudGl0eSdzIHJlbmRlcmFibGVzLlxuICAgKiBUaGUgYFJlbmRlcmFibGVgIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbmRlcmVkXG4gICAqIHdoZW4gdGhpcyBlbnRpdHkgaXMgdHJhY2tlZC5cbiAgICogQG1ldGhvZCByZW1vdmVSZW5kZXJhYmxlXG4gICAqIEBtZW1iZXJvZiBFbnRpdHkucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UmVuZGVyYWJsZX0gcmVuZGVyYWJsZVxuICAgKi9cbiAgcmVtb3ZlUmVuZGVyYWJsZShyZW5kZXJhYmxlKSB7XG4gICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgIHJlbW92ZUFycmF5SXRlbSh0aGlzLnJlbmRlcmFibGVzLCByZW5kZXJhYmxlKTtcbiAgICAgIHRoaXMub2JqZWN0LnJlbW92ZShyZW5kZXJhYmxlKTtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbVJlbmRlcmVyLnJlbW92ZSh0aGlzLm9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBgUmVuZGVyYWJsZXNgIHJlZ2lzdGVyZWQgdG8gdGhpcyBlbnRpdHkuXG4gICAqIOuTseuhneuQnCDrqqjrk6AgYFJlbmRlcmFibGVzYOydhCDsgq3soJztlanri4jri6QuXG4gICAqIEBtZXRob2QgRW50aXR5I3Jlc2V0UmVuZGVyYWJsZXNcbiAgICovXG4gIHJlc2V0UmVuZGVyYWJsZXMoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gZm9yIChsZXQgcmVuZGVyYWJsZSBvZiB0aGlzLnJlbmRlcmFibGVzKSB7XG4gICAgICAvLyAgIHRoaXMub2JqZWN0LnJlbW92ZShyZW5kZXJhYmxlKTtcbiAgICAgIC8vIH1cblxuICAgICAgdGhpcy5yZW5kZXJhYmxlcyA9IFtdO1xuICAgICAgZG9tUmVuZGVyZXIucmVtb3ZlKHRoaXMub2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgdGhlIFJlbmRlcmFibGVzIG9mIHRoaXMgZW50aXR5LlxuICAgKiDrk7HroZ3rkJwg66qo65OgIGBSZW5kZXJhYmxlc2DsnYQg67CY7ZmY7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIEVudGl0eSNnZXRBbGxSZW5kZXJhYmxlc1xuICAgKiBAcmV0dXJuIHtSZW5kZXJhYmxlW119XG4gICAqL1xuICBnZXRBbGxSZW5kZXJhYmxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJhYmxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBSZW5kZXJhYmxlIHdpdGggdGhlIGdpdmVuIGB1dWlkYCwgb3IgYG51bGxgIGlmIG5vIHN1Y2hcbiAgICogUmVuZGVyYWJsZSBleGlzdHMuXG4gICAqIOyngOygleuQnCBVVUlE66W8IOqwgOynhCBgUmVuZGVyYWJsZXNg7J2EIOuwmO2ZmO2VqeuLiOuLpC4g7JeG7Jy866m0IGBudWxsYOydhCDrsJjtmZjtlanri4jri6QuXG4gICAqIEBtZXRob2QgZ2V0UmVuZGVyYWJsZVxuICAgKiBAbWVtYmVyb2YgRW50aXR5LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXVpZFxuICAgKiBAcmV0dXJuIHtSZW5kZXJhYmxlfG51bGx9XG4gICAqL1xuICBnZXRSZW5kZXJhYmxlKHV1aWQpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5yZW5kZXJhYmxlcy5sZW5ndGg7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlc1tpXS51dWlkID09PSB1dWlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmFibGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gZ2V0U2NyZWVuKCkge1xuICAvLyAgIGNvbnN0IGNhbWVyYSA9IExldHNlZUVuZ2luZS5jYW1lcmE7XG4gIC8vXG4gIC8vICAgaWYgKGNhbWVyYSkge1xuICAvLyAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgLy8gICAgIG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLnRvQ1NTM0QoKSk7XG4gIC8vXG4gIC8vICAgICBjb25zdCB2ID0gdGhpcy5vYmplY3QucG9zaXRpb24uY2xvbmUoKTtcbiAgLy8gICAgIHYuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gIC8vXG4gIC8vICAgICBjb25zdCBoYWxmV2lkdGggPSBDb250ZXh0LndpZHRoICogMC41O1xuICAvLyAgICAgY29uc3QgaGFsZkhlaWdodCA9IENvbnRleHQuaGVpZ2h0ICogMC41O1xuICAvL1xuICAvLyAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKCkuc2V0KFxuICAvLyAgICAgICAodi54ICsgMSkgKiBoYWxmV2lkdGgsXG4gIC8vICAgICAgICgtdi55ICsgMSkgKiBoYWxmSGVpZ2h0XG4gIC8vICAgICApO1xuICAvL1xuICAvLyAgIH0gZWxzZSB7XG4gIC8vICAgICBjb25zb2xlLmVycm9yKCdDYW1lcmEgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgbG9va0F0KHBvc2l0aW9uKSB7XG4gICAgdGhpcy5vYmplY3QubG9va0F0KHBvc2l0aW9uKTtcbiAgfVxuXG4gIGxvb3RBdFJlbmRlcmFibGVzKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5vYmplY3QudHJhdmVyc2UoKG9iaikgPT4ge1xuICAgICAgaWYgKHRoaXMub2JqZWN0ICE9PSBvYmopIHtcbiAgICAgICAgb2JqLmxvb2tBdChwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBsb29rQXRDYW1lcmEoKSB7XG4gICAgY29uc3QgY2FtZXJhUG9zZSA9IExldHNlZUVuZ2luZS5jYW1lcmEucG9zaXRpb247XG5cbiAgICB0aGlzLmxvb3RBdFJlbmRlcmFibGVzKGNhbWVyYVBvc2UpO1xuICB9XG5cbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAvLyAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMudXJpLCBsaXN0ZW5lcik7XG4gIC8vIH1cbiAgLy9cbiAgLy8gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAvLyAgIGV2ZW50TWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMudXJpLCBjYWxsYmFjayk7XG4gIC8vIH1cblxuICBzdWJzY3JpYmUodHlwZSwgY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdWJzY3JpYmUodGhpcy51cmksIHR5cGUsIGNhbGxiYWNrLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHVuc3Vic2NyaWJlKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIudW5zdWJzY3JpYmUodGhpcy51cmksIHR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG5vdGlmeSh0eXBlLCBldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVudGl0eUV2ZW50KSB7XG4gICAgICBzdXBlci5ub3RpZnkodGhpcy51cmksIHR5cGUsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgTWF0cml4NCBmcm9tICcuLi9tYXRoL01hdHJpeDQnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsndHJhY2tzdGFydCd8J3RyYWNrbW92ZSd8J3RyYWNrZW5kJ30gRW50aXR5RXZlbnRUeXBlXG4gKi9cbi8vIGV4cG9ydCB0eXBlIEVudGl0eUV2ZW50VHlwZSA9ICd0cmFja3N0YXJ0JyB8ICd0cmFja21vdmUnIHwgJ3RyYWNrZW5kJztcblxuLyoqXG4gKiBAY2FsbGJhY2sgRW50aXR5RXZlbnRMaXN0ZW5lclxuICogQHBhcmFtIHtFbnRpdHlFdmVudH0gZXZlbnRcbiAqL1xuXG4vLyBleHBvcnQgdHlwZSBFbnRpdHlFdmVudExpc3RlbmVyID0gKGV2ZW50OiBFbnRpdHlFdmVudCkgPT4gdm9pZDtcblxuLyoqXG4gKiBAY2xhc3MgRW50aXR5RXZlbnRcbiAqIEBjbGFzc2Rlc2MgQ2xhc3MgcmVwcmVzZW50aW5nIGZlYXR1cmUgdHJhY2tpbmcgZXZlbnRzLlxuICogQGF1dGhvciBKb29IeXVuIExlZSAobGpoQGxldHNlZS5pbylcbiAqIEBzaW5jZSAyMDE2LiAwMy4gMjMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtFbnRpdHl9IGVudGl0eVxuICogQHBhcmFtIHtUcmFja2FibGV9IHRyYWNrYWJsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gW21hdHJpeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGU9MV1cbiAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgYHR5cGVgIG9yIGBlbnRpdHlgIGlzIG5vdCBzcGVjaWZpZWQuXG4gKi9cblxuLyovISoqXG4gKiBUaGUgdHlwZSBvZiB0aGlzIHRyYWNrIGV2ZW50LlxuICogQG1lbWJlciB7c3RyaW5nfSB0eXBlXG4gKiBAbWVtYmVyb2YgRW50aXR5RXZlbnQjXG4gKiEvXG5sZXQgX3R5cGU7XG5cbi8hKipcbiAqIFRoZSB0YXJnZXQgb2YgdGhpcyB0cmFjayBldmVudC5cbiAqIEBtZW1iZXIge0VudGl0eX0gdGFyZ2V0XG4gKiBAbWVtYmVyb2YgRW50aXR5RXZlbnQjXG4gKiEvXG5sZXQgX3RhcmdldDtcblxuLyEqKlxuICogQSA0eDQgW21hdHJpeF17QGxpbmsgXCJodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXRyaXhfKG1hdGhlbWF0aWNzKVwifVxuICogaW4gYVxuICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcilcbiAqIGZvcm1hdCB0aGF0IHJlcHJlc2VudHMgdGhlIHRyYW5zbGF0aW9uIGFuZCB0aGUgcm90YXRpb24gb2YgdGhlIGVudGl0eVxuICogcmVsYXRpdmUgdG8gdGhlIGRldmljZSBjYW1lcmEuXG4gKiBAdG9kbyBjb2x1bW4gdnMgcm93LCByb3RhdGlvbi90cmFuc2xhdGlvbiBvZiB3aGF0IHJlbGF0aXZlIHRvIHdoYXRcbiAqIEBtZW1iZXIge01hdHJpeDR9IG1hdHJpeFxuICogQG1lbWJlcm9mIEVudGl0eUV2ZW50I1xuICogQGRlZmF1bHQgW1xuICogMSwgMCwgMCwgMCxcbiAqIDAsIDEsIDAsIDAsXG4gKiAwLCAwLCAxLCAwLFxuICogMCwgMCwgMCwgMVxuICogXVxuICohL1xubGV0IF9tYXRyaXg7XG5cbi8hKipcbiAqXG4gKiBAbWVtYmVyIHtPYmplY3R9IHBpeGVsU2l6ZVxuICogQG1lbWJlcm9mIEVudGl0eUV2ZW50I1xuICogQGRlZmF1bHQge1xuICogd2lkdGg6IDAuMCxcbiAqIGhlaWdodDogMC4wLFxuICogZGVwdGg6IDAsMFxuICogfVxuICohL1xubGV0IF9waXhlbFNpemUgPSB7XG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIGRlcHRoOiBudWxsXG59O1xuXG5sZXQgX3NjYWxlOyovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eUV2ZW50IHtcbiAgY29uc3RydWN0b3IoXG4gICAgdHlwZSxcbiAgICB0YXJnZXQsXG4gICAgbWF0cml4LFxuICAgIHBpeGVsU2l6ZSxcbiAgICBzY2FsZVxuICApIHtcbiAgICBpZiAoIXR5cGUgfHwgIXRhcmdldCkgdGhyb3cgbmV3IEVycm9yKCdFbnRpdHlFdmVudCByZXF1aXJlcyBhbiBldmVudCB0eXBlIGFuZCBlbnRpdHknKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5tYXRyaXggPSBtYXRyaXggfHwgbmV3IE1hdHJpeDQoKTtcbiAgICB0aGlzLnBpeGVsU2l6ZSA9IHBpeGVsU2l6ZSB8fCB7d2lkdGg6IDAuMCwgaGVpZ2h0OiAwLjAsIGRlcHRoOiAwLjB9O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIH1cbn1cblxuIiwiY29uc3QgRXZlbnRUeXBlID0ge1xuICBUUkFDS19TVEFSVDogJ3RyYWNrc3RhcnQnLFxuICBUUkFDS19NT1ZFOiAndHJhY2ttb3ZlJyxcbiAgVFJBQ0tfRU5EOiAndHJhY2tlbmQnXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudFR5cGU7XG4iLCJpbXBvcnQge2NvbnRleHR9IGZyb20gJy4uL0NvbnRleHQnO1xuLy8gaW1wb3J0IHtldmVudE1hbmFnZXJ9IGZyb20gJy4uL2V2ZW50L0V2ZW50TWFuYWdlcic7XG4vLyBpbXBvcnQgVmVjdG9yMyBmcm9tICcuLi8uLi8uLi9tYXRoL1ZlY3RvcjMnO1xuLy8gaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi4vLi4vLi4vbWF0aC9RdWF0ZXJuaW9uJztcbi8vIGltcG9ydCBFdWxlciBmcm9tICcuLi8uLi8uLi9tYXRoL0V1bGVyJztcbmltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG5pbXBvcnQgRW50aXR5T2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL29ic2VydmVyL0VudGl0eU9ic2VydmVyJztcblxuY29uc3QgX3R5cGUgPSAnTGV0c2VlVGhyZWUnO1xubGV0IF9pbnN0YW5jZSA9IG51bGw7XG5sZXQgX3JlbmRlcmVyID0gbnVsbDtcbmxldCBfY2FtZXJhID0gbnVsbDtcbmxldCBfc2NlbmUgPSBudWxsO1xubGV0IF9hdXRvUmVuZGVyID0gdHJ1ZTtcbmNvbnN0IF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmxldCBMRVRTRUVfVEhSRUUgPSBudWxsO1xuXG5jb25zdCBlbnRpdHlHcm91cCA9IG5ldyBNYXAoKTtcblxuY29uc3QgcmVuZGVyU2NlbmUgPSAoZXZlbnQpID0+IHtcbiAgaWYgKF9hdXRvUmVuZGVyKSB7XG4gICAgLy8gdGhpcy5jbGVhcih0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBfcmVuZGVyZXIuc3RhdGUucmVzZXQoKTtcbiAgICBfcmVuZGVyZXIucmVuZGVyKF9zY2VuZSwgX2NhbWVyYSk7XG4gICAgLy8gdGhpcy5vblJlbmRlckNhbGxiYWNrKGV2ZW50KTtcbiAgfVxufVxuXG5jb25zdCBnZXRUaHJlZUdyb3VwID0gKHVyaSkgPT4ge1xuICBpZiAoZW50aXR5R3JvdXAuZ2V0KHVyaSkgPT0gbnVsbCkge1xuICAgIGNvbnN0IGdyb3VwID0gbmV3IExFVFNFRV9USFJFRS5Hcm91cCgpO1xuXG4gICAgZ3JvdXAubmFtZSA9IHVyaTtcbiAgICBlbnRpdHlHcm91cC5zZXQodXJpLCBncm91cCk7XG4gICAgX3NjZW5lLmFkZChncm91cCk7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG4gIHJldHVybiBlbnRpdHlHcm91cC5nZXQodXJpKTtcbn07XG5cbmNvbnN0IF9hZGRPYmplY3RUb0VudGl0eSA9ICh1cmksIG9iamVjdCkgPT4ge1xuICBjb25zdCBncm91cCA9IGdldFRocmVlR3JvdXAodXJpKTtcblxuICBncm91cC5hZGQob2JqZWN0KTtcbn07XG5jb25zdCByZW1vdmVPYmplY3RGcm9tRW50aXR5ID0gKHVyaSwgb2JqZWN0KSA9PiB7XG4gIGlmICh0aGlzLm9iamVjdHNbdXJpXSkge1xuICAgIHRoaXMub2JqZWN0c1t1cmldLnJlbW92ZShvYmplY3QpO1xuXG4gICAgaWYgKHRoaXMub2JqZWN0c1t1cmldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMub2JqZWN0c1t1cmldO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBvblRyYWNrU3RhcnRDYWxsYmFjayA9IChlKSA9PiB7fVxuY29uc3Qgb25UcmFja01vdmVDYWxsYmFjayA9IChlKSA9PiB7fVxuY29uc3Qgb25UcmFja0VuZENhbGxiYWNrID0gKGUpID0+IHt9XG5cbmNvbnN0IG9uVHJhY2tNb3ZlID0gKGUpID0+IHtcbiAgaWYgKGVudGl0eUdyb3VwLmdldChlLnRhcmdldC51cmkpICE9IG51bGwpIHtcblxuICAgIC8vIGNvbnN0IG9iamVjdCA9IHRoaXMub2JqZWN0c1tlLnRhcmdldC51cmldO1xuICAgIC8vIGNvbnN0IGdyb3VwID0gdGhpcy5nZXRUaHJlZUdyb3VwKGUudGFyZ2V0LnVyaSk7XG4gICAgY29uc3QgZ3JvdXAgPSBlbnRpdHlHcm91cC5nZXQoZS50YXJnZXQudXJpKTtcblxuICAgIGdyb3VwLm1hdHJpeC5jb21wb3NlKGdyb3VwLnBvc2l0aW9uLCBncm91cC5xdWF0ZXJuaW9uLCBncm91cC5zY2FsZSk7XG4gICAgZ3JvdXAubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgLy8gZS5ldmVudCB3YXMgZGlzcGF0Y2hlZCBmcm9tIE9iamVjdFRyYWNrZXIuXG4gICAgLy8gSW52ZXJ0IFggYXhpcyB3YXMgYWxyZWFkeSBhcHBsaWVkIGF0IE9iamVjdFRyYWNrZXJcbiAgICBjb25zdCBtYXRyaXggPSBlLm1hdHJpeDtcblxuICAgIG1hdHJpeC5kZWNvbXBvc2UoXG4gICAgICBfY2FtZXJhLnBvc2l0aW9uLFxuICAgICAgX2NhbWVyYS5xdWF0ZXJuaW9uLFxuICAgICAgX2NhbWVyYS5zY2FsZVxuICAgICk7XG4gICAgX2NhbWVyYS51cGRhdGVNYXRyaXgoKTtcbiAgICBjb25zdCB0bXAgPSBuZXcgTWF0cml4NCgpLmdldEludmVyc2UoX2NhbWVyYS5tYXRyaXgpO1xuXG4gICAgX2NhbWVyYS5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICBfY2FtZXJhLmFwcGx5TWF0cml4KHRtcCk7XG4gICAgX2NhbWVyYS51cGRhdGVNYXRyaXgoKTtcblxuICAgIF9jYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICBfY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKF9jYW1lcmEubWF0cml4V29ybGQpO1xuXG4gICAgZ3JvdXAudmlzaWJsZSA9IHRydWU7XG4gICAgcmVuZGVyU2NlbmUoZSk7XG4gICAgb25UcmFja01vdmVDYWxsYmFjayhlKTtcbiAgfVxufTtcbmNvbnN0IG9uVHJhY2tTdGFydCA9IChlKSA9PiB7XG4gIGlmIChlbnRpdHlHcm91cC5nZXQoZS50YXJnZXQudXJpKSAhPSBudWxsKSBlbnRpdHlHcm91cC5nZXQoZS50YXJnZXQudXJpKS52aXNpYmxlID0gdHJ1ZTtcbiAgcmVuZGVyU2NlbmUoZSk7XG4gIG9uVHJhY2tTdGFydENhbGxiYWNrKGUpO1xufTtcbmNvbnN0IG9uVHJhY2tFbmQgPSAoZSkgPT4ge1xuICBpZiAoZW50aXR5R3JvdXAuZ2V0KGUudGFyZ2V0LnVyaSkgIT0gbnVsbCkgZW50aXR5R3JvdXAuZ2V0KGUudGFyZ2V0LnVyaSkudmlzaWJsZSA9IGZhbHNlO1xuICByZW5kZXJTY2VuZShlKTtcbiAgb25UcmFja0VuZENhbGxiYWNrKGUpO1xufTtcblxuY29uc3QgaW5pdCA9IChjYW1lcmFQYXJhbSwgekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpID0+IHtcbiAgTEVUU0VFX1RIUkVFID0gd2luZG93LlRIUkVFO1xuICBfY2FudmFzLmNsYXNzTmFtZSA9ICdhci1yZW5kZXJlcic7XG4gIF9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBfY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gIF9jYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gIF9jYW52YXMuc3R5bGUubWFyZ2luID0gMDtcbiAgX2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgX2NhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXggKyB6SW5kZXhJbmNyZW1lbnQ7XG4gIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKF9jYW52YXMsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gIF9jYW1lcmEgPSBuZXcgTEVUU0VFX1RIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKC4uLmNhbWVyYVBhcmFtKTtcbiAgX3NjZW5lID0gbmV3IExFVFNFRV9USFJFRS5TY2VuZSgpO1xuICBfcmVuZGVyZXIgPSBuZXcgTEVUU0VFX1RIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgIGFscGhhOiB0cnVlLFxuICAgIGNhbnZhczogX2NhbnZhc1xuICB9KTtcbiAgX2NhbWVyYS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gIF9jYW1lcmEubG9va0F0KF9zY2VuZS5wb3NpdGlvbik7XG4gIF9yZW5kZXJlci5zZXRTaXplKGNvbnRleHQuc2NyZWVuV2lkdGgsIGNvbnRleHQuc2NyZWVuSGVpZ2h0KTtcbiAgX3NjZW5lLmFkZChfY2FtZXJhKTtcblxuICAvLyBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2ttb3ZlJywgKGUpID0+IG9uVHJhY2tNb3ZlKGUpKTtcbiAgLy8gZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrc3RhcnQnLCAoZSkgPT4gb25UcmFja1N0YXJ0KGUpKTtcbiAgLy8gZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrZW5kJywgKGUpID0+IG9uVHJhY2tFbmQoZSkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV0c2VlVGhyZWUgZXh0ZW5kcyBFbnRpdHlPYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtLCB6SW5kZXgsIHpJbmRleEluY3JlbWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCF3aW5kb3cuVEhSRUUpIHRocm93IG5ldyBFcnJvcignVEhSRUUgaXMgbm90IGRlZmluZGVkLiBwbGVhc2UgaW1wb3J0IHRocmVlLmpzIGxpYnJhcnkuJyk7XG4gICAgaWYgKF9pbnN0YW5jZSkgcmV0dXJuIF9pbnN0YW5jZTtcbiAgICBpbml0KHBhcmFtLCB6SW5kZXgsIHpJbmRleEluY3JlbWVudCk7XG5cbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2ttb3ZlJywgKGUpID0+IG9uVHJhY2tNb3ZlKGUpKTtcbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2tzdGFydCcsIChlKSA9PiBvblRyYWNrU3RhcnQoZSkpO1xuICAgIHRoaXMuc3Vic2NyaWJlKCd0cmFja2VuZCcsIChlKSA9PiBvblRyYWNrRW5kKGUpKTtcblxuICAgIF9pbnN0YW5jZSA9IHRoaXM7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gX3R5cGU7XG4gIH1cblxuICBnZXQgY2FtZXJhKCkge1xuICAgIHJldHVybiBfY2FtZXJhO1xuICB9XG5cbiAgZ2V0IHNjZW5lKCkge1xuICAgIHJldHVybiBfc2NlbmU7XG4gIH1cblxuICBhZGRPYmplY3RUb0VudGl0eSh1cmksIG9iamVjdCkge1xuICAgIF9hZGRPYmplY3RUb0VudGl0eSh1cmksIG9iamVjdCk7XG4gIH1cblxuICBlbnRpdHlHcm91cCh1cmkpIHtcbiAgICBpZiAoZW50aXR5R3JvdXAuZ2V0KHVyaSkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBlbnRpdHkgZ3JvdXAgZm91bmRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZW50aXR5R3JvdXAuZ2V0KHVyaSk7XG4gIH1cblxuICByZW1vdmVPYmplY3RGcm9tRW50aXR5KHVyaSwgb2JqZWN0KSB7XG4gICAgcmVtb3ZlT2JqZWN0RnJvbUVudGl0eSh1cmksIG9iamVjdCk7XG4gIH1cblxuICB1cGRhdGVPcmllbnRhdGlvbihuZXdDb25maWcpIHtcbiAgICBfcmVuZGVyZXIuc2V0U2l6ZShuZXdDb25maWcud2lkdGgsIG5ld0NvbmZpZy5oZWlnaHQpO1xuICAgIF9jYW1lcmEuYXNwZWN0ID0gbmV3Q29uZmlnLmFzcGVjdDtcbiAgICBfY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfVxufVxuXG4iLCIvKiBpbXBvcnQg7IS57IWY7J2AIOuCmOykkeyXkCDrs4Trj4TroZwg64W87J2Y7ZWY7JesIOygleumrO2VqeyLnOuLpC4gYnkgYWhuICovXG5pbXBvcnQgVmlkZW9NYW5hZ2VyIGZyb20gJy4vbGlicy9WaWRlb01hbmFnZXInO1xuaW1wb3J0IEFSM0RSZW5kZXJNb2R1bGVNYW5hZ2VyIGZyb20gJy4vbGlicy9BUjNEUmVuZGVyTW9kdWxlTWFuYWdlcic7XG5pbXBvcnQgRXZlbnRNYW5hZ2VyIGZyb20gJy4vbGlicy9FdmVudE1hbmFnZXInO1xuaW1wb3J0ICogYXMgTWVzc2FnZSBmcm9tICcuL2xpYnMvTWVzc2FnZVR5cGVzJztcbmltcG9ydCB7TEVUU0VFX0VWRU5ULCBFTlRJVFlfRVZFTlR9IGZyb20gJy4vbGlicy9NZXNzYWdlVHlwZXMnO1xuaW1wb3J0IHtjc3NQYXJzZXJ9IGZyb20gJy4vbGlicy9DU1NQYXJzZXInO1xuaW1wb3J0IHtcbiAgbG9hZEltYWdlLFxuICBjcmVhdGVMZXRzZWVXcmFwcGVyLFxuICBjcmVhdGVMb2FkZXIsXG4gIGFkZFZpZXdwb3J0LFxuICBjcmVhdGVTdGF0dXNTY3JlZW4sIC8qIFVVSUQsKi9cbiAgaXNOaWxcbn0gZnJvbSAnLi9VdGlsJztcbmltcG9ydCBFbnRpdHlQYXJzZXIgZnJvbSAnLi9saWJzL0VudGl0eVBhcnNlcic7XG5pbXBvcnQge2NvbnRleHR9IGZyb20gJ0NvbnRleHQnO1xuaW1wb3J0IEVudGl0eU9ic2VydmVyIGZyb20gJy4vb2JzZXJ2ZXJzL29ic2VydmVyL0VudGl0eU9ic2VydmVyJztcbmltcG9ydCBFbmdpbmUgZnJvbSAnLi9lbmdpbmUnO1xuaW1wb3J0IFNjcmVlbiBmcm9tICcuL1NjcmVlbic7XG5cbmltcG9ydCBNYXRyaXg0IGZyb20gJy4vbWF0aC9NYXRyaXg0JztcbmltcG9ydCBNYXRyaXgzIGZyb20gJy4vbWF0aC9NYXRyaXgzJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4vbWF0aC9WZWN0b3IyJztcbmltcG9ydCBWZWN0b3IzIGZyb20gJy4vbWF0aC9WZWN0b3IzJztcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4vbWF0aC9RdWF0ZXJuaW9uJztcbmltcG9ydCBFdWxlciBmcm9tICcuL21hdGgvRXVsZXInO1xuXG5pbXBvcnQgT2JqZWN0M0QgZnJvbSAnLi9jb3JlL09iamVjdDNEJztcbmltcG9ydCBFbnRpdHkgZnJvbSAnLi9lbnRpdHkvRW50aXR5JztcbmltcG9ydCBFbnRpdHlFdmVudCBmcm9tICcuL2VudGl0eS9FbnRpdHlFdmVudCc7XG5pbXBvcnQgRE9NUmVuZGVyYWJsZSBmcm9tICcuL3JlbmRlcmVyL0RPTVJlbmRlcmFibGUnO1xuXG4vKiBsZXRzZWVFbmdpbmXsl5Ag64SY6rKo7KSEIOyduOyekOulvCDqsJ3ssrTroZwg65Sw66GcIOunjOuTpOyngCDslYrqs6AsIO2VtOuLuSDqsJLsnYQg6rSA66as7ZWY64qUIOuppOuyhCDqsJ3ssrTrpbwgTGV0c2VlIENsYXNz7JeQ7IScIOylkOqzoCDsnojsnLzrqbRcbiAgIGxldHNlZUVuZ2luZeyXkOyEnCDsp4HsoJEg6re4IOqwkuydhCDssLjsobDtlZjsl6wg7IKs7Jqp7ZWY64+E66GdIOuzgOqyve2VqeyLnOuLpC4gYnkgYWhuICovXG5jb25zdCBfbGV0c2VlRW5naW5lQ29uZmlnID0ge1xuICBydW5UeXBlOiAnQlJPV1NFUicsXG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIG9yaWVudGF0aW9uOiBudWxsLFxuICBkYXRhOiBudWxsLFxuICBwcm9qZWN0aW9uUGFyYW1ldGVyOiBudWxsLFxuICBleHRlcm5hbDogbnVsbFxufTtcblxuLyogdmFsaWRhdGVDb25maWfrnbzqs6Ag65CY7Ja0IOyeiOuKlOuNsCDqt7jrg6Ug7IKs7Jqp7J6QIOyEpOygleyXkCDrjIDtlZwg6riw67O46rCSIOyngOygle2VtCDso7zripQg7ZWo7IiY7J206rWw7JqULiDsnbTrn7Ag6rK97JqwIENvbmZpZyBvciBTZXR0aW5ncyBDbGFzc+ulvFxuICDrlLDroZwg66eM65Ok7Ja0IOq3uCDslYjsl5Ag6rSA66CoIHBhcnNlcuyZgCB2YWxpZGF0aW9uIOuhnOyngeydhCDri7TripQg6rKMIOyWtOuWqOq5jCDtlanri4jri6QuIGJ5IGFobiAqL1xuY29uc3QgdmFsaWRhdGVDb25maWcgPSAoX2NvbmZpZykgPT4ge1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgYXBwS2V5OiBgJHtBUFBfS0VZfWAsXG4gICAgdHJhY2tlclR5cGU6IF9jb25maWcudHJhY2tlclR5cGUgfHwgJ0lNQUdFJyxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBjYW1lcmFQYXJhbWV0ZXI6IHtcbiAgICAgIGZvdjogNTAsXG4gICAgICBuZWFyOiAwLjEsXG4gICAgICBmYXI6IDIwMDBcbiAgICB9LFxuICAgIHpJbmRleDogMTAwLFxuICAgIHpJbmRleEluY3JlbWVudDogMTBcbiAgfTtcblxuICBpZiAoX2NvbmZpZy50eXBlKSBjb25maWcudHJhY2tlclR5cGUgPSBfY29uZmlnLnR5cGU7XG4gIGlmIChfY29uZmlnLmV4dGVybmFsKSBjb25maWcuZXh0ZXJuYWwgPSBfY29uZmlnLmV4dGVybmFsO1xuICBpZiAoX2NvbmZpZy5jYW1lcmFQYXJhbWV0ZXIpIHtcbiAgICBpZiAoXG4gICAgICBfY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mb3YgJiZcbiAgICAgICAgX2NvbmZpZy5jYW1lcmFQYXJhbWV0ZXIubmVhciAmJlxuICAgICAgICBfY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mYXJcbiAgICApIHtcbiAgICAgIGNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIgPSBfY29uZmlnLmNhbWVyYVBhcmFtZXRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3YsIG5lYXIsIGZhciBhcmUgbWFuZGF0b3J5IGZpZWxkLicpO1xuICAgIH1cbiAgfVxuICAvLyBAYXV0aG9yIHRyZWV0b3J5IDogTE9DQUwg7ZmY6rK97J28IOuVjCwg7JWx7YKk66W8IOuwm+yVhOyYpOuKlCDqsoPsnbQg7J6I7Jy866m0IOyEpOygle2VmOqzoCwg7JeG7Jy866m0IOq4sOuzuO2CpCDsgqzsmqk/XG4gIGlmIChfX0xPQ0FMX18pIHtcbiAgICBpZiAoX2NvbmZpZy5hcHBLZXkpIGNvbmZpZy5hcHBLZXkgPSBfY29uZmlnLmFwcEtleTtcbiAgICBpZiAoX2NvbmZpZy52aWRlb1VybCkgY29uZmlnLmFwcEtleSA9IF9jb25maWcuYXBwS2V5O1xuICAgIGlmIChfY29uZmlnLmRlYnVnKSBjb25maWcuYXBwS2V5ID0gX2NvbmZpZy5hcHBLZXk7XG4gIH1cblxuICBpZiAodHlwZW9mIF9jb25maWcuekluZGV4ID09PSAnbnVtYmVyJykgY29uZmlnLnpJbmRleCA9IF9jb25maWcuekluZGV4O1xuICBpZiAodHlwZW9mIF9jb25maWcuekluZGV4SW5jcmVtZW50ID09PVxuICAgICAgJ251bWJlcicpIGNvbmZpZy56SW5kZXhJbmNyZW1lbnQgPSBfY29uZmlnLnpJbmRleEluY3JlbWVudDtcblxuICBpZiAoX2NvbmZpZy5ib2R5SWQpIHtcbiAgICBjb25maWcuYm9keUlkID0gX2NvbmZpZy5ib2R5SWQ7XG4gICAgY29udGV4dC5ib2R5SWQgPSBfY29uZmlnLmJvZHlJZDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuYm9keUlkID0gY29udGV4dC5ib2R5SWQ7XG4gIH1cblxuICBjb25maWcuZG9tUmVuZGVyZXJJZCA9IGNvbnRleHQuZG9tUmVuZGVyZXJJZDtcbiAgY29uZmlnLnZpZGVvSWQgPSBjb250ZXh0LnZpZGVvQ29udGFpbmVySWQ7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG5cbi8vIHJlbmRlciBtb2R1bGUgZW5kXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcIklNQUdFXCJ8XCJNQVJLRVJcInxcIlFSQ09ERVwiKX0gVHJhY2tlclR5cGUgLSDsgqzsmqkg6rCA64ql7ZWcIO2KuOuemey7pCDtg4DsnoVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEVudGl0eUV2ZW50XG4gKiBAcHJvcGVydHkge1widHJhY2tzdGFydFwifFwidHJhY2ttb3ZlXCJ8XCJ0cmFja2VuZFwifSB0eXBlIC0g7ZiE7J6sIO2KuOueme2CuSDsg4Htg5xcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdHJpeC5lbGVtZW50c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlXG4gKiBAcHJvcGVydHkge29iamVjdH0gcGl4ZWxTaXplXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxTaXplLndpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxTaXplLmhlaWdodFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsU2l6ZS5kZXB0aFxuICogQHByb3BlcnR5IHsoXCJtbVwiKX0gcGl4ZWxTaXplLnVuaXRcbiAqIEBwcm9wZXJ0eSB7RW50aXR5fSB0YXJnZXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExldHNlZVN0YXR1c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSDsg4Htg5wg7L2U65OcXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtIOyDge2DnCDrqZTshLjsp4BcbiAqIEBkZXNjcmlwdGlvblxuICogTGV0c2VlU3RhdHVz64qUIExldHNlZSBFbmdpbmUg7J6R64+Z7KSRIOuwnOyDne2VmOuKlCDqsIHsooUg7IOB7YOcIOuzgOqyveydtOuCmCDsmIjsmbgg7IOB7Zmp7J2EIOygleydmO2VnCDsvZTrk5zrpbwg64KY7YOA64OF64uI64ukLlxuICog7IOB7YOcIOy9lOuTnOyZgCDshKTrqoUg66mU7Iuc7KeA64qUIOyVhOuemOydmCDtkZzsmYAg6rCZ7Iq164uI64ukLlxuICpcbiAqIHxDT0RFIHxNRVNTQUdFICB8XG4gKiB8LS0tICB8LS0tICB8XG4gKiB8MTAxICB8IFVzZSBjaHJvbWUgd2l0aCBpb3N8XG4gKiB8MTAyICB8IFVuc3VwcG9ydGVkIGJyb3dzZXJ8XG4gKiB8MTAzICB8IE5vIGNhbWVyYSBkZXRlY3RlZHxcbiAqIHwxMDQgIHwgTm8gbW9iaWxlIGRldmljZSBkZXRlY3RlZHxcbiAqIHwyMDAgIHwgQ2FtZXJhIGluaXRpYWxpemUgc3RhcnR8XG4gKiB8MjAxICB8IENhbWVyYSBpbml0aWFsaXplIGRvbmV8XG4gKiB8MjAyICB8IFZpZGVvIHN0YXJ0fFxuICovXG5cbi8qKlxuICogTGV0c2VlIOqwneyytOulvCDsg53shLHtlanri4jri6QuXG4gKiBAY2xhc3NcbiAqIEBuYW1lIExldHNlZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIOugm+yLnCDsvZjtlLzqt7hcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuYXBwS2V5IC0gTGV0c2VlIFdlYiBBUiBTREsg7J247KadIO2CpFxuICogQHBhcmFtIHtUcmFja2VyVHlwZX0gY29uZmlnLnRyYWNrZXJUeXBlIC0g7Yq4656Z7LukIO2DgOyehVxuICogQHJldHVybnMge0xldHNlZX1cbiAqL1xuY2xhc3MgTGV0c2VlIHsgLy8gTGV0c2VlT2JzZXJ2ZXLripQgRXZlbnRNYW5hZ2Vy66GcIOu2hOumrCDrj4Xrpr3si5ztgqgg65KkIExldHNlZeydmCDrqaTrsoQg6rCd7LK066GcIOq0gOumrO2VnOuLpC4gYnkgYWhuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKCdMZXRzZWUgaXMgY29uc3RydWN0ZWQhJyk7IC8vIOy2lO2bhCDsooAg642UIOy5nOygiO2VnCDrqZTsi5zsp4DroZwg67O07JmE7ZWp7Iuc64ukLiBieSBhaG5cblxuICAgIHRoaXMuVkVSU0lPTiA9ICcwLjkuMjAuMDAyOCc7XG4gICAgdGhpcy5WRVJTSU9OX1NUUklORyA9IChfX0RFVl9fKSA/XG4gICAgICAoX19MT0NBTF9fKSA/IGBWRVJTSU9OOiAke3RoaXMuVkVSU0lPTn1fbG9jYWxgIDogYFZFUlNJT046ICR7dGhpcy5WRVJTSU9OfV9kZXZgIDpcbiAgICAgIGBWRVJTSU9OOiAke3RoaXMuVkVSU0lPTn1gO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB0aGlzLnJlZkltYWdlRGF0YSA9IG51bGw7IC8vIOuhnOuUqe2VnCBFbnRpdHkg6rCd7LK07J2YIOyGjeyEseycvOuhnCDsp4DsoJXrkJwg7J2066+47KeA7J24642wIEVudGl0eU1hbmFnZXLsl5DshJwg66Gc65Oc7ZWcIOydtOuvuOyngCBibG9i7J2EIFRyYWNrZXLsl5DshJwg6rCA7KC46rCA66m0IOuQmOuLiCDsl6zquLDshKAg6rSA66as7ZWgIO2VhOyalOqwgCDsl4bsnYwgYnkgYWhuXG4gICAgdGhpcy5faXNQYXVzZSA9IGZhbHNlOyAvLyDsl5Tsp4TsnZgg7J287Iuc7KCV7KeAIOyDge2DnOulvCDqtIDrpqztlZjripQg67OA7IiY66GcIOuztOydtOuKlOuNsCDslYTri5ggZ2V0dGVyL3NldHRlciDsnbjqsIA/IOuzgOyImOydtOuptCDqt7jsl5Ag66ee64qUIOuEpOydtOuwjeydhCDtlZjsnpAgYnkgYWhuXG4gICAgdGhpcy5fdXBkYXRlRmxhZyA9IGZhbHNlOyAvLyDsnbTqsoPrj4Qg662Q7ZWY64qU642wIOyTsOuKlOyngCDslYTsp4HsnYAg66qo66W06rKg7J2MIEZsYWfsnZgg7Jet7ZWg7J2EIO2VmOuKlCDqsbTqsIA/IGJ5IGFoblxuICAgIHRoaXMudmlkZW9Mb2FkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3RMb2FkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuYmFyY29kZVJlYWRGbGFnID0gZmFsc2U7XG5cbiAgICB0aGlzLnN0YXRlID0gbnVsbDsgLy8g7J206rGwIOutkO2VmOuKlOuNsCDsk7DripTsp4Ag7JWE7KeB7J2AIOuqqOultOqyoOydjCDrs4DsiJjrqoXsnLzroZwg7LaU7KCV7J20IOyViOuQqCBieSBhaG5cbiAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgIHRoaXMuY3NzRGF0YSA9IG51bGw7IC8vIENTU1BhcnNlcuyXkCDrhJjquLDripQg7IaM7Iqk7J246rG06rCAIOyVhOuLmCDtjIzsi7HrkJwg6rKw6rO87J246rG06rCAIOq3vOuNsCBMZXRzZWUgQ2xhc3PqsIAg7KCA7J6l7ZWY6rOgIOq0gOumrO2VtOyVvCDtlZjripQg6rG06rCAPz8/IGJ5IGFoblxuICAgIHRoaXMucHJvbWlzZUNoYWluID0gW107IC8vIOuJmOyLoOyngD8gVF9UIGJ5IGFoblxuICAgIHRoaXMuYXJTY3JlZW4gPSB7fTsgLy8gT0sgYnkgYWhuXG4gICAgdGhpcy5lbnRpdHlNYW5hZ2VyID0gbnVsbDsgLy8g6reA7ZWY6rKMIOuqqOyLnOyekCBieSBhaG5cbiAgICB0aGlzLnZpZGVvTWFuYWdlciA9IG51bGw7IC8vIOyWmOuPhCDsoJXspJHtnogg66qo7Iuc7J6QIOq3gOyduOydtOyLnOuLpCBieSBhaG5cbiAgICB0aGlzLkFSM0RSZW5kZXJNb2R1bGVNYW5hZ2VyID0gbnVsbDtcbiAgICAvLyDslpwg662Q7KeAPyBFbnRpdHlNYW5hZ2Vy7JmAIOutkOqwgCDri6TrpbTsp4A/IEVudGl0eeuzhCBFdmVudCDqtIDrpqztlZjripQg6rKD7J20652866m0IFRyYWNrZXJNYW5hZ2Vy7JeQ7IScIEV2ZW50TWFuYWdlcuuhnCDsoITri6zrkJjslrTslbwg7ZWgIOuTryBieSBhaG5cbiAgICB0aGlzLmVudGl0eU9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy50cmFja2VyID0gbnVsbDtcblxuICAgIHRoaXMuZnBzID0gMzA7XG4gICAgdGhpcy5mcHNJbnRlcnZhbCA9IDEwMDAgLyB0aGlzLmZwcztcbiAgICB0aGlzLm5vdyA9IG51bGw7XG4gICAgdGhpcy50aGVuID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmVsYXBzZWQgPSBudWxsO1xuICB9XG5cbiAgLyog6rKw66GgOiBwcmVwYXJl7J2YIOuCtOyaqeuTpOydgCBjb25zdHJ1Y3RvciDrmJDripQgaW5pdOuhnCDrgpjriITqs6Ag7KCV66as7ZWY64qUIOqyjCDrp57sp4Ag7JWK7J2E6rmMPyDtlZzrsogg642UIOqzoOuvvC4uLi5ieSBhaG4gKi9cbiAgcHJlcGFyZShfY29uZmlnKSB7XG5cbiAgICB0aGlzLk1hdHJpeDQgPSBNYXRyaXg0O1xuICAgIHRoaXMuTWF0cml4MyA9IE1hdHJpeDM7XG4gICAgdGhpcy5WZWN0b3IyID0gVmVjdG9yMjtcbiAgICB0aGlzLlZlY3RvcjMgPSBWZWN0b3IzO1xuICAgIHRoaXMuUXVhdGVybmlvbiA9IFF1YXRlcm5pb247XG4gICAgdGhpcy5FdWxlciA9IEV1bGVyO1xuICAgIHRoaXMuT2JqZWN0M0QgPSBPYmplY3QzRDtcbiAgICB0aGlzLkVudGl0eSA9IEVudGl0eTtcbiAgICB0aGlzLkVudGl0eU9ic2VydmVyID0gRW50aXR5RXZlbnQ7XG4gICAgdGhpcy5ET01SZW5kZXJhYmxlID0gRE9NUmVuZGVyYWJsZTtcblxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChNZXNzYWdlLkxFVFNFRV9DU1MuTEVUU0VFX0xPQURJTkcpOyAvLyDroZzrlKnrqZTsi5zsp4Dsl5Ag64yA7ZWcIOqxsD8gYnkgYWhuXG4gICAgYWRkVmlld3BvcnQoKTsgLy8gQVJXZWJBcHDsnZggdmlld3BvcnTrpbwgQVLsl5Ag7KCB7ZWp7ZWY6rKMIOyhsOygle2VtOykjC4gdXNlciBkZWZpbmXqs7wg6rCS7J20IOuLpOultOuptCDslrTrlrvqsowg65CY7KeAPyBieSBhaG5cbiAgICBjcmVhdGVMZXRzZWVXcmFwcGVyKCk7IC8vIExldHNlZVdyYXBwZXLqsIAg662U6rCA7JqUPyBieSBhaG5cbiAgICBjcmVhdGVMb2FkZXIoKTsgLy8gY3JlYXRlTG9hZGVy64qUIOustOyXh+ydhCDqsIDsoLjsmKTripQg66Gc642U66W8IOunjOuTnOuCmOyalD8gbG9hZGVy6rCAIO2VnOuRkOqwnOuDkC4uLuunjOuToOqxsCDslrTrlJTsl5Ag7J6I64KY7JqUPyBieSBhaG5cbiAgICB0aGlzLmVudGl0eU1hbmFnZXIgPSBuZXcgRW50aXR5UGFyc2VyKCk7IC8vIHByZXBhcmXsmYAgaW5pdCDri6jqs4TqsIAg66qF7ZmV7Z6IIOq1rOu2hOuQmOyngCDslYrslYTsl6wuIOydtOqxsCBjb25zdHJ1Y3RvcuyXkOyEnCDsg53shLHtlbTshJwg64Sj7Ja07KO866m0IOyZnCDslYjrj7zsmpQ/IGJ5IGFoblxuICAgIHRoaXMudmlkZW9NYW5hZ2VyID0gbmV3IFZpZGVvTWFuYWdlcigpOyAvLyDslpjripQg7JmcIOyViOuPvOyalD8g7J2867CY7KCB7Jy866GcIENsYXNzIGNvbnN0cnVjdG9y6rCAIOuppOuyhCDrs4DsiJgg7LSI6riw7ZmUIO2VmOuKlCDroZzsp4Eg65Ok7Ja06rCA64qU642wLi4uIGJ5IGFoblxuICAgIC8qIOyVhOuemCDqtazrrLjsnYAgdmlkZW9NYW5hZ2Vy6rCAIOy0iOq4sO2ZlCDrkKAg65WMIOuTseuhne2VtOyVvCDtlZjripQg6rGwIOyVhOuLiOyXkOyalD8gYnkgYWhuKi9cbiAgICB0aGlzLnZpZGVvTWFuYWdlci5zdWJzY3JpYmUoTEVUU0VFX0VWRU5ULk9OX1NUQVRVUywgZSA9PiB7XG4gICAgICAvLyB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCBlKTtcbiAgICAgIGlmIChlLmNvZGUgPT09IDIwMikgdGhpcy52aWRlb0xvYWRGbGFnID0gdHJ1ZTtcbiAgICAgIGlmIChlLnN0YXR1cyA9PT0gJ2Vycm9yJykgY3JlYXRlU3RhdHVzU2NyZWVuKGUuY29kZSk7XG4gICAgfSk7XG4gICAgdGhpcy5BUjNEUmVuZGVyTW9kdWxlTWFuYWdlciA9IG5ldyBBUjNEUmVuZGVyTW9kdWxlTWFuYWdlcigpO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcigpO1xuXG4gICAgLy8gQGF1dGhvciB0cmVldG9yeSA6IExPQ0FMIO2ZmOqyveydvCDrlYwsIHZhbGlkYXRlIO2VmOuKlCDqsoPsnbQg7KGw6rG07J20IOuLrOudvOyngOqyjCDtlZjrqbQg65CY7KeAIOyViuydhOq5jD9cbiAgICAvLyBAYXV0aG9yIGFobiA6IFNldHRpbmdzIO2BtOuemOyKpOuhnCDrlLDroZwg67m864qU6rG0IOyWtOuVjOyalD9cbiAgICB0aGlzLmNvbmZpZyA9IHZhbGlkYXRlQ29uZmlnKF9jb25maWcpO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmNvbmZpZy5ib2R5SWQpOyAvLyDsnbTqsbQg7JmcIO2VmOuCmOyalD8gYnkgYWhuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5BUl9NT0RFX09OKTsgLy8g7J206rG0IOustOyKqCDsnbzsnYQg7ZWY64KY7JqUPyBieSBhaG5cblxuICAgIC8qIFN0YXJ0IGRvbSBwbGFjZSBob2xkZXJcbiAgICAgIGRvbVBsYWNlaG9sZGVy64qUIOustOyXh+ydtOuDkD8g64SIIExldHNlZSBDbGFzc+yXkCDsnojslrTslbwg7ZWY64qUIOuGiOydtOuDkD8gYnkgYWhuICovXG4gICAgY29uc3QgZG9tUGxhY2Vob2xkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGRvbVBsYWNlaG9sZGVyLmlkID0gY29udGV4dC5wbGFjZWhvbGRlcklkO1xuICAgIGRvbVBsYWNlaG9sZGVyLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnLCAnaW1wb3J0YW50Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkb21QbGFjZWhvbGRlcik7XG4gICAgLy8gRW5kIGRvbSBwbGFjZSBob2xkZXJcblxuICAgIHRoaXMuY3NzRGF0YSA9IGNzc1BhcnNlci5wYXJzZSh0aGlzLmNvbmZpZy5ib2R5SWQpOyAvLyDrhKQgY3NzRGF0YeuKlCBjc3NQYXJzZXLsnZgg7IKw7Lac66y87J207Iut64uI64ukLiBieSBhaG5cblxuICAgIHRoaXMuZW50aXR5T2JzZXJ2ZXIgPSBuZXcgRW50aXR5T2JzZXJ2ZXIoKTsgLy8g7LSI6riw7ZmUIOq1rOusuOydgCDsnITsqr3snLzroZwg66qw7JWE7IScIOygleumrO2VmOyjoCBieSBhaG5cbiAgICAvKiDslYTrnpggZW50aXR5T2JzZXJ2ZXIuc3Vic2NyaWJlIOu2gOu2hOydgCBFdmVudE1hbmFnZXLsmYDsnZgg6rSA6rOE66GcIOyeheyepSDsoJXrpqwg6rCA64ql7ZWg65OvPyBieSBhaG4gKi9cbiAgICB0aGlzLmVudGl0eU9ic2VydmVyLnN1YnNjcmliZShFTlRJVFlfRVZFTlQuVFJBQ0tfU1RBUlQsIGUgPT4ge1xuICAgICAgLy8gdGhpcy5ldmVudE1hbmFnZXIubm90aWZ5KEVOVElUWV9FVkVOVC5UUkFDS19TVEFSVCwgZSk7XG4gICAgICAvLyB0aGlzLnRyYWNrU3RhdHVzQ3NzKEVOVElUWV9FVkVOVC5UUkFDS19TVEFSVCk7XG4gICAgfSk7XG4gICAgdGhpcy5lbnRpdHlPYnNlcnZlci5zdWJzY3JpYmUoRU5USVRZX0VWRU5ULlRSQUNLX01PVkUsIGUgPT4ge1xuICAgICAgLy8gdGhpcy5ldmVudE1hbmFnZXIubm90aWZ5KExFVFNFRV9FVkVOVC5UUkFDS19NT1ZFLCBlKTtcbiAgICAgIC8vIHRoaXMudHJhY2tTdGF0dXNDc3MoRU5USVRZX0VWRU5ULlRSQUNLX01PVkUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW50aXR5T2JzZXJ2ZXIuc3Vic2NyaWJlKEVOVElUWV9FVkVOVC5UUkFDS19FTkQsIGUgPT4ge1xuICAgICAgLy8gdGhpcy5ldmVudE1hbmFnZXIubm90aWZ5KExFVFNFRV9FVkVOVC5UUkFDS19FTkQsIGUpO1xuICAgICAgLy8gdGhpcy50cmFja1N0YXR1c0NzcyhFTlRJVFlfRVZFTlQuVFJBQ0tfRU5EKTtcbiAgICB9KTtcblxuICAgIC8qIOydjC4u7Jes6riw7IScIGxvYWRJbWFnZeulvCDtlZjrhKTsmpQuIGNoZWNrRW50aXR564qUIEVudGl0eU1hbmFnZXLroZwg7Y647J6F7ZWY64qUIOqyjCDslrTrlYzsmpQ/IGJ5IGFobiAqL1xuICAgIGNvbnN0IGNoZWNrRW50aXR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLmluaXRFbnRpdHkodGhpcy5jc3NEYXRhKS50aGVuKChvYmopID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG9iajtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRyYWNrZXJUeXBlID09PSAnSU1BR0UnKSB7XG4gICAgICAgICAgbG9hZEltYWdlKHRoaXMuc3RhdGVbMF0uZW50aXR5LmltYWdlKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZkltYWdlRGF0YSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZWZJbWFnZURhdGEpO1xuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKiBjaGVja0VuduuKlCDrrLTsl4fsnoXri4jquYw/IHNjcmVlbiDrk7Eg6riw67O4IOygleuztOuKlCDqsIEgc291cmNlIOqwneyytOyXkOyEnCDsp4DqsIAg7KeB7KCRIOqwgOyguOqwgOuptCDrkJjsp4AuIOq3uOugh+yngCBFbmdpbmU/IOq3uOumrOqzoCDrhIwg7J207KCcIEVuZ2luZeydtCDslYTri4jslbwgYnkgYWhuICovXG4gICAgY29uc3QgY2hlY2tFbnYgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnZpZGVvTWFuYWdlci5pbml0KHRoaXMuY29uZmlnLnpJbmRleCwgdGhpcy5jb25maWcuekluZGV4SW5jcmVtZW50KVxuICAgICAgICAudGhlbigoX3NjcmVlblNpemUpID0+IHtcbiAgICAgICAgICB0aGlzLmFyU2NyZWVuID0gbmV3IFNjcmVlbihfc2NyZWVuU2l6ZS53aWR0aCwgX3NjcmVlblNpemUuaGVpZ2h0LFxuICAgICAgICAgICAgdGhpcy52aWRlb01hbmFnZXIpO1xuICAgICAgICAgIF9sZXRzZWVFbmdpbmVDb25maWcud2lkdGggPSB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLndpZHRoO1xuICAgICAgICAgIF9sZXRzZWVFbmdpbmVDb25maWcuaGVpZ2h0ID0gdGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5oZWlnaHQ7XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy5vcmllbnRhdGlvbiA9IHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8uYW5nbGU7XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy5kYXRhID0gdGhpcy5jc3NEYXRhO1xuICAgICAgICAgIF9sZXRzZWVFbmdpbmVDb25maWcuZG9tUmVuZGVyZXJJZCA9IHRoaXMuY29uZmlnLmRvbVJlbmRlcmVySWQ7XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy56SW5kZXggPSB0aGlzLmNvbmZpZy56SW5kZXg7XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy56SW5kZXhJbmNyZW1lbnQgPSB0aGlzLmNvbmZpZy56SW5kZXhJbmNyZW1lbnQ7XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy5wcm9qZWN0aW9uUGFyYW1ldGVyID1cbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIuZm92LFxuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5zY3JlZW5Bc3BlY3RSYXRpbyxcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYVBhcmFtZXRlci5uZWFyLFxuICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhUGFyYW1ldGVyLmZhclxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy5leHRlcm5hbCA9IHRoaXMuY29uZmlnLmV4dGVybmFsIHx8IG51bGw7XG5cbiAgICAgICAgICB0aGlzLmVuZ2luZSA9IG5ldyBFbmdpbmUoX2xldHNlZUVuZ2luZUNvbmZpZyk7XG4gICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICAgICAgICB0aGlzLkFSM0RSZW5kZXJNb2R1bGVNYW5hZ2VyLmFkZEVuZ2luZSh0aGlzLmVuZ2luZSk7XG4gICAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEVudGl0eUV2ZW50KCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKiDrs4Trj4Qg67aE66as65CcIFRyYWNrZXIuanMg7YyM7J287J2EIOuhnOuTnO2VmOuKlCDqsbA/IO2VhOyalO2VqD8gYnkgYWhuICovXG4gICAgY29uc3QgY2hlY2tTY3JpcHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICAgICAgc3dpdGNoICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSkge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlICdJTUFHRSc6XG4gICAgICAgICAgc2NyaXB0LnNyYyA9IGAke1RSQUNLRVJfVVJMfSR7SU1BR0VfVFJBQ0tFUl9GSUxFX05BTUV9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTUFSS0VSJzpcbiAgICAgICAgICBzY3JpcHQuc3JjID0gYCR7VFJBQ0tFUl9VUkx9JHtNQVJLRVJfVFJBQ0tFUl9GSUxFX05BTUV9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUVJDT0RFJzpcbiAgICAgICAgICBzY3JpcHQuc3JjID0gYCR7VFJBQ0tFUl9VUkx9JHtRUkNPREVfVFJBQ0tFUl9GSUxFX05BTUV9YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGlmICh0eXBlICE9PSAnU0xBTScpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNjcmlwdCk7XG4gICAgICAvLyBFeHBvc2VkIFRyYWNrZXIgZnJvbSB3ZWJwYWNrXG4gICAgICBzY3JpcHQub25sb2FkID0gKCkgPT4gcmVzb2x2ZShuZXcgVHJhY2tlcih0aGlzKSk7XG4gICAgICBzY3JpcHQub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYFNjcmlwdCBsb2FkIGVycm9yIGZvciAke3NyY31gKSk7XG4gICAgICAvLyB9IGVsc2UgaWYgKHR5cGUgPT09ICdTTEFNJykge1xuICAgICAgLy8gICByZXNvbHZlKG5ldyBTbGFtKCkpO1xuICAgICAgLy8gfVxuICAgIH0pO1xuXG4gICAgLyog7J206rGwIOyVhOyngeuPhCDrqqjrpbTqsqDslrTsmpQgYnkgYWhuICovXG4gICAgdGhpcy5wcm9taXNlQ2hhaW4gPSBbY2hlY2tFbnRpdHksIGNoZWNrRW52LCBjaGVja1NjcmlwdF07XG5cbiAgICAvKiDsnpAsIG9yaWVudGF0aW9uY2hhbmdlIOydtOuypO2KuOqwgCDrsJzsg53tlojsnYQg65WMIHZpZGVvTWFuYWdlcuyXkCDsnojripQg7Iqk7YGs66awIOyDge2DnOqwkuydhCBFbmdpbmVDb25maWfsl5Ag7Y2864KY66aF64uI64ukLlxuICAgICAg67CU67O06rCZ7JWE7JqULi4u7J207KCc64qUIEVuZ2luZeyXkOyEnCBsZXRzZWUuc2NyZWVu7J2EIOq1rOuPhe2VtOyEnCDsp4HsoJEg7JWM7JWE6rCA64qUIOqyjCDsoovqsqDslrTsmpRcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBlID0+IHtcbiAgICAgIGlmICh0aGlzLnRyYWNrZXIpIHRoaXMudHJhY2tlci5zdG9wVHJhY2tlciA9IHRydWU7XG4gICAgICB0aGlzLnZpZGVvTWFuYWdlci5vcmllbnRhdGlvbkNoYW5nZSgpO1xuICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy53aWR0aCA9IHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8ud2lkdGg7XG4gICAgICBfbGV0c2VlRW5naW5lQ29uZmlnLmhlaWdodCA9IHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8uaGVpZ2h0O1xuICAgICAgX2xldHNlZUVuZ2luZUNvbmZpZy5vcmllbnRhdGlvbiA9IHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8uYW5nbGU7XG4gICAgICBfbGV0c2VlRW5naW5lQ29uZmlnLnByb2plY3Rpb25QYXJhbWV0ZXIgPVxuICAgICAgICAgIFtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mb3YsXG4gICAgICAgICAgICB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLnNjcmVlbkFzcGVjdFJhdGlvLFxuICAgICAgICAgICAgdGhpcy5jb25maWcuY2FtZXJhUGFyYW1ldGVyLm5lYXIsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIuZmFyXG4gICAgICAgICAgXTtcbiAgICAgIHRoaXMuZW5naW5lLm9uQ29uZmlndXJhdGlvbkNoYW5nZWQoe1xuICAgICAgICAnd2lkdGgnOiBfbGV0c2VlRW5naW5lQ29uZmlnLndpZHRoLFxuICAgICAgICAnaGVpZ2h0JzogX2xldHNlZUVuZ2luZUNvbmZpZy5oZWlnaHQsXG4gICAgICAgICdvcmllbnRhdGlvbic6IF9sZXRzZWVFbmdpbmVDb25maWcuYW5nbGUsXG4gICAgICAgICdhc3BlY3QnOiB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLnNjcmVlbkFzcGVjdFJhdGlvXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnRyYWNrZXIpIHRoaXMudHJhY2tlci5zdG9wVHJhY2tlciA9IGZhbHNlO1xuICAgICAgLy8gdGhpcy5kaXNwYXRjaChNZXNzYWdlLkVWRU5UX0FQUF9ST1RBVElPTkNIQU5HRSwgZSk7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci5ub3RpZnkoTEVUU0VFX0VWRU5ULlJPVEFUSU9OX0NIQU5HRSwgZSk7XG4gICAgfSk7XG4gICAgKi9cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZXYgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ3Jlc2l6ZScpO1xuICAgICAgaWYgKHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbi5maXRXaWR0aEFuZEhlaWdodCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdMZXRzZWUgaXMgcHJlcGFyZWQhISEnKTtcbiAgfVxuXG4gIC8qIOqysOq1rSBpbml07J2AIHRyYWNrZXIg7ZWY64KY66eMIOuLpOujqOqzoCDrp4jrhKTsmpQuIHRyYWNrZXLrpbwg7JyE7ZWcIGluaXTsnbTqtbDsmpQuICovXG4gIGluaXQoY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm9uTG9hZChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29uZmlnID0gdmFsaWRhdGVDb25maWcoY29uZmlnKTtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29uZmlnKTtcbiAgICAgIFByb21pc2UuYWxsKHRoaXMucHJvbWlzZUNoYWluKS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy50cmFja2VyID0gdmFsdWVbMl07XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrZXIuaW5pdFRyYWNrZXIoXG4gICAgICAgICAgdGhpcy52aWRlb01hbmFnZXIudmlkZW9FbGVtZW50LFxuICAgICAgICAgIHRoaXMudmlkZW9NYW5hZ2VyLmNhbnZhc0VsZW1lbnQsXG4gICAgICAgICAgdGhpcy5jb25maWcuYXBwS2V5KTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBmcmFtZUJ5dGVBZGRyZXNzID0gdHJhY2tlci51cGRhdGVTY3JlZW4odGhpcy52aWRlb01hbmFnZXIuc2NyZWVuV2lkdGgsIHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkhlaWdodCk7XG4gICAgICAgIC8vIGlmICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSA9PT0gJ0lNQUdFJykgdGhpcy5zZXRSZWZlcmVuY2VJbWFnZShyZWZJbWFnZURhdGEuaW1nKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRyYWNrZXJUeXBlID09PSAnSU1BR0UnKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLnNldFJlZkltYWdlKFxuICAgICAgICAgICAgdGhpcy5yZWZJbWFnZURhdGEuaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcudHJhY2tlclR5cGUgPT09ICdNQVJLRVInKSB7XG4gICAgICAgICAgdGhpcy50cmFja2VyLmNyZWF0ZU1hcmtlclN0YXRlKFxuICAgICAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLm1hcmtlckxpc3QgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRyYWNrZXJUeXBlID09PSAnUVJDT0RFJykge1xuICAgICAgICAgIHRoaXMudHJhY2tlci5jcmVhdGVNYXJrZXJTdGF0ZShcbiAgICAgICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci5jb2RlTGlzdCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodGhpcy5jb25maWcudHJhY2tlclR5cGUgPT09ICdTTEFNJykgdHJhY2tlci5jcmVhdGVNYXJrZXJTdGF0ZSh0aGlzLmVudGl0eU1hbmFnZXIuY29kZUxpc3QgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMucmVuZGVyQWxsVGFzaygpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyog66y07IqoIOydvOydhCDtlZjripTsp4Ag66qo66W06rKg7Iq164uI64ukLiDrj4zslYTripQg6rCA64qU642wIOyViOuztOydtOqyjOunjCDtlZjripQg6rGw64Sk7JqUPyAqL1xuICBwYXVzZSgpIHtcbiAgICB0aGlzLl9pc1BhdXNlID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoTWVzc2FnZS5MRVRTRUVfQ1NTLkFSX01PREVfT04pO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChNZXNzYWdlLkxFVFNFRV9DU1MuQVJfTU9ERV9PRkYpO1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIEVOVElUWV9FVkVOVC5UUkFDS19TVEFSVCxcbiAgICAgIEVOVElUWV9FVkVOVC5UUkFDS19NT1ZFLFxuICAgICAgRU5USVRZX0VWRU5ULlRSQUNLX0VORCxcbiAgICApO1xuICAgIHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgLyog7J206rKD64+EIOyViOuztOydtOuNmOqxsCDrs7TsnbTqsozrp4wg7ZWY64qULi4uPyBieSBhaG4gKi9cbiAgcmVzdW1lKCkge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChNZXNzYWdlLkxFVFNFRV9DU1MuQVJfTU9ERV9PTik7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKE1lc3NhZ2UuTEVUU0VFX0NTUy5BUl9NT0RFX09GRik7XG4gICAgdGhpcy52aWRlb01hbmFnZXIuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuX2lzUGF1c2UgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBpc1BhdXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1BhdXNlO1xuICB9XG5cbiAgLyog66mU7J24IOujuSAqL1xuICByZW5kZXJBbGxUYXNrKCkge1xuICAgIC8vIGNhbGMgZWxhcHNlZCB0aW1lIHNpbmNlIGxhc3QgbG9vcFxuICAgIHRoaXMubm93ID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmVsYXBzZWQgPSB0aGlzLm5vdyAtIHRoaXMudGhlbjtcblxuICAgIC8vIGlmIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkLCBkcmF3IHRoZSBuZXh0IGZyYW1lXG4gICAgaWYgKHRoaXMuZWxhcHNlZCA+IHRoaXMuZnBzSW50ZXJ2YWwpIHtcbiAgICAgIC8vIEdldCByZWFkeSBmb3IgbmV4dCBmcmFtZSBieSBzZXR0aW5nIHRoZW49bm93LCBidXQgYWxzbyBhZGp1c3QgZm9yIHlvdXJcbiAgICAgIC8vIHNwZWNpZmllZCBmcHNJbnRlcnZhbCBub3QgYmVpbmcgYSBtdWx0aXBsZSBvZiBSQUYncyBpbnRlcnZhbCAoMTYuN21zKVxuICAgICAgdGhpcy50aGVuID0gdGhpcy5ub3cgLSAodGhpcy5lbGFwc2VkICUgdGhpcy5mcHNJbnRlcnZhbCk7XG4gICAgICAvLyBAYXV0aG9yIHRyZWV0b3J5IOyVhOuemCDsvZTrk5wg64Sj7Jy866m0IOuPmeyekeyViOuQqCAtPiDsvZTroZzsnbQg7KeE7ZaJIOykkSwg6rCR7J6Q6riwIOuwnOyDne2VnCDqsoPsnoRcbiAgICAgIC8vIHRoaXMuQVIzRFJlbmRlck1vZHVsZU1hbmFnZXIucmVuZGVyTW9kdWxlcy5mb3JFYWNoKHZhbCA9PiB2YWwocGVyZm9ybWFuY2Uubm93KCkpKTtcbiAgICAgIGlmIChkb0NhcHR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5iYXJjb2RlUmVhZEZsYWcpIHtcbiAgICAgICAgICBkb0NhcHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmFja2VyLnByb2Nlc3NGcmFtZSh0aGlzLl9pc1BhdXNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmlkZW9Mb2FkRmxhZyAmJiAhdGhpcy5maXJzdExvYWRGbGFnKSB7IC8vIOydtOu2gOu2hC4uLi7rrZDsp4AgYnkgYWhuXG4gICAgICB0aGlzLmZpcnN0TG9hZEZsYWcgPSB0cnVlO1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfTE9BREVEKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShNZXNzYWdlLkxFVFNFRV9DU1MuTEVUU0VFX0xPQURJTkcpO1xuICAgICAgY29uc3QgY2hlY2tMb2FkZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfTE9BREVEKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfTE9BRElORyk7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLm5vdGlmeShNZXNzYWdlLkVWRU5UX0FQUF9PTkxPQUQpO1xuICAgICAgICBjbGVhclRpbWVvdXQoY2hlY2tMb2FkZXIpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfVxuICAgIDtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyQWxsVGFzaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyog7J206rKD64+EIOutlOyngCDrqqjrpbTqsqDsirXri4jri6QuIGJ5IGFobiAqL1xuICB0cmFja1N0YXR1c0NzcyhzdGF0dXMpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBFTlRJVFlfRVZFTlQuVFJBQ0tfU1RBUlQsXG4gICAgICBFTlRJVFlfRVZFTlQuVFJBQ0tfTU9WRSxcbiAgICAgIEVOVElUWV9FVkVOVC5UUkFDS19FTkQsXG4gICAgKTtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoc3RhdHVzKTtcbiAgfTtcblxuICAvKipcbiAgICog7Luk7Iqk7YWAIOuhnOuUqSDtmZTrqbTsnYQg65Ox66Gd7ZWp64uI64ukLiDsoITri6zrkJwgaHRtbCDshozsiqTripQgYGlkPWxldHNlZUxvYWRlcldyYXBwZXJg7J24IGBkaXZg7YOc6re47JeQIOy2lOqwgOuQqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjc2V0TG9hZGluZ1NjcmVlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCAtIOyCrOyaqe2VoCDroZzrlKkg7ZmU66m07J2YIGh0bWwg7L2U65OcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNzcyAtIOyeheugpe2VnCBodG1s7L2U65Oc66W8IOychO2VnCBjc3NcbiAgICogQGV4YW1wbGVcbiAgICogLy8gc3RyaW5n7ZiV7YOc66GcIGh0bWzsvZTrk5zrpbwg7IOd7ISx7ZWp64uI64ukLlxuICAgKiBjb25zdCBjdXN0b21Mb2FkZXIgPSBcIjxwPjxzcGFuPkxvYWRpbmcuLi48L3NwYW4+PC9wPlwiO1xuICAgKiAvLyBjc3Prpbwgc3RyaW5n7Jy866GcIOyDneyEse2VmOqzoCBBcnJheeyXkCDri7TsirXri4jri6QuXG4gICAqIGNvbnN0IGN1c3RvbUxvYWRlckNzcyA9IFtcbiAgICogYCNsZXRzZWVMb2FkZXJXcmFwcGVyIHAge1xuICAgKiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAqICAgIGxlZnQ6IDUwJTtcbiAgICogICAgdG9wOiA1MCU7XG4gICAqICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgKiAgfWAsXG4gICAqIGAjbGV0c2VlTG9hZGVyV3JhcHBlciBwIHNwYW4ge1xuICAgKiAgICBjb2xvcjogIzY2NjY2NjtcbiAgICogfWBdO1xuICAgKiAvLyBodG1s6rO8IGNzc+ulvCDrk7HroZ3tlanri4jri6QuXG4gICAqIG15QXBwLnNldExvYWRpbmdTY3JlZW4oY3VzdG9tTG9hZGVyLCBjdXN0b21Mb2FkZXJDc3MpO1xuICAgKi9cbiAgc2V0TG9hZGluZ1NjcmVlbihodG1sLCBjc3MpIHsgLy8g7J206rKMIOy1nOyEoOyduOqwgOyalD8gYnkgYWhuXG4gICAgaWYgKCEhaHRtbCAmJiAhIWNzcykgY3JlYXRlTG9hZGVyKGh0bWwsIGNzcyk7XG4gICAgZWxzZSBjb25zb2xlLmxvZygnWW91IG5lZWQgc2V0dXAgYm90aCBodG1sIGFuZCBjc3MnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDrk7HroZ3rkJwg66qo65OgIOyXlO2EsO2LsOulvCDrsJjtmZjtlanri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI2dldEVudGl0aWVzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGdldEFsbEVudGl0aWVzKCkgeyAvLyBFbnRpdHlNYW5hZ2Vy66W8IO2Gte2VtOyEnCDsoJHqt7ztlZjrqbQg65CoIGJ5IGFoblxuICAgIHJldHVybiAoaXNOaWwodGhpcykpID9cbiAgICAgIG5ldyBFcnJvcignUnVuIGxldHNlZS5pbml0IGZpcnN0JykgOlxuICAgICAgdGhpcy5lbmdpbmUuZ2V0RW50aXRpZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDso7zslrTsp4QgdXJp66W8IOqwgOynhCDsl5TthLDti7Drpbwg67CY7ZmY7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNnZXRFbnRpdHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICAgKiBAcmV0dXJucyB7RW50aXR5fSBFbnRpdHlcbiAgICovXG4gIGdldEVudGl0eSh1cmkpIHsgLy8gRW50aXR5TWFuYWdlcuulvCDthrXtlbTshJwg7KCR6re87ZWY66m0IOuQqCBieSBhaG5cbiAgICByZXR1cm4gKGlzTmlsKHRoaXMpKSA/XG4gICAgICBuZXcgRXJyb3IoJ1J1biBsZXRzZWUuaW5pdCBmaXJzdCcpIDpcbiAgICAgIHRoaXMuZW5naW5lLmdldEVudGl0eSh1cmkpO1xuICB9XG5cbiAgLyoqXG4gICAqIOyngOygleuQnCB1cmnrpbwg6rCA7KeEIOyXlO2EsO2LsOulvCDsgq3soJztlanri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI3JlbW92ZUVudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqL1xuICByZW1vdmVFbnRpdHkodXJpKSB7IC8vIEVudGl0eU1hbmFnZXLrpbwg7Ya17ZW07IScIOygkeq3vO2VmOuptCDrkKggYnkgYWhuXG4gICAgcmV0dXJuIChpc05pbCh0aGlzKSkgP1xuICAgICAgbmV3IEVycm9yKCdSdW4gbGV0c2VlLmluaXQgZmlyc3QnKSA6XG4gICAgICB0aGlzLmVuZ2luZS5yZW1vdmVFbnRpdHkodXJpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDsp4DsoJXrkJwgdXJp66W8IOqwgOynhCDsl5TthLDti7DqsIAg7J6I64qU7KeAIO2ZleyduO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjaGFzRW50aXR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBoYXNFbnRpdHkodXJpKSB7IC8vIEVudGl0eU1hbmFnZXLrpbwg7Ya17ZW07IScIOygkeq3vO2VmOuptCDrkKguIGJ5IGFoblxuICAgIHJldHVybiAoaXNOaWwodGhpcykpID9cbiAgICAgIG5ldyBFcnJvcignUnVuIGxldHNlZS5pbml0IGZpcnN0JykgOlxuICAgICAgdGhpcy5lbmdpbmUuaGFzRW50aXR5KHVyaSk7XG4gIH1cblxuICAvKipcbiAgICogTGV0c2VlIFdlYiBBUiBTREvsnZgg67KE7KCE7J2EIOuwmO2ZmO2VqeuLiOuLpC5cbiAgICogQG1lbWJlciB7c3RyaW5nfSBMZXRzZWUjdmVyc2lvblxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB2ZXJzaW9uKCkgeyAvLyDslrTsp5ztlLwg7J2066CH6rKMIOqwgOyguOqwiCDqurzrqbTshJwg7JmcIGNvbnN066W8IOunjOuTnOuCmOyalD8gYnkgYWhuXG4gICAgcmV0dXJuIFZFUlNJT05fU1RSSU5HO1xuICB9XG5cbiAgLyog7J2MIOydtOqxtCDslrTrlqDtlZwg6rK97Jqw7JeQIOyTsOydtOuCmOyalD8gYnkgYWhuICovXG4gIGdldCBjc3NTZWxlY3RvcigpIHtcbiAgICBpZiAoaXNOaWwodGhpcykpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1J1biBsZXRzZWUuaW5pdCBmaXJzdCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYm9keUlkOiB0aGlzLmNvbmZpZy5ib2R5SWQsXG4gICAgICBkb21SZW5kZXJlcklkOiB0aGlzLmNvbmZpZy5kb21SZW5kZXJlcklkLFxuICAgICAgdmlkZW9JZDogdGhpcy5jb25maWcudmlkZW9JZFxuICAgIH07XG4gIH1cbn1cblxuLy8gZXhwb3J0IGRlZmF1bHQgTGV0c2VlO1xuZXhwb3J0IGNvbnN0IGxldHNlZSA9IG5ldyBMZXRzZWUoe30pO1xud2luZG93LmxldHNlZSA9IGxldHNlZTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIChldmVudCkgPT4ge1xuICBjb25zb2xlLmxvZygnRE9NIGlzIHJlYWR5LicpO1xuICBsZXRzZWUucHJlcGFyZSh7fSk7XG59KTtcbiIsImxldCByZW5kZXJNb2R1bGUgPSBuZXcgTWFwKCk7XG5cbmNsYXNzIEFSM0RSZW5kZXJNb2R1bGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8g7J206rGwIOyVhOyngeydgCDsgqzsmqntlZjsp4Ag7JWK64qUIOqyg+ycvOuhnCDslYTripTrjbAsIERPTVJlbmRlcmVy7JmAIFRocmVlUmVuZGVyZXLrk7Eg7Jm467aAIOugjOuNlOungSDsl5Tsp4Tqs7wg7Jew64+Z65CY64qUIOuqqOuTiOuTpOydtCDtmLjstpzrkKAg66qp66GdIGJ5IGFoblxuICAgIC8vIHRoaXMucmVuZGVyTW9kdWxlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5naW5lID0gbnVsbDtcbiAgfTtcblxuICBhZGRFbmdpbmUoX2VuZ2luZSkge1xuICAgIHRoaXMuZW5naW5lID0gX2VuZ2luZTtcbiAgfVxuXG4gIC8qKlxuICAgKiDroIzrjZTrp4Hsi5zsl5Ag7J6R64+Z7ZWgIOy7pOyKpO2FgCDrqqjrk4jsnYQg65Ox66Gd7ZWp64uI64ukLiDrk7HroZ3rkJwg66qo65OI7J2AIExldHNlZeydmCDroIzrjZTrp4Eg66Oo7ZSE7JeQIOunnuy2lOyWtCDsi6TtlonrkKnri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI2FkZFJlbmRlck1vZHVsZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlT2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVPYmplY3QubmFtZSAtIOy7pOyKpO2FgCDrqqjrk4jsnZgg7J2066aE7J6F64uI64ukLiDsnKDri4jtgaztlZjsl6zslbwg7ZWp64uI64ukLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2R1bGVPYmplY3Qub25SZW5kZXIgLSDsi6TtlonrkKAg66CM642UIOuqqOuTiCDsnoXri4jri6QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtb2R1bGVPYmplY3Qub25SZW5kZXIudGljayAtIG1z64uo7JyE66GcIOuwmO2ZmOuQmOuKlCDsi5zqsITsnoXri4jri6QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBjdXN0b21Nb2R1bGUgPSAodGljaykgPT4gY29uc29sZS5sb2codGljayk7XG4gICAqIG15QXBwLmFkZFJlbmRlck1vZHVsZSh7XG4gICAqICAgICBuYW1lOiAnbXlDdXN0b21Nb2R1bGUnLFxuICAgKiAgICAgb25SZW5kZXI6IGN1c3RvbU1vZHVsZVxuICAgKiB9KTtcbiAgICovXG4gIGFkZFJlbmRlck1vZHVsZShtb2R1bGVPYmplY3QpIHsgLy8gOHRod2FsbCDrlLDrnbztlZwg6rGw6ri0IO2VnOuNsC4uLuuLqOyInCDtmLjstpzrp4wg65CY64qUIOqxtCDrrLjsoJzsnoXri4jri6QuIGJ5IGFoblxuICAgIHJldHVybiAoZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKCEhbW9kdWxlT2JqZWN0Lm5hbWUgJiYgISFtb2R1bGVPYmplY3Qub25SZW5kZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVPYmplY3Qub25SZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVuZGVyIE1vZHVsZVxcJ3MgYWN0aW9uIGlzIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJNb2R1bGUuaGFzKG1vZHVsZU9iamVjdC5uYW1lKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdEdXBsaWNhdGUgbW9kdWxlIG5hbWUnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyTW9kdWxlLnNldChtb2R1bGVPYmplY3QubmFtZSwgbW9kdWxlT2JqZWN0Lm9uUmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdZb3UgbXVzdCBzZXQgbmFtZSBhbmQgb25SZW5kZXInKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfShtb2R1bGVPYmplY3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDtlbTri7kg7J2066aE7J2EIOqwgOynhCDroIzrjZQg66qo65OI7J2EIOyCreygnO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjcmVtb3ZlUmVuZGVyTW9kdWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0g7IKt7KCc7ZWY6rOg7J6QIO2VmOuKlCDrqqjrk4gg7J2066aEXG4gICAqL1xuICByZW1vdmVSZW5kZXJNb2R1bGUobmFtZSkgeyAvLyDsnbTqsoPrj4Qg7IS47Yq47J207KeA7JqULiBieSBhaG5cbiAgICByZXR1cm4gKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBsZXQgZmxhZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoISFuYW1lICYmIHJlbmRlck1vZHVsZS5oYXMobmFtZSkpIHtcbiAgICAgICAgcmVuZGVyTW9kdWxlLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmxhZztcbiAgICB9KG5hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDrk7HroZ3rkJwg66qo65OgIOugjOuNlCDrqqjrk4jsnYQg7IKt7KCc7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNyZXNldFJlbmRlck1vZHVsZXNcbiAgICovXG4gIHJlc2V0UmVuZGVyTW9kdWxlcygpIHsgLy8g7J206rKMIO2VhOyalO2VnOqxtOqwgD9cbiAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbmRlck1vZHVsZS5jbGVhcigpO1xuICAgIH0oKSk7XG4gIH1cblxuICAvKipcbiAgICog65Ox66Gd65CcIOugjOuNlCDrqqjrk4jsnYQg67CY7ZmY7ZWp64uI64ukLlxuICAgKiBAbWVtYmVyIHtBcnJheX0gTGV0c2VlI3JlbmRlck1vZHVsZVxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCByZW5kZXJNb2R1bGVzKCkgeyAvLyByZW5kZXIgbW9kdWxl7J2EIOyEoOyWuO2VmOugpOuptCDslrTrlrvqsowg7ZW07JW8IO2VmOuCmOyalD9cbiAgICBjb25zb2xlLmxvZyhyZW5kZXJNb2R1bGUpO1xuICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgcmVuZGVyTW9kdWxlTWFwID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG5cbiAgICAgICAgcmVuZGVyTW9kdWxlTWFwLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgICAgICBvYmpba10gPSB2O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfShyZW5kZXJNb2R1bGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aHJlZS5qc+ydmCBgV2ViZ2xSZW5kZXJlcmDrpbwg7Leo65Od7ZWp64uI64ukLlxuICAgKiBAbWVtYmVyIHtUSFJFRS5XZWJnbFJlbmRlcmVyfSBMZXRzZWUjdGhyZWVSZW5kZXJlclxuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB0aHJlZVJlbmRlcmVyKCkgeyAvLyDsnbTqsbQgUmVuZGVyTW9kdWxl66GcIOunjOuTpOyWtCDsp4DripQg6rKD7J287YWQ642wPyBieSBhaG5cbiAgICByZXR1cm4gdGhpcy5lbmdpbmUudGhyZWVSZW5kZXJlcjtcbiAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBUjNEUmVuZGVyTW9kdWxlTWFuYWdlcjtcbiIsImltcG9ydCB7aXNOdWxsfSBmcm9tICcuLi9VdGlsJztcbi8vIGNvbnN0IEhUVFAgPSAnJkBodHRwQDsnO1xuLy8gY29uc3QgSFRUUFMgPSAnJkBodHRwc0A7JztcbmNvbnN0IEFUVFJfVFJBTlNMQVRFID0gJ3RyYW5zbGF0ZSc7XG5jb25zdCBBVFRSX1JPVEFURSA9ICdyb3RhdGUnO1xuXG5jb25zdCBQUk9QRVJUWV9UQVJHRVQgPSAnLWxldHNlZS10YXJnZXQnO1xuY29uc3QgUFJPUEVSVFlfVFJBTlNGT1JNID0gJy1sZXRzZWUtdHJhbnNmb3JtJztcbmNvbnN0IEFOR0xFX1VOSVQgPSB7XG4gIGRlZ3JlZTogJ2RlZycsXG4gIHJhZGlhbjogJ3JhZCcsXG4gIHR1cm46ICd0dXJuJyxcbiAgZ3JhZGlhbjogJ2dyYWQnXG59XG5cbmNvbnN0IFRSQU5TTEFURV9SRUcgPSBuZXcgUmVnRXhwKGAke0FUVFJfVFJBTlNMQVRFfVxcKC5bMC05LC5cXC1dK1xcKWAsICdnJyk7XG5jb25zdCBST1RBVEVfUkVHID0gbmV3IFJlZ0V4cChgJHtBVFRSX1JPVEFURX1cXCguKFswLTksLlxcLV18JHtBTkdMRV9VTklULmRlZ3JlZX18JHtBTkdMRV9VTklULnJhZGlhbn18JHtBTkdMRV9VTklULnR1cm59fCR7QU5HTEVfVU5JVC5ncmFkaWFufSkrXFwpYCwgJ2cnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgVVJJX1JFRyA9IC91cmlcXChbJ1wiXS5bXid8XCJdK1snXCJdXFwpL2c7XG4vLyBjb25zdCBVUklfUkVHID0gL3VyaVxcKCgnfFwiKSg/Omh0dHAocyk/OlxcL1xcLyk/W1xcdy4tXSsoPzpcXC5bXFx3XFwuLV0rKStbXFx3XFwtXFwuX346Lz8jW1xcXUAhXFwkJidcXChcXClcXCpcXCssOz0uXSsoJ3xcIilcXCkvZztcblxuLyoqXG4gKiBAY2xhc3MgQ1NTUGFyc2VyXG4gKiBAYXV0aG9yIEpvb0h5dW4gTGVlIChsamhAbGV0c2VlLmlvKVxuICogQHNpbmNlIDIwMTcuIDAzLiAxMC5cbiAqL1xuY2xhc3MgQ1NTUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhTWFwID0ge307XG4gICAgdGhpcy5kb21SZW5kZXJlcklkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBhcnNlXG4gICAqIEBtZW1iZXJvZiBDU1NQYXJzZXIucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcGFyc2UoaWQpIHtcbiAgICB0aGlzLmRhdGFNYXAgPSB7fTtcbiAgICB0aGlzLmRvbVJlbmRlcmVySWQgPSBpZDtcbiAgICBjb25zdCBzdHlsZVRhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVUYWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB0YWcgPSBzdHlsZVRhZ3NbaV07XG5cbiAgICAgIGlmICh0YWcubWVkaWEgPT09ICdwbGFjZScpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnJlbW92ZUNvbW1lbnQodGFnLmlubmVySFRNTCk7XG5cbiAgICAgICAgdGhpcy5wYXJzZURhdGEoc3R5bGUpO1xuICAgICAgICB0aGlzLnJlbW92ZU1lZGlhKHRhZywgc3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZGF0YU1hcCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVDb21tZW50XG4gICAqIEBtZW1iZXJvZiBDU1NQYXJzZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlbW92ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcL1xcKigufFtcXHJcXG5dKSo/XFwqXFwvL2csICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBhcnNlRGF0YVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIHBhcnNlRGF0YSh0ZXh0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gdGV4dC5zcGxpdCgnfScpO1xuXG4gICAgc3R5bGVzLnBvcCgpO1xuICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgY29uc3Qgc2VwZXJhdGVTdHlsZSA9IHN0eWxlLnNwbGl0KCd7Jyk7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IHNlcGVyYXRlU3R5bGVbMF0udHJpbSgpO1xuICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZXMgPSBzZXBlcmF0ZVN0eWxlWzFdLnNwbGl0KCc7Jyk7XG4gICAgICBjb25zdCByZW5kZXJhYmxlID0ge3NlbGVjdG9yLCB0cmFuc2xhdGU6IFswLjAsIDAuMCwgMC4wXSwgcm90YXRpb246IFswLCAwLCAwXX07XG4gICAgICBsZXQgZW50aXR5ID0gbnVsbDtcblxuICAgICAgcHJvcGVydHlWYWx1ZXMucG9wKCk7XG5cbiAgICAgIHByb3BlcnR5VmFsdWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgcHJvcCA9IHByb3AudHJpbSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3Auc3Vic3RyaW5nKDAsIHByb3AuaW5kZXhPZignOicpKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wLnN1YnN0cmluZyhwcm9wLmluZGV4T2YoJzonKSArIDEpO1xuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSBQUk9QRVJUWV9UQVJHRVQ6XG4gICAgICAgICAgICBjb25zdCBwYXJzZVZhbHVlID0gdGhpcy5wYXJzZVRhcmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGVudGl0eSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogcGFyc2VWYWx1ZVswXSxcbiAgICAgICAgICAgICAgdXJpOiBwYXJzZVZhbHVlWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQUk9QRVJUWV9UUkFOU0ZPUk06XG4gICAgICAgICAgICBjb25zdCB7dHJhbnNsYXRlLCByb3RhdGV9ID0gdGhpcy5wYXJzZVBvc2l0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgcmVuZGVyYWJsZS50cmFuc2xhdGVbMF0gPSB0cmFuc2xhdGVbMF07XG4gICAgICAgICAgICByZW5kZXJhYmxlLnRyYW5zbGF0ZVsxXSA9IHRyYW5zbGF0ZVsxXTtcbiAgICAgICAgICAgIHJlbmRlcmFibGUudHJhbnNsYXRlWzJdID0gdHJhbnNsYXRlWzJdO1xuXG4gICAgICAgICAgICByZW5kZXJhYmxlLnJvdGF0aW9uWzBdID0gcm90YXRlWzBdO1xuICAgICAgICAgICAgcmVuZGVyYWJsZS5yb3RhdGlvblsxXSA9IHJvdGF0ZVsxXTtcbiAgICAgICAgICAgIHJlbmRlcmFibGUucm90YXRpb25bMl0gPSByb3RhdGVbMl07XG5cbiAgICAgICAgICAgIC8vIGlmIChjb250YWluZXIgPT09ICdnZW8nKSB7XG4gICAgICAgICAgICAvLyAgIGVudGl0eSA9IHtcbiAgICAgICAgICAgIC8vICAgICB0eXBlOiAnZ2VvJyxcbiAgICAgICAgICAgIC8vICAgICB1cmk6ICdnZW9sb2NhdGlvbidcbiAgICAgICAgICAgIC8vICAgfTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFNYXBbZW50aXR5LnVyaV0pIHtcbiAgICAgICAgICB0aGlzLmRhdGFNYXBbZW50aXR5LnVyaV0gPSB7ZW50aXR5LCByZW5kZXJhYmxlczogW119O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YU1hcFtlbnRpdHkudXJpXTtcblxuICAgICAgICAvLyBUT0RPOiBnZXQgZW50aXR5IGRlc2NyaXB0aW9uXG4gICAgICAgIGRhdGEuZW50aXR5ID0gZW50aXR5O1xuICAgICAgICBkYXRhLnJlbmRlcmFibGVzLnB1c2gocmVuZGVyYWJsZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVRhcmdldCh2YWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgdXJpID0gKHN0ci5tYXRjaChVUklfUkVHKSkgPyBzdHIubWF0Y2goVVJJX1JFRylbMF0ucmVwbGFjZSgvdXJpXFwoWydcIl18WydcIl1cXCkvZywgJycpIDogJyc7XG5cbiAgICByZXR1cm4gWydvYmplY3QnLCB1cmldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGFyc2VWYWx1ZVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7e3JvdGF0ZTogQXJyYXksIHRyYW5zbGF0ZTogQXJyYXl9fVxuICAgKi9cbiAgcGFyc2VQb3NpdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgcHJvcFBvc2l0aW9uID0gKHN0ci5tYXRjaChUUkFOU0xBVEVfUkVHKSkgPyBzdHIubWF0Y2goVFJBTlNMQVRFX1JFRylbMF0ucmVwbGFjZShuZXcgUmVnRXhwKGAke0FUVFJfVFJBTlNMQVRFfVxcXFwofFxcXFwpYCwgJ2cnKSwgJycpIDogJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBjb25zdCBwcm9wUm90YXRpb24gPSAoc3RyLm1hdGNoKFJPVEFURV9SRUcpKSA/IHN0ci5tYXRjaChST1RBVEVfUkVHKVswXS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7QVRUUl9ST1RBVEV9XFxcXCh8XFxcXClgLCAnZycpLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zbGF0ZTogKCEhcHJvcFBvc2l0aW9uKSA/IFsuLi50aGlzLmdldFRyYW5zbGF0ZShwcm9wUG9zaXRpb24pXSA6IFswLCAwLCAwXSwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcm90YXRlOiAoISFwcm9wUm90YXRpb24pID8gWy4uLnRoaXMuZ2V0Um90YXRpb24ocHJvcFJvdGF0aW9uKV0gOiBbMCwgMCwgMF0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH07XG4gIH1cblxuICBnZXRUcmFuc2xhdGUodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoaXNOdWxsKHZhbHVlLm1hdGNoKC9bMC05XS8pKSkgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIHZhbHVlIG5vdCBwcm92aWRlZCcpO1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Um90YXRpb24odmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpXG4gICAgICAubWFwKHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoQU5HTEVfVU5JVC5kZWdyZWUpKSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZShBTkdMRV9VTklULmRlZ3JlZSwgJycpKSAqIChNYXRoLlBJIC8gMTgwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAodmFsdWUubWF0Y2gobmV3IFJlZ0V4cChBTkdMRV9VTklULnJhZGlhbikpKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKEFOR0xFX1VOSVQucmFkaWFuLCAnJykpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKEFOR0xFX1VOSVQuZ3JhZGlhbikpKSByZXR1cm4gKHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZShBTkdMRV9VTklULmdyYWRpYW4sICcnKSkgKiAzNjAgLyA0MDApICogKE1hdGguUEkgLyAxODApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKEFOR0xFX1VOSVQudHVybikpKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKEFOR0xFX1VOSVQudHVybiwgJycpKSAqIDM2MCAqIChNYXRoLlBJIC8gMTgwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlLm1hdGNoKC9bMC05XS8pKSkgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIHZhbHVlIG5vdCBwcm92aWRlZCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbG93ZWQgdW5pdCBhcmUgXCIke0FOR0xFX1VOSVQuZGVncmVlfVwiLCBcIiR7QU5HTEVfVU5JVC5yYWRpYW59XCIsIFwiJHtBTkdMRV9VTklULmdyYWRpYW59XCIsIFwiJHtBTkdMRV9VTklULnR1cm59XCIuYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH0pO1xuICB9XG5cbiAgc3BsaXRBbmRSZW1vdmVUYWlsKHZhbHVlLCBzZXBhcmF0b3JtLCByZW1vdmUpIHtcbiAgICBjb25zdCB0ZW1wQXJyYXkgPSB2YWx1ZS5yZXBsYWNlKHJlbW92ZSwgJycpO1xuXG4gICAgdGVtcEFycmF5LnNwbGl0KHNlcGFyYXRvcik7XG4gICAgcmV0dXJuIHRlbXBBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEJhc2VcbiAgICogQG1lbWJlcm9mIENTU1BhcnNlclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRCYXNlKCkge1xuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIGNvbnN0IHBhdGhBcnJheSA9IHVybC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGxhc3QgPSBwYXRoQXJyYXlbcGF0aEFycmF5Lmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QuaW5kZXhPZignLmh0bWwnKSA+IC0xKSB7XG4gICAgICBwYXRoQXJyYXkucG9wKCk7XG4gICAgfVxuXG4gICAgbGV0IGJhc2UgPSBwYXRoQXJyYXkuam9pbignLycpO1xuXG4gICAgaWYgKGJhc2Uuc3Vic3RyKGJhc2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgYmFzZSArPSAnLyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVNZWRpYVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IHRhZ0VsZW1cbiAgICogQHBhcmFtIHN0eWxlXG4gICAqL1xuXG4gIHJlbW92ZU1lZGlhKHRhZ0VsZW0sIHN0eWxlKSB7XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNvbnN0IG1vZGlmaWVkU3R5bGUgPSBzdHlsZVxuICAgICAgLy8gLnJlcGxhY2UoLygtbGV0c2VlLXRhcmdldCkuKzsvZywgJycpXG4gICAgICAvLyAucmVwbGFjZSgvKC1sZXRzZWUtdHJhbnNmb3JtKS4rOy9nLCAnJylcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke1BST1BFUlRZX1RBUkdFVH0pLis7YCwgJ2cnKSwgJycpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtQUk9QRVJUWV9UUkFOU0ZPUk19KS4rO2AsICdnJyksICcnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJylcbiAgICAgIC5yZXBsYWNlKC8oe1xccyspL2csICd7JylcbiAgICAgIC5yZXBsYWNlKC8oO1xccyspL2csICc7JylcbiAgICAgIC5zcGxpdCgnfScpO1xuXG4gICAgbW9kaWZpZWRTdHlsZS5wb3AoKTtcbiAgICBjb25zdCBwbGFjZVN0eWxlID0gbW9kaWZpZWRTdHlsZS5tYXAodmFsID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gdmFsLnNwbGl0KCd7JylbMF0uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsLnNwbGl0KCd7JylbMV07XG4gICAgICBjb25zdCBuZXdTZWxlY3RvciA9IHNlbGVjdG9yLm1hcChzZWwgPT4gYCMke3RoaXMuZG9tUmVuZGVyZXJJZCB9LmFyLW1vZGUtb24gJHtzZWwudHJpbSgpfWApO1xuXG4gICAgICByZXR1cm4gYCR7bmV3U2VsZWN0b3Iuam9pbignLCcpfXske3ZhbHVlfX1gO1xuICAgIH0pO1xuXG4gICAgbmV3U3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgcGxhY2VTdHlsZS51bnNoaWZ0KGBib2R5IyR7dGhpcy5kb21SZW5kZXJlcklkIH0uYXItbW9kZS1vbntvdmVyZmxvdzpoaWRkZW47fWApO1xuICAgIG5ld1N0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBsYWNlU3R5bGUuam9pbignJykpKTtcbiAgICBoZWFkLnJlcGxhY2VDaGlsZChuZXdTdHlsZSwgdGFnRWxlbSk7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBjc3NQYXJzZXIgPSBuZXcgQ1NTUGFyc2VyKCk7XG4iLCJsZXQgaW5zdGFuY2UgPSBudWxsO1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHtcbiAgZW50aXR5OlxuICAgIHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgdXJpOiBudWxsLFxuICAgICAgbGV0c2VlTWFya2VySWQ6IG51bGwsXG4gICAgICBjb2RlU3RyaW5nOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGltYWdlOiBudWxsLFxuICAgICAgc2l6ZToge3dpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsIGRlcHRoOiAwLjAsIHVuaXQ6ICdtbSd9XG4gICAgfSxcbiAgcGl4ZWxTaXplOiB7d2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCwgZGVwdGg6IG51bGwsIHVuaXQ6ICdweCd9LFxuICBzY2FsZTogbnVsbFxufTtcblxubGV0IF9lbnRpdHlTdGF0ZSA9IFtdLFxuICBfbWFya2VyTGlzdCA9IFtdLFxuICBfY29kZUxpc3QgPSBbXTtcblxuY2xhc3MgRmV0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMuZW50aXR5ID0ge307XG4gICAgdGhpcy5lbnRpdHkudXJpID0gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBnZXQgZmV0Y2hFbnRpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZldGNoKHRoaXMuZW50aXR5LnVyaSlcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAvLyB0ZW1wLmVudGl0eS51cmkgPSBkYXRhO1xuICAgICAgICAgIHRoaXMuZW50aXR5LmxldHNlZU1hcmtlcklkID0gZGF0YS5sZXRzZWVNYXJrZXJJZCB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuZW50aXR5LmNvZGVTdHJpbmcgPSBkYXRhLmNvZGVTdHJpbmcgfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLmVudGl0eS5uYW1lID0gZGF0YS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5lbnRpdHkuaW1hZ2UgPSBkYXRhLmltYWdlIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5lbnRpdHkuc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBkYXRhLnNpemUud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogZGF0YS5zaXplLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgZGVwdGg6IGRhdGEuc2l6ZS5oZWlnaHQgfHwgMCxcbiAgICAgICAgICAgIHVuaXQ6IGRhdGEuc2l6ZS51bml0IHx8ICdtbSdcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucGl4ZWxTaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IGRhdGEuc2l6ZS53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBkYXRhLnNpemUuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgICBkZXB0aDogZGF0YS5zaXplLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgdW5pdDogZGF0YS5zaXplLnVuaXQgfHwgJ21tJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zY2FsZSA9IGRhdGEuc2NhbGUgfHwgMTtcbiAgICAgICAgICBpZiAodGhpcy5lbnRpdHkubGV0c2VlTWFya2VySWQgIT09IG51bGwpIF9tYXJrZXJMaXN0LnB1c2godGhpcy5lbnRpdHkubGV0c2VlTWFya2VySWQpO1xuICAgICAgICAgIGlmICh0aGlzLmVudGl0eS5jb2RlU3RyaW5nICE9PSBudWxsKSBfY29kZUxpc3QucHVzaCh0aGlzLmVudGl0eS5jb2RlU3RyaW5nKTtcblxuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgICBjb25zdCBlbnRpdHkgPSB7Li4udGVtcGxhdGUsIC4uLkpTT04ucGFyc2UoanNvbil9O1xuXG4gICAgICAgICAgX2VudGl0eVN0YXRlLnB1c2goZW50aXR5KTtcbiAgICAgICAgICByZXNvbHZlKGVudGl0eSk7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHlQYXJzZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoIWluc3RhbmNlKSBpbnN0YW5jZSA9IHRoaXM7XG4gICAgdGhpcy5lbnRpdHlMaXN0ID0gW107XG4gIH1cblxuICBnZXQgZW50aXR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIF9lbnRpdHlTdGF0ZTtcbiAgfVxuXG4gIGdldCBtYXJrZXJMaXN0KCkge1xuICAgIHJldHVybiBfbWFya2VyTGlzdDtcbiAgfVxuXG4gIGdldCBjb2RlTGlzdCgpIHtcbiAgICByZXR1cm4gX2NvZGVMaXN0O1xuICB9XG5cbiAgaW5pdEVudGl0eShlbnRpdHkpIHtcbiAgICB0aGlzLmVudGl0eUxpc3QgPSBlbnRpdHlcbiAgICAgIC5tYXAob2JqZWN0ID0+IG9iamVjdC5lbnRpdHkudXJpKVxuICAgICAgLm1hcChvYmplY3QgPT4gbmV3IEZldGNoZXIob2JqZWN0KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5lbnRpdHlMaXN0Lm1hcChvYmplY3QgPT4gb2JqZWN0LmZldGNoRW50aXR5KVxuICAgIClcbiAgICAgIC50aGVuKGRhdGEgPT4gZGF0YSk7XG4gIH1cbn1cbiIsImltcG9ydCBMZXRzZWVPYnNlcnZlciBmcm9tICcuLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvTGV0c2VlT2JzZXJ2ZXInO1xuaW1wb3J0ICogYXMgTWVzc2FnZSBmcm9tICcuL01lc3NhZ2VUeXBlcyc7XG5pbXBvcnQge2lzTmlsfSBmcm9tICcuLi9VdGlsJztcbmltcG9ydCB7TEVUU0VFX0VWRU5UfSBmcm9tICcuL01lc3NhZ2VUeXBlcyc7XG5cbmNsYXNzIEV2ZW50TWFuYWdlciBleHRlbmRzIExldHNlZU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVuZ2luZSA9IG51bGw7XG4gIH1cblxuICBhZGRFbmdpbmUoX2VuZ2luZSkge1xuICAgIHRoaXMuZW5naW5lID0gX2VuZ2luZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkaXNwYXRjaCDsi5zrpqzspogg66qo65GQIOydvOuLqCBFdmVudE1hbmFnZXLroZwg6re465+w642wIO2Vqey5oCDsiJjripQg7JeG64KYPyBieSBhaG5cbiAgICpcbiAgICogQGF1dGhvciB0cmFja2VyIOqwgCDtlanss5Dsp4DrqbQsIOydtCDqtIDroKjrkJwg67aA67aE7J2AIG1lcmdlIOuQmOyWtOyVvCDtlahcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKiBAcGFyYW0gY3VycmVudFN0YXRlXG4gICAqL1xuICBkaXNwYXRjaFRyYWNrU3RhdGUobWF0cml4LCBjdXJyZW50U3RhdGUpIHtcbiAgICBsZXQgbmV3U3RhdGUgPSBbXTtcblxuICAgIGlmIChcbiAgICAgICh0aGlzLmVuZ2luZSAhPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5lbmdpbmUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAobWF0cml4ICE9PSBudWxsIHx8IHR5cGVvZiBtYXRyaXggIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAoY3VycmVudFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnRTdGF0ZSAhPT0gTWVzc2FnZS5TVEFURV9SRUNPR05JWkUgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50U3RhdGUgIT09ICd1bmRlZmluZWQnKVxuICAgICkge1xuXG4gICAgICBuZXdTdGF0ZSA9IGxldHNlZS5zdGF0ZS5tYXAob2JqID0+IHtcbiAgICAgICAgb2JqLnR5cGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgIG9iai5tYXRyaXggPSBKU09OLnBhcnNlKCdbJyArIG1hdHJpeCArICddJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW5naW5lLm9iamVjdFRyYWNrZXIudXBkYXRlU3RhdGUobmV3U3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnW2Vycm9yXSBsZXRzZWUgaXMgbm90IGxvYWRlZCEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogdHJhY2tlciDtlanss5Dsp4DrqbQsIG1lcmdlIOuQoCDsmIjsoJVcbiAgICpcbiAgICogQHBhcmFtIG1hdHJpeFxuICAgKiBAcGFyYW0gY3VycmVudFN0YXRlXG4gICAqIEBwYXJhbSBtYXJrZXJJZFxuICAgKi9cbiAgZGlzcGF0Y2hUcmFja1N0YXRlTWFya2VyKG1hdHJpeCwgY3VycmVudFN0YXRlLCBtYXJrZXJJZCA9IG51bGwpIHtcbiAgICBsZXQgbmV3U3RhdGUgPSBbXTtcblxuICAgIGlmIChcbiAgICAgICh0aGlzLmVuZ2luZSAhPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5lbmdpbmUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAobWF0cml4ICE9PSBudWxsIHx8IHR5cGVvZiBtYXRyaXggIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAoY3VycmVudFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnRTdGF0ZSAhPT0gTWVzc2FnZS5TVEFURV9SRUNPR05JWkUgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjdXJyZW50U3RhdGUgIT09ICd1bmRlZmluZWQnKVxuICAgICkge1xuICAgICAgbmV3U3RhdGUgPSBsZXRzZWUuc3RhdGUuZmlsdGVyKG9iaiA9PiB7XG4gICAgICAgIHJldHVybiBtYXJrZXJJZC5pbmNsdWRlcyhvYmouZW50aXR5LmxldHNlZU1hcmtlcklkKTtcbiAgICAgIH0pLm1hcChvYmogPT4ge1xuICAgICAgICBvYmoudHlwZSA9IGN1cnJlbnRTdGF0ZVttYXJrZXJJZC5pbmRleE9mKG9iai5lbnRpdHkubGV0c2VlTWFya2VySWQpXTtcbiAgICAgICAgb2JqLm1hdHJpeCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgJ1snICsgbWF0cml4W21hcmtlcklkLmluZGV4T2Yob2JqLmVudGl0eS5sZXRzZWVNYXJrZXJJZCldICsgJ10nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVuZ2luZS5vYmplY3RUcmFja2VyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1tlcnJvcl0gbGV0c2VlIGlzIG5vdCBsb2FkZWQhJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHRyYWNrZXIg7ZWp7LOQ7KeA66m0LCBtZXJnZSDrkKAg7JiI7KCVXG4gICAqXG4gICAqIEBwYXJhbSBtYXRyaXhcbiAgICogQHBhcmFtIGN1cnJlbnRTdGF0ZVxuICAgKiBAcGFyYW0gbWFya2VySWRcbiAgICovXG4gIGRpc3BhdGNoVHJhY2tTdGF0ZVFyKG1hdHJpeCwgY3VycmVudFN0YXRlLCBtYXJrZXJJZCA9IG51bGwpIHtcbiAgICBsZXQgbmV3U3RhdGUgPSBbXTtcblxuICAgIGlmIChcbiAgICAgICFpc05pbCh0aGlzLmVuZ2luZSkgJiZcbiAgICAgICAgIWlzTmlsKG1hdHJpeCkgJiZcbiAgICAgICAgIWlzTmlsKGN1cnJlbnRTdGF0ZSkgJiZcbiAgICAgICAgY3VycmVudFN0YXRlICE9PSBNZXNzYWdlLkVOVElUWV9FVkVOVC5SRUNPR05JWkVcbiAgICApIHtcbiAgICAgIG5ld1N0YXRlID0gbGV0c2VlLnN0YXRlLmZpbHRlcihvYmogPT4ge1xuICAgICAgICByZXR1cm4gbWFya2VySWQuaW5jbHVkZXMob2JqLmVudGl0eS5jb2RlU3RyaW5nKTtcbiAgICAgIH0pLm1hcChvYmogPT4ge1xuICAgICAgICBvYmoudHlwZSA9IGN1cnJlbnRTdGF0ZVttYXJrZXJJZC5pbmRleE9mKG9iai5lbnRpdHkuY29kZVN0cmluZyldO1xuICAgICAgICBvYmoubWF0cml4ID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAnWycgKyBtYXRyaXhbbWFya2VySWQuaW5kZXhPZihvYmouZW50aXR5LmNvZGVTdHJpbmcpXSArICddJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW5naW5lLm9iamVjdFRyYWNrZXIudXBkYXRlU3RhdGUobmV3U3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnW2Vycm9yXSBsZXRzZWUgaXMgbm90IGxvYWRlZCEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog66Cb7IucIOyXlOynhOydtCDsi5zsnpHrkJwg7ZuE7JeQIOyghOuLrOuQqeuLiOuLpC4gYG9ubG9hZGDsnbTrsqTtirjsnZgg7IiP7Lu3IOyeheuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25Mb2FkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkxvYWQoY2FsbGJhY2spIHsgLy8g7JmcIOyXlOynhOydtCAn7Iuc7J6RJ+uQmOuptCDsoITri6zrkJjripTqsIAhICfroZzrk5wn65CY66m0IOyghOuLrOuQmOyWtOyVvOyngCEhIVxuICAgIHRoaXMuc3Vic2NyaWJlKExFVFNFRV9FVkVOVC5PTl9MT0FELCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICog7Kad6rCVIOuMgOyDgeydmCDtirjrnpntgrkg7Iuc7J6R6rO8IO2VqOq7mCDsoITri6zrkJjripQg7J2067Kk7Yq4IOyeheuLiOuLpC4gYHRyYWNrc3RhcnRgIOydtOuypO2KuOydmCDsiI/su7cg7J6F64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNvblRyYWNrU3RhcnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtFbnRpdHlFdmVudH0gY2FsbGJhY2suZXZlbnRcbiAgICovXG4gIG9uVHJhY2tTdGFydChjYWxsYmFjaykgeyAvLyBUcmFja1N0YXJ0LCBUcmFja01vdmUsIFRyYWNrRW5k64qUIERPTSBVSSDsnbTrsqTtirjsmYAg6rCZ7J2AIOyImOykgOycvOuhnCDsspjrpqztlZjrqbQg65Cp64uI64ukLiBieSBhaG5cbiAgICB0aGlzLnN1YnNjcmliZShMRVRTRUVfRVZFTlQuVFJBQ0tfU1RBUlQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDspp3qsJUg64yA7IOB7J2YIO2KuOueme2CueykkSDsoITri6zrkJjripQg7J2067Kk7Yq4IOyeheuLiOuLpC4gYHRyYWNrbW92ZWAg7J2067Kk7Yq47J2YIOyIj+y7tyDsnoXri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI29uVHJhY2tNb3ZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RW50aXR5RXZlbnR9IGNhbGxiYWNrLmV2ZW50XG4gICAqL1xuICBvblRyYWNrTW92ZShjYWxsYmFjaykgeyAvLyDsnbTqsoPrj4QgRE9NIFVJIOydtOuypO2KuOyZgCDqsJnsnYAg7IiY7KSA7J6F64uI64ukLiDsvZzrsLEg65Ox66Gd7J2AIEVudGl0eSBNYW5hZ2Vy7JeQ7IScIOygnOqzte2VmOuKlCDqsbQg7Ja065WM7JqUPyBieSBhaG5cbiAgICB0aGlzLnN1YnNjcmliZShMRVRTRUVfRVZFTlQuVFJBQ0tfTU9WRSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIOymneqwlSDrjIDsg4HsnZgg7Yq4656Z7YK57J20IOupiOy2lOuptCDsoITri6zrkJjripQg7J2067Kk7Yq4IOyeheuLiOuLpC4gYHRyYWNrZW5kYCDsnbTrsqTtirjsnZgg7IiP7Lu3IOyeheuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25UcmFja0VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0VudGl0eUV2ZW50fSBjYWxsYmFjay5ldmVudFxuICAgKi9cbiAgb25UcmFja0VuZChjYWxsYmFjaykgeyAvLyDsnbTqsoPrj4Qg7JyE7JmAIOqwmeydtCDshYvtirjsnoQgYnkgYWhuXG4gICAgdGhpcy5zdWJzY3JpYmUoTEVUU0VFX0VWRU5ULlRSQUNLX0VORCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIOugm+yLnCDqsJ3ssrTsnZgg7IOB7YOc66W8IOyghOuLrO2VmOuKlCDsnbTrsqTtirgg7J6F64uI64ukLiAuIGBhcHBfc3RhdHVzYCDsnbTrsqTtirjsnZgg7IiP7Lu3IOyeheuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25TdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtMZXRzZWVTdGF0dXN9IGNhbGxiYWNrLmV2ZW50XG4gICAqL1xuICBvblN0YXR1cyhjYWxsYmFjaykgeyAvLyDsnbTqsbQgTGV0c2VlIExpZmVjeWNsZeydtCDrqLzsoIAg7KCV7J2Y65CY64qUIOqyjCDtlYTsmpTtlaAg65OvLlxuICAgIHRoaXMuc3Vic2NyaWJlKExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDquLDquLDsnZgg6rCA66GcL+yEuOuhnCDrs4DtmZgg7ZuEIOyghOuLrOuQmOuKlCDsnbTrsqTtirgg7J6F64uI64ukLiB3aW5kb3fsnZggYG9yaWVudGF0aW9uY2hhbmdlYCDsnbTrsqTtirjsmYDripQg64us66asIO2ZlOuptCDrsKntlqUg7KCE7ZmY7JeQ65Sw66W4IExldHNlZSDrgrTrtoDsnZgg7Jew7IKw7J20IOyZhOujjOuQnCDtm4Qg7KCE64us65Cp64uI64ukLlxuICAgKiDsvZzrsLHsnYAgd2luZG937J2YIGBvcmllbnRhdGlvbmNoYW5nZWDsmYAg64+Z7J287ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNvbk9yaWVudGF0aW9uQ2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7ZXZlbnR9IGNhbGxiYWNrLmV2ZW50XG4gICAqL1xuICBvbk9yaWVudGF0aW9uQ2hhbmdlKGNhbGxiYWNrKSB7IC8vIHNjcmVlbiBvYmplY3Qg7ZmU7J207YyFISDqsbDquLDroZwg66qw7J6QLiBieSBhaG5cbiAgICB0aGlzLnN1YnNjcmliZShMRVRTRUVfRVZFTlQuUk9UQVRJT05fQ0hBTkdFLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGV0c2VlIOqwneyytOyXkCDsnbTrsqTtirjrpbwg65Ox66Gd7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNhZGRFdmVudExpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBFdmVudFR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtldmVudH0gY2FsbGJhY2suZXZlbnRcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHsgLy8g66y07JeH7J2EIOuTseuhne2VoCDsiJgg7J6I64qUIOqygeuLiOq5jD8gYnkgYWhuXG4gICAgdGhpcy5zdWJzY3JpYmUodHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExldHNlZSDqsJ3ssrTsl5DshJwg7J2067Kk7Yq466W8IOyCreygnO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gRXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7IC8vIOustOyXh+ydhCDsoJzqsbDtlaAg7IiYIOyeiOuKlCDqsoHri4jquYw/IOqysOq1rSBMZXRzZWVPYnNlcnZlcuuhnCDrhJjquLDripTrjbAuLi5FdmVudE1hbmFnZXLroZwg7J2864uoLiBieSBhaG5cbiAgICB0aGlzLnVuc3Vic2NyaWJlKHR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG59O1xuXG5leHBvcnQgZGVmYXVsdCBFdmVudE1hbmFnZXI7XG4iLCJleHBvcnQgY29uc3QgRVZFTlRfQVBQX1NUQVRVUyA9ICdhcHBfc3RhdHVzJztcbmV4cG9ydCBjb25zdCBFVkVOVF9BUFBfT05MT0FEID0gJ29ubG9hZCc7XG5leHBvcnQgY29uc3QgRVZFTlRfQVBQX1JPVEFUSU9OQ0hBTkdFID0gJ3JvdGF0aW9uY2hhbmdlJztcblxuZXhwb3J0IGNvbnN0IFNUQVRFX1RSQUNLX1NUQVJUID0gJ3RyYWNrc3RhcnQnO1xuZXhwb3J0IGNvbnN0IFNUQVRFX1RSQUNLX01PVkUgPSAndHJhY2ttb3ZlJztcbmV4cG9ydCBjb25zdCBTVEFURV9UUkFDS19FTkQgPSAndHJhY2tlbmQnO1xuZXhwb3J0IGNvbnN0IFNUQVRFX1JFQ09HTklaRSA9ICdyZWNvZ25pemUnO1xuXG5leHBvcnQgY29uc3QgT0JKRUNUX0VWRU5UID0ge1xuICBPQkpFQ1RfQURERUQ6ICdhZGRlZCcsXG4gIE9CSkVDVF9SRU1PVkVEOiAncmVtb3ZlZCdcbn1cblxuZXhwb3J0IGNvbnN0IEVOVElUWV9FVkVOVCA9IHtcbiAgVEFSR0VUOiAnRW50aXR5RXZlbnQnLFxuICBUUkFDS19TVEFSVDogJ3RyYWNrc3RhcnQnLFxuICBUUkFDS19NT1ZFOiAndHJhY2ttb3ZlJyxcbiAgVFJBQ0tfRU5EOiAndHJhY2tlbmQnLFxuICBSRUNPR05JWkU6ICdyZWNvZ25pemUnXG59O1xuXG5leHBvcnQgY29uc3QgTEVUU0VFX0VWRU5UID0ge1xuICBUQVJHRVQ6ICdMZXRzZWVFdmVudCcsXG4gIE9OX0xPQUQ6ICdvbmxvYWQnLFxuICBPTl9TVEFUVVM6ICdhcHBfc3RhdHVzJyxcbiAgUk9UQVRJT05fQ0hBTkdFOiAncm90YXRpb25jaGFuZ2UnLFxuICBUUkFDS19TVEFSVDogJ3RyYWNrc3RhcnQnLFxuICBUUkFDS19NT1ZFOiAndHJhY2ttb3ZlJyxcbiAgVFJBQ0tfRU5EOiAndHJhY2tlbmQnXG59O1xuXG5leHBvcnQgY29uc3QgTEVUU0VFX0NTUyA9IHtcbiAgQVJfTU9ERV9PTjogJ2FyLW1vZGUtb24nLFxuICBBUl9NT0RFX09GRjogJ2FyLW1vZGUtb2ZmJyxcbiAgTEVUU0VFX0xPQURJTkc6ICdsZXRzZWUtbG9hZGluZycsXG4gIExFVFNFRV9MT0FERUQ6ICdsZXRzZWUtbG9hZGVkJyxcbiAgTEVUU0VFX1NUQVRVUzogJ2xldHNlZS1zdGF0dXMnXG59O1xuIiwiaW1wb3J0IEVudGl0eSBmcm9tICcuLi9lbnRpdHkvRW50aXR5JztcblxuaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi4vbWF0aC9NYXRyaXg0JztcbmltcG9ydCBWZWN0b3IzIGZyb20gJy4uL21hdGgvVmVjdG9yMyc7XG5pbXBvcnQgUXVhdGVybmlvbiBmcm9tICcuLi9tYXRoL1F1YXRlcm5pb24nO1xuaW1wb3J0IEV1bGVyIGZyb20gJy4uL21hdGgvRXVsZXInO1xuXG5pbXBvcnQge3RyYWNrYWJsZU1hbmFnZXJ9IGZyb20gJy4uL2NvcmUvVHJhY2thYmxlTWFuYWdlcic7XG5pbXBvcnQgRW50aXR5RXZlbnQgZnJvbSAnLi4vZW50aXR5L0VudGl0eUV2ZW50JztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZW50aXR5L0VudGl0eUV2ZW50VHlwZSc7XG5cbmltcG9ydCBFbnRpdHlPYnNlcnZlciBmcm9tICcuLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvRW50aXR5T2JzZXJ2ZXInO1xuXG5jb25zdCB0cmFuc2xhdGVNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuY29uc3Qgcm90YXRpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG5jbGFzcyBPYmplY3RUcmFja2VyIGV4dGVuZHMgRW50aXR5T2JzZXJ2ZXIge1xuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBtZW1iZXIge09iamVjdDxzdHJpbmcsIEVudGl0eT59IHRhcmdldHNcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS5yZW5kZXJlclxuICAgKi9cbiAgLy8gdGFyZ2V0czoge1t1cmk6IHN0cmluZ106IEVudGl0eX07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhcmdldHMgPSB7fTtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy51c2VDYW1lcmEgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBjdXJyZW50bHkgdHJhY2tpbmcgYW4gZW50aXR5IHdpdGggYHVyaWAuXG4gICAqIEBtZXRob2QgaXNUcmFja2luZ1xuICAgKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLnJlbmRlcmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdXJpXVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcmFja2luZyDsl6zrtoBcbiAgICovXG4gIGlzVHJhY2tpbmcodXJpKSB7XG4gICAgaWYgKHVyaSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0c1t1cmldKSByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMudGFyZ2V0cykubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY3VycmVudGx5IHRyYWNrZWQgb2JqZWN0cy5cbiAgICogQG1ldGhvZCBnZXRUcmFja2luZ0NvdW50XG4gICAqIEBtZW1iZXJvZiBMZXRzZWVFbmdpbmUudHJhY2tlclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudGFyZ2V0cykubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB1cmlcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRUYXJnZXQodXJpKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0c1t1cmldO1xuICB9XG5cbiAgYWRkVGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0c1t0YXJnZXQudXJpXSA9IHRhcmdldDtcbiAgfVxuXG4gIHJlbW92ZVRhcmdldCh0YXJnZXQpIHtcbiAgICBkZWxldGUgdGhpcy50YXJnZXRzW3RhcmdldC51cmldO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgcmVuZGVyZXIgYnkgZGlzcGF0Y2hpbmcgYSBgJ3RyYWNrZW5kJ2AgZXZlbnQgZm9yIGFsbCBlbnRpdGllc1xuICAgKiB0aGF0IGFyZSBjdXJyZW50bHkgdHJhY2tlZC5cbiAgICog66qo65OgIFRyYWNrRXZlbnTrpbwgY2xlYXJcbiAgICogVHJhY2tpbmcg7KSR7J24IOuMgOyDgeyXkCDrjIDtlbTshJzripQgVHJhY2tFbmQg7J2067Kk7Yq4IOuwnOyDnVxuICAgKiBAbWV0aG9kIGNsZWFyXG4gICAqIEBtZW1iZXJvZiBMZXRzZWVFbmdpbmUucmVuZGVyZXJcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGZvciAobGV0IGVudGl0eSBvZiBPYmplY3QudmFsdWVzKHRoaXMudGFyZ2V0cykpIHtcbiAgICAgIHRoaXMub25UcmFja0VuZChuZXcgRW50aXR5RXZlbnQoJ3RyYWNrZW5kJywgZW50aXR5KSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXRzID0ge307XG4gICAgLy8gTGV0c2VlRW5naW5lLnJlbmRlcmVyLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQG1ldGhvZCBvblVwZGF0ZVN0YXRlXG4gICAqIEBtZW1iZXJvZiBMZXRzZWVFbmdpbmUudHJhY2tlclxuICAgKiBAcGFyYW0gIHtBcnJheX0gc3RhdGVcbiAgICovXG4gIHVwZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQgfHwgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBjb25zdCBlID0gZXZlbnQuZW50aXR5O1xuICAgICAgbGV0IGVudGl0eSA9IHRyYWNrYWJsZU1hbmFnZXIuZ2V0RW50aXR5KGUudXJpKSB8fCBuZXcgRW50aXR5KGUudXJpLCBlKTtcblxuICAgICAgZW50aXR5LnNldERhdGEoZSk7XG4gICAgICBlbnRpdHkub2JqZWN0LnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgZW50aXR5Lm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpLmZyb21BcnJheShldmVudC5tYXRyaXgpO1xuICAgICAgY29uc3QgZW50aXR5RXZlbnQgPSBuZXcgRW50aXR5RXZlbnQoZXZlbnQudHlwZSwgZW50aXR5LCBtYXRyaXgsIGV2ZW50LnBpeGVsU2l6ZSwgZXZlbnQuc2NhbGUpO1xuXG4gICAgICBpZiAoZW50aXR5RXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5UUkFDS19TVEFSVCkge1xuICAgICAgICAgIHRoaXMub25UcmFja1N0YXJ0KGVudGl0eUV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBFdmVudFR5cGUuVFJBQ0tfTU9WRSkge1xuICAgICAgICAgIHRoaXMub25UcmFja01vdmUoZW50aXR5RXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5UUkFDS19FTkQpIHtcbiAgICAgICAgICB0aGlzLm9uVHJhY2tFbmQoZW50aXR5RXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKiBAbWV0aG9kIG9uVHJhY2tTdGFydFxuICAgKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLnJlbmRlcmVyXG4gICAqIEBwYXJhbSAge0VudGl0eUV2ZW50fSBldmVudFxuICAgKi9cbiAgb25UcmFja1N0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgdGFyZ2V0LnRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLmFkZFRhcmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQudXJpICE9PSAndW5rbm93bicpIHtcbiAgICAgIHRhcmdldC5zY2FsZSA9IGV2ZW50LnNjYWxlO1xuICAgICAgdGhpcy5ub3RpZnkoJ3RyYWNrc3RhcnQnLCBldmVudCk7XG4gICAgICB0YXJnZXQubm90aWZ5KCd0cmFja3N0YXJ0JywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBtZXRob2Qgb25UcmFja01vdmVcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS5yZW5kZXJlclxuICAgKiBAcGFyYW0gIHtFbnRpdHlFdmVudH0gZXZlbnRcbiAgICovXG4gIG9uVHJhY2tNb3ZlKGV2ZW50KSB7XG5cbiAgICBjb25zdCBlbnRpdHkgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgZW50aXR5T2JqZWN0ID0gZW50aXR5Lm9iamVjdDtcblxuICAgIC8vIFN0YXJ0IGludmVydCBYIEF4aXNcbiAgICBjb25zdCByb3RhdGVNID0gbmV3IE1hdHJpeDQoKTtcbiAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tRXVsZXIobmV3IEV1bGVyKE1hdGguUEksIDAsIDApKTtcblxuICAgIHJvdGF0ZU0ubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG4gICAgZXZlbnQubWF0cml4Lm11bHRpcGx5KHJvdGF0ZU0pO1xuICAgIC8vIEVuZCBpbnZlcnQgWCBheGlzXG5cbiAgICAvLyBBcHBseSBwb3NlIHRvIGNhbWVyYSBvciBvYmplY3QuXG4gICAgaWYgKHRoaXMudXNlQ2FtZXJhKSB7XG4gICAgICBldmVudC5tYXRyaXguZGVjb21wb3NlKFxuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbixcbiAgICAgICAgdGhpcy5jYW1lcmEucXVhdGVybmlvbixcbiAgICAgICAgdGhpcy5jYW1lcmEuc2NhbGVcbiAgICAgICk7XG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVNYXRyaXgoKTtcbiAgICAgIGNvbnN0IHRtcCA9IG5ldyBNYXRyaXg0KCkuZ2V0SW52ZXJzZSh0aGlzLmNhbWVyYS5tYXRyaXgpO1xuXG4gICAgICB0aGlzLmNhbWVyYS5tYXRyaXguaWRlbnRpdHkoKTtcbiAgICAgIHRoaXMuY2FtZXJhLmFwcGx5TWF0cml4KHRtcCk7XG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVNYXRyaXgoKTtcblxuICAgICAgdGhpcy5jYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlfSA9IGV2ZW50Lm1hdHJpeC5kZWNvbXBvc2VkVmFsdWU7XG5cbiAgICAgIHRyYW5zbGF0ZU1hdHJpeC5tYWtlVHJhbnNsYXRpb24oLi4ucG9zaXRpb24udG9BcnJheSgpKTtcbiAgICAgIHJvdGF0aW9uTWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgICAgZW50aXR5T2JqZWN0Lm1hdHJpeC5tdWx0aXBseSh0cmFuc2xhdGVNYXRyaXgpO1xuICAgICAgZW50aXR5T2JqZWN0Lm1hdHJpeC5tdWx0aXBseShyb3RhdGlvbk1hdHJpeCk7XG5cbiAgICAgIGVudGl0eU9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICBlbnRpdHlPYmplY3QudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGVudGl0eS51cmkgIT09ICd1bmtub3duJykge1xuICAgICAgdGhpcy5ub3RpZnkoJ3RyYWNrbW92ZScsIGV2ZW50KTtcbiAgICAgIGVudGl0eS5ub3RpZnkoJ3RyYWNrbW92ZScsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKiBAbWV0aG9kIG9uVHJhY2tFbmRcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS5yZW5kZXJlclxuICAgKiBAcGFyYW0gIHtFbnRpdHlFdmVudH0gZXZlbnRcbiAgICovXG4gIG9uVHJhY2tFbmQoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICB0YXJnZXQudHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnJlbW92ZVRhcmdldCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXQudXJpICE9PSAndW5rbm93bicpIHtcbiAgICAgIHRoaXMubm90aWZ5KCd0cmFja2VuZCcsIGV2ZW50KTtcbiAgICAgIHRhcmdldC5ub3RpZnkoJ3RyYWNrZW5kJywgZXZlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb2JqZWN0VHJhY2tlciA9IG5ldyBPYmplY3RUcmFja2VyKCk7XG5cbiIsImltcG9ydCBhZGFwdGVyIGZyb20gJy4uL3ZlbmRvci9hZGFwdGVyX25vX2VkZ2UnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4vLyBpbXBvcnQgU2NyZWVuIGZyb20gJy4uL1NjcmVlbic7XG5pbXBvcnQge2dldEJyb3dzZXJJbmZvfSBmcm9tICcuLi9VdGlsJztcbmltcG9ydCBMZXRzZWVPYnNlcnZlciBmcm9tICcuLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvTGV0c2VlT2JzZXJ2ZXInO1xuaW1wb3J0IHtMRVRTRUVfRVZFTlR9IGZyb20gJy4vTWVzc2FnZVR5cGVzJztcbmltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi4vQ29udGV4dCc7XG5cbi8vIGltcG9ydCAqIGFzIE1lc3NhZ2UgZnJvbSAnLi9NZXNzYWdlVHlwZXMnO1xuLy8gaW1wb3J0IHtWSURFT19FVkVOVH0gZnJvbSAnLi9NZXNzYWdlVHlwZXMnO1xuLy8gaW1wb3J0IExldHNlZUV2ZW50IGZyb20gJy4vTGV0c2VlRXZlbnQnO1xuLy8gaW1wb3J0IFZpZGVvT2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL29ic2VydmVyL1ZpZGVvT2JzZXJ2ZXInO1xuXG5sZXQgaW5zdGFuY2U7XG5jb25zdCBfY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb25zdCBfdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbmNvbnN0IF9zY2VuZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xubGV0IF9zY3JlZW5XaWR0aDtcbmxldCBfc2NyZWVuSGVpZ2h0O1xubGV0IF9hbmdsZSA9IDA7XG5sZXQgX3NjcmVlbkFzcGVjdFJhdGlvO1xubGV0IF90eXBlID0gbnVsbDtcbmxldCBfYnJvd3NlciA9ICd1bmtub3duJztcbmxldCBfb3MgPSAndW5rbm93bic7XG5cbmxldCBfdmlkZW9BdHRhY2hlZCA9IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5sZXQgX2lzUG9ydHJhaXQgPSB0cnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmxldCBkZXZpY2VMaXN0ID0gW107XG5sZXQgaXNGaXJzdENhbWVyYUluaXQgPSB0cnVlOyAvLyDstIjquLAg7Lm066mU6528IEluaXQg7Iuc7JeQXG5cbmNvbnN0IGdldFVzZXJNZWRpYUNvbnN0cmFpbnRzID0gKHNyYykgPT4ge1xuICBjb25zdCBjb25zdHJhaW50cyA9IHt9O1xuXG4gIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIGNvbnN0cmFpbnRzLnZpZGVvID0ge307XG5cbiAgaWYgKHNyYyA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGUgPSAnZW52aXJvbm1lbnQnO1xuICAgIC8qKlxuXHRcdCAqIO2bhOuptCDsubTrqZTrnbzsnZgg65SU67CU7J207IqkIOyepey5mOyXkCDrjIDtlZwg7JiI7Jm4IOy2nOugpS4gKEV4Y2VwdGlvbiBhYm91dCBmcm9udC1iYWNrIGNhbWVyYSBkZXZpY2UpXG5cdFx0ICogfHwg6rWs66y4IOydtO2bhOuhnCDstpTqsIDtlZjsl6wg7LaU6rCA7KCB7J24IExhYmVsIOuTseuhneydtCDqsIDriqUuIChBZGQgTGFiZWwgdXNpbmcgfHwgc3ludGF4IGZvciBhZGQgZXhjZXB0aW9uIGRldmljZSlcblx0XHQgKiBzMTAgOiBjYW1lcmEyIDAsIGZhY2luZyBiYWNrXG5cdFx0ICovXG4gICAgbGV0IGV4Y2VwdGlvbkRldmljZXMgPSBkZXZpY2VMaXN0LmZpbHRlcigoZGV2aWNlKSA9PiB7XG4gICAgICByZXR1cm4gKGRldmljZS5sYWJlbCA9PT0gJ2NhbWVyYTIgMCwgZmFjaW5nIGJhY2snIHx8IGRldmljZS5sYWJlbCA9PT0gJ2FkZGl0aW9uYWwgLi4uLicpO1xuICAgIH0pO1xuXG4gICAgaWYgKGV4Y2VwdGlvbkRldmljZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZXhjZXB0aW9uRGV2aWNlc1swXS5kZXZpY2VJZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3JjID09PSAndXNlcicpIHtcbiAgICBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlID0gJ3VzZXInO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gc3JjO1xuICB9XG5cbiAgY29uc3RyYWludHMudmlkZW8ud2lkdGggPSB7fTtcbiAgY29uc3RyYWludHMudmlkZW8ud2lkdGgubWluID0gMTAyNDtcbiAgY29uc3RyYWludHMudmlkZW8ud2lkdGguaWRlYWwgPSAxMjgwO1xuICBjb25zdHJhaW50cy52aWRlby53aWR0aC5tYXggPSAxOTIwO1xuXG4gIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCA9IHt9O1xuICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQubWluID0gNTc2O1xuICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQuaWRlYWwgPSA3MjA7XG4gIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodC5tYXggPSAxMDgwO1xuXG4gIHJldHVybiBjb25zdHJhaW50cztcbn07XG5cbmNvbnN0IGdldE1lZGlhID0gKGNvbnN0cmFpbnRzKSA9PiB7XG4gIGlmICh3aW5kb3cuc3RyZWFtKSB7XG4gICAgd2luZG93LnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgLnRoZW4oKHN0cmVhbSkgPT4ge1xuICAgICAgICByZXNvbHZlKHN0cmVhbSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCBjaGVja0NhbWVyYSA9IGRldmljZXMgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBoYXNXZWJjYW0gPSBmYWxzZTtcblxuICAgIGRldmljZUxpc3QgPSBbXTtcbiAgICBkZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHtcbiAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgIGhhc1dlYmNhbSA9IHRydWU7XG4gICAgICAgIGRldmljZUxpc3QucHVzaCh7ZGV2aWNlSWQ6IGRldmljZS5kZXZpY2VJZCwgbGFiZWw6IGRldmljZS5sYWJlbH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNXZWJjYW0pIHtcbiAgICAgIHJlamVjdCgnTm8gdmlkZW9JbnB1dCBTdHJlYW0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRmlyc3RDYW1lcmFJbml0KSB7XG4gICAgICAgIHJlc29sdmUoZ2V0VXNlck1lZGlhQ29uc3RyYWludHMoJ2Vudmlyb25tZW50JykpO1xuICAgICAgICBpc0ZpcnN0Q2FtZXJhSW5pdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBnb3RTdHJlYW0gPSAobWVkaWFTdHJlYW0pID0+IHtcbiAgX3ZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgX3ZpZGVvQXR0YWNoZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgY3VycmVudCB2aWRlbyBzdHJlYW0sIGFuZCBjb25uZWN0IG5ldyBzdHJlYW0uXG4gKi9cbmNvbnN0IHJlbW92ZVN0cmVhbSA9IChtZWRpYVN0cmVhbSkgPT4ge1xuICBpZiAod2luZG93LnN0cmVhbSkge1xuICAgIHdpbmRvdy5zdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICB0cmFjay5zdG9wKCk7XG4gICAgfSk7XG4gIH1cbiAgd2luZG93LnN0cmVhbSA9IG1lZGlhU3RyZWFtO1xuICBfdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gIF92aWRlb0F0dGFjaGVkID0gZmFsc2U7XG59O1xuXG5jb25zdCBfaW5pdENhbWVyYUNvbnRhaW5lciA9ICh6SW5kZXgsIHpJbmRleEluY3JlbWVudCkgPT4ge1xuICBfdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCB0cnVlKTtcbiAgX3ZpZGVvRWxlbWVudC5hdXRvcGxheSA9IHRydWU7XG4gIF92aWRlb0VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICBfdmlkZW9FbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgX3ZpZGVvRWxlbWVudC5zdHlsZS50b3AgPSAnMHB4JztcbiAgX3ZpZGVvRWxlbWVudC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gIF92aWRlb0VsZW1lbnQuc3R5bGUuekluZGV4ID0gJy0xMDAnO1xuICBfdmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBfdmlkZW9FbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcblxuICBfdmlkZW9FbGVtZW50LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgcGluayc7XG4gIC8qKlxuXHQgKiBpT1Mgc2FmYXJpIOydmCDqsr3smrAsIDx2aWRlbz4g7YOc6re47J2YIHZpc2liaWxpdHkg66W8IGhpZGRlbiDsnLzroZwg7LKY66as7ZWY66m0IOyKpO2KuOumvCDsnqzsg50g7Iuc7JeQIHN0cmVhbSDsnbQgZnJlZXppbmcg65CY64qUIO2YhOyDgeydtCDrsJzsg53tlahcblx0ICogQW5kcm9pZCBDaHJvbWUg7J2YIOqyveyasCwgPHZpZGVvPiDtg5zqt7jsnZggdmlzaWJpbGl0eSDrpbwgaGlkZGVuIOycvOuhnCDsspjrpqztlbTrj4Qgc3RyZWFtIOyerOyDneydtCDsnpgg65CoXG5cdCAqIEBhdXRob3IgdHJlZXRvcnlAbGV0c2VlLmlvXG5cdCAqL1xuICAvLyBfdmlkZW9FbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgLy8gX3ZpZGVvRWxlbWVudC5zdHlsZS5vYmplY3RGaXQgPSAnY292ZXInO1xuICAvLyAvLyBfdmlkZW9FbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgLy8gX3ZpZGVvRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuXG4gIF9zY2VuZUNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIF9zY2VuZUNhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgX3NjZW5lQ2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgX3NjZW5lQ2FudmFzLnN0eWxlLnpJbmRleCA9ICcwJztcbiAgX3NjZW5lQ2FudmFzLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgYmx1ZSc7XG5cbiAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChfdmlkZW9FbGVtZW50KTtcbiAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChfc2NlbmVDYW52YXMpO1xuICBfY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgX2NvbnRhaW5lci5zdHlsZS50b3AgPSAnMHB4JztcbiAgX2NvbnRhaW5lci5zdHlsZS5yaWdodCA9ICcwcHgnO1xuICBfY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xuICBfY29udGFpbmVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgX2NvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgX2NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gIF9jb250YWluZXIuc3R5bGUuekluZGV4ID0gekluZGV4O1xuICBfY29udGFpbmVyLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgcmVkJztcblxuICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmcgPSAnMHB4JztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChfY29udGFpbmVyKTtcblxufTtcblxuY29uc3QgX2F0dGFjaFNvdXJjZVRvVmlkZW8gPSAodmlkZW9VcmwpID0+IHtcbiAgY29uc3Qgc291cmNlTVA0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG5cbiAgc291cmNlTVA0LnNyYyA9IHZpZGVvVXJsO1xuICBzb3VyY2VNUDQudHlwZSA9ICd2aWRlby9tcDQnO1xuICBfdmlkZW9FbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZU1QNCk7XG4gIF92aWRlb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsICgpID0+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59O1xuXG5jb25zdCBfc2V0QXNwZWN0UmF0aW8gPSAoKSA9PiB7XG5cblx0Y29uc3QgYW5nbGUgPSAodHlwZW9mIHNjcmVlbi5vcmllbnRhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIXNjcmVlbi5vcmllbnRhdGlvbikgPyB3aW5kb3cub3JpZW50YXRpb24gOiBzY3JlZW4ub3JpZW50YXRpb24uYW5nbGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgY29uc3QgdHlwZSA9ICh0eXBlb2Ygc2NyZWVuLm9yaWVudGF0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhc2NyZWVuLm9yaWVudGF0aW9uKSA/ICdzYWZhcmknIDogJ2Nocm9tZSc7XG5cbiAgX2FuZ2xlID0gYW5nbGU7XG4gIF90eXBlID0gdHlwZTtcblxuICBpZiAoKF9hbmdsZSA9PT0gOTAgfHwgX2FuZ2xlID09PSAtOTAgfHwgX2FuZ2xlID09PSAyNzAgfHwgX2FuZ2xlID09PSAtMjcwKSAmJiBfdHlwZSAhPT0gJ2Nocm9tZScpIHtcbiAgICBfc2NyZWVuV2lkdGggPSBzY3JlZW4uaGVpZ2h0O1xuICAgIF9zY3JlZW5IZWlnaHQgPSBzY3JlZW4ud2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgX3NjcmVlbldpZHRoID0gc2NyZWVuLndpZHRoO1xuICAgIF9zY3JlZW5IZWlnaHQgPSBzY3JlZW4uaGVpZ2h0O1xuICB9XG4gIF9zY3JlZW5Bc3BlY3RSYXRpbyA9IF9zY3JlZW5XaWR0aCAvIF9zY3JlZW5IZWlnaHQ7XG4gIF9pc1BvcnRyYWl0ID0gX3NjcmVlbkFzcGVjdFJhdGlvIDw9IDE7XG5cbiAgX3NjZW5lQ2FudmFzLndpZHRoID0gX3NjcmVlbldpZHRoO1xuICBfc2NlbmVDYW52YXMuaGVpZ2h0ID0gX3NjcmVlbkhlaWdodDtcbiAgX3NjZW5lQ2FudmFzLnN0eWxlLndpZHRoID0gYCR7X3NjcmVlbldpZHRofXB4YDtcbiAgX3NjZW5lQ2FudmFzLnN0eWxlLmhlaWdodCA9IGAke19zY3JlZW5IZWlnaHR9cHhgO1xuICBfc2NlbmVDYW52YXMuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuXG4gIHJldHVybiB7IHdpZHRoOiBfc2NyZWVuV2lkdGgsIGhlaWdodDogX3NjcmVlbkhlaWdodCB9O1xufTtcblxuY29uc3QgX2luaXRDYW52YXMgPSAoKSA9PiB7XG4gIHJldHVybiBfc2V0QXNwZWN0UmF0aW8oKTtcbn07XG5cbmNsYXNzIHZpZGVvTWFuYWdlciBleHRlbmRzIExldHNlZU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoaW5zdGFuY2UpIHJldHVybiBpbnN0YW5jZTtcbiAgICBfdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICAvLyB0aGlzLmRpc3BhdGNoKE1lc3NhZ2UuRVZFTlRfQVBQX1NUQVRVUywge1xuICAgICAgdGhpcy5ub3RpZnkoTEVUU0VFX0VWRU5ULk9OX1NUQVRVUywge1xuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgY29kZTogMjAyLFxuICAgICAgICBtZXNzYWdlOiAnVmlkZW8gc3RhcnQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IF9jb250YWluZXI7XG4gICAgdGhpcy5jb250YWluZXJJZCA9IGNvbnRleHQudmlkZW9Db250YWluZXJJZDtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5jb250YWluZXJJZCk7XG5cbiAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgLy8gdXBkYXRlIGRldmljZUxpc3Qgd2hlbiBkZXZpY2UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkLlxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAgIC50aGVuKGRldmljZXMgPT4ge1xuICAgICAgICAgIGRldmljZUxpc3QgPSBbXTtcbiAgICAgICAgICBkZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHtcbiAgICAgICAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgICAgICAgIGRldmljZUxpc3QucHVzaCh7ZGV2aWNlSWQ6IGRldmljZS5kZXZpY2VJZCwgbGFiZWw6IGRldmljZS5sYWJlbH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGluaXQoekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgX2luaXRDYW1lcmFDb250YWluZXIoekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpO1xuICAgICAgaWYgKHRoaXMudmlkZW9VcmwpIHtcbiAgICAgICAgX2F0dGFjaFNvdXJjZVRvVmlkZW8odGhpcy52aWRlb1VybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEF0dGFjaGVkVmlkZW8oKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCB7XG4gICAgICAgICAgICAgIGNvZGU6IDIwMCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0NhbWVyYSBpbml0aWFsaXplIHN0YXJ0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihjaGVja0NhbWVyYSlcbiAgICAgICAgICAudGhlbigoY29uc3RyYWludHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgICAgcmVtb3ZlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgICAgICBnb3RTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCB7XG4gICAgICAgICAgICAgIGNvZGU6IDIwMSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0NhbWVyYSBpbml0aWFsaXplIGRvbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBfc2NyZWVuU2l6ZSA9IF9pbml0Q2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbihfc2NyZWVuU2l6ZS53aWR0aCwgX3NjcmVlblNpemUuaGVpZ2h0LCB0aGlzKTtcbiAgICAgICAgICAgIHJlc29sdmUoX3NjcmVlblNpemUpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRBdHRhY2hlZFZpZGVvKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gICAgICBjb25zdCBicm93c2VyTmFtZSA9IGJyb3dzZXJJbmZvLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG9zTmFtZSA9IGJyb3dzZXJJbmZvLm9zTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoYnJvd3Nlck5hbWUubWF0Y2goL2Nocm9tZS9pKSkge1xuICAgICAgICBfYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgICAgfSBlbHNlIGlmIChicm93c2VyTmFtZS5tYXRjaCgvc2FmYXJpL2kpKSB7XG4gICAgICAgIF9icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYnJvd3NlciA9ICd1bmtub3duJztcbiAgICAgIH1cbiAgICAgIGlmIChvc05hbWUubWF0Y2goL2lvcy9pKSkge1xuICAgICAgICBfb3MgPSAnaW9zJztcbiAgICAgIH0gZWxzZSBpZiAob3NOYW1lLm1hdGNoKC9hbmRyb2lkL2kpKSB7XG4gICAgICAgIF9vcyA9ICdhbmRyb2lkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9vcyA9ICd1bmtub3duJztcbiAgICAgIH1cbiAgICAgIGlmIChfb3MgPT09ICdpb3MnICYmIF9icm93c2VyICE9PSAnc2FmYXJpJykge1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoKE1lc3NhZ2UuRVZFTlRfQVBQX1NUQVRVUywge1xuICAgICAgICB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCB7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGNvZGU6IDEwMSxcbiAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHVzZSBzYWZhcmkgd2l0aCBpb3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZWplY3QoJ1BsZWFzZSB1c2Ugc2FmYXJpIHdpdGggaW9zJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckluZm8uaXNXZWJSVENTdXBwb3J0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgY29kZTogMTAyLFxuICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBicm93c2VyJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVqZWN0KCdQbGVhc2UgdXNlIENocm9tZSwgRmlyZWZveCwgaU9TIDExLCBBbmRyb2lkIDUgb3IgaGlnaGVyLCBTYWZhcmkgMTEgb3IgaGlnaGVyJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiAoIWJyb3dzZXJJbmZvLmlzTW9iaWxlRGV2aWNlKSB7XG4gICAgICAvLyAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAvLyAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgIC8vICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAvLyAgICAgY29kZTogMTA0LFxuICAgICAgLy8gICAgIG1lc3NhZ2U6ICdObyBtb2JpbGUgZGV2aWNlIGRldGVjdGVkJ1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vICAgcmVqZWN0KCdObyBtb2JpbGUgZGV2aWNlJyk7XG4gICAgICAvLyB9XG4gICAgICAvLyBpZiAoKHNjcmVlbi5oZWlnaHQgKiBzY3JlZW4ud2lkdGgpID4gOTIxNjAwKSB7XG4gICAgICAvLyAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAvLyAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgIC8vICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAvLyAgICAgY29kZTogMTA2LFxuICAgICAgLy8gICAgIG1lc3NhZ2U6ICdTY3JlZW4gc2l6ZSBpcyB0b28gbGFyZ2UuJ1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vICAgcmVqZWN0KCdTY3JlZW4gc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgICAgIC8vIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfTtcblxuICBvcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICBfc2V0QXNwZWN0UmF0aW8oKTtcbiAgfTtcblxuICBzZXRWaWRlb1NvdXJjZShzcmMpIHtcbiAgICBpZiAoL1teXFxzXStcXC5tcDRcXGIvLnRlc3Qoc3JjKSkge1xuICAgICAgX2F0dGFjaFNvdXJjZVRvVmlkZW8oc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzID0gZ2V0VXNlck1lZGlhQ29uc3RyYWludHMoc3JjKTtcblxuICAgICAgdGhpcy5yZWNvbm5lY3RNZWRpYVN0cmVhbShjb25zdHJhaW50cyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0U291cmNlRGV2aWNlTGlzdCgpIHtcbiAgICByZXR1cm4gZGV2aWNlTGlzdDtcbiAgfVxuXG4gIC8vIEZpeGVkIGdldHRlci9zZXR0ZXJcbiAgZ2V0IHNjcmVlbkluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBfc2NyZWVuV2lkdGgsXG4gICAgICBoZWlnaHQ6IF9zY3JlZW5IZWlnaHQsXG4gICAgICBhbmdsZTogX2FuZ2xlLFxuICAgICAgc2NyZWVuQXNwZWN0UmF0aW86IF9zY3JlZW5Bc3BlY3RSYXRpb1xuICAgIH07XG4gIH1cblxuICBnZXQgdmlkZW9FbGVtZW50KCkge1xuICAgIHJldHVybiBfdmlkZW9FbGVtZW50O1xuICB9XG5cbiAgZ2V0IGNhbnZhc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIF9zY2VuZUNhbnZhcztcbiAgfVxuICAvLyBjb25zdHJhaW5066W8IOydtOyaqe2VmOyXrCDrr7jrlJTslrQgU3RyZWFt7J2EIOyWu+yWtOyYpOuKlCDrqZTshJzrk5wuXG4gIC8vIGdldCBtZWRpYVN0cmVhbSB1c2luZyBjb25zdHJhaW50cy5cbiAgcmVjb25uZWN0TWVkaWFTdHJlYW0oY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZ2V0TWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgcmVtb3ZlU3RyZWFtKCk7XG4gICAgICAgICAgd2luZG93LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICBnb3RTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCB7XG4gICAgICAgICAgICBjb2RlOiAyMDEsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ2FtZXJhIGluaXRpYWxpemUgZG9uZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfaW5pdENhbnZhcygpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmlkZW9NYW5hZ2VyO1xuIiwiaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi9RdWF0ZXJuaW9uJztcbmltcG9ydCBWZWN0b3IzIGZyb20gJy4vVmVjdG9yMyc7XG5pbXBvcnQgTWF0cml4NCBmcm9tICcuL01hdHJpeDQnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9NYXRoJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J1hZWid8J1laWCd8J1pYWSd8J1haWSd8J1lYWid8J1pZWCd9IEV1bGVyUm90YXRpb25PcmRlclxuICovXG4vLyB0eXBlIEV1bGVyUm90YXRpb25PcmRlciA9ICdYWVonIHwgJ1laWCcgfCAnWlhZJyB8ICdYWlknIHwgJ1lYWicgfCAnWllYJztcblxuLyoqXG4gKiBCeSBkZWZhdWx0IHRoaXMgaXMgYW4gZW1wdHkgZnVuY3Rpb24sIGhvd2V2ZXIgaXQgY2FuIGJlIHNldCB2aWFcbiAqIHtAbGluayBFdWxlciNvbkNoYW5nZX0uIEl0IGdldHNlIGNhbGxlZCBhZnRlciBjaGFuZ2luZyB0aGUge0BsaW5rIEV1bGVyI3h9LFxuICoge0BsaW5rIEV1bGVyI3l9LCB7QGxpbmsgRXVsZXIjen0sIG9yIHtAbGluayBFdWxlciNvcmRlcn0gcHJvcGVydGllcywgYW5kXG4gKiBhbHNvIGFmdGVyIGNhbGxpbmcgbW9zdCBzZXR0ZXIgZnVuY3Rpb25zLlxuICogQG1lbWJlciB7RnVuY3Rpb259IG9uQ2hhbmdlQ2FsbGJhY2tcbiAqIEBtZW1iZXJvZiBFdWxlciNcbiAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkgeyB9XG4gKi9cbmxldCBvbkNoYW5nZUNhbGxiYWNrID0gKCkgPT4ge307XG5cbmNvbnN0IF9pc0V1bGVyID0gdHJ1ZTtcbmNvbnN0IERlZmF1bHRPcmRlciA9ICdYWVonO1xuY29uc3QgUm90YXRpb25PcmRlcnMgPSBbXG4gICdYWVonLFxuICAnWVpYJyxcbiAgJ1pYWScsXG4gICdYWlknLFxuICAnWVhaJyxcbiAgJ1pZWCdcbl07XG5cbi8qKlxuICogQGNsYXNzIEV1bGVyXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZ1xuICogW0V1bGVyIEFuZ2xlc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcl9hbmdsZXMpLiBFdWxlciBhbmdsZXNcbiAqIGRlc2NyaWJlIGEgcm90YXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBieSByb3RhdGluZyBhbiBvYmplY3Qgb24gaXRzIHZhcmlvdXNcbiAqIGF4ZXMgaW4gc3BlY2lmaWVkIGFtb3VudHMgcGVyIGF4aXMsIGFuZCBhIHNwZWNpZmllZCBheGlzIG9yZGVyLlxuICogQGV4YW1wbGVcbiAqIHZhciBhID0gbmV3IEV1bGVyKDAsIDEsIDEuNTcsICdYWVonKTtcbiAqIHZhciBiID0gbmV3IFZlY3RvcjMoMSwgMCwgMSk7XG4gKiBiLmFwcGx5RXVsZXIoYSk7XG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSBUaGUgYW5nbGUgb2YgdGhlIHkgYXhpcyBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdIFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge0V1bGVyUm90YXRpb25PcmRlcn0gW29yZGVyPSdYWVonXSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC4gKE11c3QgYmUgdXBwZXIgY2FzZSkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV1bGVyIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCwgb3JkZXIgPSBEZWZhdWx0T3JkZXIpIHtcblxuICAgIC8vIGNvbnN0YW50cyBmb3Igb3B0aW1pc2F0aW9uXG4gICAgdGhpcy5zZXRGcm9tUXVhdGVybmlvblE7XG4gICAgdGhpcy5yZW9yZGVyUTtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB4IGNvbXBvbmVudC4gSWYgdGhpcyBpcyBjaGFuZ2VkLFxuICAgKiB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gd2lsbCBiZSBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0geFxuICAgKiBAbWVtYmVyb2YgRXVsZXIjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB4KCkge1xuICAgIHJldHVybiB0aGlzLl94O1xuICB9XG5cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgb25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB5IGNvbXBvbmVudC4gSWYgdGhpcyBpcyBjaGFuZ2VkLFxuICAgKiB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gd2lsbCBiZSBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0geVxuICAgKiBAbWVtYmVyb2YgRXVsZXIjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgb25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB6IGNvbXBvbmVudC4gSWYgdGhpcyBpcyBjaGFuZ2VkLFxuICAgKiB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gd2lsbCBiZSBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0gelxuICAgKiBAbWVtYmVyb2YgRXVsZXIjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzLl96O1xuICB9XG5cbiAgc2V0IHoodmFsdWUpIHtcbiAgICB0aGlzLl96ID0gdmFsdWU7XG4gICAgb25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgZ2V0IGlzRXVsZXIoKSB7XG4gICAgcmV0dXJuIF9pc0V1bGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvcmRlciBpbiB3aGljaCB0byBhcHBseSByb3RhdGlvbnMuIERlZmF1bHQgaXMgYCdYWVonYCwgd2hpY2ggbWVhbnNcbiAgICogdGhhdCB0aGUgb2JqZWN0IHdpbGwgZmlyc3QgYmUgcm90YXRlZCBhcm91bmQgaXRzIFggYXhpcywgdGhlbiBpdHMgWSBheGlzLFxuICAgKiBhbmQgZmluYWxseSBpdHMgWiBheGlzLiBPdGhlciBwb3NzaWJpbGl0aWVzIGFyZTogYCdZWlgnYCwgYCdaWFknYCxcbiAgICogYCdYWlknYCwgYCdZWFonYCwgYW5kIGAnWllYJ2AuIFRoZXNlIG11c3QgYmUgaW4gdXBwZXIgY2FzZS5cbiAgICpcbiAgICogTGV0c2VlIHVzZXMgX2ludHJpbnNpY18gKFRhaXQtQnJ5YW4pIG9yZGVyaW5nLCBhbHNvIGtub3duIGFzIHRoaXMuX3lhd18sXG4gICAqIF9waXRjaF8sIGFuZCBfcm9sbF8uIFRoaXMgbWVhbnMgdGhhdCByb3RhdGlvbnMgYXJlIHBlcmZvcm1lZCB3aXRoIHJlc3BlY3RcbiAgICogdG8gdGhlIF9sb2NhbF8gY29vcmRpbmF0ZSBzeXN0ZW0uIFRoYXQgaXMsIGZvciBvcmRlciBgJ1hZWidgLCB0aGUgcm90YXRpb25cbiAgICogaXMgZmlyc3QgYXJvdW5kIHdvcmxkLVgsIHRoZW4gYXJvdW5kIGxvY2FsLVkgKHdoaWNoIG1heSBub3cgYmUgZGlmZmVyZW50XG4gICAqIGZyb20gdGhlIHdvcmxkIFktYXhpcyksIHRoZW4gbG9jYWwtWiAod2hpY2ggbWF5IGJlIGRpZmZlcmVudCBmcm9tIHRoZVxuICAgKiB3b3JsZCBaLWF4aXMpLlxuICAgKlxuICAgKiBTb21lIGltcGxlbWVudGF0aW9ucyBtYXkgdXNlIF9leHRyaW5zaWNfIChwcm9wZXIpIG9yZGVyaW5nLCBpbiB3aGljaCBjYXNlXG4gICAqIHJvdGF0aW9ucyBhcmUgcGVyZm9ybWVkIHdpdGggcmVzcGVjdCB0byB0aGUgX3dvcmxkXyBjb29yZGluYXRlIHN5c3RlbSwgc29cbiAgICogdGhhdCBmb3Igb3JkZXIgYCdYWVonYCwgdGhlIHJvdGF0aW9ucyBhcmUgYXJvdW5kIHdvcmxkLVgsIHdvcmxkLVksIGFuZFxuICAgKiB3b3JsZC1aLlxuICAgKlxuICAgKiBDb252ZXJ0aW5nIGJldHdlZW4gdGhlIHR3byB0eXBlcyBpcyByZWxhdGl2ZWx5IHN0cmFpZ2h0Zm9yd2FyZCwgeW91IGp1c3RcbiAgICogbmVlZCB0byByZXZlcnNlIHRoZSBvcmRlciBhbmQgdGhlIHJvdGF0aW9uLCBzbyB0aGF0IGFuIGludHJpbnNpY1xuICAgKiAoTGV0c2VlKSBFdWxlciByb3RhdGlvbiBvZiBhbmdsZXMgYGFgLCBgYmAsIGBjYCBhYm91dCBgJ1hZWidgIHdpbGwgYmVcbiAgICogZXF1aXZhbGVudCB0byBhbiBleHRyaW5zaWMgRXVsZXIgcm90YXRpb24gb2YgYW5nbGVzIGBjYCwgYGJgLCBgYWAgYWJib3V0XG4gICAqIGAnWllYJ2AuXG4gICAqXG4gICAqIElmIHRoaXMgaXMgY2hhbmdlZCwge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IHdpbGwgYmUgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtFdWxlclJvdGF0aW9uT3JkZXJ9IG9yZGVyXG4gICAqIEBtZW1iZXJvZiBFdWxlciNcbiAgICogQGRlZmF1bHQgJ1hZWidcbiAgICovXG4gIGdldCBvcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG4gIH1cblxuICBzZXQgb3JkZXIodmFsdWUpIHtcbiAgICB0aGlzLl9vcmRlciA9IHZhbHVlO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbmdsZXMgb2YgdGhpcyBldWxlciB0cmFuc2Zvcm0gYW5kIG9wdGlvbmFsbHkgdGhlXG4gICAqIHtAbGluayBFdWxlciNvcmRlcn0gYW5kIHRoZW4gY2FsbCB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30uXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFuZ2xlIG9mIHRoZSB5IGF4aXMgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIGFuZ2xlIG9mIHRoZSB6IGF4aXMgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtvcmRlcl0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAqL1xuICBzZXQoeCwgeSwgeiwgb3JkZXIpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHtAbGluayBFdWxlcn0gd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHRoaXMgb25lLlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHJldHVybiB7RXVsZXJ9XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEV1bGVyKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdmFsdWUgb2YgYGV1bGVyYCB0byB0aGlzIGV1bGVyLlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtFdWxlcn0gZVxuICAgKi9cbiAgY29weShlKSB7XG4gICAgdGhpcy5feCA9IGUueDtcbiAgICB0aGlzLl95ID0gZS55O1xuICAgIHRoaXMuX3ogPSBlLno7XG4gICAgdGhpcy5fb3JkZXIgPSBlLm9yZGVyO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbmdsZXMgb2YgdGhpcyBldWxlciB0cmFuc2Zvcm0gZnJvbSBhIHB1cmUgcm90YXRpb24gbWF0cml4IGJhc2VkXG4gICAqIG9uIHRoZSBvcmllbnRhdGlvbiBzcGVjaWZpZWQgYnkgYG9yZGVyYC5cbiAgICogQG1ldGhvZCBzZXRGcm9tUm90YXRpb25NYXRyaXhcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG0gQSB7QGxpbmsgTWF0cml4NH0gb2Ygd2hpY2ggdGhlIHVwcGVyIDN4MyBvZiBtYXRyaXggaXMgYSBwdXJlIFtyb3RhdGlvbiBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JvdGF0aW9uX21hdHJpeCkgKGkuZS4gdW5zY2FsZWQpLlxuICAgKiBAcGFyYW0ge0V1bGVyUm90YXRpb25PcmRlcn0gW29yZGVyXSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPXRydWVdIFdoZXRoZXIgdG8gY2FsbCB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gYWZ0ZXIgYXBwbHlpbmcgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNldEZyb21Sb3RhdGlvbk1hdHJpeChtLCBvcmRlciwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG4gICAgY29uc3QgdGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgY29uc3QgW1xuICAgICAgbTExLCBtMjEsIG0zMSwgbTQxLFxuICAgICAgbTEyLCBtMjIsIG0zMiwgbTQyLFxuICAgICAgbTEzLCBtMjMsIG0zMywgbTQzLFxuICAgIF0gPSB0ZTtcblxuICAgIG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICBpZiAob3JkZXIgPT09ICdYWVonKSB7XG4gICAgICB0aGlzLl95ID0gTWF0aC5hc2luKGNsYW1wKG0xMywgLTEsIDEpKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG0xMykgPCAwLjk5OTk5KSB7XG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0xMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMihtMzIsIG0yMik7XG4gICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7XG4gICAgICB0aGlzLl94ID0gTWF0aC5hc2luKC1jbGFtcChtMjMsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMjMpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMihtMTMsIG0zMyk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0xMSk7XG4gICAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG4gICAgICB0aGlzLl94ID0gTWF0aC5hc2luKGNsYW1wKG0zMiwgLTEsIDEpKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG0zMikgPCAwLjk5OTk5KSB7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0zMyk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKC1tMTIsIG0yMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIobTIxLCBtMTEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWVgnKSB7XG4gICAgICB0aGlzLl95ID0gTWF0aC5hc2luKC1jbGFtcChtMzEsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMzEpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMihtMzIsIG0zMyk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMjIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7XG4gICAgICB0aGlzLl96ID0gTWF0aC5hc2luKGNsYW1wKG0yMSwgLTEsIDEpKTtcblxuICAgICAgaWYgKE1hdGguYWJzKG0yMSkgPCAwLjk5OTk5KSB7XG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1tMjMsIG0yMik7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1tMzEsIG0xMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdYWlknKSB7XG4gICAgICB0aGlzLl96ID0gTWF0aC5hc2luKC1jbGFtcChtMTIsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMTIpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMihtMzIsIG0yMik7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKC1tMjMsIG0zMyk7XG4gICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYEV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICR7b3JkZXJ9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuICAgIGlmICh1cGRhdGUgIT09IGZhbHNlKSB7XG4gICAgICBvbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYW5nbGVzIG9mIHRoaXMgZXVsZXIgdHJhbnNmb3JtIGZyb20gYSBub3JtYWxpemVkIHF1YXRlcm5pb24gYmFzZWRcbiAgICogb24gdGhlIG9yaWVudGF0aW9uIHNwZWNpZmllZCBieSBgb3JkZXJgLlxuICAgKiBAbWV0aG9kIHNldEZyb21RdWF0ZXJuaW9uXG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxIEEgbm9ybWFsaXplZCBxdWF0ZXJuaW9uLlxuICAgKiBAcGFyYW0ge0V1bGVyUm90YXRpb25PcmRlcn0gW29yZGVyXSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPXRydWVdIFdoZXRoZXIgdG8gY2FsbCB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gYWZ0ZXIgYXBwbHlpbmcgdGhlIG1hdHJpeC5cbiAgICovXG4gIHNldEZyb21RdWF0ZXJuaW9uKHEsIG9yZGVyLCB1cGRhdGUgPSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uUSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuc2V0RnJvbVF1YXRlcm5pb25RID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEZyb21RdWF0ZXJuaW9uUS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKTtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgodGhpcy5zZXRGcm9tUXVhdGVybmlvblEsIG9yZGVyLCB1cGRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBFdWxlciN4fSwge0BsaW5rIEV1bGVyI3l9LCBhbmQge0BsaW5rIEV1bGVyI3p9LCBhbmRcbiAgICogb3B0aW9uYWxseSB1cGRhdGUgdGhlIHtAbGluayBFdWxlciNvcmRlcn0uIHtAbGluayBFdWxlciNvbkNoYW5nZUNhbGxiYWNrfVxuICAgKiBpcyBjYWxsZWQgYWZ0ZXIgdGhlc2UgY2hhbmdlcyBhcmUgbWFkZS5cbiAgICogQG1ldGhvZCBzZXRGcm9tVmVjdG9yM1xuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKiBAcGFyYW0ge0V1bGVyUm90YXRpb25PcmRlcn0gW29yZGVyXSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG9yZGVyIHRoYXQgdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC5cbiAgICovXG4gIHNldEZyb21WZWN0b3IzKHYsIG9yZGVyID0gdGhpcy5fb3JkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodi54LCB2LnksIHYueiwgb3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgZXVsZXIgYW5nbGUgd2l0aCBhIGBuZXdPcmRlcmAgYnkgY3JlYXRpbmcgYSBxdWF0ZXJuaW9uIGZyb20gdGhpc1xuICAgKiBldWxlciBhbmdsZSBhbmQgdGhlbiBzZXR0aW5nIHRoaXMgZXVsZXIgYW5nbGUgd2l0aCB0aGUgcXVhdGVybmlvbiBhbmQgdGhlXG4gICAqIGBuZXdPcmRlcmAuXG4gICAqXG4gICAqIF9XQVJOSU5HXzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uLlxuICAgKiBAbWV0aG9kIHJlb3JkZXJcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtuZXdPcmRlcl1cbiAgICovXG4gIHJlb3JkZXIobmV3T3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucmVvcmRlclEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnJlb3JkZXJRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlb3JkZXJRLnNldEZyb21FdWxlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbih0aGlzLnJlb3JkZXJRLCBuZXdPcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciBzdHJpY3QgZXF1YWxpdHkgb2YgdGhpcyBldWxlciBhbmQgYGV1bGVyYC5cbiAgICogQG1ldGhvZCBlcXVhbHNcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtFdWxlcn0gZXVsZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhldWxlcikge1xuICAgIHJldHVybiAoZXVsZXIueCA9PT0gdGhpcy5feCkgJiZcbiAgICAgIChldWxlci55ID09PSB0aGlzLl95KSAmJlxuICAgICAgKGV1bGVyLnogPT09IHRoaXMuX3opICYmXG4gICAgICAoZXVsZXIub3JkZXIgPT09IHRoaXMuX29yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIHRoaXMgZXVsZXIncyB7QGxpbmsgRXVsZXIjeH0gYW5nbGUgdG8gYGFycmF5WzBdYC4gQXNzaWducyB0aGlzXG4gICAqIGV1bGVyJ3Mge0BsaW5rIEV1bGVyI3l9IGFuZ2xlIHRvIGBhcnJheVsxXWAuIEFzc2lnbnMgdGhpcyBldWxlcidzXG4gICAqIHtAbGluayBFdWxlciN6fSBhbmdsZSB0byBgYXJyYXlbMl1gLiBPcHRpb25hbGx5IGFzc2lnbnMgdGhpcyBldWxlcidzXG4gICAqIHtAbGluayBFdWxlciNvcmRlcn0gdG8gYGFycmF5WzNdYC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgQXJyYXkgb2YgbGVuZ3RoIDMgb3IgNC4gVGhlIG9wdGlvbmFsIDR0aCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB7QGxpbmsgRXVsZXIjb3JkZXJ9LlxuICAgKi9cbiAgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgdGhpcy5feCA9IGFycmF5WzBdO1xuICAgIHRoaXMuX3kgPSBhcnJheVsxXTtcbiAgICB0aGlzLl96ID0gYXJyYXlbMl07XG5cbiAgICBpZiAoYXJyYXlbM10gIT09IHVuZGVmaW5lZCAmJiBhcnJheVszXSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fb3JkZXIgPSBhcnJheVszXTtcbiAgICB9XG5cbiAgICBvbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZm9ybSBgW3gsIHksIHosIG9yZGVyXWAuXG4gICAqIEBtZXRob2QgdG9BcnJheVxuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBbYXJyYXk9W11dIEFycmF5IHRvIHN0b3JlIHRoZSBldWxlciBpbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9mZnNldCBpbiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXMuX3g7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuICAgIGFycmF5W29mZnNldCArIDJdID0gdGhpcy5fejtcbiAgICBhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMuX29yZGVyO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBldWxlcidzIHtAbGluayBFdWxlciN4fSwge0BsaW5rIEV1bGVyI3l9LCBhbmQge0BsaW5rIEV1bGVyI3p9XG4gICAqIHByb3BlcnRpZXMgYXMgYSB7QGxpbmsgVmVjdG9yM30uXG4gICAqIEBtZXRob2QgdG9WZWN0b3IzXG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gW29wdGlvbmFsUmVzdWx0XVxuICAgKiBAcmV0dXJuIHtWZWN0b3IzfVxuICAgKi9cbiAgdG9WZWN0b3IzKG9wdGlvbmFsUmVzdWx0KSB7XG4gICAgaWYgKG9wdGlvbmFsUmVzdWx0KSB7XG4gICAgICByZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy5feCwgdGhpcy5feSwgdGhpcy5feik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBFdWxlciNvbkNoYW5nZUNhbGxiYWNrfSBmdW5jdGlvbi5cbiAgICogQG1ldGhvZCBvbkNoYW5nZVxuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNoYW5nZShjYWxsYmFjaykge1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2soKSB7fVxufVxuXG4iLCJpbXBvcnQgVmVjdG9yMyBmcm9tICcuL1ZlY3RvcjMnO1xuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi9WZWN0b3IyJztcbmV4cG9ydCBjb25zdCBERUcyUkFEID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBSQUQyREVHID0gMTgwIC8gTWF0aC5QSTtcblxuLyoqXG4gKiBDb252ZXJ0cyBkZWdyZXNzIHRvIHJhZGlhbnMuXG4gKiBAbWV0aG9kIGRlZ1RvUmFkXG4gKiBAbWVtYmVyb2YgbW9kdWxlOk1hdGhcbiAqIEBwYXJhbSAge251bWJlcn0gZGVncmVlc1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZGVnVG9SYWQgPSAoZGVncmVlcykgPT4gZGVncmVlcyAqIERFRzJSQUQ7XG5cbi8qKlxuICogQ29udmVydHMgcmFkaWFucyB0byBkZWdyZWVzLlxuICogQG1ldGhvZCByYWRUb0RlZ1xuICogQG1lbWJlcm9mIG1vZHVsZTpNYXRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJhZGlhbnNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJhZFRvRGVnID0gKHJhZGlhbnMpID0+IHJhZGlhbnMgKiBSQUQyREVHO1xuXG4vKipcbiAqIFZlY3RvcjMg6rCS7J2EIO2YhOyerCBTY3JlZW4g64K07JeQIFZlY3RvcjIg6rCS7Jy866GcIOuzgO2ZmFxuICogQG1lbWJlcm9mIG1vZHVsZTpNYXRoXG4gKiBAbWV0aG9kIHdvcmxkVG9TY3JlZW5cbiAqIEBwYXJhbSB7VmVjdG9yM30gcG9zaXRpb25cbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cbmV4cG9ydCBjb25zdCB3b3JsZFRvU2NyZWVuID0gKHBvc2l0aW9uKSA9PiB7XG4gIGNvbnN0IGNhbWVyYSA9IExldHNlZUVuZ2luZS5jYW1lcmE7XG5cbiAgaWYgKGNhbWVyYSkge1xuICAgIGNvbnN0IHYgPSBwb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgdi5wcm9qZWN0KGNhbWVyYSk7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKCkuc2V0KFxuICAgICAgKHYueCArIDEpICogKHNjcmVlbi53aWR0aCAvIDIpLFxuICAgICAgKC12LnkgKyAxKSAqIChzY3JlZW4uaGVpZ2h0IC8gMilcbiAgICApO1xuICB9XG4gIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsYW1wcyB0aGUgYHZhbHVlYCB0byBiZSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqIEBtZXRob2QgY2xhbXBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBiZSBjbGFtcGVkLlxuICogQHBhcmFtICB7bnVtYmVyfSBtaW4gICBNaW5pbXVtIHZhbHVlLlxuICogQHBhcmFtICB7bnVtYmVyfSBtYXggICBNYXhpbXVtIHZhbHVlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgY2xhbXAgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgRXVjbGlkZWFuIG1vZHVsZSBvZiBgbSAlIG5gLCB0aGF0IGlzOlxuICogYGBgXG4gKiAoKG4gJSBtKSArIG0pICUgbVxuICogYGBgXG4gKiBAbWV0aG9kIGV1Y2xpZGVhbk1vZHVsb1xuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG5cbiAqIEBwYXJhbSAge251bWJlcn0gbVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5leHBvcnQgY29uc3QgZXVjbGlkZWFuTW9kdWxvID0gKG4sIG0pID0+IHtcbiAgcmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xufTtcblxuLyoqXG4gKiBMaW5lYXIgbWFwcGluZyBvZiBgeGAgZnJvbSByYW5nZSBgW2ExLCBhMl1gIHRvIHJhbmdlIGBbYjEsIGIyXWAuXG4gKiBAbWV0aG9kIG1hcExpbmVhclxuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggIFZhbHVlIHRvIGJlIG1hcHBlZC5cbiAqIEBwYXJhbSAge251bWJlcn0gYTEgTWluaW11bSB2YWx1ZSBmb3IgcmFuZ2UgQS5cbiAqIEBwYXJhbSAge251bWJlcn0gYTIgTWF4aW11bSB2YWx1ZSBmb3IgcmFuZ2UgQS5cbiAqIEBwYXJhbSAge251bWJlcn0gYjEgTWluaW11bSB2YWx1ZSBmb3IgcmFuZ2UgQi5cbiAqIEBwYXJhbSAge251bWJlcn0gYjIgTWF4aW11bSB2YWx1ZSBmb3IgcmFuZ2UgQi5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcExpbmVhciA9ICh4LCBhMSwgYTIsIGIxLCBiMikgPT4ge1xuICByZXR1cm4gYjEgKyAoKHggLSBhMSkgKiAoYjIgLSBiMSkgLyAoYTIgLSBhMSkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWVcbiAqIFtsaW5lYXJseSBpbnRlcnBvbGF0ZWRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9pbnRlcnBvbGF0aW9uKVxuICogZnJvbSB0d28ga25vd24gcG9pbnRzIGJhc2VkIG9uIHRoZSBnaXZlbiBpbnRlcnZhbCAtIGB0ID0gMGAgd2lsbCByZXR1cm4gYHhgXG4gKiBhbmQgYHQgPSAxYCB3aWxsIHJldHVybiBgeWAuXG4gKiBAbWV0aG9kIGxlcnBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IFN0YXJ0IHBvaW50LlxuICogQHBhcmFtICB7bnVtYmVyfSB5IEVuZCBwb2ludC5cbiAqIEBwYXJhbSAge251bWJlcn0gdCBJbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludmVydmFsIGBbMCwgMV1gLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVycCA9ICh4LCB5LCB0KSA9PiB7XG4gIHJldHVybiAoKDEgLSB0KSAqIHgpICsgKHQgKiB5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAgdGhhdCByZXByZXNlbnRzIHRoZSBwZXJjZW50YWdlIHRoYXQgYHhgXG4gKiBoYXMgbW92ZWQgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAsIGJ1dCBzbW9vdGhlZCBvciBzbG93ZWQgZG93biB0aGUgY2xvc2VyIGB4YFxuICogaXMgdG8gdGhlIGBtaW5gIGFuZCBgbWF4YC4gU2VlXG4gKiBbU21vb3Roc3RlcF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwKSBmb3IgZGV0YWlscy5cbiAqIEBtZXRob2Qgc21vb3Roc3RlcFxuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggICBUaGUgdmFsdWUgdG8gZXZhbHVhdGUgYmFzZWQgb24gaXRzIHBvc2l0aW9uIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICogQHBhcmFtICB7bnVtYmVyfSBtaW4gQW55IGB4YCB2YWx1ZSBiZWxvdyBgbWluYCB3aWxsIGJlIGAwYC5cbiAqIEBwYXJhbSAge251bWJlcn0gbWF4IEFueSBgeGAgdmFsdWUgYWJvdmUgYG1heGAgd2lsbCBiZSBgMWAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBzbW9vdGhzdGVwID0gKHgsIG1pbiwgbWF4KSA9PiB7XG4gIGlmICh4IDw9IG1pbikgcmV0dXJuIDA7XG4gIGlmICh4ID49IG1heCkgcmV0dXJuIDE7XG5cbiAgeCA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuICByZXR1cm4geCAqIHggKiAoMyAtICgyICogeCkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC4gQVxuICogW3ZhcmlhdGlvbiBvbiBzbW9vdGhzdGVwXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwI1ZhcmlhdGlvbnMpXG4gKiB0aGF0IGhhcyB6ZXJvIDFzdCBhbmQgMm5kIG9yZGVyIGRlcml2YXRpdmVzIGF0IGB4ID0gMGAgYW5kIGB4ID0gMWAuXG4gKiBAbWV0aG9kIHNtb290aGVyc3RlcFxuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggICBUaGUgdmFsdWUgdG8gZXZhbHVhdGUgYmFzZWQgb24gaXRzIHBvc2l0aW9uIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICogQHBhcmFtICB7bnVtYmVyfSBtaW4gQW55IGB4YCB2YWx1ZSBiZWxvdyBgbWluYCB3aWxsIGJlIGAwYC5cbiAqIEBwYXJhbSAge251bWJlcn0gbWF4IEFueSBgeGAgdmFsdWUgYWJvdmUgYG1heGAgd2lsbCBiZSBgMWAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBzbW9vdGhlcnN0ZXAgPSAoeCwgbWluLCBtYXgpID0+IHtcbiAgaWYgKHggPD0gbWluKSByZXR1cm4gMDtcbiAgaWYgKHggPj0gbWF4KSByZXR1cm4gMTtcblxuICB4ID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gIHJldHVybiB4ICogeCAqIHggKiAoKHggKiAoKHggKiA2KSAtIDE1KSkgKyAxMCk7XG59O1xuXG4vKipcbiAqIFJhbmRvbSBpbnRlZ2VyIGluIHRoZSBpbnRlcnZhbCBgbG93YCB0byBgaGlnaGAuXG4gKiBAbWV0aG9kIHJhbmRJbnRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSAge251bWJlcn0gaGlnaFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcmFuZEludCA9IChsb3csIGhpZ2gpID0+IGxvdyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93ICsgMSkpO1xuXG4vKipcbiAqIFJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgYGxvd2AgdG8gYGhpZ2hgLlxuICogQG1ldGhvZCByYW5kRmxvYXRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSAge251bWJlcn0gaGlnaFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcmFuZEZsb2F0ID0gKGxvdywgaGlnaCkgPT4gbG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpO1xuXG4vKipcbiAqIFJhbmRvbSBmbG9hdCBpbiB0aGUgaW50ZXJ2YWwgYC1yYW5nZS8yYCB0byBgcmFuZ2UvMmAuXG4gKiBAbWV0aG9kIHJhbmRGbG9hdFNwcmVhZFxuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJhbmdlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByYW5kRmxvYXRTcHJlYWQgPSAocmFuZ2UpID0+IHJhbmdlICogKDAuNSAtIE1hdGgucmFuZG9tKCkpO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwb3dlciBvZiAyLlxuICogQG1ldGhvZCBpc1Bvd2VyT2ZUd29cbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSAgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Bvd2VyT2ZUd28gPSAodmFsdWUpID0+ICh2YWx1ZSAmICh2YWx1ZSAtIDEpKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMiB0byBhIGdpdmVuIG51bWJlciBgdmFsdWVgLlxuICogQG1ldGhvZCBuZWFyZXN0UG93ZXJPZlR3b1xuICogQG1lbWJlcm9mIG1vZHVsZTpVdGlsXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBuZWFyZXN0UG93ZXJPZlR3byA9ICh2YWx1ZSkgPT4gMiAqKiAoTWF0aC5yb3VuZChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMikpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmVhcmVzdCBwb3dlciBvZiAyIHRoYXQgaXMgYmlnZ2VyIHRoYW4gYHZhbHVlYC5cbiAqIEBtZXRob2QgbmV4dFBvd2VyT2ZUd29cbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbmV4dFBvd2VyT2ZUd28gPSAodmFsdWUpID0+IHtcbiAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuXG4gIHJlc3VsdCAtPSAxO1xuICByZXN1bHQgfD0gcmVzdWx0ID4+IDE7XG4gIHJlc3VsdCB8PSByZXN1bHQgPj4gMjtcbiAgcmVzdWx0IHw9IHJlc3VsdCA+PiA0O1xuICByZXN1bHQgfD0gcmVzdWx0ID4+IDg7XG4gIHJlc3VsdCB8PSByZXN1bHQgPj4gMTY7XG4gIHJlc3VsdCArPSAxO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBbiBvYmplY3Qgd2l0aCBzZXZlcmFsIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQG1vZHVsZSBVdGlsXG4gKiBAYXV0aG9yIEpvb0h5dW4gTGVlIChsamhAbGV0c2VlLmlvKVxuICogQHNpbmNlIDIwMTYuIDAzLiAxNy5cbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgTWF0aFV0aWwgPSB7XG4gIGRlZ1RvUmFkLFxuICByYWRUb0RlZyxcbiAgd29ybGRUb1NjcmVlbixcbiAgY2xhbXAsXG4gIGV1Y2xpZGVhbk1vZHVsbyxcbiAgbWFwTGluZWFyLFxuICBsZXJwLFxuICBzbW9vdGhzdGVwLFxuICBzbW9vdGhlcnN0ZXAsXG4gIHJhbmRJbnQsXG4gIHJhbmRGbG9hdCxcbiAgcmFuZEZsb2F0U3ByZWFkLFxuICBpc1Bvd2VyT2ZUd28sXG4gIG5lYXJlc3RQb3dlck9mVHdvLFxuICBuZXh0UG93ZXJPZlR3b1xufTtcblxud2luZG93Lk1hdGguZGVnVG9SYWQgPSBkZWdUb1JhZDtcbndpbmRvdy5NYXRoLnJhZFRvRGVnID0gcmFkVG9EZWc7XG53aW5kb3cuTWF0aC53b3JsZFRvU2NyZWVuID0gd29ybGRUb1NjcmVlbjtcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFV0aWw7XG4iLCJpbXBvcnQgVmVjdG9yMyBmcm9tICcuL1ZlY3RvcjMnO1xuLy8gaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi9NYXRyaXg0JztcblxuLyoqXG4gKiBBXG4gKiBbY29sdW1uLW1ham9yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctX2FuZF9jb2x1bW4tbWFqb3Jfb3JkZXIpXG4gKiBsaXN0IG9mIG1hdHJpeCB2YWx1ZXMuXG4gKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9IGVsZW1lbnRzXG4gKiBAbWVtYmVyb2YgTWF0cml4MyNcbiAqIEBkZWZhdWx0IFtcbiAqIDEsIDAsIDAsXG4gKiAwLCAxLCAwLFxuICogMCwgMCwgMVxuICogXVxuICovXG4vLyBsZXQgdGhpcy5fZWxlbWVudHM7XG5cbi8qKlxuICogVXNlZCB0byBjaGVjayB3aGV0aGVyIHRoaXMgb3IgZGVyaXZlZCBjbGFzc2VzIGFyZSB7QGxpbmsgTWF0cml4M31zLiBZb3VcbiAqIHNob3VsZCBub3QgY2hhbmdlIHRoaXMsIGFzIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBmb3Igb3B0aW1pc2F0aW9uLlxuICogQHByb3BlcnR5IGlzTWF0cml4M1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCB0cnVlXG4gKi9cbmNvbnN0IF9pc01hdHJpeDMgPSB0cnVlO1xuXG4vKipcbiAqIEBjbGFzcyBNYXRyaXgzXG4gKiBAY2xhc3NkZXNjXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIDN4M1xuICogW21hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF0cml4XyhtYXRoZW1hdGljcykpLlxuICogQGV4YW1wbGVcbiAqIHZhciBtID0gbmV3IE1hdHJpeDMoKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4MyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAxLCAwLCAwLFxuICAgICAgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDEsXG4gICAgXSk7XG4gIH1cblxuICBnZXQgZWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzO1xuICB9XG5cbiAgZ2V0IGlzTWF0cml4MygpIHtcbiAgICByZXR1cm4gX2lzTWF0cml4MztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSAzeDMgbWF0cml4IHZhbHVlcyB0byB0aGUgZ2l2ZW5cbiAgICogW3Jvdy1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyKVxuICAgKiBzZXF1ZW5jZSBvZiB2YWx1ZXMuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbjExIFZhbHVlIHRvIHB1dCBpbiByb3cgMSwgY29sIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMTIgVmFsdWUgdG8gcHV0IGluIHJvdyAxLCBjb2wgMi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4xMyBWYWx1ZSB0byBwdXQgaW4gcm93IDEsIGNvbCAzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjIxIFZhbHVlIHRvIHB1dCBpbiByb3cgMiwgY29sIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMjIgVmFsdWUgdG8gcHV0IGluIHJvdyAyLCBjb2wgMi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4yMyBWYWx1ZSB0byBwdXQgaW4gcm93IDIsIGNvbCAzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjMxIFZhbHVlIHRvIHB1dCBpbiByb3cgMywgY29sIDEuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMzIgVmFsdWUgdG8gcHV0IGluIHJvdyAzLCBjb2wgMi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4zMyBWYWx1ZSB0byBwdXQgaW4gcm93IDMsIGNvbCAzLlxuICAgKi9cbiAgc2V0KFxuICAgIG4xMSwgbjEyLCBuMTMsXG4gICAgbjIxLCBuMjIsIG4yMyxcbiAgICBuMzEsIG4zMiwgbjMzLFxuICApIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gICAgdGVbMF0gPSBuMTE7XG4gICAgdGVbMV0gPSBuMjE7XG4gICAgdGVbMl0gPSBuMzE7XG4gICAgdGVbM10gPSBuMTI7XG4gICAgdGVbNF0gPSBuMjI7XG4gICAgdGVbNV0gPSBuMzI7XG4gICAgdGVbNl0gPSBuMTM7XG4gICAgdGVbN10gPSBuMjM7XG4gICAgdGVbOF0gPSBuMzM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgbWF0cml4IHRvIHRoZSAzeDMgaWRlbnRpdHkgbWF0cml4OlxuICAgKiBgYGBcbiAgICogMSAwIDBcbiAgICogMCAxIDBcbiAgICogMCAwIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgaWRlbnRpdHlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICB0aGlzLnNldChcbiAgICAgIDEsIDAsIDAsXG4gICAgICAwLCAxLCAwLFxuICAgICAgMCwgMCwgMSxcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtYXRyaXggd2l0aCBpZGVudGljYWwgZWxlbWVudHMgdG8gdGhpcyBvbmUuXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge01hdHJpeDN9XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDMoKS5mcm9tQXJyYXkodGhpcy5fZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgZWxlbWVudHMgb2YgbWF0cml4IGBtYCBpbnRvIHRoaXMgbWF0cml4LlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge01hdHJpeDN9IG1cbiAgICovXG4gIGNvcHkobSkge1xuICAgIGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMuc2V0KFxuICAgICAgbWVbMF0sIG1lWzNdLCBtZVs2XSxcbiAgICAgIG1lWzFdLCBtZVs0XSwgbWVbN10sXG4gICAgICBtZVsyXSwgbWVbNV0sIG1lWzhdLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoaXMgbWF0cml4IHRvIHRoZSB1cHBlciAzeDMgbWF0cml4IG9mIHRoZSB7QGxpbmsgTWF0cml4NH0gYG1gLlxuICAgKiBAbWV0aG9kIHNldEZyb21NYXRyaXg0XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIHNldEZyb21NYXRyaXg0KG0pIHtcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnNldChcbiAgICAgIG1lWzBdLCBtZVs0XSwgbWVbOF0sXG4gICAgICBtZVsxXSwgbWVbNV0sIG1lWzldLFxuICAgICAgbWVbMl0sIG1lWzZdLCBtZVsxMF0sXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIChhcHBsaWVzKSB0aGlzIG1hdHJpeCB0byBldmVyeSAzRCB2ZWN0b3IgaW4gdGhlIGBhdHRyaWJ1dGVgLlxuICAgKiBAbWV0aG9kIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGVcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0J1ZmZlckF0dHJpYnV0ZX0gYXR0cmlidXRlIEFuIGF0dHJpYnV0ZSBvZiBmbG9hdHMgdGhhdCByZXByZXNldCAzRCB2ZWN0b3JzLlxuICAgKiBAcmV0dXJuIHtCdWZmZXJBdHRyaWJ1dGV9XG4gICAqL1xuICBhcHBseVRvQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICB2MS54ID0gYXR0cmlidXRlLmdldFgoaSk7XG4gICAgICB2MS55ID0gYXR0cmlidXRlLmdldFkoaSk7XG4gICAgICB2MS56ID0gYXR0cmlidXRlLmdldFooaSk7XG4gICAgICB2MS5hcHBseU1hdHJpeDModGhpcyk7XG4gICAgICBhdHRyaWJ1dGUuc2V0WFlaKGksIHYxLngsIHYxLnksIHYxLnopO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyBldmVyeSBjb21wb25lbnQgb2YgdGhlIG1hdHJpeCBieSB0aGUgc2NhbGFyIHZhbHVlIGBzYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVNjYWxhclxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIG11bHRpcGx5U2NhbGFyKHMpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gICAgdGVbMF0gKj0gcztcbiAgICB0ZVszXSAqPSBzO1xuICAgIHRlWzZdICo9IHM7XG4gICAgdGVbMV0gKj0gcztcbiAgICB0ZVs0XSAqPSBzO1xuICAgIHRlWzddICo9IHM7XG4gICAgdGVbMl0gKj0gcztcbiAgICB0ZVs1XSAqPSBzO1xuICAgIHRlWzhdICo9IHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlXG4gICAqIFtkZXRlcm1pbmFudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGV0ZXJtaW5hbnQpIG9mIHRoaXMgbWF0cml4LlxuICAgKiBAbWV0aG9kIGRldGVybWluYW50XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkZXRlcm1pbmFudCgpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuX2VsZW1lbnRzO1xuICAgIGNvbnN0IGEgPSB0ZVswXTtcbiAgICBjb25zdCBiID0gdGVbMV07XG4gICAgY29uc3QgYyA9IHRlWzJdO1xuICAgIGNvbnN0IGQgPSB0ZVszXTtcbiAgICBjb25zdCBlID0gdGVbNF07XG4gICAgY29uc3QgZiA9IHRlWzVdO1xuICAgIGNvbnN0IGcgPSB0ZVs2XTtcbiAgICBjb25zdCBoID0gdGVbN107XG4gICAgY29uc3QgaSA9IHRlWzhdO1xuXG4gICAgcmV0dXJuIChhICogZSAqIGkpIC0gKGEgKiBmICogaCkgLSAoYiAqIGQgKiBpKSArIChiICogZiAqIGcpICsgKGMgKiBkICogaCkgLSAoYyAqIGUgKiBnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyBtYXRyaXggdG8gdGhlXG4gICAqIFtpbnZlcnNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnZlcnRpYmxlX21hdHJpeCkgb2YgdGhlIHBhc3NlZFxuICAgKiBtYXRyaXggYG1hdHJpeGAsIHVzaW5nIHRoZVxuICAgKiBbYW5hbHl0aWMgbWV0aG9kXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnZlcnRpYmxlX21hdHJpeCNBbmFseXRpY19zb2x1dGlvbikuXG4gICAqIElmIGB0aHJvd09uRGVnZW5lcmF0ZWAgaXMgbm90IHNldCBhbmQgdGhlIG1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZSwgc2V0XG4gICAqIHRoaXMgdG8gdGhlIDN4MyBpZGVudGl0eSBtYXRyaXguXG4gICAqIEBtZXRob2QgZ2V0SW52ZXJzZVxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7TWF0cml4M30gbWF0cml4IFRoZSBtYXRyaXggdG8gdGFrZSB0aGUgaW52ZXJzZSBvZi5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3Rocm93T25EZWdlbmVyYXRlPWZhbHNlXSBJZiB0cnVlLCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbWF0cml4IGlzIGRlZ2VuZXJhdGUgKG5vdCBpbnZlcnRpYmxlKS5cbiAgICovXG4gIGdldEludmVyc2UobWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG4gICAgY29uc3QgdGUgPSB0aGlzLl9lbGVtZW50cztcbiAgICBjb25zdCBuMTEgPSBtZVswXTtcbiAgICBjb25zdCBuMjEgPSBtZVsxXTtcbiAgICBjb25zdCBuMzEgPSBtZVsyXTtcbiAgICBjb25zdCBuMTIgPSBtZVszXTtcbiAgICBjb25zdCBuMjIgPSBtZVs0XTtcbiAgICBjb25zdCBuMzIgPSBtZVs1XTtcbiAgICBjb25zdCBuMTMgPSBtZVs2XTtcbiAgICBjb25zdCBuMjMgPSBtZVs3XTtcbiAgICBjb25zdCBuMzMgPSBtZVs4XTtcbiAgICBjb25zdCB0MTEgPSAobjMzICogbjIyKSAtIChuMzIgKiBuMjMpO1xuICAgIGNvbnN0IHQxMiA9IChuMzIgKiBuMTMpIC0gKG4zMyAqIG4xMik7XG4gICAgY29uc3QgdDEzID0gKG4yMyAqIG4xMikgLSAobjIyICogbjEzKTtcbiAgICBjb25zdCBkZXQgPSAobjExICogdDExKSArIChuMjEgKiB0MTIpICsgKG4zMSAqIHQxMyk7XG5cbiAgICBpZiAoZGV0ID09PSAwKSB7XG4gICAgICBjb25zdCBtc2cgPSAnTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhblxcJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMCc7XG5cbiAgICAgIGlmICh0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cbiAgICB0ZVswXSA9IHQxMSAqIGRldEludjtcbiAgICB0ZVsxXSA9ICgobjMxICogbjIzKSAtIChuMzMgKiBuMjEpKSAqIGRldEludjtcbiAgICB0ZVsyXSA9ICgobjMyICogbjIxKSAtIChuMzEgKiBuMjIpKSAqIGRldEludjtcbiAgICB0ZVszXSA9IHQxMiAqIGRldEludjtcbiAgICB0ZVs0XSA9ICgobjMzICogbjExKSAtIChuMzEgKiBuMTMpKSAqIGRldEludjtcbiAgICB0ZVs1XSA9ICgobjMxICogbjEyKSAtIChuMzIgKiBuMTEpKSAqIGRldEludjtcbiAgICB0ZVs2XSA9IHQxMyAqIGRldEludjtcbiAgICB0ZVs3XSA9ICgobjIxICogbjEzKSAtIChuMjMgKiBuMTEpKSAqIGRldEludjtcbiAgICB0ZVs4XSA9ICgobjIyICogbjExKSAtIChuMjEgKiBuMTIpKSAqIGRldEludjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBbVHJhbnNwb3Nlc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNwb3NlKSB0aGlzIG1hdHJpeCBpbiBwbGFjZS5cbiAgICogQG1ldGhvZCB0cmFuc3Bvc2VcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqL1xuICB0cmFuc3Bvc2UoKSB7XG4gICAgbGV0IHRtcDtcbiAgICBjb25zdCBtID0gdGhpcy5fZWxlbWVudHM7XG5cbiAgICB0bXAgPSBtWzFdO1xuICAgIG1bMV0gPSBtWzNdO1xuICAgIG1bM10gPSB0bXA7XG4gICAgdG1wID0gbVsyXTtcbiAgICBtWzJdID0gbVs2XTtcbiAgICBtWzZdID0gdG1wO1xuICAgIHRtcCA9IG1bNV07XG4gICAgbVs1XSA9IG1bN107XG4gICAgbVs3XSA9IHRtcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIHRoZSB1cHBlciBsZWZ0IDN4MyBvZiB0aGVcbiAgICogW25vcm1hbCBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05vcm1hbF9tYXRyaXgpIG9mIHRoZSBwYXNzZWRcbiAgICogYG1hdHJpeDRgLiBUaGUgbm9ybWFsIG1hdHJpeCBpcyB0aGVcbiAgICogW2ludmVyc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludmVydGlibGVfbWF0cml4KVxuICAgKiBbdHJhbnNwb3NlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3Bvc2UpIG9mIHRoZSBtYXRyaXhcbiAgICogYG1hdHJpeDRgLlxuICAgKiBAbWV0aG9kIGdldE5vcm1hbE1hdHJpeFxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtYXRyaXg0XG4gICAqL1xuICBnZXROb3JtYWxNYXRyaXgobWF0cml4NCkge1xuICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KG1hdHJpeDQpLmdldEludmVyc2UodGhpcykudHJhbnNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogW1RyYW5zcG9zZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyYW5zcG9zZSkgdGhpcyBtYXRyaXggaW50byB0aGVcbiAgICogc3VwcGxpZWQgYXJyYXksIGFuZCByZXR1cm5zIGl0c2VsZiB1bmNoYW5nZWQuXG4gICAqIEBtZXRob2QgdHJhbnNwb3NlSW50b0FycmF5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSByIEFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgdmVjdG9yIGluLlxuICAgKi9cbiAgdHJhbnNwb3NlSW50b0FycmF5KHIpIHtcbiAgICBjb25zdCBtID0gdGhpcy5fZWxlbWVudHM7XG5cbiAgICByWzBdID0gbVswXTtcbiAgICByWzFdID0gbVszXTtcbiAgICByWzJdID0gbVs2XTtcbiAgICByWzNdID0gbVsxXTtcbiAgICByWzRdID0gbVs0XTtcbiAgICByWzVdID0gbVs3XTtcbiAgICByWzZdID0gbVsyXTtcbiAgICByWzddID0gbVs1XTtcbiAgICByWzhdID0gbVs4XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCBiYXNlZCBvbiBhbiBgYXJyYXlgIGluXG4gICAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gICAqIGZvcm1hdC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVhZCB0aGUgZWxlbWVudHMgZnJvbS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIEluZGV4IG9mIGZpcnN0IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgKi9cbiAgZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgaW5kZXggPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSArPSAxKSB7XG4gICAgICB0aGlzLl9lbGVtZW50c1tpXSA9IGFycmF5W2kgKyBpbmRleF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggdG8gYW4gYXJyYXkgaW5cbiAgICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcilcbiAgICogZm9ybWF0LlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBbYXJyYXk9W11dICBBcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIHZlY3RvciBpbi4gSWYgbm90IGdpdmVuIGEgbmV3IGFycmF5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9mZnNldCBpbiB0aGUgYXJyYXkgYXQgd2hpY2ggdG8gcHV0IHRoZSByZXN1bHQuXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgaWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5ID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBvZmZzZXQgfHwgMDtcbiAgICBjb25zdCB0ZSA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgYXJyYXlbaW5kZXggKyBpXSA9IHRlW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufVxuXG4iLCJpbXBvcnQgVmVjdG9yMyBmcm9tICcuL1ZlY3RvcjMnO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi9RdWF0ZXJuaW9uJztcbmltcG9ydCB7ZGVnVG9SYWR9IGZyb20gJy4vTWF0aCc7XG5cbi8vIGNvbnN0YW50cyBmb3Igb3B0aW1pc2F0aW9uXG5sZXQgZXh0cmFjdFJvdGF0aW9uVjtcbmxldCBsb29rQXRYO1xubGV0IGxvb2tBdFk7XG5sZXQgbG9va0F0WjtcbmxldCBkZWNvbXBvc2VWO1xubGV0IGRlY29tcG9zZU07XG5cbi8qKlxuICogQVxuICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcilcbiAqIGxpc3Qgb2YgbWF0cml4IHZhbHVlcy5cbiAqIEBtZW1iZXIge251bWJlcltdfSBlbGVtZW50c1xuICogQG1lbWJlcm9mIE1hdHJpeDQjXG4gKiBAZGVmYXVsdCBbXG4gKiAxLCAwLCAwLCAwLFxuICogMCwgMSwgMCwgMCxcbiAqIDAsIDAsIDEsIDAsXG4gKiAwLCAwLCAwLCAxXG4gKiBdXG4gKi9cbi8vIGxldCB0aGlzLmVsZW1lbnRzID0gW1xuLy8gICAxLCAwLCAwLCAwLFxuLy8gICAwLCAxLCAwLCAwLFxuLy8gICAwLCAwLCAxLCAwLFxuLy8gICAwLCAwLCAwLCAxXG4vLyBdO1xuXG5sZXQgb25DaGFuZ2VDYWxsYmFjayA9ICgpID0+IHt9O1xuXG5jb25zdCBfaXNNYXRyaXg0ID0gdHJ1ZTtcblxuLyoqXG4gKiBAY2xhc3MgTWF0cml4NFxuICogQGNsYXNzZGVzY1xuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSA0eDRcbiAqIFttYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hdHJpeF8obWF0aGVtYXRpY3MpKS4gVGhlIG1vc3RcbiAqIGNvbW1vbiB1c2Ugb2YgYSA0eDQgbWF0cml4IGluIDNEIGNvbXB1dGVyIGdyYXBoaWNzIGlzIGFzIGFcbiAqIFt0cmFuc2Zvcm1hdGlvbiBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyYW5zZm9ybWF0aW9uX21hdHJpeCkuXG4gKiBGb3IgYW4gaW50cm9kdWN0aW9uIHRvIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGFzIHVzZWQgaW4gV2ViR0wsIGNoZWNrIG91dFxuICogdGhpc1xuICogW3R1dG9yaWFsXShodHRwOi8vd3d3Lm9wZW5nbC10dXRvcmlhbC5vcmcvYmVnaW5uZXJzLXR1dG9yaWFscy90dXRvcmlhbC0zLW1hdHJpY2VzKS5cbiAqIFRoaXMgYWxsb3dzIGEge0BsaW5rIFZlY3RvcjN9IHJlcHJlc2VudGluZyBhIHBvaW50IGluIDNEIHNwYWNlIHRvIHVuZGVyZ29cbiAqIHRyYW5zZm9ybWF0aW9ucyBzdWNoIGFzIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2hlYXIsIHNjYWxlLCByZWZsZWN0aW9uLFxuICogb3J0aG9nb25hbCBvciBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIGFuZCBzbyBvbiwgYnkgYmVpbmcgbXVsdGlwbGllZCBieSB0aGVcbiAqIG1hdHJpeC4gVGhpcyBpcyBrbm93biBhcyBfYXBwbHlpbmdfIHRoZSBtYXRyaXggdG8gdGhlIHZlY3Rvci5cbiAqXG4gKiBFdmVyeSB7QGxpbmsgT2JqZWN0M0R9IGhhcyB0aHJlZSBhc3NvY2lhdGVkIHtAbGluayBNYXRyaXg0fXM6XG4gKiAqIHtAbGluayBPYmplY3QzRCNtYXRyaXh9OiB0aGlzIHN0b3JlcyB0aGUgbG9jYWwgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QuXG4gKiAqIHtAbGluayBPYmplY3QzRCNtYXRyaXhXb3JsZH06IHRoZSBnbG9iYWwgb3Igd29ybGQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QuIFRoaXMgaXMgdGhlIG9iamVjdHMgdHJhbnNmb3JtYXRpb24gcmVsYXRpdmUgdG8gaXRzIHBhcmVudC4gSWYgdGhlIG9iamVjdCBoYXMgbm8gcGFyZW50LCB0aGVuIHRoaXMgaXMgaWRlbnRpY2FsIHRvIHRoZSBsb2NhbCB0cmFuc2Zvcm0uXG4gKiAqIHtAbGluayBPYmplY3QzRCNtb2RlbFZpZXdNYXRyaXh9OiBUT0RPLlxuICpcbiAqIHtAbGluayBDYW1lcmF9cyBoYXZlIHR3byBhZGRpdGlvbmFsIHtAbGluayBNYXRyaXg0fXM6XG4gKiAqIHtAbGluayBDYW1lcmEjbWF0cml4V29ybGRJbnZlcnNlfTogVGhlIGludmVyc2Ugb2YgdGhlIHtAbGluayBPYmplY3QzRCNtYXRyaXhXb3JsZH0gZGVzY3JpYmVkIGFib3ZlLlxuICogKiB7QGxpbmsgQ2FtZXJhI3Byb2plY3Rpb25NYXRyaXh9OiBUT0RPLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXRyaXg0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtcbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgXTtcbiAgfVxuICAvL1xuICAvLyBnZXQgZWxlbWVudHMoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XG4gIC8vIH1cblxuICBnZXQgaXNNYXRyaXg0KCkge1xuICAgIHJldHVybiBfaXNNYXRyaXg0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUge0BsaW5rIE1hdHJpeDQjZWxlbWVudHN9IG9mIHRoaXMgbWF0cml4IHRvIHRoZSBzdXBwbGllZCByb3ctbWFqb3JcbiAgICogdmFsdWVzIGBuMTFgLCBgbjEyYCwgLi4uLCBgbjQ0YC5cbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMTFcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjEzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMTRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4yMVxuICAgKiBAcGFyYW0ge251bWJlcn0gbjIyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMjNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4yNFxuICAgKiBAcGFyYW0ge251bWJlcn0gbjMxXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMzJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4zM1xuICAgKiBAcGFyYW0ge251bWJlcn0gbjM0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuNDFcbiAgICogQHBhcmFtIHtudW1iZXJ9IG40MlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjQzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuNDRcbiAgICovXG4gIHNldChcbiAgICBuMTEsIG4xMiwgbjEzLCBuMTQsXG4gICAgbjIxLCBuMjIsIG4yMywgbjI0LFxuICAgIG4zMSwgbjMyLCBuMzMsIG4zNCxcbiAgICBuNDEsIG40MiwgbjQzLCBuNDQsXG4gICkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWzBdID0gbjExO1xuICAgIHRlWzRdID0gbjEyO1xuICAgIHRlWzhdID0gbjEzO1xuICAgIHRlWzEyXSA9IG4xNDtcbiAgICB0ZVsxXSA9IG4yMTtcbiAgICB0ZVs1XSA9IG4yMjtcbiAgICB0ZVs5XSA9IG4yMztcbiAgICB0ZVsxM10gPSBuMjQ7XG4gICAgdGVbMl0gPSBuMzE7XG4gICAgdGVbNl0gPSBuMzI7XG4gICAgdGVbMTBdID0gbjMzO1xuICAgIHRlWzE0XSA9IG4zNDtcbiAgICB0ZVszXSA9IG40MTtcbiAgICB0ZVs3XSA9IG40MjtcbiAgICB0ZVsxMV0gPSBuNDM7XG4gICAgdGVbMTVdID0gbjQ0O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIG1hdHJpeCB0byB0aGVcbiAgICogW2lkZW50aXR5IG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWRlbnRpdHlfbWF0cml4KS5cbiAgICogQG1ldGhvZCBpZGVudGl0eVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICovXG4gIGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IG1hdHJpeCB3aXRoIGlkZW50aWNhbCB7QGxpbmsgTWF0cml4NCNlbGVtZW50c30gdG8gdGhpcyBvbmUuXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge01hdHJpeDR9XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDQoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB7QGxpbmsgTWF0cml4NCNlbGVtZW50c30gb2YgbWF0cml4IGBtYCBpbnRvIHRoaXMgbWF0cml4LlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgY29weShtKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IG1lID0gbS5lbGVtZW50cztcblxuICAgIHRlWzBdID0gbWVbMF07XG4gICAgdGVbMV0gPSBtZVsxXTtcbiAgICB0ZVsyXSA9IG1lWzJdO1xuICAgIHRlWzNdID0gbWVbM107XG4gICAgdGVbNF0gPSBtZVs0XTtcbiAgICB0ZVs1XSA9IG1lWzVdO1xuICAgIHRlWzZdID0gbWVbNl07XG4gICAgdGVbN10gPSBtZVs3XTtcbiAgICB0ZVs4XSA9IG1lWzhdO1xuICAgIHRlWzldID0gbWVbOV07XG4gICAgdGVbMTBdID0gbWVbMTBdO1xuICAgIHRlWzExXSA9IG1lWzExXTtcbiAgICB0ZVsxMl0gPSBtZVsxMl07XG4gICAgdGVbMTNdID0gbWVbMTNdO1xuICAgIHRlWzE0XSA9IG1lWzE0XTtcbiAgICB0ZVsxNV0gPSBtZVsxNV07XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudCBvZiB0aGUgc3VwcGxpZWQgbWF0cml4IGBtYCBpbnRvIHRoaXNcbiAgICogbWF0cml4J3MgdHJhbnNsYXRpb24gY29tcG9uZW50LlxuICAgKiBAbWV0aG9kIGNvcHlQb3NpdGlvblxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBjb3B5UG9zaXRpb24obSkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG4gICAgdGVbMTJdID0gbWVbMTJdO1xuICAgIHRlWzEzXSA9IG1lWzEzXTtcbiAgICB0ZVsxNF0gPSBtZVsxNF07XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIFtiYXNpc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzaXNfKGxpbmVhcl9hbGdlYnJhKSlcbiAgICogb2YgdGhpcyBtYXRyaXggaW50byB0aGUgdGhyZWUgYXhpcyB2ZWN0b3JzIHByb3ZpZGVkLiBJZiB0aGlzIG1hdHJpeCBpczpcbiAgICogYGBgXG4gICAqIGEgYiBjIGRcbiAgICogZSBmIGcgaFxuICAgKiBpIGogayBsXG4gICAqIG0gbiBvIHBcbiAgICogYGBgXG4gICAqIHRoZW4gdGhlIGB4QXhpc2AsIGB5QXhpc2AsIGB6QXhpc2Agd2lsbCBiZSBzZXQgdG86XG4gICAqIGBgYFxuICAgKiB4QXhpcyA9IChhLCBlLCBpKVxuICAgKiB5QXhpcyA9IChkLCBmLCBqKVxuICAgKiB6QXhpcyA9IChjLCBnLCBrKVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBleHRyYWN0QmFzaXNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30geEF4aXNcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB5QXhpc1xuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHpBeGlzXG4gICAqL1xuICBleHRyYWN0QmFzaXMoeEF4aXMsIHlBeGlzLCB6QXhpcykge1xuICAgIHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMCk7XG4gICAgeUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAxKTtcbiAgICB6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRoZVxuICAgKiBbYmFzaXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2lzXyhsaW5lYXJfYWxnZWJyYSkpIG1hdHJpeFxuICAgKiBjb25zaXN0aW5nIG9mIHRoZSB0aHJlZSBwcm92aWRlZCBiYXNpcyB2ZWN0b3JzOlxuICAgKiBgYGBcbiAgICogeEF4aXMueCAgeUF4aXMueCAgekF4aXMueCAgMFxuICAgKiB4QXhpcy55ICB5QXhpcy55ICB6QXhpcy55ICAwXG4gICAqIHhBeGlzLnogIHlBeGlzLnogIHpBeGlzLnogIDBcbiAgICogICAgMCAgICAgICAgMCAgICAgICAgMCAgICAgMFxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlQmFzaXNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30geEF4aXNcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB5QXhpc1xuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHpBeGlzXG4gICAqL1xuICBtYWtlQmFzaXMoeEF4aXMsIHlBeGlzLCB6QXhpcykge1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG4gICAgICB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuICAgICAgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgcm90YXRpb24gY29tcG9uZW50IG9mIHRoZSBzdXBwbGllZCBtYXRyaXggYG1gIGludG8gdGhpc1xuICAgKiBtYXRyaXgncyByb3RhdGlvbiBjb21wb25lbnQuXG4gICAqIEBtZXRob2QgZXh0cmFjdFJvdGF0aW9uXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIGV4dHJhY3RSb3RhdGlvbihtKSB7XG4gICAgaWYgKHR5cGVvZiBleHRyYWN0Um90YXRpb25WID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZXh0cmFjdFJvdGF0aW9uViA9IG5ldyBWZWN0b3IzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IG1lID0gbS5lbGVtZW50cztcbiAgICBjb25zdCBzY2FsZVggPSAxIC8gZXh0cmFjdFJvdGF0aW9uVi5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDApLmxlbmd0aCgpO1xuICAgIGNvbnN0IHNjYWxlWSA9IDEgLyBleHRyYWN0Um90YXRpb25WLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMSkubGVuZ3RoKCk7XG4gICAgY29uc3Qgc2NhbGVaID0gMSAvIGV4dHJhY3RSb3RhdGlvblYuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcblxuICAgIHRlWzBdID0gbWVbMF0gKiBzY2FsZVg7XG4gICAgdGVbMV0gPSBtZVsxXSAqIHNjYWxlWDtcbiAgICB0ZVsyXSA9IG1lWzJdICogc2NhbGVYO1xuXG4gICAgdGVbNF0gPSBtZVs0XSAqIHNjYWxlWTtcbiAgICB0ZVs1XSA9IG1lWzVdICogc2NhbGVZO1xuICAgIHRlWzZdID0gbWVbNl0gKiBzY2FsZVk7XG5cbiAgICB0ZVs4XSA9IG1lWzhdICogc2NhbGVaO1xuICAgIHRlWzldID0gbWVbOV0gKiBzY2FsZVo7XG4gICAgdGVbMTBdID0gbWVbMTBdICogc2NhbGVaO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcm90YXRpb24gY29tcG9uZW50ICh0aGUgdXBwZXIgbGVmdCAzeDMgbWF0cml4KSBvZiB0aGlzIG1hdHJpeCB0b1xuICAgKiB0aGUgb3JpZW50YXRpb24gc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiB7QGxpbmsgRXVsZXJ9IGFuZ2xlLiBUaGUgcmVzdCBvZiB0aGVcbiAgICogbWF0cml4IGlzIHNldCB0byB0aGUgaWRlbnRpdHkuIERlcGVuZGluZyBvbiB0aGUge0BsaW5rIEV1bGVyI29yZGVyfSBvZiB0aGVcbiAgICogYGV1bGVyYCwgdGhlcmUgYXJlIHNpeCBwb3NzaWJsZSBvdXRjb21lcy4gU2VlXG4gICAqIFt0aGlzIHBhZ2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1bGVyX2FuZ2xlcyNSb3RhdGlvbl9tYXRyaXgpXG4gICAqIGZvciBhIGNvbXBsZXRlIGxpc3QuXG4gICAqIEBtZXRob2QgbWFrZVJvdGF0aW9uRnJvbUV1bGVyXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtFdWxlcn0gZXVsZXJcbiAgICovXG4gIG1ha2VSb3RhdGlvbkZyb21FdWxlcihldWxlcikge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCB7IHgsIHksIHosIG9yZGVyIH0gPSBldWxlcjtcbiAgICBjb25zdCBjeCA9IE1hdGguY29zKHgpO1xuICAgIGNvbnN0IHN4ID0gTWF0aC5zaW4oeCk7XG4gICAgY29uc3QgY3kgPSBNYXRoLmNvcyh5KTtcbiAgICBjb25zdCBzeSA9IE1hdGguc2luKHkpO1xuICAgIGNvbnN0IGN6ID0gTWF0aC5jb3Moeik7XG4gICAgY29uc3Qgc3ogPSBNYXRoLnNpbih6KTtcblxuICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcbiAgICAgIHRlWzBdID0gY3kgKiBjejtcbiAgICAgIHRlWzRdID0gLWN5ICogc3o7XG4gICAgICB0ZVs4XSA9IHN5O1xuXG4gICAgICB0ZVsxXSA9IChjeCAqIHN6KSArIChzeCAqIGN6ICogc3kpO1xuICAgICAgdGVbNV0gPSAoY3ggKiBjeikgLSAoc3ggKiBzeiAqIHN5KTtcbiAgICAgIHRlWzldID0gLXN4ICogY3k7XG5cbiAgICAgIHRlWzJdID0gKHN4ICogc3opIC0gKGN4ICogY3ogKiBzeSk7XG4gICAgICB0ZVs2XSA9IChzeCAqIGN6KSArIChjeCAqIHN6ICogc3kpO1xuICAgICAgdGVbMTBdID0gY3ggKiBjeTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgdGVbMF0gPSAoY3kgKiBjeikgKyAoc3kgKiBzeiAqIHN4KTtcbiAgICAgIHRlWzRdID0gKHN5ICogY3ogKiBzeCkgLSAoY3kgKiBzeik7XG4gICAgICB0ZVs4XSA9IGN4ICogc3k7XG5cbiAgICAgIHRlWzFdID0gY3ggKiBzejtcbiAgICAgIHRlWzVdID0gY3ggKiBjejtcbiAgICAgIHRlWzldID0gLXN4O1xuXG4gICAgICB0ZVsyXSA9IChjeSAqIHN6ICogc3gpIC0gKHN5ICogY3opO1xuICAgICAgdGVbNl0gPSAoc3kgKiBzeikgKyAoY3kgKiBjeiAqIHN4KTtcbiAgICAgIHRlWzEwXSA9IGN4ICogY3k7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pYWScpIHtcbiAgICAgIHRlWzBdID0gKGN5ICogY3opIC0gKHN5ICogc3ogKiBzeCk7XG4gICAgICB0ZVs0XSA9IC1jeCAqIHN6O1xuICAgICAgdGVbOF0gPSAoc3kgKiBjeikgKyAoY3kgKiBzeiAqIHN4KTtcblxuICAgICAgdGVbMV0gPSAoY3kgKiBzeikgKyAoc3kgKiBjeiAqIHN4KTtcbiAgICAgIHRlWzVdID0gY3ggKiBjejtcbiAgICAgIHRlWzldID0gKHN5ICogc3opIC0gKGN5ICogY3ogKiBzeCk7XG5cbiAgICAgIHRlWzJdID0gLWN4ICogc3k7XG4gICAgICB0ZVs2XSA9IHN4O1xuICAgICAgdGVbMTBdID0gY3ggKiBjeTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuICAgICAgdGVbMF0gPSBjeSAqIGN6O1xuICAgICAgdGVbNF0gPSAoc3ggKiBjeiAqIHN5KSAtIChjeCAqIHN6KTtcbiAgICAgIHRlWzhdID0gKGN4ICogY3ogKiBzeSkgKyAoc3ggKiBzeik7XG5cbiAgICAgIHRlWzFdID0gY3kgKiBzejtcbiAgICAgIHRlWzVdID0gKHN4ICogc3ogKiBzeSkgKyAoY3ggKiBjeik7XG4gICAgICB0ZVs5XSA9IChjeCAqIHN6ICogc3kpIC0gKHN4ICogY3opO1xuXG4gICAgICB0ZVsyXSA9IC1zeTtcbiAgICAgIHRlWzZdID0gc3ggKiBjeTtcbiAgICAgIHRlWzEwXSA9IGN4ICogY3k7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1laWCcpIHtcbiAgICAgIHRlWzBdID0gY3kgKiBjejtcbiAgICAgIHRlWzRdID0gKHN4ICogc3kpIC0gKGN4ICogY3kgKiBzeik7XG4gICAgICB0ZVs4XSA9IChzeCAqIGN5ICogc3opICsgKGN4ICogc3kpO1xuXG4gICAgICB0ZVsxXSA9IHN6O1xuICAgICAgdGVbNV0gPSBjeCAqIGN6O1xuICAgICAgdGVbOV0gPSAtc3ggKiBjejtcblxuICAgICAgdGVbMl0gPSAtc3kgKiBjejtcbiAgICAgIHRlWzZdID0gKGN4ICogc3kgKiBzeikgKyAoc3ggKiBjeSk7XG4gICAgICB0ZVsxMF0gPSAoY3ggKiBjeSkgLSAoc3ggKiBzeSAqIHN6KTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykge1xuICAgICAgdGVbMF0gPSBjeSAqIGN6O1xuICAgICAgdGVbNF0gPSAtc3o7XG4gICAgICB0ZVs4XSA9IHN5ICogY3o7XG5cbiAgICAgIHRlWzFdID0gKGN4ICogY3kgKiBzeikgKyAoc3ggKiBzeSk7XG4gICAgICB0ZVs1XSA9IGN4ICogY3o7XG4gICAgICB0ZVs5XSA9IChjeCAqIHN5ICogc3opIC0gKHN4ICogY3kpO1xuXG4gICAgICB0ZVsyXSA9IChzeCAqIGN5ICogc3opIC0gKGN4ICogc3kpO1xuICAgICAgdGVbNl0gPSBzeCAqIGN6O1xuICAgICAgdGVbMTBdID0gKHN4ICogc3kgKiBzeikgKyAoY3ggKiBjeSk7XG4gICAgfVxuXG4gICAgLy8gbGFzdCBjb2x1bW5cbiAgICB0ZVszXSA9IDA7XG4gICAgdGVbN10gPSAwO1xuICAgIHRlWzExXSA9IDA7XG5cbiAgICAvLyBib3R0b20gcm93XG4gICAgdGVbMTJdID0gMDtcbiAgICB0ZVsxM10gPSAwO1xuICAgIHRlWzE0XSA9IDA7XG4gICAgdGVbMTVdID0gMTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByb3RhdGlvbiBjb21wb25lbnQgb2YgdGhpcyBtYXRyaXggdG8gdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBieVxuICAgKiBgcWAsIGFzIG91dGxpbmVkXG4gICAqIFtoZXJlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXgjUXVhdGVybmlvbikuIFRoZSByZXN0XG4gICAqIG9mIHRoZSBtYXRyaXggaXMgc2V0IHRvIHRoZSBpZGVudGl0eS4gU28sIGdpdmVuIGBxID0gdyArIHhpICsgeWogKyB6a2AsXG4gICAqIHRoZSByZXN1bHRpbmcgbWF0cml4IHdpbGwgYmU6XG4gICAqIDxwcmUgY2xhc3M9XCJjb2RlIHByZXR0eXByaW50IHByZXR0eXByaW50ZWRcIiBzdHlsZT1cIlwiPjxjb2RlPjxzcGFuIGNsYXNzPVwibGl0XCI+MTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ5PHN1cD4yPC9zdXA+PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mno8c3VwPjI8L3N1cD48L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ4eTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ6dzwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeHo8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeXc8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjA8L3NwYW4+XG4gICAqIDxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ4eTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4rPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ6dzwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjE8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeDxzdXA+Mjwvc3VwPjwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ6PHN1cD4yPC9zdXA+PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeXo8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeHc8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjA8L3NwYW4+XG4gICAqIDxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ4ejwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ5dzwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnl6PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPis8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnh3PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4xPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mng8c3VwPjI8L3N1cD48L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeTxzdXA+Mjwvc3VwPjwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjA8L3NwYW4+XG4gICAqIDxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICAgICAgICAgICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgICAgICAgICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+MTwvc3Bhbj48L2NvZGU+PC9wcmU+XG4gICAqIEBtZXRob2QgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb25cbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxuICAgKi9cbiAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSkge1xuICAgIGNvbnN0IHsgeCwgeSwgeiwgdyB9ID0gcTtcbiAgICBjb25zdCB4MiA9IHggKyB4O1xuICAgIGNvbnN0IHkyID0geSArIHk7XG4gICAgY29uc3QgejIgPSB6ICsgejtcbiAgICBjb25zdCB4eCA9IHggKiB4MjtcbiAgICBjb25zdCB4eSA9IHggKiB5MjtcbiAgICBjb25zdCB4eiA9IHggKiB6MjtcbiAgICBjb25zdCB5eSA9IHkgKiB5MjtcbiAgICBjb25zdCB5eiA9IHkgKiB6MjtcbiAgICBjb25zdCB6eiA9IHogKiB6MjtcbiAgICBjb25zdCB3eCA9IHcgKiB4MjtcbiAgICBjb25zdCB3eSA9IHcgKiB5MjtcbiAgICBjb25zdCB3eiA9IHcgKiB6MjtcblxuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDEgLSAoeXkgKyB6eiksIHh5IC0gd3osIHh6ICsgd3ksIDAsXG4gICAgICB4eSArIHd6LCAxIC0gKHh4ICsgenopLCB5eiAtIHd4LCAwLFxuICAgICAgeHogLSB3eSwgeXogKyB3eCwgMSAtICh4eCArIHl5KSwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgcm90YXRpb24gbWF0cml4LCBsb29raW5nIGZyb20gYGV5ZWAgdG93YXJkcyBgdGFyZ2V0YCBvcmllbnRlZFxuICAgKiBieSB0aGUgYHVwYCB2ZWN0b3IuXG4gICAqIEBtZXRob2QgbG9va0F0XG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSBleWVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gdGFyZ2V0XG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHVwXG4gICAqL1xuICBsb29rQXQoZXllLCB0YXJnZXQsIHVwKSB7XG4gICAgaWYgKHR5cGVvZiBsb29rQXRYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9va0F0WCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb29rQXRZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9va0F0WSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb29rQXRaID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9va0F0WiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxvb2tBdFouc3ViVmVjdG9ycyhleWUsIHRhcmdldCk7XG5cbiAgICBpZiAobG9va0F0Wi5sZW5ndGhTcSgpID09PSAwKSB7XG4gICAgICBsb29rQXRaLl96ID0gMTtcbiAgICB9XG5cbiAgICBsb29rQXRaLm5vcm1hbGl6ZSgpO1xuICAgIGxvb2tBdFguY3Jvc3NWZWN0b3JzKHVwLCBsb29rQXRaKTtcblxuICAgIGlmIChsb29rQXRYLmxlbmd0aFNxKCkgPT09IDApIHtcbiAgICAgIGxvb2tBdFouX3ogKz0gMC4wMDAxO1xuICAgICAgbG9va0F0WC5jcm9zc1ZlY3RvcnModXAsIGxvb2tBdFopO1xuICAgIH1cblxuICAgIGxvb2tBdFgubm9ybWFsaXplKCk7XG4gICAgbG9va0F0WS5jcm9zc1ZlY3RvcnMobG9va0F0WiwgbG9va0F0WCk7XG5cbiAgICB0ZVswXSA9IGxvb2tBdFguX3g7XG4gICAgdGVbNF0gPSBsb29rQXRZLl94O1xuICAgIHRlWzhdID0gbG9va0F0Wi5feDtcbiAgICB0ZVsxXSA9IGxvb2tBdFguX3k7XG4gICAgdGVbNV0gPSBsb29rQXRZLl95O1xuICAgIHRlWzldID0gbG9va0F0Wi5feTtcbiAgICB0ZVsyXSA9IGxvb2tBdFguX3o7XG4gICAgdGVbNl0gPSBsb29rQXRZLl96O1xuICAgIHRlWzEwXSA9IGxvb2tBdFouX3o7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3N0LW11bHRpcGxpZXMgdGhpcyBtYXRyaXggYnkgYG1gLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIG11bHRpcGx5KG0pIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIG0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZS1tdWx0aXBsaWVzIHRoaXMgbWF0cml4IGJ5IGBtYC5cbiAgICogQG1ldGhvZCBwcmVtdWx0aXBseVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBwcmVtdWx0aXBseShtKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyhtLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IHRvIGBhIMOXIGJgLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5TWF0cmljZXNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gYVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IGJcbiAgICovXG4gIG11bHRpcGx5TWF0cmljZXMoYSwgYikge1xuICAgIGNvbnN0IGFlID0gYS5lbGVtZW50cztcbiAgICBjb25zdCBiZSA9IGIuZWxlbWVudHM7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgY29uc3QgW1xuICAgICAgYTExLCBhMjEsIGEzMSwgYTQxLFxuICAgICAgYTEyLCBhMjIsIGEzMiwgYTQyLFxuICAgICAgYTEzLCBhMjMsIGEzMywgYTQzLFxuICAgICAgYTE0LCBhMjQsIGEzNCwgYTQ0LFxuICAgIF0gPSBhZTtcblxuICAgIGNvbnN0IFtcbiAgICAgIGIxMSwgYjIxLCBiMzEsIGI0MSxcbiAgICAgIGIxMiwgYjIyLCBiMzIsIGI0MixcbiAgICAgIGIxMywgYjIzLCBiMzMsIGI0MyxcbiAgICAgIGIxNCwgYjI0LCBiMzQsIGI0NCxcbiAgICBdID0gYmU7XG5cbiAgICB0ZVswXSA9IChhMTEgKiBiMTEpICsgKGExMiAqIGIyMSkgKyAoYTEzICogYjMxKSArIChhMTQgKiBiNDEpO1xuICAgIHRlWzRdID0gKGExMSAqIGIxMikgKyAoYTEyICogYjIyKSArIChhMTMgKiBiMzIpICsgKGExNCAqIGI0Mik7XG4gICAgdGVbOF0gPSAoYTExICogYjEzKSArIChhMTIgKiBiMjMpICsgKGExMyAqIGIzMykgKyAoYTE0ICogYjQzKTtcbiAgICB0ZVsxMl0gPSAoYTExICogYjE0KSArIChhMTIgKiBiMjQpICsgKGExMyAqIGIzNCkgKyAoYTE0ICogYjQ0KTtcbiAgICB0ZVsxXSA9IChhMjEgKiBiMTEpICsgKGEyMiAqIGIyMSkgKyAoYTIzICogYjMxKSArIChhMjQgKiBiNDEpO1xuICAgIHRlWzVdID0gKGEyMSAqIGIxMikgKyAoYTIyICogYjIyKSArIChhMjMgKiBiMzIpICsgKGEyNCAqIGI0Mik7XG4gICAgdGVbOV0gPSAoYTIxICogYjEzKSArIChhMjIgKiBiMjMpICsgKGEyMyAqIGIzMykgKyAoYTI0ICogYjQzKTtcbiAgICB0ZVsxM10gPSAoYTIxICogYjE0KSArIChhMjIgKiBiMjQpICsgKGEyMyAqIGIzNCkgKyAoYTI0ICogYjQ0KTtcbiAgICB0ZVsyXSA9IChhMzEgKiBiMTEpICsgKGEzMiAqIGIyMSkgKyAoYTMzICogYjMxKSArIChhMzQgKiBiNDEpO1xuICAgIHRlWzZdID0gKGEzMSAqIGIxMikgKyAoYTMyICogYjIyKSArIChhMzMgKiBiMzIpICsgKGEzNCAqIGI0Mik7XG4gICAgdGVbMTBdID0gKGEzMSAqIGIxMykgKyAoYTMyICogYjIzKSArIChhMzMgKiBiMzMpICsgKGEzNCAqIGI0Myk7XG4gICAgdGVbMTRdID0gKGEzMSAqIGIxNCkgKyAoYTMyICogYjI0KSArIChhMzMgKiBiMzQpICsgKGEzNCAqIGI0NCk7XG4gICAgdGVbM10gPSAoYTQxICogYjExKSArIChhNDIgKiBiMjEpICsgKGE0MyAqIGIzMSkgKyAoYTQ0ICogYjQxKTtcbiAgICB0ZVs3XSA9IChhNDEgKiBiMTIpICsgKGE0MiAqIGIyMikgKyAoYTQzICogYjMyKSArIChhNDQgKiBiNDIpO1xuICAgIHRlWzExXSA9IChhNDEgKiBiMTMpICsgKGE0MiAqIGIyMykgKyAoYTQzICogYjMzKSArIChhNDQgKiBiNDMpO1xuICAgIHRlWzE1XSA9IChhNDEgKiBiMTQpICsgKGE0MiAqIGIyNCkgKyAoYTQzICogYjM0KSArIChhNDQgKiBiNDQpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgZXZlcnkgY29tcG9uZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIgdmFsdWUgYHNgLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5U2NhbGFyXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHNcbiAgICovXG4gIG11bHRpcGx5U2NhbGFyKHMpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZVtpXSAqPSBzO1xuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZVxuICAgKiBbZGV0ZXJtaW5hbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50KSBvZiB0aGlzIG1hdHJpeC5cbiAgICogQmFzZWQgb24gdGhlIG1ldGhvZCBvdXRsaW5lZFxuICAgKiBbaGVyZV0oaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtKS5cbiAgICogQG1ldGhvZCBkZXRlcm1pbmFudFxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgY29uc3QgW1xuICAgICAgbjExLCBuMjEsIG4zMSwgbjQxLFxuICAgICAgbjEyLCBuMjIsIG4zMiwgbjQyLFxuICAgICAgbjEzLCBuMjMsIG4zMywgbjQzLFxuICAgICAgbjE0LCBuMjQsIG4zNCwgbjQ0LFxuICAgIF0gPSB0ZTtcblxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuICAgIC8vICggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcbiAgICBjb25zdCBhID0gKG4xNCAqIG4yMyAqIG4zMikgLSAobjEzICogbjI0ICogbjMyKSAtIChuMTQgKiBuMjIgKiBuMzMpXG4gICAgICArIChuMTIgKiBuMjQgKiBuMzMpICsgKG4xMyAqIG4yMiAqIG4zNCkgLSAobjEyICogbjIzICogbjM0KTtcbiAgICBjb25zdCBiID0gKG4xMSAqIG4yMyAqIG4zNCkgLSAobjExICogbjI0ICogbjMzKSArIChuMTQgKiBuMjEgKiBuMzMpXG4gICAgICAtIChuMTMgKiBuMjEgKiBuMzQpICsgKG4xMyAqIG4yNCAqIG4zMSkgLSAobjE0ICogbjIzICogbjMxKTtcbiAgICBjb25zdCBjID0gKG4xMSAqIG4yNCAqIG4zMikgLSAobjExICogbjIyICogbjM0KSAtIChuMTQgKiBuMjEgKiBuMzIpXG4gICAgICArIChuMTIgKiBuMjEgKiBuMzQpICsgKG4xNCAqIG4yMiAqIG4zMSkgLSAobjEyICogbjI0ICogbjMxKTtcbiAgICBjb25zdCBkID0gKC1uMTMgKiBuMjIgKiBuMzEpIC0gKG4xMSAqIG4yMyAqIG4zMikgKyAobjExICogbjIyICogbjMzKVxuICAgICAgKyAobjEzICogbjIxICogbjMyKSAtIChuMTIgKiBuMjEgKiBuMzMpICsgKG4xMiAqIG4yMyAqIG4zMSk7XG5cbiAgICByZXR1cm4gKG40MSAqIGEpICsgKG40MiAqIGIpICsgKG40MyAqIGMpICsgKG40NCAqIGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtUcmFuc3Bvc2VzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3Bvc2UpIHRoaXMgbWF0cml4LlxuICAgKiBAbWV0aG9kIHRyYW5zcG9zZVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICovXG4gIHRyYW5zcG9zZSgpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IHRtcDtcblxuICAgIHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuICAgIHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuICAgIHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuICAgIHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBjb21wb25lbnQgZm9yIHRoaXMgbWF0cml4IGZyb20gdmVjdG9yIGB2YCwgd2l0aG91dFxuICAgKiBhZmZlY3RpbmcgdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeCAtIGkuZS4gaWYgdGhlIG1hdHJpeCBpcyBjdXJyZW50bHk6XG4gICAqIGBgYFxuICAgKiBhICBiICBjICBkXG4gICAqIGUgIGYgIGcgIGhcbiAgICogaSAgaiAgayAgbFxuICAgKiBtICBuICBvICBwXG4gICAqIGBgYFxuICAgKiB0aGlzIGJlY29tZXM6XG4gICAqIGBgYFxuICAgKiBhICBiICBjIHYueFxuICAgKiBlICBmICBnIHYueVxuICAgKiBpICBqICBrIHYuelxuICAgKiBtICBuICBvICBwXG4gICAqIGBgYFxuICAgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIHNldFBvc2l0aW9uKHYpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgdGVbMTJdID0gdi54O1xuICAgIHRlWzEzXSA9IHYueTtcbiAgICB0ZVsxNF0gPSB2Lno7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCB0byB0aGVcbiAgICogW2ludmVyc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludmVydGlibGVfbWF0cml4KSBvZiB0aGUgcGFzc2VkXG4gICAqIG1hdHJpeCBgbWAsIHVzaW5nIHRoZSBtZXRob2Qgb3V0bGluZWRcbiAgICogW2hlcmVdKGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSkuXG4gICAqIElmIGB0aHJvd09uRGVnZW5lcmF0ZWAgaXMgbm90IHNldCBhbmQgdGhlIG1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZSwgc2V0c1xuICAgKiB0aGlzIHRvIHRoZSA0eDQgaWRlbnRpdHkgbWF0cml4LlxuICAgKiBAbWV0aG9kIGdldEludmVyc2VcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbSBUaGUgbWF0cml4IHRvIHRha2UgdGhlIGludmVyc2Ugb2YuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rocm93T25EZWdlbmVyYXRlPWZhbHNlXSBJZiB0cnVlLCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgbWF0cml4IGlzIGRlZ2VuZXJhdGUgKG5vdCBpbnZlcnRpYmxlKS5cbiAgICovXG4gIGdldEludmVyc2UobSwgdGhyb3dPbkRlZ2VuZXJhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICBjb25zdCBbXG4gICAgICBuMTEsIG4yMSwgbjMxLCBuNDEsXG4gICAgICBuMTIsIG4yMiwgbjMyLCBuNDIsXG4gICAgICBuMTMsIG4yMywgbjMzLCBuNDMsXG4gICAgICBuMTQsIG4yNCwgbjM0LCBuNDQsXG4gICAgXSA9IG1lO1xuXG4gICAgY29uc3QgdDExID0gKG4yMyAqIG4zNCAqIG40MikgLSAobjI0ICogbjMzICogbjQyKSArIChuMjQgKiBuMzIgKiBuNDMpXG4gICAgICAtIChuMjIgKiBuMzQgKiBuNDMpIC0gKG4yMyAqIG4zMiAqIG40NCkgKyAobjIyICogbjMzICogbjQ0KTtcbiAgICBjb25zdCB0MTIgPSAobjE0ICogbjMzICogbjQyKSAtIChuMTMgKiBuMzQgKiBuNDIpIC0gKG4xNCAqIG4zMiAqIG40MylcbiAgICAgICsgKG4xMiAqIG4zNCAqIG40MykgKyAobjEzICogbjMyICogbjQ0KSAtIChuMTIgKiBuMzMgKiBuNDQpO1xuICAgIGNvbnN0IHQxMyA9IChuMTMgKiBuMjQgKiBuNDIpIC0gKG4xNCAqIG4yMyAqIG40MikgKyAobjE0ICogbjIyICogbjQzKVxuICAgICAgLSAobjEyICogbjI0ICogbjQzKSAtIChuMTMgKiBuMjIgKiBuNDQpICsgKG4xMiAqIG4yMyAqIG40NCk7XG4gICAgY29uc3QgdDE0ID0gKG4xNCAqIG4yMyAqIG4zMikgLSAobjEzICogbjI0ICogbjMyKSAtIChuMTQgKiBuMjIgKiBuMzMpXG4gICAgICArIChuMTIgKiBuMjQgKiBuMzMpICsgKG4xMyAqIG4yMiAqIG4zNCkgLSAobjEyICogbjIzICogbjM0KTtcblxuICAgIGNvbnN0IGRldCA9IChuMTEgKiB0MTEpICsgKG4yMSAqIHQxMikgKyAobjMxICogdDEzKSArIChuNDEgKiB0MTQpO1xuXG4gICAgaWYgKGRldCA9PT0gMCkge1xuICAgICAgY29uc3QgbXNnID0gJ01hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW5cXCd0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDAnO1xuXG4gICAgICBpZiAodGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRldEludiA9IDEgLyBkZXQ7XG5cbiAgICB0ZVswXSA9IHQxMSAqIGRldEludjtcbiAgICB0ZVsxXSA9ICgobjI0ICogbjMzICogbjQxKSAtIChuMjMgKiBuMzQgKiBuNDEpIC0gKG4yNCAqIG4zMSAqIG40MylcbiAgICAgICsgKG4yMSAqIG4zNCAqIG40MykgKyAobjIzICogbjMxICogbjQ0KSAtIChuMjEgKiBuMzMgKiBuNDQpKSAqIGRldEludjtcbiAgICB0ZVsyXSA9ICgobjIyICogbjM0ICogbjQxKSAtIChuMjQgKiBuMzIgKiBuNDEpICsgKG4yNCAqIG4zMSAqIG40MilcbiAgICAgIC0gKG4yMSAqIG4zNCAqIG40MikgLSAobjIyICogbjMxICogbjQ0KSArIChuMjEgKiBuMzIgKiBuNDQpKSAqIGRldEludjtcbiAgICB0ZVszXSA9ICgobjIzICogbjMyICogbjQxKSAtIChuMjIgKiBuMzMgKiBuNDEpIC0gKG4yMyAqIG4zMSAqIG40MilcbiAgICAgICsgKG4yMSAqIG4zMyAqIG40MikgKyAobjIyICogbjMxICogbjQzKSAtIChuMjEgKiBuMzIgKiBuNDMpKSAqIGRldEludjtcblxuICAgIHRlWzRdID0gdDEyICogZGV0SW52O1xuICAgIHRlWzVdID0gKChuMTMgKiBuMzQgKiBuNDEpIC0gKG4xNCAqIG4zMyAqIG40MSkgKyAobjE0ICogbjMxICogbjQzKVxuICAgICAgLSAobjExICogbjM0ICogbjQzKSAtIChuMTMgKiBuMzEgKiBuNDQpICsgKG4xMSAqIG4zMyAqIG40NCkpICogZGV0SW52O1xuICAgIHRlWzZdID0gKChuMTQgKiBuMzIgKiBuNDEpIC0gKG4xMiAqIG4zNCAqIG40MSkgLSAobjE0ICogbjMxICogbjQyKVxuICAgICAgKyAobjExICogbjM0ICogbjQyKSArIChuMTIgKiBuMzEgKiBuNDQpIC0gKG4xMSAqIG4zMiAqIG40NCkpICogZGV0SW52O1xuICAgIHRlWzddID0gKChuMTIgKiBuMzMgKiBuNDEpIC0gKG4xMyAqIG4zMiAqIG40MSkgKyAobjEzICogbjMxICogbjQyKVxuICAgICAgLSAobjExICogbjMzICogbjQyKSAtIChuMTIgKiBuMzEgKiBuNDMpICsgKG4xMSAqIG4zMiAqIG40MykpICogZGV0SW52O1xuXG4gICAgdGVbOF0gPSB0MTMgKiBkZXRJbnY7XG4gICAgdGVbOV0gPSAoKG4xNCAqIG4yMyAqIG40MSkgLSAobjEzICogbjI0ICogbjQxKSAtIChuMTQgKiBuMjEgKiBuNDMpXG4gICAgICArIChuMTEgKiBuMjQgKiBuNDMpICsgKG4xMyAqIG4yMSAqIG40NCkgLSAobjExICogbjIzICogbjQ0KSkgKiBkZXRJbnY7XG4gICAgdGVbMTBdID0gKChuMTIgKiBuMjQgKiBuNDEpIC0gKG4xNCAqIG4yMiAqIG40MSkgKyAobjE0ICogbjIxICogbjQyKVxuICAgICAgLSAobjExICogbjI0ICogbjQyKSAtIChuMTIgKiBuMjEgKiBuNDQpICsgKG4xMSAqIG4yMiAqIG40NCkpICogZGV0SW52O1xuICAgIHRlWzExXSA9ICgobjEzICogbjIyICogbjQxKSAtIChuMTIgKiBuMjMgKiBuNDEpIC0gKG4xMyAqIG4yMSAqIG40MilcbiAgICAgICsgKG4xMSAqIG4yMyAqIG40MikgKyAobjEyICogbjIxICogbjQzKSAtIChuMTEgKiBuMjIgKiBuNDMpKSAqIGRldEludjtcblxuICAgIHRlWzEyXSA9IHQxNCAqIGRldEludjtcbiAgICB0ZVsxM10gPSAoKG4xMyAqIG4yNCAqIG4zMSkgLSAobjE0ICogbjIzICogbjMxKSArIChuMTQgKiBuMjEgKiBuMzMpXG4gICAgICAtIChuMTEgKiBuMjQgKiBuMzMpIC0gKG4xMyAqIG4yMSAqIG4zNCkgKyAobjExICogbjIzICogbjM0KSkgKiBkZXRJbnY7XG4gICAgdGVbMTRdID0gKChuMTQgKiBuMjIgKiBuMzEpIC0gKG4xMiAqIG4yNCAqIG4zMSkgLSAobjE0ICogbjIxICogbjMyKVxuICAgICAgKyAobjExICogbjI0ICogbjMyKSArIChuMTIgKiBuMjEgKiBuMzQpIC0gKG4xMSAqIG4yMiAqIG4zNCkpICogZGV0SW52O1xuICAgIHRlWzE1XSA9ICgobjEyICogbjIzICogbjMxKSAtIChuMTMgKiBuMjIgKiBuMzEpICsgKG4xMyAqIG4yMSAqIG4zMilcbiAgICAgIC0gKG4xMSAqIG4yMyAqIG4zMikgLSAobjEyICogbjIxICogbjMzKSArIChuMTEgKiBuMjIgKiBuMzMpKSAqIGRldEludjtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhlIGNvbHVtbnMgb2YgdGhpcyBtYXRyaXggYnkgdmVjdG9yIGB2YC5cbiAgICogQG1ldGhvZCBzY2FsZVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBzY2FsZSh2KSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdjtcbiAgICB0ZVswXSAqPSB4O1xuICAgIHRlWzRdICo9IHk7XG4gICAgdGVbOF0gKj0gejtcbiAgICB0ZVsxXSAqPSB4O1xuICAgIHRlWzVdICo9IHk7XG4gICAgdGVbOV0gKj0gejtcbiAgICB0ZVsyXSAqPSB4O1xuICAgIHRlWzZdICo9IHk7XG4gICAgdGVbMTBdICo9IHo7XG4gICAgdGVbM10gKj0geDtcbiAgICB0ZVs3XSAqPSB5O1xuICAgIHRlWzExXSAqPSB6O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1heGltdW0gc2NhbGUgdmFsdWUgb2YgdGhlIDMgYXhlcy5cbiAgICogQG1ldGhvZCBnZXRNYXhTY2FsZU9uQXhpc1xuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TWF4U2NhbGVPbkF4aXMoKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHNjYWxlWFNxID0gKHRlWzBdICogdGVbMF0pICsgKHRlWzFdICogdGVbMV0pICsgKHRlWzJdICogdGVbMl0pO1xuICAgIGNvbnN0IHNjYWxlWVNxID0gKHRlWzRdICogdGVbNF0pICsgKHRlWzVdICogdGVbNV0pICsgKHRlWzZdICogdGVbNl0pO1xuICAgIGNvbnN0IHNjYWxlWlNxID0gKHRlWzhdICogdGVbOF0pICsgKHRlWzldICogdGVbOV0pICsgKHRlWzEwXSAqIHRlWzEwXSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heChzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHRyYW5zbGF0aW9uIHRyYW5zZm9ybTpcbiAgICogYGBgXG4gICAqIDEgIDAgIDAgIHhcbiAgICogMCAgMSAgMCAgeVxuICAgKiAwICAwICAxICB6XG4gICAqIDAgIDAgIDAgIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZVRyYW5zbGF0aW9uXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgeCBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgeSBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaGUgYW1vdW50IHRvIHRyYW5zbGF0ZSBpbiB0aGUgeiBheGlzLlxuICAgKi9cbiAgbWFrZVRyYW5zbGF0aW9uKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxLCAwLCAwLCB4LFxuICAgICAgMCwgMSwgMCwgeSxcbiAgICAgIDAsIDAsIDEsIHosXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHJvdGF0aW9uYWwgdHJhbnNmb3JtYXRpb24gYXJvdW5kIHRoZSB4IGF4aXMgYnlcbiAgICogYHRoZXRhYC4gVGhlIHJlc3VsdGluZyBtYXRyaXggd2lsbCBiZTpcbiAgICogYGBgXG4gICAqIDEgICAgMCAgICAgIDAgICAgICAwXG4gICAqIDAgIGNvcyjOuCkgLXNpbijOuCkgIDBcbiAgICogMCAgc2luKM64KSAgY29zKM64KSAgMFxuICAgKiAwICAgIDAgICAgICAwICAgICAgMVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlUm90YXRpb25YXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIG1ha2VSb3RhdGlvblgodGhldGEpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxLCAwLCAwLCAwLFxuICAgICAgMCwgYywgLXMsIDAsXG4gICAgICAwLCBzLCBjLCAwLFxuICAgICAgMCwgMCwgMCwgMSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgeSBheGlzIGJ5XG4gICAqIGB0aGV0YWAuIFRoZSByZXN1bHRpbmcgbWF0cml4IHdpbGwgYmU6XG4gICAqIGBgYFxuICAgKiAgY29zKM64KSAgMCAgc2luKM64KSAgMFxuICAgKiAgICAwICAgICAxICAgIDAgICAgIDBcbiAgICogLXNpbijOuCkgIDAgIGNvcyjOuCkgIDBcbiAgICogICAgMCAgICAgMCAgICAwICAgICAxXG4gICAqIGBgYFxuICAgKiBAbWV0aG9kIG1ha2VSb3RhdGlvbllcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aGV0YSBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgbWFrZVJvdGF0aW9uWSh0aGV0YSkge1xuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgY29uc3QgcyA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIGMsIDAsIHMsIDAsXG4gICAgICAwLCAxLCAwLCAwLFxuICAgICAgLXMsIDAsIGMsIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHJvdGF0aW9uYWwgdHJhbnNmb3JtYXRpb24gYXJvdW5kIHRoZSB6IGF4aXMgYnlcbiAgICogYHRoZXRhYC4gVGhlIHJlc3VsdGluZyBtYXRyaXggd2lsbCBiZTpcbiAgICogYGBgXG4gICAqIGNvcyjOuCkgLXNpbijOuCkgIDAgIDBcbiAgICogc2luKM64KSAgY29zKM64KSAgMCAgMFxuICAgKiAgIDAgICAgICAgMCAgICAgMSAgMFxuICAgKiAgIDAgICAgICAgMCAgICAgMCAgMVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlUm90YXRpb25aXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIG1ha2VSb3RhdGlvbloodGhldGEpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICBjLCAtcywgMCwgMCxcbiAgICAgIHMsIGMsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgcm90YXRpb24gdHJhbnNmb3JtIGFyb3VuZCBgYXhpc2AgYnkgYHRoZXRhYC4gVGhpcyBpcyBhXG4gICAqIHNvbWV3aGF0IGNvbnRyb3ZlcnNpYWwgYnV0IG1hdGhlbWF0aWNhbGx5IHNvdW5kIGFsdGVybmF0aXZlIHRvIHJvdGF0aW5nXG4gICAqIHZpYSB7QGxpbmsgUXVhdGVybmlvbn1zLiBTZWUgdGhlIGRpc2N1c3Npb25cbiAgICogW2hlcmVdKGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcCkuXG4gICAqIEBtZXRob2QgbWFrZVJvdGF0aW9uQXhpc1xuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgKi9cbiAgbWFrZVJvdGF0aW9uQXhpcyhheGlzLCBhbmdsZSkge1xuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0ID0gMSAtIGM7XG4gICAgY29uc3QgeyB4LCB5LCB6IH0gPSBheGlzO1xuICAgIGNvbnN0IHR4ID0gdCAqIHg7XG4gICAgY29uc3QgdHkgPSB0ICogeTtcblxuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgICh0eCAqIHgpICsgYywgKHR4ICogeSkgLSAocyAqIHopLCAodHggKiB6KSArIChzICogeSksIDAsXG4gICAgICAodHggKiB5KSArIChzICogeiksICh0eSAqIHkpICsgYywgKHR5ICogeikgLSAocyAqIHgpLCAwLFxuICAgICAgKHR4ICogeikgLSAocyAqIHkpLCAodHkgKiB6KSArIChzICogeCksICh0ICogeiAqIHopICsgYywgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIGEgc2NhbGUgdHJhbnNmb3JtOlxuICAgKiBgYGBcbiAgICogeCAgMCAgMCAgMFxuICAgKiAwICB5ICAwICAwXG4gICAqIDAgIDAgIHogIDBcbiAgICogMCAgMCAgMCAgMVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlU2NhbGVcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2NhbGUgaW4gdGhlIHggYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSBpbiB0aGUgeSBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaGUgYW1vdW50IHRvIHNjYWxlIGluIHRoZSB6IGF4aXMuXG4gICAqL1xuICBtYWtlU2NhbGUoeCwgeSwgeikge1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIHgsIDAsIDAsIDAsXG4gICAgICAwLCB5LCAwLCAwLFxuICAgICAgMCwgMCwgeiwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIGEgc2hlYXIgdHJhbnNmb3JtOlxuICAgKiBgYGBcbiAgICogMSAgeSAgeiAgMFxuICAgKiB4ICAxICB6ICAwXG4gICAqIHggIHkgIDEgIDBcbiAgICogMCAgMCAgMCAgMVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlU2hlYXJcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBhbW91bnQgdG8gc2hlYXIgaW4gdGhlIHggYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzaGVhciBpbiB0aGUgeSBheGlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaGUgYW1vdW50IHRvIHNoZWFyIGluIHRoZSB6IGF4aXMuXG4gICAqL1xuICBtYWtlU2hlYXIoeCwgeSwgeikge1xuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDEsIHksIHosIDAsXG4gICAgICB4LCAxLCB6LCAwLFxuICAgICAgeCwgeSwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IHRvIHRoZSB0cmFuc2Zvcm1hdGlvbiBjb21wb3NlZCBvZiBgcG9zaXRpb25gLFxuICAgKiBgcXVhdGVybmlvbmAsIGFuZCBgc2NhbGVgLiBJbnRlcm5hbGx5IHRoaXMgY2FsbHNcbiAgICoge0BsaW5rIE1hdHJpeDQjbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb259IGZvbGxvd2VkIGJ5XG4gICAqIHtAbGluayBNYXRyaXg0I3NjYWxlfSwgdGhlbiBmaW5hbGx5IHtAbGluayBNYXRyaXg0I3NldFBvc2l0aW9ufS5cbiAgICogQG1ldGhvZCBjb21wb3NlXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHNjYWxlXG4gICAqL1xuICBjb21wb3NlKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xuICAgIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gICAgdGhpcy5zY2FsZShzY2FsZSk7XG4gICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wb3NlcyB0aGlzIG1hdHJpeCBpbnRvIGl0J3MgYHBvc2l0aW9uYCwgJ3F1YXRlcm5pb24nLCBhbmQgJ3NjYWxlJ1xuICAgKiBjb21wb25lbnRzLlxuICAgKiBAbWV0aG9kIGRlY29tcG9zZVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gcG9zaXRpb25cbiAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSBzY2FsZVxuICAgKi9cbiAgZGVjb21wb3NlKHBvc2l0aW9uID0gbnVsbCwgcXVhdGVybmlvbiA9IG51bGwsIHNjYWxlID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGVjb21wb3NlViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlY29tcG9zZVYgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVjb21wb3NlTSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlY29tcG9zZU0gPSBuZXcgTWF0cml4NCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBsZXQgc3ggPSBkZWNvbXBvc2VWLnNldCh0ZVswXSwgdGVbMV0sIHRlWzJdKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeSA9IGRlY29tcG9zZVYuc2V0KHRlWzRdLCB0ZVs1XSwgdGVbNl0pLmxlbmd0aCgpO1xuICAgIGNvbnN0IHN6ID0gZGVjb21wb3NlVi5zZXQodGVbOF0sIHRlWzldLCB0ZVsxMF0pLmxlbmd0aCgpO1xuXG4gICAgLy8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgICBjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cbiAgICBpZiAoZGV0IDwgMCkge1xuICAgICAgc3ggPSAtc3g7XG4gICAgfVxuXG4gICAgcG9zaXRpb24uc2V0KHRlWzEyXSwgdGVbMTNdLCB0ZVsxNF0pO1xuXG4gICAgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcbiAgICAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG4gICAgZGVjb21wb3NlTS5jb3B5KHRoaXMpO1xuICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xuICAgIGNvbnN0IGludlNZID0gMSAvIHN5O1xuICAgIGNvbnN0IGludlNaID0gMSAvIHN6O1xuXG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1swXSAqPSBpbnZTWDtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzFdICo9IGludlNYO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbMl0gKj0gaW52U1g7XG5cbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzRdICo9IGludlNZO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbNV0gKj0gaW52U1k7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s2XSAqPSBpbnZTWTtcblxuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbOF0gKj0gaW52U1o7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s5XSAqPSBpbnZTWjtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzEwXSAqPSBpbnZTWjtcblxuICAgIHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGRlY29tcG9zZU0pO1xuICAgIHNjYWxlLnNldChzeCwgc3ksIHN6KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCBkZWNvbXBvc2VkVmFsdWUoKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIGlmICh0eXBlb2YgZGVjb21wb3NlViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlY29tcG9zZVYgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVjb21wb3NlTSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRlY29tcG9zZU0gPSBuZXcgTWF0cml4NCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBsZXQgc3ggPSBkZWNvbXBvc2VWLnNldCh0ZVswXSwgdGVbMV0sIHRlWzJdKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeSA9IGRlY29tcG9zZVYuc2V0KHRlWzRdLCB0ZVs1XSwgdGVbNl0pLmxlbmd0aCgpO1xuICAgIGNvbnN0IHN6ID0gZGVjb21wb3NlVi5zZXQodGVbOF0sIHRlWzldLCB0ZVsxMF0pLmxlbmd0aCgpO1xuXG4gICAgLy8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgICBjb25zdCBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG5cbiAgICBpZiAoZGV0IDwgMCkge1xuICAgICAgc3ggPSAtc3g7XG4gICAgfVxuXG4gICAgcG9zaXRpb24uc2V0KHRlWzEyXSwgdGVbMTNdLCB0ZVsxNF0pO1xuXG4gICAgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcbiAgICAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG4gICAgZGVjb21wb3NlTS5jb3B5KHRoaXMpO1xuICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xuICAgIGNvbnN0IGludlNZID0gMSAvIHN5O1xuICAgIGNvbnN0IGludlNaID0gMSAvIHN6O1xuXG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1swXSAqPSBpbnZTWDtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzFdICo9IGludlNYO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbMl0gKj0gaW52U1g7XG5cbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzRdICo9IGludlNZO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbNV0gKj0gaW52U1k7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s2XSAqPSBpbnZTWTtcblxuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbOF0gKj0gaW52U1o7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s5XSAqPSBpbnZTWjtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzEwXSAqPSBpbnZTWjtcblxuICAgIHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KGRlY29tcG9zZU0pO1xuICAgIHNjYWxlLnNldChzeCwgc3ksIHN6KTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgcXVhdGVybmlvbjogcXVhdGVybmlvbixcbiAgICAgIHNjYWxlOiBzY2FsZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhXG4gICAqIFtwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS8zRF9wcm9qZWN0aW9uI1BlcnNwZWN0aXZlX3Byb2plY3Rpb24pXG4gICAqIG1hdHJpeC5cbiAgICogQG1ldGhvZCBtYWtlRnJ1c3R1bVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gbmVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFyXG4gICAqL1xuICBtYWtlRnJ1c3R1bShcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbmVhcixcbiAgICBmYXIsXG4gICkge1xuICAgIGNvbnN0IHggPSAyICogbmVhciAvIChyaWdodCAtIGxlZnQpO1xuICAgIGNvbnN0IHkgPSAyICogbmVhciAvICh0b3AgLSBib3R0b20pO1xuICAgIGNvbnN0IGEgPSAocmlnaHQgKyBsZWZ0KSAvIChyaWdodCAtIGxlZnQpO1xuICAgIGNvbnN0IGIgPSAodG9wICsgYm90dG9tKSAvICggdG9wIC0gYm90dG9tICk7XG4gICAgY29uc3QgYyA9IC0oZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcik7XG4gICAgY29uc3QgZCA9IC0yICogZmFyICogbmVhciAvIChmYXIgLSBuZWFyKTtcblxuICAgIC8vICAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgLy8gICAgICAgICB4LCAwLCBhLCAwLFxuICAgIC8vICAgICAgICAgMCwgeSwgYiwgMCxcbiAgICAvLyAgICAgICAgIDAsIDAsIGMsIGQsXG4gICAgLy8gICAgICAgICAwLCAwLCAtMSwgMCxcbiAgICAvLyAgICAgKTtcblxuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDAsIC14LCBhLCAwLFxuICAgICAgLXksIDAsIGIsIDAsXG4gICAgICAwLCAwLCAtYywgZCxcbiAgICAgIDAsIDAsIDEsIDBcbiAgICApO1xuICB9XG5cbiAgbWFrZVBlcnNwZWN0aXZlKFxuICAgIGZvdixcbiAgICBhc3BlY3QsXG4gICAgbmVhcixcbiAgICBmYXJcbiAgKSB7XG4gICAgY29uc3QgeW1pbiA9IG5lYXIgKiBNYXRoLnRhbihkZWdUb1JhZChmb3YgKiAwLjUpKTtcbiAgICBjb25zdCB5bWF4ID0gLXltaW47XG4gICAgY29uc3QgeG1pbiA9IHltYXggKiBhc3BlY3Q7XG4gICAgY29uc3QgeG1heCA9IHltaW4gKiBhc3BlY3Q7XG4gICAgcmV0dXJuIHRoaXMubWFrZUZydXN0dW0oeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuXG4gICAqIFtvcnRob2dyYXBoaWMgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3J0aG9ncmFwaGljX3Byb2plY3Rpb24pXG4gICAqIG1hdHJpeC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnlcbiAgICoge0BsaW5rIE9ydGhvZ3JhcGhpY0NhbWVyYSN1cGRhdGVQcm9qZWN0aW9uTWF0cml4fS5cbiAgICogQG1ldGhvZCBtYWtlT3J0aG9ncmFwaGljXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvcFxuICAgKiBAcGFyYW0ge251bWJlcn0gYm90dG9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYXJcbiAgICovXG4gIG1ha2VPcnRob2dyYXBoaWMoXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIG5lYXIsXG4gICAgZmFyLFxuICApIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgdyA9IDEuMCAvIChyaWdodCAtIGxlZnQpO1xuICAgIGNvbnN0IGggPSAxLjAgLyAodG9wIC0gYm90dG9tKTtcbiAgICBjb25zdCBwID0gMS4wIC8gKGZhciAtIG5lYXIpO1xuICAgIGNvbnN0IHggPSAocmlnaHQgKyBsZWZ0KSAqIHc7XG4gICAgY29uc3QgeSA9ICh0b3AgKyBib3R0b20pICogaDtcbiAgICBjb25zdCB6ID0gKGZhciArIG5lYXIpICogcDtcblxuICAgIHJldHVybiB0aGlzLnNldChcbiAgICAgIDIgKiB3LCAwLCAwLCAteCxcbiAgICAgIDAsIDIgKiBoLCAwLCAteSxcbiAgICAgIDAsIDAsIC0yICogcCwgLXosXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgdGhpcyBtYXRyaXggYW5kIGBtYXRyaXhgIGFyZSBlcXVhbC5cbiAgICogQG1ldGhvZCBlcXVhbHNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge01hdHJpeDR9IG1hdHJpeFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG1hdHJpeCkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgaWYgKHRlW2ldICE9PSBtZVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIE1hdHJpeDQjZWxlbWVudHN9IG9mIHRoaXMgbWF0cml4IGJhc2VkIG9uIGFuIGBhcnJheWAgaW5cbiAgICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcilcbiAgICogZm9ybWF0LlxuICAgKiBAbWV0aG9kIGZyb21BcnJheVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZWFkIHRoZSB7QGxpbmsgTWF0cml4NCNlbGVtZW50c30gZnJvbS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9mZnNldCBpbnRvIHRoZSBhcnJheS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGVbaV0gPSBhcnJheVtpICsgb2Zmc2V0XTtcbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIGFuIGBhcnJheWAgaW5cbiAgICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyI0NvbHVtbi1tYWpvcl9vcmRlcilcbiAgICogZm9ybWF0LlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBbYXJyYXk9W11dIEFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgdmVjdG9yIGluLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvZmZzZXQ9MF0gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0byBwdXQgdGhlIHJlc3VsdC5cbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApe1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSB0ZVtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBvbkNoYW5nZShjYWxsYmFjaykge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25DaGFuZ2VDYWxsYmFjaygpIHt9XG59XG5cbiIsImltcG9ydCBWZWN0b3IzIGZyb20gJy4vVmVjdG9yMyc7XG4vLyBpbXBvcnQgRXVsZXIgZnJvbSAnLi9FdWxlcic7XG4vLyBpbXBvcnQgTWF0cml4NCBmcm9tICcuL01hdHJpeDQnO1xuXG5sZXQgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OO1xuXG5pZiAodHlwZW9mIEVQU0lMT04gPT09ICd1bmRlZmluZWQnKSB7XG4gIEVQU0lMT04gPSBNYXRoLnBvdygyLCAtNTIpO1xufVxuXG4vLyBjb25zdGFudHMgZm9yIG9wdGltaXNhdGlvblxuY29uc3Qgc2V0RnJvbVVuaXRWZWN0b3JzRVBTID0gMC4wMDAwMDE7XG5sZXQgc2V0RnJvbVVuaXRWZWN0b3JzVjtcblxuLy8gbGV0IHRoaXMueCA9IDAsIHRoaXMueSA9IDAsIHRoaXMueiA9IDAsIHRoaXMudyA9IDE7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgYW5kIG9mIHRoZSBmb2xsb3dpbmcgb2NjdXI6XG4gKiAqIFRoZSB7QGxpbmsgUXVhdGVybmlvbiN4fSwge0BsaW5rIFF1YXRlcm5pb24jeX0sIHtAbGluayBRdWF0ZXJuaW9uI3p9LCBvciB7QGxpbmsgUXVhdGVybmlvbiN3fSBwcm9wZXJ0aWVzIGFyZSBjaGFuZ2VkLlxuICogKiBUaGUge0BsaW5rIFF1YXRlcm5pb24jc2V0fSwge0BsaW5rIFF1YXRlcm5pb24jY29weX0sIHtAbGluayBRdWF0ZXJuaW9uJGNsb25lfSwge0BsaW5rIFF1YXRlcm5pb24jc2V0RnJvbUF4aXNBbmdsZX0sIHtAbGluayBRdWF0ZXJuaW9uJHNldEZyb21Sb3RhdGlvbk1hdHJpeH0sIHtAbGluayBRdWF0ZXJuaW9uI2Nvbmp1Z2F0ZX0sIHtAbGluayBRdWF0ZXJuaW9uI25vcm1hbGl6ZX0sIHtAbGluayBRdWF0ZXJuaW9uI211bHRpcGx5UXVhdGVybmlvbnN9LCB7QGxpbmsgUXVhdGVybmlvbiNzbGVycH0sIHtAbGluayBRdWF0ZXJuaW9uI2Zyb21BcnJheX0gZnVuY3Rpb25zIGFyZSBjYWxsZWQuXG4gKiAqIHtAbGluayBRdWF0ZXJuaW9uI3NldEZyb21FdWxlcn0gZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggaXRzIGB1cGRhdGVgIGFyZ3VtZW50IHNldCB0byBgdHJ1ZWAuXG4gKiBCeSBkZWZhdWx0LCBpdCBpcyBhbiBlbXB0eSBmdW5jdGlvbiwgaG93ZXZlciB5b3UgY2FuIGNoYW5nZSBpdCBpZiBuZWVkZWQgdXNpbmcge0BsaW5rIFF1YXRlcm5pb24jb25DaGFuZ2V9LlxuICogQHByb3BlcnR5IG9uQ2hhbmdlQ2FsbGJhY2tcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cbiAqL1xubGV0IG9uQ2hhbmdlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuY29uc3QgX2lzUXVhdGVybmlvbiA9IHRydWU7XG5cbi8qKlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBjbGFzc2Rlc2NcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgW3F1YXRlcm5pb25dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvbikuXG4gKiBUaGlzIGlzIHVzZWQgZm9yXG4gKiBbcm90YXRpbmcgdGhpbmdzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWF0ZXJuaW9uc19hbmRfc3BhdGlhbF9yb3RhdGlvbilcbiAqIHdpdGhvdXQgZW5jb3VudGVyaW5nIHRoZSBkcmVhZGVkXG4gKiBbZ2ltYmFsIGxvY2tdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2ltYmFsX2xvY2spIGlzc3VlLCBhbW9uZ3N0IG90aGVyXG4gKiBhZHZhbnRhZ2VzLlxuICogQGV4YW1wbGVcbiAqIHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAqIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZShuZXcgVmVjdG9yMygwLCAxLCAwKSwgTWF0aC5QSSAvIDIpO1xuICpcbiAqIHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAqIHZlY3Rvci5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3c9MV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhdGVybmlvbiB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIHtAbGluayBRdWF0ZXJuaW9uI29uQ2hhbmdlQ2FsbGJhY2t9XG4gICAqIGJlaW5nIGNhbGxlZC5cbiAgICogQG1lbWJlciB7bnVtYmVyfSB4XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICAvLyBnZXQgeCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy54O1xuICAvLyB9XG4gIC8vXG4gIC8vIHNldCB4KHZhbHVlKSB7XG4gIC8vICAgdGhpcy54ID0gdmFsdWU7XG4gIC8vICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiB7QGxpbmsgUXVhdGVybmlvbiNvbkNoYW5nZUNhbGxiYWNrfVxuICAgKiBiZWluZyBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0geVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbiNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgLy8gZ2V0IHkoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMueTtcbiAgLy8gfVxuICAvL1xuICAvLyBzZXQgeSh2YWx1ZSkge1xuICAvLyAgIHRoaXMueSA9IHZhbHVlO1xuICAvLyAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgd2lsbCByZXN1bHQgaW4ge0BsaW5rIFF1YXRlcm5pb24jb25DaGFuZ2VDYWxsYmFja31cbiAgICogYmVpbmcgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHpcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24jXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIC8vIGdldCB6KCkge1xuICAvLyAgIHJldHVybiB0aGlzLno7XG4gIC8vIH1cbiAgLy9cbiAgLy8gc2V0IHoodmFsdWUpIHtcbiAgLy8gICB0aGlzLnogPSB2YWx1ZTtcbiAgLy8gICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIHtAbGluayBRdWF0ZXJuaW9uI29uQ2hhbmdlQ2FsbGJhY2t9XG4gICAqIGJlaW5nIGNhbGxlZC5cbiAgICogQG1lbWJlciB7bnVtYmVyfSB3XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uI1xuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICAvLyBnZXQgdygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy53O1xuICAvLyB9XG4gIC8vXG4gIC8vIHNldCB3KHZhbHVlKSB7XG4gIC8vICAgdGhpcy53ID0gdmFsdWU7XG4gIC8vICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIC8vIH1cblxuICBnZXQgaXNRdWF0ZXJuaW9uKCkge1xuICAgIHJldHVybiBfaXNRdWF0ZXJuaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMge0BsaW5rIFF1YXRlcm5pb24jeH0sIHtAbGluayBRdWF0ZXJuaW9uI3l9LCB7QGxpbmsgUXVhdGVybmlvbiN6fSwgYW5kXG4gICAqIHtAbGluayBRdWF0ZXJuaW9uI3d9IHByb3BlcnRpZXMgb2YgdGhpcyBxdWF0ZXJuaW9uLlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdcbiAgICovXG4gIHNldCh4LCB5LCB6LCB3KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBRdWF0ZXJuaW9ufSB3aXRoIGlkZW50aWNhbCB7QGxpbmsgUXVhdGVybmlvbiN4fSxcbiAgICoge0BsaW5rIFF1YXRlcm5pb24jeX0sIHtAbGluayBRdWF0ZXJuaW9uI3p9LCBhbmQge0BsaW5rIFF1YXRlcm5pb24jd31cbiAgICogcHJvcGVydGllcyB0byB0aGlzIG9uZS5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUge0BsaW5rIFF1YXRlcm5pb24jeH0sIHtAbGluayBRdWF0ZXJuaW9uI3l9LFxuICAgKiB7QGxpbmsgUXVhdGVybmlvbiN6fSwgYW5kIHtAbGluayBRdWF0ZXJuaW9uI3d9IHByb3BlcnRpZXMgb2YgYHF1YXRlcm5pb25gXG4gICAqIGludG8gdGhpcyBxdWF0ZXJuaW9uLlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgKi9cbiAgY29weShxdWF0ZXJuaW9uKSB7XG4gICAgdGhpcy54ID0gcXVhdGVybmlvbi54O1xuICAgIHRoaXMueSA9IHF1YXRlcm5pb24ueTtcbiAgICB0aGlzLnogPSBxdWF0ZXJuaW9uLno7XG4gICAgdGhpcy53ID0gcXVhdGVybmlvbi53O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIGZyb20gdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBieSB7QGxpbmsgRXVsZXJ9IGFuZ2xlLlxuICAgKiBAbWV0aG9kIHNldEZyb21FdWxlclxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtFdWxlcn0gZXVsZXJcbiAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVcbiAgICovXG4gIHNldEZyb21FdWxlcihldWxlciwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cbiAgICAvLyAyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cbiAgICAvLyBjb250ZW50L1NwaW5DYWxjLm1cbiAgICBjb25zdCBjMSA9IE1hdGguY29zKGV1bGVyLnggLyAyKTtcbiAgICBjb25zdCBjMiA9IE1hdGguY29zKGV1bGVyLnkgLyAyKTtcbiAgICBjb25zdCBjMyA9IE1hdGguY29zKGV1bGVyLnogLyAyKTtcbiAgICBjb25zdCBzMSA9IE1hdGguc2luKGV1bGVyLnggLyAyKTtcbiAgICBjb25zdCBzMiA9IE1hdGguc2luKGV1bGVyLnkgLyAyKTtcbiAgICBjb25zdCBzMyA9IE1hdGguc2luKGV1bGVyLnogLyAyKTtcbiAgICBjb25zdCBvcmRlciA9IGV1bGVyLm9yZGVyO1xuXG4gICAgaWYgKG9yZGVyID09PSAnWFlaJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgKyAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpIC0gKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSArIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgLSAoczEgKiBzMiAqIHMzKTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgKyAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpIC0gKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSAtIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgKyAoczEgKiBzMiAqIHMzKTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgLSAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpICsgKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSArIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgLSAoczEgKiBzMiAqIHMzKTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgLSAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpICsgKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSAtIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgKyAoczEgKiBzMiAqIHMzKTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgKyAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpICsgKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSAtIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgLSAoczEgKiBzMiAqIHMzKTtcbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykge1xuICAgICAgdGhpcy54ID0gKHMxICogYzIgKiBjMykgLSAoYzEgKiBzMiAqIHMzKTtcbiAgICAgIHRoaXMueSA9IChjMSAqIHMyICogYzMpIC0gKHMxICogYzIgKiBzMyk7XG4gICAgICB0aGlzLnogPSAoYzEgKiBjMiAqIHMzKSArIChzMSAqIHMyICogYzMpO1xuICAgICAgdGhpcy53ID0gKGMxICogYzIgKiBjMykgKyAoczEgKiBzMiAqIHMzKTtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHF1YXRlcm5pb24gZnJvbSByb3RhdGlvbiBzcGVjaWZpZWQgYnkgYGF4aXNgIGFuZCBgYW5nbGVgLiBBZGFwdGVkXG4gICAqIGZyb20gdGhlIG1ldGhvZFxuICAgKiBbaGVyZV0oaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bSkuXG4gICAqIGBheGlzYCBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQsIGBhbmdsZWAgaXMgaW4gcmFkaWFucy5cbiAgICogQG1ldGhvZCBzZXRGcm9tQXhpc0FuZ2xlXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGF4aXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICAgKi9cbiAgc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSkge1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IGFuZ2xlIC8gMjtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICB0aGlzLnggPSBheGlzLnggKiBzO1xuICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XG4gICAgdGhpcy56ID0gYXhpcy56ICogcztcbiAgICB0aGlzLncgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIGZyb20gcm90YXRpb24gY29tcG9uZW50IG9mIGBtYC4gQWRhcHRlZCBmcm9tIHRoZVxuICAgKiBtZXRob2RcbiAgICogW2hlcmVdKGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtKS5cbiAgICogQG1ldGhvZCBzZXRGcm9tUm90YXRpb25NYXRyaXhcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4KG0pIHtcbiAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuICAgIGNvbnN0IHRlID0gbS5lbGVtZW50cztcblxuICAgIGNvbnN0IFtcbiAgICAgIG0xMSwgbTIxLCBtMzEsIG00MSxcbiAgICAgIG0xMiwgbTIyLCBtMzIsIG00MixcbiAgICAgIG0xMywgbTIzLCBtMzMsIG00MyxcbiAgICBdID0gdGU7XG5cbiAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcbiAgICBsZXQgcztcblxuICAgIGlmICh0cmFjZSA+IDApIHtcbiAgICAgIHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxLjApO1xuICAgICAgdGhpcy53ID0gMC4yNSAvIHM7XG4gICAgICB0aGlzLnggPSAobTMyIC0gbTIzKSAqIHM7XG4gICAgICB0aGlzLnkgPSAobTEzIC0gbTMxKSAqIHM7XG4gICAgICB0aGlzLnogPSAobTIxIC0gbTEyKSAqIHM7XG4gICAgfSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0xMSAtIG0yMiAtIG0zMyk7XG4gICAgICB0aGlzLncgPSAobTMyIC0gbTIzKSAvIHM7XG4gICAgICB0aGlzLnggPSAwLjI1ICogcztcbiAgICAgIHRoaXMueSA9IChtMTIgKyBtMjEpIC8gcztcbiAgICAgIHRoaXMueiA9IChtMTMgKyBtMzEpIC8gcztcbiAgICB9IGVsc2UgaWYgKG0yMiA+IG0zMykge1xuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMjIgLSBtMTEgLSBtMzMpO1xuICAgICAgdGhpcy53ID0gKG0xMyAtIG0zMSkgLyBzO1xuICAgICAgdGhpcy54ID0gKG0xMiArIG0yMSkgLyBzO1xuICAgICAgdGhpcy55ID0gMC4yNSAqIHM7XG4gICAgICB0aGlzLnogPSAobTIzICsgbTMyKSAvIHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTMzIC0gbTExIC0gbTIyKTtcbiAgICAgIHRoaXMudyA9IChtMjEgLSBtMTIpIC8gcztcbiAgICAgIHRoaXMueCA9IChtMTMgKyBtMzEpIC8gcztcbiAgICAgIHRoaXMueSA9IChtMjMgKyBtMzIpIC8gcztcbiAgICAgIHRoaXMueiA9IDAuMjUgKiBzO1xuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIHRvIHRoZSByb3RhdGlvbiByZXF1aXJlZCB0byByb3RhdGUgZGlyZWN0aW9uIHZlY3RvclxuICAgKiBgdkZyb21gIHRvIGRpcmVjdGlvbiB2ZWN0b3IgYHZUb2AuIEFkYXB0ZWQgZnJvbSB0aGUgbWV0aG9kXG4gICAqIFtoZXJlXShodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTMvMDkvMTgvYmVhdXRpZnVsLW1hdGhzLXF1YXRlcm5pb24tZnJvbS12ZWN0b3JzKS5cbiAgICogYHZGcm9tYCBhbmQgYHZUb2AgYXJlIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICogQG1ldGhvZCBzZXRGcm9tVW5pdFZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdkZyb21cbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2VG9cbiAgICovXG4gIHNldEZyb21Vbml0VmVjdG9ycyh2RnJvbSwgdlRvKSB7XG4gICAgLy8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxuICAgIGlmICh0eXBlb2Ygc2V0RnJvbVVuaXRWZWN0b3JzViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNldEZyb21Vbml0VmVjdG9yc1YgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGxldCByID0gdkZyb20uZG90KHZUbykgKyAxO1xuXG4gICAgaWYgKHIgPCBzZXRGcm9tVW5pdFZlY3RvcnNFUFMpIHtcbiAgICAgIHIgPSAwO1xuXG4gICAgICBpZiAoTWF0aC5hYnModkZyb20ueCkgPiBNYXRoLmFicyh2RnJvbS56KSkge1xuICAgICAgICBzZXRGcm9tVW5pdFZlY3RvcnNWLnNldCgtdkZyb20ueSwgdkZyb20ueCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRGcm9tVW5pdFZlY3RvcnNWLnNldCgwLCAtdkZyb20ueiwgdkZyb20ueSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEZyb21Vbml0VmVjdG9yc1YuY3Jvc3NWZWN0b3JzKHZGcm9tLCB2VG8pO1xuICAgIH1cblxuICAgIHRoaXMueCA9IHNldEZyb21Vbml0VmVjdG9yc1YueDtcbiAgICB0aGlzLnkgPSBzZXRGcm9tVW5pdFZlY3RvcnNWLnk7XG4gICAgdGhpcy56ID0gc2V0RnJvbVVuaXRWZWN0b3JzVi56O1xuICAgIHRoaXMudyA9IHI7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogSW52ZXJ0cyB0aGlzIHF1YXRlcm5pb24gLSBjYWxjdWxhdGUgdGhlIHtAbGluayBRdWF0ZXJuaW9uI2Nvbmp1Z2F0ZX0gYW5kXG4gICAqIHRoZW4gW25vcm1hbGl6ZXNde0BsaW5rIFF1YXRlcm5pb24jbm9ybWFsaXplfSB0aGUgcmVzdWx0LlxuICAgKiBAbWV0aG9kIGludmVyc2VcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqL1xuICBpbnZlcnNlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvdGF0aW9uYWwgY29uanVnYXRlIG9mIHRoaXMgcXVhdGVybmlvbi4gVGhlIGNvbmp1Z2F0ZSBvZiBhXG4gICAqIHF1YXRlcm5pb24gcmVwcmVzZW50cyB0aGUgc2FtZSByb3RhdGlvbiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGFib3V0XG4gICAqIHRoZSByb3RhdGlvbmFsIGF4aXMuXG4gICAqIEBtZXRob2QgY29uanVnYXRlXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKi9cbiAgY29uanVnYXRlKCkge1xuICAgIHRoaXMueCAqPSAtMTtcbiAgICB0aGlzLnkgKj0gLTE7XG4gICAgdGhpcy56ICo9IC0xO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgW2RvdCBwcm9kdWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3RfcHJvZHVjdCkgb2ZcbiAgICogcXVhdGVybmlvbnMgYHZgIGFuZCB0aGlzIG9uZS5cbiAgICogQG1ldGhvZCBkb3RcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkb3Qodikge1xuICAgIHJldHVybiAodGhpcy54ICogdi54KSArICh0aGlzLnkgKiB2LnkpICsgKHRoaXMueiAqIHYueikgKyAodGhpcy53ICogdi53KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGVcbiAgICogW0V1Y2xpZGVhbiBsZW5ndGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSlcbiAgICogKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBvZiB0aGlzIHF1YXRlcm5pb24sIGNvbnNpZGVyZWQgYXMgYSA0IGRpbWVuc2lvbmFsXG4gICAqIHZlY3Rvci4gVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSBhcmUgY29tcGFyaW5nIHRoZSBsZW5ndGhzIG9mIHR3b1xuICAgKiBxdWF0ZXJuaW9ucywgYXMgdGhpcyBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCBjYWxjdWxhdGlvbiB0aGFuXG4gICAqIHtAbGluayBRdWF0ZXJuaW9uI2xlbmd0aH0uXG4gICAqIEBtZXRob2QgbGVuZ3RoU3FcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aFNxKCkge1xuICAgIHJldHVybiAodGhpcy54ICogdGhpcy54KSArICh0aGlzLnkgKiB0aGlzLnkpICsgKHRoaXMueiAqIHRoaXMueikgKyAodGhpcy53ICogdGhpcy53KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGVcbiAgICogW0V1Y2xpZGVhbiBsZW5ndGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSlcbiAgICogKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBvZiB0aGlzIHF1YXRlcm5pb24sIGNvbnNpZGVyZWQgYXMgYSA0IGRpbWVuc2lvbmFsXG4gICAqIHZlY3Rvci5cbiAgICogQG1ldGhvZCBsZW5ndGhcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh0aGlzLnggKiB0aGlzLngpICsgKHRoaXMueSAqIHRoaXMueSkgKyAodGhpcy56ICogdGhpcy56KSArICh0aGlzLncgKiB0aGlzLncpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbTm9ybWFsaXplc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTm9ybWFsaXplZF92ZWN0b3IpIHRoaXNcbiAgICogcXVhdGVybmlvbiAtIHRoYXQgaXMsIGNhbGN1bGF0ZXMgdGhlIHF1YXRlcm5pb24gdGhhdCBwZXJmb3JtcyB0aGUgc2FtZVxuICAgKiByb3RhdGlvbiBhcyB0aGlzIG9uZSwgYnV0IGhhcyB7QGxpbmsgUXVhdGVybmlvbiNsZW5ndGh9IGVxdWFsIHRvIGAxYC5cbiAgICogQG1ldGhvZCBub3JtYWxpemVcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgbGV0IGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcbiAgICAgIHRoaXMudyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSAxIC8gbDtcbiAgICAgIHRoaXMueCA9IHRoaXMueCAqIGw7XG4gICAgICB0aGlzLnkgPSB0aGlzLnkgKiBsO1xuICAgICAgdGhpcy56ID0gdGhpcy56ICogbDtcbiAgICAgIHRoaXMudyA9IHRoaXMudyAqIGw7XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIHF1YXRlcm5pb24gYnkgYHFgLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAgICovXG4gIG11bHRpcGx5KHEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsIHEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZS1tdWx0aXBsaWVzIHRoaXMgcXVhdGVybmlvbiBieSBgcWAuXG4gICAqIEBtZXRob2QgcHJlbXVsdGlwbHlcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcVxuICAgKi9cbiAgcHJlbXVsdGlwbHkocSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMocSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYGEgw5cgYmAuIEFkYXB0ZWQgZnJvbSB0aGUgbWV0aG9kIG91dGxpbmVkXG4gICAqIFtoZXJlXShodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtKS5cbiAgICogQG1ldGhvZCBtdWx0aXBseVF1YXRlcm5pb25zXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IGFcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBiXG4gICAqL1xuICBtdWx0aXBseVF1YXRlcm5pb25zKGEsIGIpIHtcbiAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cbiAgICBjb25zdCBxYXggPSBhLng7XG4gICAgY29uc3QgcWF5ID0gYS55O1xuICAgIGNvbnN0IHFheiA9IGEuejtcbiAgICBjb25zdCBxYXcgPSBhLnc7XG4gICAgY29uc3QgcWJ4ID0gYi54O1xuICAgIGNvbnN0IHFieSA9IGIueTtcbiAgICBjb25zdCBxYnogPSBiLno7XG4gICAgY29uc3QgcWJ3ID0gYi53O1xuICAgIHRoaXMueCA9IChxYXggKiBxYncpICsgKHFhdyAqIHFieCkgKyAocWF5ICogcWJ6KSAtIChxYXogKiBxYnkpO1xuICAgIHRoaXMueSA9IChxYXkgKiBxYncpICsgKHFhdyAqIHFieSkgKyAocWF6ICogcWJ4KSAtIChxYXggKiBxYnopO1xuICAgIHRoaXMueiA9IChxYXogKiBxYncpICsgKHFhdyAqIHFieikgKyAocWF4ICogcWJ5KSAtIChxYXkgKiBxYngpO1xuICAgIHRoaXMudyA9IChxYXcgKiBxYncpIC0gKHFheCAqIHFieCkgLSAocWF5ICogcWJ5KSAtIChxYXogKiBxYnopO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHF1YXRlcm5pb25zLiBgdGBcbiAgICogcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHJvdGF0aW9uIGJldHdlZW4gdGhpcyBxdWF0ZXJuaW9uICh3aGVyZSBgdCA9IDBgKVxuICAgKiBhbmQgYHFiYCAod2hlcmUgYHQgPSAxYCkuIFRoaXMgcXVhdGVybmlvbiBpcyBzZXQgdG8gdGhlIHJlc3VsdC4gQWxzbyBzZWVcbiAgICogdGhlIHN0YXRpYyB2ZXJzaW9uIG9mIHRoZSB7QGxpbmsgUXVhdGVybmlvbi5zbGVycH0uXG4gICAqIEBtZXRob2Qgc2xlcnBcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFiIFRoZSBvdGhlciBxdWF0ZXJuaW9uIHJvdGF0aW9uXG4gICAqIEBwYXJhbSAge251bWJlcn0gdCAgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gcm90YXRlIGEgbWVzaCB0b3dhcmRzIGEgdGFyZ2V0IHF1YXRlcm5pb25cbiAgICogbWVzaC5xdWF0ZXJuaW9uLnNsZXJwKGVuZFF1YXRlcm5pb24sIDAuMDEpO1xuICAgKi9cbiAgc2xlcnAocWIsIHQpIHtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvcHkocWIpO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSB0aGlzLng7XG4gICAgY29uc3QgeSA9IHRoaXMueTtcbiAgICBjb25zdCB6ID0gdGhpcy56O1xuICAgIGNvbnN0IHcgPSB0aGlzLnc7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL3NsZXJwL1xuICAgIGxldCBjb3NIYWxmVGhldGEgPSAodyAqIHFiLncpICsgKHggKiBxYi54KSArICh5ICogcWIueSkgKyAoeiAqIHFiLnopO1xuXG4gICAgaWYgKGNvc0hhbGZUaGV0YSA8IDApIHtcbiAgICAgIHRoaXMudyA9IC1xYi53O1xuICAgICAgdGhpcy54ID0gLXFiLng7XG4gICAgICB0aGlzLnkgPSAtcWIueTtcbiAgICAgIHRoaXMueiA9IC1xYi56O1xuICAgICAgY29zSGFsZlRoZXRhID0gLWNvc0hhbGZUaGV0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3B5KHFiKTtcbiAgICB9XG5cbiAgICBpZiAoY29zSGFsZlRoZXRhID49IDEuMCkge1xuICAgICAgdGhpcy53ID0gdztcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy56ID0gejtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCgxLjAgLSAoY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhKSk7XG5cbiAgICBpZiAoTWF0aC5hYnMoc2luSGFsZlRoZXRhKSA8IDAuMDAxKSB7XG4gICAgICB0aGlzLncgPSAwLjUgKiAodyArIHRoaXMudyk7XG4gICAgICB0aGlzLnggPSAwLjUgKiAoeCArIHRoaXMueCk7XG4gICAgICB0aGlzLnkgPSAwLjUgKiAoeSArIHRoaXMueSk7XG4gICAgICB0aGlzLnogPSAwLjUgKiAoeiArIHRoaXMueik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhKTtcbiAgICBjb25zdCByYXRpb0EgPSBNYXRoLnNpbigoMSAtIHQpICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcbiAgICBjb25zdCByYXRpb0IgPSBNYXRoLnNpbih0ICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YTtcbiAgICB0aGlzLncgPSAodyAqIHJhdGlvQSkgKyAodGhpcy53ICogcmF0aW9CKTtcbiAgICB0aGlzLnggPSAoeCAqIHJhdGlvQSkgKyAodGhpcy54ICogcmF0aW9CKTtcbiAgICB0aGlzLnkgPSAoeSAqIHJhdGlvQSkgKyAodGhpcy55ICogcmF0aW9CKTtcbiAgICB0aGlzLnogPSAoeiAqIHJhdGlvQSkgKyAodGhpcy56ICogcmF0aW9CKTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUge0BsaW5rIFF1YXRlcm5pb24jeH0sIHtAbGluayBRdWF0ZXJuaW9uI3l9LFxuICAgKiB7QGxpbmsgUXVhdGVybmlvbiN6fSwgYW5kIHtAbGluayBRdWF0ZXJuaW9uI3d9IHByb3BlcnRpZXMgb2YgYHF1YXRlcm5pb25gXG4gICAqIHRvIHRoZSBlcXVpdmFsZW50IHByb3BlcnRpZXMgb2YgdGhpcyBxdWF0ZXJuaW9uIHRvIGRldGVybWluZSBpZiB0aGV5XG4gICAqIHJlcHJlc2VudCB0aGUgc2FtZSByb3RhdGlvbi5cbiAgICogQG1ldGhvZCBlcXVhbHNcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBRdWF0ZXJuaW9uIHRoYXQgdGhpcyBxdWF0ZXJuaW9uIHdpbGwgYmUgY29tcGFyZWQgdG8uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMocSkge1xuICAgIHJldHVybiAocS54ID09PSB0aGlzLngpICYmIChxLnkgPT09IHRoaXMueSkgJiYgKHEueiA9PT0gdGhpcy56KSAmJiAocS53ID09PSB0aGlzLncpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uJ3Mge0BsaW5rIFF1YXRlcm5pb24jeH0sIHtAbGluayBRdWF0ZXJuaW9uI3l9LFxuICAgKiB7QGxpbmsgUXVhdGVybmlvbiN6fSwgYW5kIHtAbGluayBRdWF0ZXJuaW9uI3d9IHByb3BlcnRpZXMgZnJvbSB0aGUgYGFycmF5YC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IEFycmF5IG9mIGZvcm1hdCBgKHgsIHksIHosIHcpYCB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcXVhdGVybmlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gQW4gb2Zmc2V0IGludG8gdGhlIGFycmF5LlxuICAgKi9cbiAgZnJvbUFycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICB0aGlzLnggPSBhcnJheVtvZmZzZXRdO1xuICAgIHRoaXMueSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgIHRoaXMueiA9IGFycmF5W29mZnNldCArIDJdO1xuICAgIHRoaXMudyA9IGFycmF5W29mZnNldCArIDNdO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWVyaWNhbCBlbGVtZW50cyBvZiB0aGlzIHF1YXRlcm5pb24gaW4gYW4gYXJyYXkgb2YgZm9ybWF0XG4gICAqIGBbeCwgeSwgeiwgd11gLlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IFthcnJheT1bXV0gQW4gb3B0aW9uYWwgYXJyYXkgdG8gc3RvcmUgdGhlIHF1YXRlcm5pb24uIElmIG5vdCBzcGVjaWZpZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXSBJZiBzcGVjaWZpZWQsIHRoZSByZXN1bHQgd2lsbCBiZSBjb3BpZWQgaW50byB0aGUgYGFycmF5YC5cbiAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAqL1xuICB0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICBhcnJheVtvZmZzZXQgKyAwXSA9IHRoaXMueDtcbiAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMueTtcbiAgICBhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuejtcbiAgICBhcnJheVtvZmZzZXQgKyAzXSA9IHRoaXMudztcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIFF1YXRlcm5pb24jb25DaGFuZ2VDYWxsYmFja30gbWV0aG9kLlxuICAgKiBAbWV0aG9kIG9uQ2hhbmdlXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2soKSB7fTtcblxuICAvKipcbiAgICogVW5saWtlIHRoZSBbbm9ybWFsXXtAbGluayBRdWF0ZXJuaW9uI3NsZXJwfSBtZXRob2QsIHRoZSBzdGF0aWMgdmVyc2lvbiBvZlxuICAgKiB7QGxpbmsgUXVhdGVybmlvbi5zbGVycH0gc2V0cyBhIHRhcmdldCBxdWF0ZXJuaW9uIHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqIHNsZXJwIG9wZXJhdGlvbi5cbiAgICogQG1ldGhvZCBzbGVycFxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvblxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFTdGFydCBUaGUgc3RhcnRpbmcgcXVhdGVybmlvbiAod2hlcmUgYHQgPSAwYCkuXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcUVuZCBUaGUgZW5kaW5nIHF1YXRlcm5pb24gKHdoZXJlIGB0ID0gMWApLlxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFUYXJnZXQgVGhlIHRhcmdldCBxdWF0ZXJuaW9uIHRoYXQgZ2V0cyBzZXQgd2l0aCB0aGUgcmVzdWx0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gdCBJbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuICAgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDb2RlIHNldHVwXG4gICAqIHZhciBzdGFydFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpLnNldCgwLCAwLCAwLCAxKS5ub3JtYWxpemUoKTtcbiAgICogdmFyIGVuZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpLnNldCgxLCAxLCAxLCAxKS5ub3JtYWxpemUoKTtcbiAgICogdmFyIHQgPSAwO1xuICAgKlxuICAgKiAvLyBVcGRhdGUgYSBtZXNoJ3Mgcm90YXRpb24gaW4gdGhlIGxvb3BcbiAgICogdCA9ICh0ICsgMC4wMSkgJSAxOyAvLyBjb25zdGFudCBhbmd1bGFyIG1vbWVudHVtXG4gICAqIFF1YXRlcm5pb24uc2xlcnAoc3RhcnRRdWF0ZXJuaW9uLCBlbmRRdWF0ZXJuaW9uLCBtZXNoLnF1YXRlcm5pb24sIHQpO1xuICAgKi9cbiAgc3RhdGljIHNsZXJwKHFTdGFydCwgcUVuZCwgcVRhcmdldCwgdCkge1xuICAgIHJldHVybiBxVGFyZ2V0LmNvcHkocVN0YXJ0KS5zbGVycChxRW5kLCB0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIHRoZSBzdGF0aWMge0BsaW5rIFF1YXRlcm5pb24uc2xlcnB9IG1ldGhvZCwgYnV0IG9wZXJhdGVzIGRpcmVjdGx5IG9uXG4gICAqIGZsYXQgYXJyYXlzIG9mIG51bWJlcnMuXG4gICAqIEBtZXRob2Qgc2xlcnBGbGF0XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGRzdCBUaGUgb3V0cHV0IGFycmF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZHN0T2Zmc2V0IEFuIG9mZnNldCBpbnRvIHRoZSBvdXRwdXQgYXJyYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHNyYzAgVGhlIHNvdXJjZSBhcnJheSBvZiB0aGUgc3RhcnRpbmcgcXVhdGVybmlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNyY09mZnNldDAgQW4gb2Zmc2V0IGludG8gdGhlIGFycmF5IGBzcmMwYC5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gc3JjMSBUaGUgc291cmNlIGFycmF5IG9mIHRoZSB0YXJnZXQgcXVhdGVybmlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNyY09mZnNldDEgQW4gb2Zmc2V0IGludG8gdGhlIGFycmF5IGBzcmMxYC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgTm9ybWFsaXplZCBpbnRlcnBvbGF0aW9uIGZhY3RvciAoYmV0d2VlbiBgMGAgYW5kIGAxYCkuXG4gICAqL1xuICBzdGF0aWMgc2xlcnBGbGF0KFxuICAgIGRzdCxcbiAgICBkc3RPZmZzZXQsXG4gICAgc3JjMCxcbiAgICBzcmNPZmZzZXQwLFxuICAgIHNyYzEsXG4gICAgc3JjT2Zmc2V0MSxcbiAgICB0XG4gICkge1xuICAgIC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cbiAgICBsZXQgeDAgPSBzcmMwW3NyY09mZnNldDAgKyAwXTtcbiAgICBsZXQgeTAgPSBzcmMwW3NyY09mZnNldDAgKyAxXTtcbiAgICBsZXQgejAgPSBzcmMwW3NyY09mZnNldDAgKyAyXTtcbiAgICBsZXQgdzAgPSBzcmMwW3NyY09mZnNldDAgKyAzXTtcbiAgICBjb25zdCB4MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDBdO1xuICAgIGNvbnN0IHkxID0gc3JjMVtzcmNPZmZzZXQxICsgMV07XG4gICAgY29uc3QgejEgPSBzcmMxW3NyY09mZnNldDEgKyAyXTtcbiAgICBjb25zdCB3MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDNdO1xuXG4gICAgaWYgKHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSkge1xuICAgICAgbGV0IHMgPSAxIC0gdDtcbiAgICAgIGNvbnN0IGNvcyA9ICh4MCAqIHgxKSArICh5MCAqIHkxKSArICh6MCAqIHoxKSArICh3MCAqIHcxKTtcbiAgICAgIGNvbnN0IGRpciA9IGNvcyA+PSAwID8gMSA6IC0xO1xuICAgICAgY29uc3Qgc3FyU2luID0gMSAtIChjb3MgKiBjb3MpO1xuXG4gICAgICAvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuICAgICAgaWYgKHNxclNpbiA+IEVQU0lMT04pIHtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zcXJ0KHNxclNpbik7XG4gICAgICAgIGNvbnN0IGxlbiA9IE1hdGguYXRhbjIoc2luLCBjb3MgKiBkaXIpO1xuICAgICAgICBzID0gTWF0aC5zaW4ocyAqIGxlbikgLyBzaW47XG4gICAgICAgIHQgPSBNYXRoLnNpbih0ICogbGVuKSAvIHNpbjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdERpciA9IHQgKiBkaXI7XG4gICAgICB4MCA9ICh4MCAqIHMpICsgKHgxICogdERpcik7XG4gICAgICB5MCA9ICh5MCAqIHMpICsgKHkxICogdERpcik7XG4gICAgICB6MCA9ICh6MCAqIHMpICsgKHoxICogdERpcik7XG4gICAgICB3MCA9ICh3MCAqIHMpICsgKHcxICogdERpcik7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcbiAgICAgIGlmIChzID09PSAxIC0gdCkge1xuICAgICAgICBjb25zdCBmID0gMSAvIE1hdGguc3FydCgoeDAgKiB4MCkgKyAoeTAgKiB5MCkgKyAoejAgKiB6MCkgKyAodzAgKiB3MCkpO1xuICAgICAgICB4MCAqPSBmO1xuICAgICAgICB5MCAqPSBmO1xuICAgICAgICB6MCAqPSBmO1xuICAgICAgICB3MCAqPSBmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRzdFtkc3RPZmZzZXRdID0geDA7XG4gICAgZHN0W2RzdE9mZnNldCArIDFdID0geTA7XG4gICAgZHN0W2RzdE9mZnNldCArIDJdID0gejA7XG4gICAgZHN0W2RzdE9mZnNldCArIDNdID0gdzA7XG4gIH1cbn1cblxuIiwiY29uc3QgX2lzVmVjdG9yMiA9IHRydWU7XG5cbi8qKlxuICogQGNsYXNzIFZlY3RvcjJcbiAqIEBjbGFzc2Rlc2NcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIDJEIFt2ZWN0b3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9zcGFjZSkuXG4gKiBBIDJEIHZlY3RvciBpcyBhbiBvcmRlcmVkIHBhaXIgb2YgbnVtYmVycyAobGFiZWxlZCBgeGAgYW5kIGB5YCksIHdoaWNoIGNhbiBiZVxuICogdXNlZCB0byByZXByZXNlbnQgYSBudW1iZXIgb2YgdGhpbmdzLCBzdWNoIGFzOlxuICogKiBBIHBvaW50IGluIDJEIHNwYWNlIChpLmUuIGEgcG9zaXRpb24gb24gYSBwbGFuZSkuXG4gKiAqIEEgZGlyZWN0aW9uIGFuZCBsZW5ndGggYWNyb3NzIGEgcGxhbmUuIEZvciBMZXRzZWUsIHRoZSBsZW5ndGggd2lsbCBhbHdheXMgYmUgdGhlIFtFdWNsaWRlYW4gZGlzdGFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSkgKHN0cmFpZ2h0LWxpbmUgZGlzdGFuY2UpIGZyb20gYCgwLCAwKWAgdG8gYCh4LCB5KWAgYW5kIHRoZSBkaXJlY3Rpb24gaXMgYWxzbyBtZWFzdXJlZCBmcm9tIGAoMCwgMClgIHRvd2FyZHMgYCh4LCB5KWAuXG4gKiAqIEFueSBhcmJpdHJhcnkgb3JkZXJlZCBwYWlyIG9mIG51bWJlcnMuXG4gKiBUaGVzZSBhcmUgb3RoZXIgdGhpbmdzIGEgMkQgdmVjdG9yIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCwgc3VjaCBhcyBtb21lbnR1bVxuICogdmVjdG9ycywgY29tcGxleCBudW1iZXJzIGFuZCBzbyBvbiwgaG93ZXZlciB0aGVzZSBhcmUgdGhlIG1vc3QgY29tbW9uIHVzZXMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGEgPSBuZXcgVmVjdG9yMigwLCAxKTtcbiAqXG4gKiAvLyBubyBhcmd1bWVudHM7IHdpbGwgYmUgaW5pdGlhbGlzZWQgdG8gKDAsIDApXG4gKiB2YXIgYiA9IG5ldyBWZWN0b3IyKCk7XG4gKlxuICogdmFyIGQgPSBhLmRpc3RhbmNlVG8oYik7XG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIFRoZSB7QGxpbmsgVmVjdG9yMiN4fSB2YWx1ZSBvZiB0aGUgdmVjdG9yLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSBUaGUge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUgb2YgdGhlIHZlY3Rvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yMiB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciB7QGxpbmsgVmVjdG9yMiN4fS5cbiAgICogQG1lbWJlciB7bnVtYmVyfSB3aWR0aFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMiNcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIFZlY3RvcjIjeX0uXG4gICAqIEBtZW1iZXIge251bWJlcn0gaGVpZ2h0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyI1xuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5feTtcbiAgfVxuXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLl95ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciB7bnVtYmVyfSB4XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge251bWJlcn0geVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMiNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cblxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIGdldCBpc1ZlY3RvcjIoKSB7XG4gICAgcmV0dXJuIF9pc1ZlY3RvcjI7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9IGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKi9cbiAgc2V0KHgsIHkpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgVmVjdG9yMiN4fSBhbmQge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzIG9mIHRoaXMgdmVjdG9yIGJvdGhcbiAgICogZXF1YWwgdG8gYHNjYWxhcmAuXG4gICAqIEBtZXRob2Qgc2V0U2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGFyXG4gICAqL1xuICBzZXRTY2FsYXIoc2NhbGFyKSB7XG4gICAgdGhpcy5feCA9IHNjYWxhcjtcbiAgICB0aGlzLl95ID0gc2NhbGFyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSB2YWx1ZSB3aXRoIGB4YC5cbiAgICogQG1ldGhvZCBzZXRYXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKi9cbiAgc2V0WCh4KSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlIHdpdGggYHlgLlxuICAgKiBAbWV0aG9kIHNldFlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqL1xuICBzZXRZKHkpIHtcbiAgICB0aGlzLl95ID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyB0byBgMGAsIHNldCB7QGxpbmsgVmVjdG9yMiN4fSB0byBgdmFsdWVgLlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyB0byBgMWAsIHNldCB7QGxpbmsgVmVjdG9yMiN5fSB0byBgdmFsdWVgLlxuICAgKiBAbWV0aG9kIHNldENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHswfDF9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0Q29tcG9uZW50KGluZGV4ID0gMCB8IDEsIHZhbHVlKSB7XG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgYGluZGV4YCBlcXVhbHMgdG8gYDBgLCByZXR1cm5zIHtAbGluayBWZWN0b3IyI3h9LlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyB0byBgMWAsIHJldHVybnMge0BsaW5rIFZlY3RvcjIjeX0uXG4gICAqIEBtZXRob2QgZ2V0Q29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHswfDF9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbXBvbmVudChpbmRleCA9IDAgfCAxKSB7XG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4IGlzIG91dCBvZiByYW5nZTogJHtpbmRleH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB7QGxpbmsgVmVjdG9yMn0gd2l0aCB0aGUgc2FtZSB7QGxpbmsgVmVjdG9yMiN4fSBhbmRcbiAgICoge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuX3gsIHRoaXMuX3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBwYXNzZWQge0BsaW5rIFZlY3RvcjJ9J3Mge0BsaW5rIFZlY3RvcjIjeH0gYW5kXG4gICAqIHtAbGluayBWZWN0b3IyI3l9IHByb3BlcnRpZXMgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqL1xuICBjb3B5KHYpIHtcbiAgICB0aGlzLl94ID0gdi54O1xuICAgIHRoaXMuX3kgPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBgdmAgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgYWRkXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICovXG4gIGFkZCh2KSB7XG4gICAgdGhpcy5feCArPSB2Lng7XG4gICAgdGhpcy5feSArPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgc2NhbGFyIHZhbHVlIGBzYCB0byB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZXMuXG4gICAqIEBtZXRob2QgYWRkU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgKi9cbiAgYWRkU2NhbGFyKHMpIHtcbiAgICB0aGlzLl94ICs9IHM7XG4gICAgdGhpcy5feSArPSBzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IgdG8gYGEgKyBiYC5cbiAgICogQG1ldGhvZCBhZGRWZWN0b3JzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGFcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBiXG4gICAqL1xuICBhZGRWZWN0b3JzKGEsIGIpIHtcbiAgICB0aGlzLl94ID0gYS54ICsgYi54O1xuICAgIHRoaXMuX3kgPSBhLnkgKyBiLnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgbXVsdGlwbGUgb2YgYHZgIGFuZCBgc2AgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgYWRkU2NhbGVkVmVjdG9yXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG4gICAgdGhpcy5feCArPSB2LnggKiBzO1xuICAgIHRoaXMuX3kgKz0gdi55ICogcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgYHZgIGZyb20gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2Qgc3ViXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICovXG4gIHN1Yih2KSB7XG4gICAgdGhpcy5feCAtPSB2Lng7XG4gICAgdGhpcy5feSAtPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIGBzYCBmcm9tIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9XG4gICAqIGNvbXBvbmVudHMuXG4gICAqIEBtZXRob2Qgc3ViU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgKi9cbiAgc3ViU2NhbGFyKHMpIHtcbiAgICB0aGlzLl94IC09IHM7XG4gICAgdGhpcy5feSAtPSBzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IgdG8gYGEgLSBiYC5cbiAgICogQG1ldGhvZCBzdWJWZWN0b3JzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBhXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGJcbiAgICovXG4gIHN1YlZlY3RvcnMoYSwgYikge1xuICAgIHRoaXMuX3ggPSBhLnggLSBiLng7XG4gICAgdGhpcy5feSA9IGEueSAtIGIueTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIGJ5IGB2YC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gdlxuICAgKi9cbiAgbXVsdGlwbHkodikge1xuICAgIHRoaXMuX3ggKj0gdi54O1xuICAgIHRoaXMuX3kgKj0gdi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgYnkgc2NhbGFyIGBzYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzXG4gICAqL1xuICBtdWx0aXBseVNjYWxhcihzKSB7XG4gICAgaWYgKGlzRmluaXRlKHMpKSB7XG4gICAgICB0aGlzLl94ICo9IHM7XG4gICAgICB0aGlzLl95ICo9IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgdGhpcy5feSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSBgdmAuXG4gICAqIEBtZXRob2QgZGl2aWRlXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICovXG4gIGRpdmlkZSh2KSB7XG4gICAgdGhpcy5feCAvPSB2Lng7XG4gICAgdGhpcy5feSAvPSB2Lnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSBzY2FsYXIgYHNgLiBTZXRzIHZlY3RvciB0byBgKDAsIDApYCBpZiBgcyA9IDBgLlxuICAgKiBAbWV0aG9kIGRpdmlkZVNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGRpdmlkZVNjYWxhcihzKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUgaXMgZ3JlYXRlclxuICAgKiB0aGFuIGB2YCdzIHtAbGluayBWZWN0b3IyI3h9IG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWVcbiAgICogd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtaW4gdmFsdWUuXG4gICAqIEBtZXRob2QgbWluXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICovXG4gIG1pbih2KSB7XG4gICAgdGhpcy5feCA9IE1hdGgubWluKHRoaXMuX3gsIHYueCk7XG4gICAgdGhpcy5feSA9IE1hdGgubWluKHRoaXMuX3ksIHYueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBvciB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZSBpcyBsZXNzIHRoYW5cbiAgICogYHZgJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUsIHJlcGxhY2UgdGhhdCB2YWx1ZSB3aXRoXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIG1heCB2YWx1ZS5cbiAgICogQG1ldGhvZCBtYXhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKi9cbiAgbWF4KHYpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5tYXgodGhpcy5feCwgdi54KTtcbiAgICB0aGlzLl95ID0gTWF0aC5tYXgodGhpcy5feSwgdi55KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlIGlzIGdyZWF0ZXJcbiAgICogdGhhbiB0aGUgYG1heGAgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUsIGl0IGlzXG4gICAqIHJlcGxhY2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLiBJZiB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IG9yXG4gICAqIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgYG1pbmAgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH1cbiAgICogb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNsYW1wXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1pbiBUaGUgbWluaW11bSB7QGxpbmsgVmVjdG9yMiN4fSBhbmQge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzLlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG1heCBUaGUgbWF4aW11bSB7QGxpbmsgVmVjdG9yMiN4fSBhbmQge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzIGluIHRoZSBkZXNpcmVkIHJhbmdlLlxuICAgKi9cbiAgY2xhbXAobWluLCBtYXgpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuICAgIHRoaXMuX3ggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMuX3gpKTtcbiAgICB0aGlzLl95ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLl95KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBvciB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZXMgYXJlIGdyZWF0ZXJcbiAgICogdGhhbiB0aGUgYG1heGAgdmFsdWUsIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IHRoZSBgbWF4YCB2YWx1ZS4gSWYgdGhpc1xuICAgKiB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBvciB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZXMgYXJlIGxlc3MgdGhhbiB0aGVcbiAgICogYG1pbmAgdmFsdWUsIHRoZXkgYXJlIHJlcGxhY2VkIGJ5IHRoZSBgbWluYCB2YWx1ZS5cbiAgICogQG1ldGhvZCBjbGFtcFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblZhbCBUaGUgbWluaW11bSB2YWx1ZSB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGNsYW1wZWQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhWYWwgVGhlIG1heGltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKi9cbiAgY2xhbXBTY2FsYXIobWluVmFsLCBtYXhWYWwpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuICAgIHRoaXMuX3ggPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy5feCkpO1xuICAgIHRoaXMuX3kgPSBNYXRoLm1heChtaW5WYWwsIE1hdGgubWluKG1heFZhbCwgdGhpcy5feSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3MgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYG1heGAgdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5XG4gICAqIHRoZSBgbWF4YCB2YWx1ZS4gSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBgbWluYCB2YWx1ZSwgaXRcbiAgICogaXMgcmVwbGFjZWQgYnkgdGhlIGBtaW5gIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNsYW1wTGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRoZSBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKi9cbiAgY2xhbXBMZW5ndGgobWluLCBtYXgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSAvIGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciBhcmUgcm91bmRlZCBkb3duIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUuXG4gICAqIEBtZXRob2QgZmxvb3JcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICBmbG9vcigpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5mbG9vcih0aGlzLl94KTtcbiAgICB0aGlzLl95ID0gTWF0aC5mbG9vcih0aGlzLl95KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9IGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciBhcmVcbiAgICogcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNlaWxcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICBjZWlsKCkge1xuICAgIHRoaXMuX3ggPSBNYXRoLmNlaWwodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IE1hdGguY2VpbCh0aGlzLl95KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIGFyZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUuXG4gICAqIEBtZXRob2Qgcm91bmRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICByb3VuZCgpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5yb3VuZCh0aGlzLl94KTtcbiAgICB0aGlzLl95ID0gTWF0aC5yb3VuZCh0aGlzLl95KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIGFyZSByb3VuZGVkIHRvd2FyZHMgemVybyAodXAgaWYgbmVnYXRpdmUsIGRvd25cbiAgICogaWYgcG9zaXRpdmUpIHRvIGFuIGludGVnZXIgdmFsdWUuXG4gICAqIEBtZXRob2Qgcm91bmRUb1plcm9cbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICByb3VuZFRvWmVybygpIHtcbiAgICB0aGlzLl94ID0gKHRoaXMuX3ggPCAwKSA/IE1hdGguY2VpbCh0aGlzLl94KSA6IE1hdGguZmxvb3IodGhpcy5feCk7XG4gICAgdGhpcy5feSA9ICh0aGlzLl95IDwgMCkgPyBNYXRoLmNlaWwodGhpcy5feSkgOiBNYXRoLmZsb29yKHRoaXMuX3kpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludmVydHMgdGhpcyB2ZWN0b3IgLSBpLmUuIHNldHMgYHggPSAteGAgYW5kIGB5ID0gLXlgLlxuICAgKiBAbWV0aG9kIG5lZ2F0ZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICB0aGlzLl94ID0gLXRoaXMuX3g7XG4gICAgdGhpcy5feSA9IC10aGlzLl95O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgW2RvdCBwcm9kdWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3RfcHJvZHVjdCkgb2ZcbiAgICogdGhpcyB2ZWN0b3IgYW5kIGB2YC5cbiAgICogQG1ldGhvZCBkb3RcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkb3Qodikge1xuICAgIHJldHVybiAodGhpcy5feCAqIHYueCkgKyAodGhpcy5feSAqIHYueSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGVcbiAgICogW0V1Y2xpZGVhbiBsZW5ndGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSlcbiAgICogKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tIGAoMCwgMClgIHRvIGAoeCwgeSlgLiBJZiB5b3UgYXJlIGNvbXBhcmluZyB0aGVcbiAgICogbGVuZ3RocyBvZiB2ZWN0b3JzLCB5b3Ugc2hvdWxkIGNvbXBhcmUgdGhlIGxlbmd0aCBzcXVhcmVkIGluc3RlYWQgYXMgaXQgaXNcbiAgICogc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdG8gY2FsY3VsYXRlLlxuICAgKiBAbWV0aG9kIGxlbmd0aFNxXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3ggKiB0aGlzLl94KSArICh0aGlzLl95ICogdGhpcy5feSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbSBgKDAsIDApYCB0byBgKHgsIHkpYC5cbiAgICogQG1ldGhvZCBsZW5ndGhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh0aGlzLl94ICogdGhpcy5feCkgKyAodGhpcy5feSAqIHRoaXMuX3kpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGVcbiAgICogW01hbmhhdHRhbiBsZW5ndGhdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGF4aWNhYl9nZW9tZXRyeSkgb2YgdGhpc1xuICAgKiB2ZWN0b3IuXG4gICAqIEBtZXRob2QgbGVuZ3RoTWFuaGF0dGFuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGhNYW5oYXR0YW4oKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuX3gpICsgTWF0aC5hYnModGhpcy5feSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIHZlY3RvciB0byBiZSBhXG4gICAqIFt1bml0IHZlY3Rvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdF92ZWN0b3IpIC0gdGhhdCBpcywgc2V0cyBpdFxuICAgKiBlcXVhbCB0byB0aGUgdmVjdG9yIHdpdGggdGhlIHNhbWUgZGlyZWN0aW9uIGFzIHRoaXMgb25lLCBidXRcbiAgICoge0BsaW5rIFZlY3RvcjIjbGVuZ3RofSAxLlxuICAgKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb2YgdGhpcyB2ZWN0b3Igd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZVxuICAgKiB4LWF4aXMuXG4gICAqIEBtZXRob2QgYW5nbGVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGFuZ2xlKCkge1xuICAgIGxldCBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5feSwgdGhpcy5feCk7XG5cbiAgICBpZiAoYW5nbGUgPCAwKSBhbmdsZSArPSAyICogTWF0aC5QSTtcbiAgICByZXR1cm4gYW5nbGU7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhpcyB2ZWN0b3IgdG8gYHZgLlxuICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9cbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkaXN0YW5jZVRvKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhpcyB2ZWN0b3IgdG8gYHZgLiBJZiB5b3UgYXJlIGp1c3RcbiAgICogY29tcGFyaW5nIHRoZSBkaXN0YW5jZSB3aXRoIGFub3RoZXIgZGlzdGFuY2UsIHlvdSBzaG91bGQgY29tcGFyZSB0aGVcbiAgICogZGlzdGFuY2Ugc3F1YXJlZCBpbnN0ZWFkIGFzIGl0IGlzIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50IHRvIGNhbGN1bGF0ZS5cbiAgICogQG1ldGhvZCBkaXN0YW5jZVRvU3F1YXJlZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRpc3RhbmNlVG9TcXVhcmVkKHYpIHtcbiAgICBjb25zdCBkeCA9IHRoaXMuX3ggLSB2Lng7XG4gICAgY29uc3QgZHkgPSB0aGlzLl95IC0gdi55O1xuXG4gICAgcmV0dXJuIChkeCAqIGR4KSArIChkeSAqIGR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGVcbiAgICogW01hbmhhdHRhbiBkaXN0YW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGF4aWNhYl9nZW9tZXRyeSlcbiAgICogZnJvbSB0aGlzIHZlY3RvciB0byBgdmAuXG4gICAqIEBtZXRob2QgZGlzdGFuY2VUb01hbmhhdHRhblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRpc3RhbmNlVG9NYW5oYXR0YW4odikge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLl94IC0gdi54KSArIE1hdGguYWJzKHRoaXMuX3kgLSB2LnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IgdG8gdGhlIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0XG4gICAqIHtAbGluayBWZWN0b3IyI2xlbmd0aH0gYGxlbmd0aGAuXG4gICAqIEBtZXRob2Qgc2V0TGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBzZXRMZW5ndGgobGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIobGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogTGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgYHZgLCB3aGVyZSBgYWxwaGFgIGlzIHRoZVxuICAgKiBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSAtIGBhbHBocSA9IDBgIHdpbGwgYmUgdGhpcyB2ZWN0b3IsIGFuZCBgYWxwaGEgPSAxYFxuICAgKiB3aWxsIGJlIGB2YC5cbiAgICogQG1ldGhvZCBsZXJwXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYge0BsaW5rIFZlY3RvcjJ9IHRvIGludGVycG9sYXRlIHRvd2FyZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSBJbnRlcnBvbGF0aW9uIGZhY3RvciBpbiB0aGUgY2xvc2VkIGludGVydmFsIGBbMCwgMV1gLlxuICAgKi9cbiAgbGVycCh2LCBhbHBoYSkge1xuICAgIHRoaXMuX3ggKz0gKHYueCAtIHRoaXMuX3gpICogYWxwaGE7XG4gICAgdGhpcy5feSArPSAodi55IC0gdGhpcy5feSkgKiBhbHBoYTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGJlIHRoZSB2ZWN0b3IgbGluZWFybHkgaW50ZXJwb2xhdGVkIGJldHdlZW4gYHYxYCBhbmRcbiAgICogYHYyYCB3aGVyZSBgYWxwaGFgIGlzIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSBjb25uZWN0aW5nIHRoZSB0d29cbiAgICogdmVjdG9ycyAtIGBhbHBoYSA9IDBgIHdpbGwgYmUgYHYxYCwgYW5kIGBhbHBoYSA9IDFgIHdpbGwgYmUgYHYyYC5cbiAgICogQG1ldGhvZCBsZXJwVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2MSBUaGUgc3RhcnRpbmcge0BsaW5rIFZlY3RvcjJ9LlxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyIHtAbGluayBWZWN0b3IyfSB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICovXG4gIGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYyLCB2MSkubXVsdGlwbHlTY2FsYXIoYWxwaGEpLmFkZCh2MSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciBzdHJpY3QgZXF1YWxpdHkgb2YgdGhpcyB2ZWN0b3IgYW5kIGB2YC5cbiAgICogQG1ldGhvZCBlcXVhbHNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHZcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyh2KSB7XG4gICAgcmV0dXJuICh2LnggPT09IHRoaXMuX3gpICYmICh2LnkgPT09IHRoaXMuX3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSB0byBiZSBgYXJyYXlbMCArIG9mZnNldF1gIGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMiN5fSB0byBiZSBgYXJyYXlbMSArIG9mZnNldF1gLlxuICAgKiBAbWV0aG9kIGZyb21BcnJheVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7QXJyYXl9IGFycmF5IFRoZSBzb3VyY2UgYXJyYXkuXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBPZmZzZXQgaW50byB0aGUgYXJyYXkuXG4gICAqL1xuICBmcm9tQXJyYXkoYXJyYXksIG9mZnNldCA9IDApIHtcbiAgICB0aGlzLl94ID0gYXJyYXlbb2Zmc2V0XTtcbiAgICB0aGlzLl95ID0gYXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBgW3gsIHldYCwgb3IgY29waWVzIG9mIHtAbGluayBWZWN0b3IyI3h9IGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMiN5fSBpbnRvIHRoZSBwcm92aWRlZCBgYXJyYXlgLlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge251bWJlcltdfSBbYXJyYXk9W11dICBBcnJheSB0byBzdG9yZSB0aGUgdmVjdG9yIHRvLiBJZiB0aGlzIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBhcnJheSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBPcHRpb25hbCBvZmZzZXQgaW50byB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgKi9cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgYXJyYXlbb2Zmc2V0XSA9IHRoaXMuX3g7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGUgdGhlIHZlY3RvciBhcm91bmQgYGNlbnRlcmAgYnkgYGFuZ2xlYCBpbiByYWRpYW5zLlxuICAgKiBAbWV0aG9kIHJvdGF0ZUFyb3VuZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBjZW50ZXIgVGhlIHBvaW50IGFyb3VuZCB3aGljaCB0byByb3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlLCBpbiByYWRpYW5zLlxuICAgKi9cbiAgcm90YXRlQXJvdW5kKGNlbnRlciwgYW5nbGUpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgeCA9IHRoaXMuX3ggLSBjZW50ZXIueDtcbiAgICBjb25zdCB5ID0gdGhpcy5feSAtIGNlbnRlci55O1xuXG4gICAgdGhpcy5feCA9ICh4ICogYykgLSAoeSAqIHMpICsgY2VudGVyLng7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgdGhpcy5feSA9ICh4ICogcykgKyAoeSAqIGMpICsgY2VudGVyLnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9NYXRoJztcbi8vIGltcG9ydCBNYXRyaXg0IGZyb20gJy4vTWF0cml4NCc7XG5pbXBvcnQgUXVhdGVybmlvbiBmcm9tICcuL1F1YXRlcm5pb24nO1xuLy8gaW1wb3J0IEV1bGVyIGZyb20gJy4vRXVsZXInO1xuLy8gaW1wb3J0IENhbWVyYSBmcm9tICcuLi9jYW1lcmEvQ2FtZXJhJztcblxuLy8gY29uc3RhbnRzIGZvciBvcHRpbWlzYXRpb25cbmxldCBhcHBseUV1bGVyUTtcbmxldCBhcHBseUF4aXNBbmdsZVE7XG4vLyBsZXQgcHJvamVjdE07XG4vLyBsZXQgdW5wcm9qZWN0TTtcbmxldCBwcm9qZWN0T25QbGFuZVY7XG5sZXQgcmVmbGVjdFY7XG5cbi8vIGxldCB0aGlzLl94ID0gMCwgdGhpcy5feSA9IDAsIHRoaXMuX3ogPSAwO1xubGV0IG9uQ2hhbmdlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcbmNvbnN0IF9pc1ZlY3RvcjMgPSB0cnVlO1xuXG4vKipcbiAqIEBjbGFzcyBWZWN0b3IzXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAzRCBbdmVjdG9yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3Jfc3BhY2UpLlxuICogQSAzRCB2ZWN0b3IgaXMgYW4gb3JkZXJlZCB0cmlwbGV0IG9mIG51bWJlcnMgKGxhYmVsZWQgYHhgLCBgeWAsIGFuZCBgemApLFxuICogd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGEgbnVtYmVyIG9mIHRoaW5ncywgc3VjaCBhczpcbiAqICogQSBwb2ludCBpbiAzRCBzcGFjZS5cbiAqICogQSBkaXJlY3Rpb24gYW5kIGxlbmd0aCBpbiAzRCBzcGFjZS4gRm9yIExldHNlZSwgdGhlIGxlbmd0aCB3aWxsIGFsd2F5cyBiZVxuICogdGhlIFtFdWNsaWRlYW4gZGlzdGFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSlcbiAqIChzdHJhaWdodC1saW5lIGRpc3RhbmNlKSBmcm9tIGAoMCwgMCwgMClgIHRvIGAoeCwgeSwgeilgIGFuZCB0aGUgZGlyZWN0aW9uIGlzXG4gKiBhbHNvIG1lYXN1cmVkIGZyb20gYCgwLCAwLCAwKWAgdG93YXJkcyBgKHgsIHksIHopYC5cbiAqICogQW55IGFyYml0cmFyeSBvcmRlcmVkIHRyaXBsZXQgb2YgbnVtYmVycy5cbiAqIFRoZXJlIGFyZSBvdGhlciB0aGluZ3MgYSAzRCB2ZWN0b3IgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50LCBzdWNoIGFzIG1vbWVudHVtXG4gKiB2ZWN0b3JzIGFuZCBzbyBvbiwgaG93ZXZlciB0aGVzZSBhcmUgdGhlIG1vc3QgY29tbW9uIHVzZXMuXG4gKiBAZXhhbXBsZVxuICogdmFyIGEgPSBuZXcgVmVjdG9yMygwLCAxLCAwKTtcbiAqXG4gKiAvLyBubyBhcmd1bWVudHM7IHdpbGwgYmUgaW5pdGlhbGlzZWQgdG8gKDAsIDAsIDApXG4gKiB2YXIgYiA9IG5ldyBWZWN0b3IzKCk7XG4gKlxuICogdmFyIGQgPSBhLmRpc3RhbmNlVG8oYik7XG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gVGhlIHggdmFsdWUgb2YgdGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSBUaGUgeSB2YWx1ZSBvZiB0aGUgdmVjdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFt6PTBdIFRoZSB6IHZhbHVlIG9mIHRoZSB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcjMge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciB7bnVtYmVyfSB4XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge251bWJlcn0geVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMyNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cblxuICBzZXQgeSh2YWx1ZSkge1xuICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHpcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB6KCkge1xuICAgIHJldHVybiB0aGlzLl96O1xuICB9XG5cbiAgc2V0IHoodmFsdWUpIHtcbiAgICB0aGlzLl96ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICBnZXQgaXNWZWN0b3IzKCkge1xuICAgIHJldHVybiBfaXNWZWN0b3IzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kIHtAbGluayBWZWN0b3IzI3p9XG4gICAqIGNvbXBvbmVudHMgb2YgdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge251bWJlcn0gelxuICAgKi9cbiAgc2V0KHgsIHksIHopIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIGFuZCB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZXNcbiAgICogb2YgdGhpcyB2ZWN0b3IgYWxsIGVxdWFsIHRvIGBzY2FsYXJgLlxuICAgKiBAbWV0aG9kIHNldFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgKi9cbiAgc2V0U2NhbGFyKHNjYWxhcikge1xuICAgIHRoaXMuX3ggPSBzY2FsYXI7XG4gICAgdGhpcy5feSA9IHNjYWxhcjtcbiAgICB0aGlzLl96ID0gc2NhbGFyO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSB2YWx1ZSB3aXRoIGB4YC5cbiAgICogQG1ldGhvZCBzZXRYXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKi9cbiAgc2V0WCh4KSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3l9IHZhbHVlIHdpdGggYHlgLlxuICAgKiBAbWV0aG9kIHNldFlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqL1xuICBzZXRZKHkpIHtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjen0gdmFsdWUgd2l0aCBgemAuXG4gICAqIEBtZXRob2Qgc2V0WlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICovXG4gIHNldFooeikge1xuICAgIHRoaXMuX3ogPSB6O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGBpbmRleGAgZXF1YWxzIGAwYCBzZXQge0BsaW5rIFZlY3RvcjMjeH0gdG8gYHZhbHVlYC5cbiAgICogSWYgYGluZGV4YCBlcXVhbHMgYDFgIHNldCB7QGxpbmsgVmVjdG9yMyN5fSB0byBgdmFsdWVgLlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyBgMmAgc2V0IHtAbGluayBWZWN0b3IzI3p9IHRvIGB2YWx1ZWAuXG4gICAqIEBtZXRob2Qgc2V0Q29tcG9uZW50XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gezB8MXwyfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHNldENvbXBvbmVudChpbmRleCA9IDAgfCAxIHwgMiwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy5feiA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGV4IGlzIG91dCBvZiByYW5nZTogJHtpbmRleH1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyBgMGAgcmV0dXJucyB0aGUge0BsaW5rIFZlY3RvcjMjeH0gdmFsdWUuXG4gICAqIElmIGBpbmRleGAgZXF1YWxzIGAxYCByZXR1cm5zIHRoZSB7QGxpbmsgVmVjdG9yMyN5fSB2YWx1ZS5cbiAgICogSWYgYGluZGV4YCBlcXVhbHMgYDJgIHJldHVybnMgdGhlIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlLlxuICAgKiBAbWV0aG9kIGdldENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHswfDF8Mn0gaW5kZXhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q29tcG9uZW50KGluZGV4ID0gMCB8IDEgfCAyKSB7XG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLl96O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICR7aW5kZXh9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcge0BsaW5rIFZlY3RvcjN9IHdpdGggdGhlIHNhbWUge0BsaW5rIFZlY3RvcjMjeH0sXG4gICAqIHtAbGluayBWZWN0b3IzI3l9LCBhbmQge0BsaW5rIFZlY3RvcjMjen0gdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtWZWN0b3IzfVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBwYXNzZWQge0BsaW5rIFZlY3RvcjN9J3Mge0BsaW5rIFZlY3RvcjMjeH0sXG4gICAqIHtAbGluayBWZWN0b3IzI3l9LCBhbmQge0BsaW5rIFZlY3RvcjMjen0gcHJvcGVydGllcyB0byB0aGlzIHZlY3Rvci5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIGNvcHkodikge1xuICAgIHRoaXMuX3ggPSB2Lng7XG4gICAgdGhpcy5feSA9IHYueTtcbiAgICB0aGlzLl96ID0gdi56O1xuICAgIC8vIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYHZgIHRvIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBhZGQodikge1xuICAgIHRoaXMuX3ggKz0gdi54O1xuICAgIHRoaXMuX3kgKz0gdi55O1xuICAgIHRoaXMuX3ogKz0gdi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNjYWxhciB2YWx1ZSBgc2AgdG8gdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSxcbiAgICoge0BsaW5rIFZlY3RvcjMjeX0sIGFuZCB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZXMuXG4gICAqIEBtZXRob2QgYWRkU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgKi9cbiAgYWRkU2NhbGFyKHMpIHtcbiAgICB0aGlzLl94ICs9IHM7XG4gICAgdGhpcy5feSArPSBzO1xuICAgIHRoaXMuX3ogKz0gcztcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGBhICsgYmAuXG4gICAqIEBtZXRob2QgYWRkVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYlxuICAgKi9cbiAgYWRkVmVjdG9ycyhhLCBiKSB7XG4gICAgdGhpcy5feCA9IGEueCArIGIueDtcbiAgICB0aGlzLl95ID0gYS55ICsgYi55O1xuICAgIHRoaXMuX3ogPSBhLnogKyBiLno7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgbXVsdGlwbGUgb2YgYHZgIGFuZCBgc2AgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgYWRkU2NhbGVkVmVjdG9yXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGFkZFNjYWxlZFZlY3Rvcih2LCBzKSB7XG4gICAgdGhpcy5feCArPSB2LnggKiBzO1xuICAgIHRoaXMuX3kgKz0gdi55ICogcztcbiAgICB0aGlzLl96ICs9IHYueiAqIHM7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIGB2YCBmcm9tIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIHN1YlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBzdWIodikge1xuICAgIHRoaXMuX3ggLT0gdi54O1xuICAgIHRoaXMuX3kgLT0gdi55O1xuICAgIHRoaXMuX3ogLT0gdi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyBgc2AgZnJvbSB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kXG4gICAqIHtAbGluayBWZWN0b3IzI3p9IGNvbXBvbmVudHMuXG4gICAqIEBtZXRob2Qgc3ViU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgKi9cbiAgc3ViU2NhbGFyKHMpIHtcbiAgICB0aGlzLl94IC09IHM7XG4gICAgdGhpcy5feSAtPSBzO1xuICAgIHRoaXMuX3ogLT0gcztcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGBhIC0gYmAuXG4gICAqIEBtZXRob2Qgc3ViVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYlxuICAgKi9cbiAgc3ViVmVjdG9ycyhhLCBiKSB7XG4gICAgdGhpcy5feCA9IGEueCAtIGIueDtcbiAgICB0aGlzLl95ID0gYS55IC0gYi55O1xuICAgIHRoaXMuX3ogPSBhLnogLSBiLno7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciBieSBgdmAuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgbXVsdGlwbHkodikge1xuICAgIHRoaXMuX3ggKj0gdi54O1xuICAgIHRoaXMuX3kgKj0gdi55O1xuICAgIHRoaXMuX3ogKj0gdi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgYnkgc2NhbGFyIGBzYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIG11bHRpcGx5U2NhbGFyKHMpIHtcbiAgICB0aGlzLl94ICo9IHM7XG4gICAgdGhpcy5feSAqPSBzO1xuICAgIHRoaXMuX3ogKj0gcztcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIGVxdWFsIHRvIGBhIMOXIGJgLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5VmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYlxuICAgKi9cbiAgbXVsdGlwbHlWZWN0b3JzKGEsIGIpIHtcbiAgICB0aGlzLl94ID0gYS54ICogYi54O1xuICAgIHRoaXMuX3kgPSBhLnkgKiBiLnk7XG4gICAgdGhpcy5feiA9IGEueiAqIGIuejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGV1bGVyIHRyYW5zZm9ybSB0byB0aGlzIHZlY3RvciBieSBjb252ZXJ0aW5nIHRoZSB7QGxpbmsgRXVsZXJ9XG4gICAqIG9iamVjdCB0byBhIHtAbGluayBRdWF0ZXJuaW9ufSBhbmQgYXBwbHlpbmcuXG4gICAqIEBtZXRob2QgYXBwbHlFdWxlclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtFdWxlcn0gZXVsZXJcbiAgICovXG4gIGFwcGx5RXVsZXIoZXVsZXIpIHtcbiAgICBpZiAodHlwZW9mIGFwcGx5RXVsZXJRID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYXBwbHlFdWxlclEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihhcHBseUV1bGVyUS5zZXRGcm9tRXVsZXIoZXVsZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgcm90YXRpb24gc3BlY2lmaWVkIGJ5IGFuIGBheGlzYCBhbmQgYW4gYGFuZ2xlYCB0byB0aGlzIHZlY3Rvci5cbiAgICogQG1ldGhvZCBhcHBseUF4aXNBbmdsZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBheGlzIEEgbm9ybWFsaXplZCB7QGxpbmsgVmVjdG9yM30uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBBbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgYXBwbHlBeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcbiAgICBpZiAodHlwZW9mIGFwcGx5QXhpc0FuZ2xlUSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFwcGx5QXhpc0FuZ2xlUSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKGFwcGx5QXhpc0FuZ2xlUS5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSk7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciAod2l0aCBhbiBpbXBsaWNpdCBgMWAgaW4gdGhlIDR0aCBkaW1lbnNpb24pIGFuZCBgbWAsXG4gICAqIGFuZCBkaXZpZGVzIGJ5IHBlcnNwZWN0aXZlLlxuICAgKiBAbWV0aG9kIGFwcGx5TWF0cml4NFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBhcHBseU1hdHJpeDQobSkge1xuICAgIGNvbnN0IHggPSB0aGlzLl94O1xuICAgIGNvbnN0IHkgPSB0aGlzLl95O1xuICAgIGNvbnN0IHogPSB0aGlzLl96O1xuICAgIGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy5feCA9IChlWzBdICogeCkgKyAoZVs0XSAqIHkpICsgKGVbOF0gKiB6KSArIGVbMTJdO1xuICAgIHRoaXMuX3kgPSAoZVsxXSAqIHgpICsgKGVbNV0gKiB5KSArIChlWzldICogeikgKyBlWzEzXTtcbiAgICB0aGlzLl96ID0gKGVbMl0gKiB4KSArIChlWzZdICogeSkgKyAoZVsxMF0gKiB6KSArIGVbMTRdO1xuICAgIGNvbnN0IHcgPSAoZVszXSAqIHgpICsgKGVbN10gKiB5KSArIChlWzExXSAqIHopICsgZVsxNV07XG5cbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodyk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIHtAbGluayBRdWF0ZXJuaW9ufSB0cmFuc2Zvcm0gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgYXBwbHlRdWF0ZXJuaW9uXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAgICovXG4gIGFwcGx5UXVhdGVybmlvbihxKSB7XG4gICAgY29uc3QgeCA9IHRoaXMuX3g7XG4gICAgY29uc3QgeSA9IHRoaXMuX3k7XG4gICAgY29uc3QgeiA9IHRoaXMuX3o7XG4gICAgY29uc3QgcXggPSBxLng7XG4gICAgY29uc3QgcXkgPSBxLnk7XG4gICAgY29uc3QgcXogPSBxLno7XG4gICAgY29uc3QgcXcgPSBxLnc7XG5cbiAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxuICAgIGNvbnN0IGl4ID0gKHF3ICogeCkgKyAocXkgKiB6KSAtIChxeiAqIHkpO1xuICAgIGNvbnN0IGl5ID0gKHF3ICogeSkgKyAocXogKiB4KSAtIChxeCAqIHopO1xuICAgIGNvbnN0IGl6ID0gKHF3ICogeikgKyAocXggKiB5KSAtIChxeSAqIHgpO1xuICAgIGNvbnN0IGl3ID0gKC1xeCAqIHgpIC0gKHF5ICogeSkgLSAocXogKiB6KTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICB0aGlzLl94ID0gKGl4ICogcXcpICsgKGl3ICogLXF4KSArIChpeSAqIC1xeikgLSAoaXogKiAtcXkpO1xuICAgIHRoaXMuX3kgPSAoaXkgKiBxdykgKyAoaXcgKiAtcXkpICsgKGl6ICogLXF4KSAtIChpeCAqIC1xeik7XG4gICAgdGhpcy5feiA9IChpeiAqIHF3KSArIChpdyAqIC1xeikgKyAoaXggKiAtcXkpIC0gKGl5ICogLXF4KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBbUHJvamVjdHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9wcm9qZWN0aW9uKSB0aGUgdmVjdG9yXG4gICAqIHdpdGggdGhlIGBjYW1lcmFgLlxuICAgKiBAbWV0aG9kIHByb2plY3RcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgQ2FtZXJhIHRvIHVzZSBpbiB0aGUgcHJvamVjdGlvbi5cbiAgICovXG4gIHByb2plY3QoY2FtZXJhKSB7XG4gICAgLy8gaWYgKHR5cGVvZiBwcm9qZWN0TSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyAgIHByb2plY3RNID0gbmV3IE1hdHJpeDQoKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyBwcm9qZWN0TS5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBwcm9qZWN0TS5nZXRJbnZlcnNlKGNhbWVyYS5tYXRyaXhXb3JsZCkpO1xuICAgIC8vIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChwcm9qZWN0TSk7XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbVW5wcm9qZWN0c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX3Byb2plY3Rpb24pIHRoZSB2ZWN0b3JcbiAgICogd2l0aCB0aGUgYGNhbWVyYWAncyBwcm9qZWN0aW9uIG1hdHJpeC5cbiAgICogQG1ldGhvZCB1bnByb2plY3RcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Q2FtZXJhfSBjYW1lcmEgQ2FtZXJhIHRvIHVzZSBpbiB0aGUgcHJvamVjdGlvbi5cbiAgICovXG4gIHVucHJvamVjdChjYW1lcmEpIHtcbiAgICAvLyBpZiAodHlwZW9mIHVucHJvamVjdE0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gICB1bnByb2plY3RNID0gbmV3IE1hdHJpeDQoKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyB1bnByb2plY3RNLm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLm1hdHJpeFdvcmxkLCB1bnByb2plY3RNLmdldEludmVyc2UoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpKTtcbiAgICAvLyByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodW5wcm9qZWN0TSk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgZGlyZWN0aW9uIG9mIHRoaXMgdmVjdG9yIGJ5IGEgbWF0cml4ICh0aGUgdXBwZXIgbGVmdCAzIHggM1xuICAgKiBzdWJzZXQgb2YgdGhlIGBtYCkgYW5kIHRoZW4gW25vcm1hbGl6ZXNde0BsaW5rIFZlY3RvcjMjbm9ybWFsaXplfSB0aGVcbiAgICogcmVzdWx0LlxuICAgKiBAbWV0aG9kIHRyYW5zZm9ybURpcmVjdGlvblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICB0cmFuc2Zvcm1EaXJlY3Rpb24obSkge1xuICAgIC8vIGlucHV0IGFmZmluZSBtYXRyaXhcbiAgICAvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cbiAgICBjb25zdCB4ID0gdGhpcy5feDtcbiAgICBjb25zdCB5ID0gdGhpcy5feTtcbiAgICBjb25zdCB6ID0gdGhpcy5fejtcbiAgICBjb25zdCBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMuX3ggPSAoZVswXSAqIHgpICsgKGVbNF0gKiB5KSArIChlWzhdICogeik7XG4gICAgdGhpcy5feSA9IChlWzFdICogeCkgKyAoZVs1XSAqIHkpICsgKGVbOV0gKiB6KTtcbiAgICB0aGlzLl96ID0gKGVbMl0gKiB4KSArIChlWzZdICogeSkgKyAoZVsxMF0gKiB6KTtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIGJ5IGB2YC5cbiAgICogQG1ldGhvZCBkaXZpZGVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgZGl2aWRlKHYpIHtcbiAgICB0aGlzLl94IC89IHYueDtcbiAgICB0aGlzLl95IC89IHYueTtcbiAgICB0aGlzLl96IC89IHYuejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIGJ5IHNjYWxhciBgc2AuIFNldHMgdmVjdG9yIHRvIGAoMCwgMCwgMClgIGlmIGBzID0gMGAuXG4gICAqIEBtZXRob2QgZGl2aWRlU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gc1xuICAgKi9cbiAgZGl2aWRlU2NhbGFyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gcyk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yIHtAbGluayBWZWN0b3IzI3p9XG4gICAqIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBgdmAncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yXG4gICAqIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtaW5cbiAgICogdmFsdWUuXG4gICAqIEBtZXRob2QgbWluXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIG1pbih2KSB7XG4gICAgdGhpcy5feCA9IE1hdGgubWluKHRoaXMuX3gsIHYueCk7XG4gICAgdGhpcy5feSA9IE1hdGgubWluKHRoaXMuX3ksIHYueSk7XG4gICAgdGhpcy5feiA9IE1hdGgubWluKHRoaXMuX3osIHYueik7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yIHtAbGluayBWZWN0b3IzI3p9XG4gICAqIHZhbHVlIGlzIGxlc3MgdGhhbiBgdmAncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yXG4gICAqIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBtYXhcbiAgICogdmFsdWUuXG4gICAqIEBtZXRob2QgbWF4XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIG1heCh2KSB7XG4gICAgdGhpcy5feCA9IE1hdGgubWF4KHRoaXMuX3gsIHYueCk7XG4gICAgdGhpcy5feSA9IE1hdGgubWF4KHRoaXMuX3ksIHYueSk7XG4gICAgdGhpcy5feiA9IE1hdGgubWF4KHRoaXMuX3osIHYueik7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yIHtAbGluayBWZWN0b3IzI3p9XG4gICAqIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYG1heGAgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sXG4gICAqIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnkgdGhlXG4gICAqIGNvcnJlc3BvbmRpbmcgdmFsdWUuIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LFxuICAgKiBvciB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIGBtaW5gIHZlY3RvcidzXG4gICAqIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSwgb3Ige0BsaW5rIFZlY3RvcjMjen0gdmFsdWUsIGl0IGlzXG4gICAqIHJlcGxhY2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNsYW1wXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IG1pblxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IG1heFxuICAgKi9cbiAgY2xhbXAobWluLCBtYXgpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuICAgIHRoaXMuX3ggPSBNYXRoLm1heChtaW4ueCwgTWF0aC5taW4obWF4LngsIHRoaXMuX3gpKTtcbiAgICB0aGlzLl95ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLl95KSk7XG4gICAgdGhpcy5feiA9IE1hdGgubWF4KG1pbi56LCBNYXRoLm1pbihtYXgueiwgdGhpcy5feikpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiB2YWx1ZXMgYXJlIGdyZWF0ZXIgdGhhbiB0aGUgYG1heGAgdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBgbWF4YCB2YWx1ZS5cbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yIHtAbGluayBWZWN0b3IzI3p9XG4gICAqIHZhbHVlcyBhcmUgbGVzcyB0aGFuIHRoZSBgbWluYCB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnkgdGhlIGBtaW5gIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNsYW1wU2NhbGFyXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBjb21wb25lbnRzIHdpbGwgYmUgY2xhbXBlZCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGNsYW1wZWQgdG8uXG4gICAqL1xuICBjbGFtcFNjYWxhcihtaW4sIG1heCkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG4gICAgdGhpcy5feCA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB0aGlzLl94KSk7XG4gICAgdGhpcy5feSA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB0aGlzLl95KSk7XG4gICAgdGhpcy5feiA9IE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB0aGlzLl96KSk7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoZSBgbWF4YCB2YWx1ZSwgaXQgaXMgcmVwbGFjZWQgYnlcbiAgICogdGhlIGBtYXhgIHZhbHVlLiBJZiB0aGlzIHZlY3RvcidzIGxlbmd0aCBpcyBsZXNzIHRoYW4gdGhlIGBtaW5gIHZhbHVlLCBpdFxuICAgKiBpcyByZXBsYWNlZCBieSB0aGUgYG1pbmAgdmFsdWUuXG4gICAqIEBtZXRob2QgY2xhbXBMZW5ndGhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdGhlIGxlbmd0aCB3aWxsIGJlIGNsYW1wZWQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgdGhlIGxlbmd0aCB3aWxsIGJlIGNsYW1wZWQgdG8uXG4gICAqL1xuICBjbGFtcExlbmd0aChtaW4sIG1heCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkgLyBsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIGZsb29yXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKi9cbiAgZmxvb3IoKSB7XG4gICAgdGhpcy5feCA9IE1hdGguZmxvb3IodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IE1hdGguZmxvb3IodGhpcy5feSk7XG4gICAgdGhpcy5feiA9IE1hdGguZmxvb3IodGhpcy5feik7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kIHtAbGluayBWZWN0b3IzI3p9IGNvbXBvbmVudHNcbiAgICogb2YgdGhlIHZlY3RvciBhcmUgcm91bmRlZCB1cCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNlaWxcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqL1xuICBjZWlsKCkge1xuICAgIHRoaXMuX3ggPSBNYXRoLmNlaWwodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IE1hdGguY2VpbCh0aGlzLl95KTtcbiAgICB0aGlzLl96ID0gTWF0aC5jZWlsKHRoaXMuX3opO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgYXJlIHJvdW5kZWQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cbiAgICogQG1ldGhvZCByb3VuZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICovXG4gIHJvdW5kKCkge1xuICAgIHRoaXMuX3ggPSBNYXRoLnJvdW5kKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSBNYXRoLnJvdW5kKHRoaXMuX3kpO1xuICAgIHRoaXMuX3ogPSBNYXRoLnJvdW5kKHRoaXMuX3opO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgYXJlIHJvdW5kZWQgdG93YXJkcyB6ZXJvICh1cCBpZiBuZWdhdGl2ZSxcbiAgICogZG93biBpZiBwb3NpdGl2ZSkgdG8gYW4gaW50ZWdlciB2YWx1ZS5cbiAgICogQG1ldGhvZCByb3VuZFRvWmVyb1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICovXG4gIHJvdW5kVG9aZXJvKCkge1xuICAgIHRoaXMuX3ggPSB0aGlzLl94IDwgMCA/IE1hdGguY2VpbCh0aGlzLl94KSA6IE1hdGguZmxvb3IodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IHRoaXMuX3kgPCAwID8gTWF0aC5jZWlsKHRoaXMuX3kpIDogTWF0aC5mbG9vcih0aGlzLl95KTtcbiAgICB0aGlzLl96ID0gdGhpcy5feiA8IDAgPyBNYXRoLmNlaWwodGhpcy5feikgOiBNYXRoLmZsb29yKHRoaXMuX3opO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludmVydHMgdGhpcyB2ZWN0b3IgLSBpLmUuIHNldHMgYHggPSAteGAsIGB5ID0gLXlgLCBhbmQgYHogPSAtemAuXG4gICAqIEBtZXRob2QgbmVnYXRlXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKi9cbiAgbmVnYXRlKCkge1xuICAgIHRoaXMuX3ggPSAtdGhpcy5feDtcbiAgICB0aGlzLl95ID0gLXRoaXMuX3k7XG4gICAgdGhpcy5feiA9IC10aGlzLl96O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgW2RvdCBwcm9kdWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3RfcHJvZHVjdCkgb2ZcbiAgICogdGhpcyB2ZWN0b3IgYW5kIGB2YC5cbiAgICogQG1ldGhvZCBkb3RcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkb3Qodikge1xuICAgIHJldHVybiAodGhpcy5feCAqIHYueCkgKyAodGhpcy5feSAqIHYueSkgKyAodGhpcy5feiAqIHYueik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZSBvZiB0aGVcbiAgICogW0V1Y2xpZGVhbiBsZW5ndGhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSlcbiAgICogKHN0cmFpZ2h0LWxpbmUgbGVuZ3RoKSBmcm9tIGAoMCwgMCwgMClgIHRvIGAoeCwgeSwgeilgLiBJZiB5b3UgYXJlXG4gICAqIGNvbXBhcmluZyBsZW5ndGhzIG9mIHZlY3RvcnMsIHlvdSBzaG91bGQgY29tcGFyZSB0aGUgbGVuZ3RoIHNxdWFyZWRcbiAgICogaW5zdGVhZCBhcyBpdCBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUuXG4gICAqIEBtZXRob2QgbGVuZ3RoU3FcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aFNxKCkge1xuICAgIHJldHVybiAodGhpcy5feCAqIHRoaXMuX3gpICsgKHRoaXMuX3kgKiB0aGlzLl95KSArICh0aGlzLl96ICogdGhpcy5feik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbSBgKDAsIDAsIDApYCB0byBgKHgsIHksIHopYC5cbiAgICogQG1ldGhvZCBsZW5ndGhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh0aGlzLl94ICogdGhpcy5feCkgKyAodGhpcy5feSAqIHRoaXMuX3kpICsgKHRoaXMuX3ogKiB0aGlzLl96KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtNYW5oYXR0YW4gbGVuZ3RoXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheGljYWJfZ2VvbWV0cnkpIG9mIHRoaXNcbiAgICogdmVjdG9yLlxuICAgKiBAbWV0aG9kIGxlbmd0aE1hbmhhdHRhblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoTWFuaGF0dGFuKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLl94KSArIE1hdGguYWJzKHRoaXMuX3kpICsgTWF0aC5hYnModGhpcy5feik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIHZlY3RvciB0byBhXG4gICAqIFt1bml0IHZlY3Rvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdF92ZWN0b3IpIC0gdGhhdCBpcywgc2V0c1xuICAgKiBpdCBlcXVhbCB0byB0aGUgdmVjdG9yIHdpdGggdGhlIHNhbWUgZGlyZWN0aW9uIGFzIHRoaXMgb25lLCBidXRcbiAgICoge0BsaW5rIFZlY3RvcjMjbGVuZ3RofSBgMWAuXG4gICAqIEBtZXRob2Qgbm9ybWFsaXplXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIHRoZSB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhpcyBvbmUsIGJ1dFxuICAgKiB7QGxpbmsgVmVjdG9yMyNsZW5ndGh9IGBsZW5ndGhgLlxuICAgKiBAbWV0aG9kIHNldExlbmd0aFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGB2YCwgd2hlcmUgYGFscGhhYCBpcyB0aGVcbiAgICogZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgLSBgYWxwaGEgPSAwYCB3aWxsIGJlIHRoaXMgdmVjdG9yLCBhbmQgYGFscGhhID0gMWBcbiAgICogd2lsbCBiZSBgdmAuXG4gICAqIEBtZXRob2QgbGVycFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2IHtAbGluayBWZWN0b3IzfSB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICovXG4gIGxlcnAodiwgYWxwaGEpIHtcbiAgICB0aGlzLl94ICs9ICh2LnggLSB0aGlzLl94KSAqIGFscGhhO1xuICAgIHRoaXMuX3kgKz0gKHYueSAtIHRoaXMuX3kpICogYWxwaGE7XG4gICAgdGhpcy5feiArPSAodi56IC0gdGhpcy5feikgKiBhbHBoYTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGJlIHRoZSB2ZWN0b3IgbGluZWFybHkgaW50ZXJwb2xhdGVkIGJldHdlZW4gYHYxYCBhbmRcbiAgICogYHYyYCB3aGVyZSBgYWxwaGFgIGlzIHRoZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSBjb25uZWN0aW5nIHRoZSB0d29cbiAgICogdmVjdG9ycyAtIGBhbHBoYSA9IDBgIHdpbGwgYmUgYHYxYCwgYW5kIGBhbHBoYSA9IDFgIHdpbGwgYmUgYHYyYC5cbiAgICogQG1ldGhvZCBsZXJwVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2MSBUaGUgc3RhcnRpbmcge0BsaW5rIFZlY3RvcjN9LlxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHYyIHtAbGluayBWZWN0b3IzfSB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICovXG4gIGxlcnBWZWN0b3JzKHYxLCB2MiwgYWxwaGEpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKHYyLCB2MSkubXVsdGlwbHlTY2FsYXIoYWxwaGEpLmFkZCh2MSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0b1xuICAgKiBbY3Jvc3MgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3NfcHJvZHVjdCkgb2YgaXRzZWxmIGFuZFxuICAgKiBgdmAuXG4gICAqIEBtZXRob2QgY3Jvc3NcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgY3Jvc3Modikge1xuICAgIGNvbnN0IHggPSB0aGlzLl94O1xuICAgIGNvbnN0IHkgPSB0aGlzLl95O1xuICAgIGNvbnN0IHogPSB0aGlzLl96O1xuXG4gICAgdGhpcy5feCA9ICh5ICogdi56KSAtICh6ICogdi55KTtcbiAgICB0aGlzLl95ID0gKHogKiB2LngpIC0gKHggKiB2LnopO1xuICAgIHRoaXMuX3ogPSAoeCAqIHYueSkgLSAoeSAqIHYueCk7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0b1xuICAgKiBbY3Jvc3MgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3Jvc3NfcHJvZHVjdCkgb2YgYGFgIGFuZFxuICAgKiBgYmAuXG4gICAqIEBtZXRob2QgY3Jvc3NWZWN0b3JzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGFcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBiXG4gICAqL1xuICBjcm9zc1ZlY3RvcnMoYSwgYikge1xuICAgIGNvbnN0IGF4ID0gYS54O1xuICAgIGNvbnN0IGF5ID0gYS55O1xuICAgIGNvbnN0IGF6ID0gYS56O1xuICAgIGNvbnN0IGJ4ID0gYi54O1xuICAgIGNvbnN0IGJ5ID0gYi55O1xuICAgIGNvbnN0IGJ6ID0gYi56O1xuXG4gICAgdGhpcy5feCA9IChheSAqIGJ6KSAtIChheiAqIGJ5KTtcbiAgICB0aGlzLl95ID0gKGF6ICogYngpIC0gKGF4ICogYnopO1xuICAgIHRoaXMuX3ogPSAoYXggKiBieSkgLSAoYXkgKiBieCk7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogW1Byb2plY3RzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfcHJvamVjdGlvbikgdGhpcyB2ZWN0b3JcbiAgICogb250byBhbm90aGVyIGB2ZWN0b3JgLlxuICAgKiBAbWV0aG9kIHByb2plY3RPblZlY3RvclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2ZWN0b3JcbiAgICovXG4gIHByb2plY3RPblZlY3Rvcih2ZWN0b3IpIHtcbiAgICBjb25zdCBzY2FsYXIgPSB2ZWN0b3IuZG90KHRoaXMpIC8gdmVjdG9yLmxlbmd0aFNxKCk7XG5cbiAgICByZXR1cm4gdGhpcy5jb3B5KHZlY3RvcikubXVsdGlwbHlTY2FsYXIoc2NhbGFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbUHJvamVjdHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9wcm9qZWN0aW9uKSB0aGlzIHZlY3RvclxuICAgKiBvbnRvIGEgcGxhbmUgYnkgc3VidHJhY3RpbmcgdGhpcyB2ZWN0b3IgcHJvamVjdGVkIG9udG8gdGhlIHBsYW5lJ3Mgbm9ybWFsXG4gICAqIGZyb20gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgcHJvamVjdE9uUGxhbmVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gcGxhbmVOb3JtYWwgQSB2ZWN0b3IgcmVwcmVzZW50aW5nIGEgcGxhbmUgbm9ybWFsLlxuICAgKi9cbiAgcHJvamVjdE9uUGxhbmUocGxhbmVOb3JtYWwpIHtcbiAgICBpZiAodHlwZW9mIHByb2plY3RPblBsYW5lViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHByb2plY3RPblBsYW5lViA9IG5ldyBWZWN0b3IzKCk7XG4gICAgfVxuXG4gICAgcHJvamVjdE9uUGxhbmVWLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKHBsYW5lTm9ybWFsKTtcbiAgICByZXR1cm4gdGhpcy5zdWIocHJvamVjdE9uUGxhbmVWKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZsZWN0IHRoZSB2ZWN0b3Igb2ZmIG9mIHBsYW5lIG9ydGhvZ29uYWwgdG8gYG5vcm1hbGAuIGBub3JtYWxgIGlzXG4gICAqIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aC5cbiAgICogQG1ldGhvZCByZWZsZWN0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IG5vcm1hbCBUaGUgbm9ybWFsIHRvIHRoZSByZWZsZWN0aW5nIHBsYW5lLlxuICAgKi9cbiAgcmVmbGVjdChub3JtYWwpIHtcbiAgICBpZiAodHlwZW9mIHJlZmxlY3RWID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVmbGVjdFYgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN1YihyZWZsZWN0Vi5jb3B5KG5vcm1hbCkubXVsdGlwbHlTY2FsYXIoMiAqIHRoaXMuZG90KG5vcm1hbCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCB2ZWN0b3IgYHZgIGluIHJhZGlhbnMuXG4gICAqIEBtZXRob2QgYW5nbGVUb1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGFuZ2xlVG8odikge1xuICAgIGNvbnN0IHRoZXRhID0gdGhpcy5kb3QodikgLyAoTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSkpO1xuICAgIC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG4gICAgcmV0dXJuIE1hdGguYWNvcyhjbGFtcCh0aGV0YSwgLTEsIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIHZlY3RvciB0byBgdmAuXG4gICAqIEBtZXRob2QgZGlzdGFuY2VUb1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRpc3RhbmNlVG8odikge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHZlY3RvciB0byBgdmAuIElmIHlvdSBhcmUganVzdFxuICAgKiBjb21wYXJpbmcgdGhlIGRpc3RhbmNlIHdpdGggYW5vdGhlciBkaXN0YW5jZSwgeW91IHNob3VsZCBjb21wYXJlIHRoZVxuICAgKiBkaXN0YW5jZSBzcXVhcmVkIGluc3RlYWQgYXMgaXQgaXMgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdG8gY2FsY3VsYXRlLlxuICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9TcXVhcmVkXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZGlzdGFuY2VUb1NxdWFyZWQodikge1xuICAgIGNvbnN0IGR4ID0gdGhpcy5feCAtIHYueDtcbiAgICBjb25zdCBkeSA9IHRoaXMuX3kgLSB2Lnk7XG4gICAgY29uc3QgZHogPSB0aGlzLl96IC0gdi56O1xuICAgIHJldHVybiAoZHggKiBkeCkgKyAoZHkgKiBkeSkgKyAoZHogKiBkeik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtNYW5oYXR0YW4gZGlzdGFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheGljYWJfZ2VvbWV0cnkpIGZyb21cbiAgICogdGhpcyB2ZWN0b3IgdG8gYHZgLlxuICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9NYW5oYXR0YW5cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkaXN0YW5jZVRvTWFuaGF0dGFuKHYpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5feCAtIHYueCkgKyBNYXRoLmFicyh0aGlzLl95IC0gdi55KSArIE1hdGguYWJzKHRoaXMuX3ogLSB2LnopO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHZlY3RvciB0byB0aGUgcG9zaXRpb24gZWxlbWVudHMgb2YgdGhlXG4gICAqIFt0cmFuc2Zvcm0gbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc2Zvcm1hdGlvbl9tYXRyaXgpXG4gICAqIGBtYC5cbiAgICogQG1ldGhvZCBzZXRGcm9tTWF0cml4UG9zaXRpb25cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgc2V0RnJvbU1hdHJpeFBvc2l0aW9uKG0pIHtcbiAgICAvLyByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDMpO1xuXG4gICAgY29uc3QgZSA9IG0uZWxlbWVudHM7XG4gICAgdGhpcy5feCA9IGVbMTJdO1xuICAgIHRoaXMuX3kgPSBlWzEzXTtcbiAgICB0aGlzLl96ID0gZVsxNF07XG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIHRoZSBzY2FsZSBlbGVtZW50cyBvZiB0aGVcbiAgICogW3RyYW5zZm9ybSBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyYW5zZm9ybWF0aW9uX21hdHJpeClcbiAgICogYG1gLlxuICAgKiBAbWV0aG9kIHNldEZyb21NYXRyaXhTY2FsZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBzZXRGcm9tTWF0cml4U2NhbGUobSkge1xuICAgIGNvbnN0IHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDApLmxlbmd0aCgpO1xuICAgIGNvbnN0IHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDEpLmxlbmd0aCgpO1xuICAgIGNvbnN0IHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDIpLmxlbmd0aCgpO1xuICAgIHRoaXMuX3ggPSBzeDtcbiAgICB0aGlzLl95ID0gc3k7XG4gICAgdGhpcy5feiA9IHN6O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpOyAvLyBUT0RPIHJlZHVuZGFudFxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMyN6fSBlcXVhbCB0byB0aGUgY29sdW1uIG9mIHRoZSBgbWF0cml4YCBzcGVjaWZpZWQgYnkgdGhlXG4gICAqIGBpbmRleGAuXG4gICAqIEBtZXRob2Qgc2V0RnJvbU1hdHJpeENvbHVtblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgc2V0RnJvbU1hdHJpeENvbHVtbihtLCBpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmZyb21BcnJheShtLmVsZW1lbnRzLCBpbmRleCAqIDQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3Igc3RyaWN0IGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCBgdmAuXG4gICAqIEBtZXRob2QgZXF1YWxzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSB2XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHModikge1xuICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy5feCkgJiYgKHYueSA9PT0gdGhpcy5feSkgJiYgKHYueiA9PT0gdGhpcy5feikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSB2YWx1ZSB0byBiZSBgYXJyYXlbMCArIG9mZnNldF1gLFxuICAgKiB7QGxpbmsgVmVjdG9yMyN5fSB2YWx1ZSB0byBiZSBgYXJyYXlbMSArIG9mZnNldF1gLCB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZVxuICAgKiB0byBiZSBgYXJyYXlbMiArIG9mZnNldF1gLlxuICAgKiBAbWV0aG9kIGZyb21BcnJheVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyW119IGFycmF5ICBUaGUgc291cmNlIGFycmF5LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvZmZzZXQ9MF0gT2Zmc2V0IGludG8gdGhlIGFycmF5LlxuICAgKi9cbiAgZnJvbUFycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICB0aGlzLl94ID0gYXJyYXlbb2Zmc2V0ICsgMF07XG4gICAgdGhpcy5feSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgIHRoaXMuX3ogPSBhcnJheVtvZmZzZXQgKyAyXTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IGBbeCwgeSwgel1gLCBvciBjb3BpZXMge0BsaW5rIFZlY3RvcjMjeH0sXG4gICAqIHtAbGluayBWZWN0b3IzI3l9LCBhbmQge0BsaW5rIFZlY3RvcjMjen0gdmFsdWVzIGludG8gdGhlIHByb3ZpZGVkIGBhcnJheWAuXG4gICAqIEBtZXRob2QgdG9BcnJheVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyW119IFthcnJheT1bXV0gQXJyYXkgdG8gc3RvcmUgdGhlIHZlY3RvciB0by4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvZmZzZXQ9MF0gT3B0aW9uYWwgb2Zmc2V0IGludG8gdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAgICovXG4gIHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGFycmF5W29mZnNldCArIDBdID0gdGhpcy5feDtcbiAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRoaXMuX3k7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLl96O1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIG9uQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbkNoYW5nZUNhbGxiYWNrKCkge31cbn1cblxuIiwiaW1wb3J0IHtFdmVudERhdGFPYmplY3R9IGZyb20gJy4uL2NvcmUvRGF0YSc7XG5pbXBvcnQge2lzTmlsfSBmcm9tICcuLi9VdGlsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGhhbmRsZXJzKSB7XG4gICAgaWYgKGlzTmlsKEV2ZW50RGF0YU9iamVjdC5nZXRUYXJnZXQodGFyZ2V0KSkpIHtcbiAgICAgIEV2ZW50RGF0YU9iamVjdC5hZGRIYW5kbGVyKHRhcmdldCwgaGFuZGxlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHN1YnNjcmliZSh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IEV2ZW50RGF0YU9iamVjdC5nZXRIYW5kbGVyKHRhcmdldCwgdHlwZSk7XG5cbiAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgaGFuZGxlci5hZGQoY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgdW5zdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBFdmVudERhdGFPYmplY3QuZ2V0SGFuZGxlcih0YXJnZXQsIHR5cGUpO1xuXG4gICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGhhbmRsZXIuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeSh0YXJnZXQsIHR5cGUsIGFyZ3MpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gRXZlbnREYXRhT2JqZWN0LmdldEhhbmRsZXIodGFyZ2V0LCB0eXBlKTtcblxuICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBoYW5kbGVyLmZvckVhY2goKHZhbHVlKSA9PiB2YWx1ZShhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICB0cmFjZShfdGFyZ2V0LCBfdHlwZSwgX2V2ZW50KSB7XG4gICAgY29uc29sZS5sb2coYCR7X3RhcmdldH0gPT4gJHtfdHlwZX0gWyR7KF9ldmVudCAhPT0gbnVsbCkgPyBfZXZlbnQgOiAnZW1wdHkhJ31dYCk7XG4gIH1cbn1cbiIsImltcG9ydCBPYnNlcnZlciBmcm9tICcuLi9PYnNlcnZlcic7XG5pbXBvcnQgRW50aXR5RXZlbnQgZnJvbSAnLi4vLi4vZW50aXR5L0VudGl0eUV2ZW50JztcbmltcG9ydCB7RU5USVRZX0VWRU5UfSBmcm9tICcuLi8uLi9saWJzL01lc3NhZ2VUeXBlcyc7XG4vLyBpbXBvcnQgTWF0cml4NCBmcm9tICcuLi9tYXRoL01hdHJpeDQnO1tcblxuY29uc3QgRW50aXR5VHlwZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICBtYXRyaXg6IG51bGwsXG4gIHBpeGVsU2l6ZToge1xuICAgIHdpZHRoOiAwLjAsXG4gICAgaGVpZ2h0OiAwLjAsXG4gICAgZGVwdGg6IDAuMFxuICB9LFxuICBzY2FsZTogMS4wXG59O1xuXG5jb25zdCBoYW5kbGVycyA9IG5ldyBNYXAoXG4gIFtcbiAgICBbRU5USVRZX0VWRU5ULlRSQUNLX1NUQVJULCBuZXcgU2V0KCldLFxuICAgIFtFTlRJVFlfRVZFTlQuVFJBQ0tfTU9WRSwgbmV3IFNldCgpXSxcbiAgICBbRU5USVRZX0VWRU5ULlRSQUNLX0VORCwgbmV3IFNldCgpXVxuICBdKTtcbmNvbnN0IHRhcmdldCA9IEVOVElUWV9FVkVOVC5UQVJHRVQ7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eU9ic2VydmVyIGV4dGVuZHMgT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih0YXJnZXQsIGhhbmRsZXJzKTtcbiAgfVxuXG4gIHN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaywgLi4uYXJncykge1xuICAgIHN1cGVyLnN1YnNjcmliZSh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHVuc3Vic2NyaWJlKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIudW5zdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG5cbiAgfVxuXG4gIG5vdGlmeSh0eXBlLCBldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVudGl0eUV2ZW50KSB7XG4gICAgICBzdXBlci5ub3RpZnkodGFyZ2V0LCB0eXBlLCBldmVudCk7XG4gICAgICAvLyBzdXBlci50cmFjZSh0YXJnZXQsIHR5cGUsIGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBPYnNlcnZlciBmcm9tICcuLi9PYnNlcnZlcic7XG5pbXBvcnQge0xFVFNFRV9FVkVOVH0gZnJvbSAnLi4vLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuXG5jb25zdCBoYW5kbGVycyA9IG5ldyBNYXAoW1xuICBbTEVUU0VFX0VWRU5ULk9OX0xPQUQsIG5ldyBTZXQoKV0sXG4gIFtMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCBuZXcgU2V0KCldLFxuICBbTEVUU0VFX0VWRU5ULlJPVEFUSU9OX0NIQU5HRSwgbmV3IFNldCgpXVxuXSk7XG5jb25zdCB0YXJnZXQgPSBMRVRTRUVfRVZFTlQuVEFSR0VUO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXRzZWVPYnNlcnZlciBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodGFyZ2V0LCBoYW5kbGVycyk7XG4gIH1cblxuICBzdWJzY3JpYmUodHlwZSwgY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgbm90aWZ5KHR5cGUsIGV2ZW50KSB7XG4gICAgc3VwZXIubm90aWZ5KHRhcmdldCwgdHlwZSwgZXZlbnQpO1xuICAgIHN1cGVyLnRyYWNlKHRhcmdldCwgdHlwZSwgZXZlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQge2RvbVJlbmRlcmVyfSBmcm9tICcuL0RPTVJlbmRlcmVyJztcbmltcG9ydCBPYmplY3QzRCBmcm9tICcuLi9jb3JlL09iamVjdDNEJztcbmltcG9ydCB7RW50aXR5RGF0YU9iamVjdH0gZnJvbSAnLi4vY29yZS9EYXRhJztcbmltcG9ydCB7T0JKRUNUX0VWRU5UfSBmcm9tICcuLi9saWJzL01lc3NhZ2VUeXBlcyc7XG5pbXBvcnQge2lzTnVsbH0gZnJvbSAnLi4vVXRpbCc7XG5pbXBvcnQge2NvbnRleHR9IGZyb20gJy4uL0NvbnRleHQnO1xuXG5jb25zdCBfdHlwZSA9ICdET01SZW5kZXJhYmxlJztcbmNvbnN0IF9pc0RPTVJlbmRlcmFibGUgPSB0cnVlO1xubGV0IGdob3N0SWQgPSAwO1xuXG4vKipcbiAqIEBjbGFzcyBDbGFzcyByZXByZXNlbnRpbmcgYSBIVE1MIGVsZW1lbnQgdGhhdCBjYW4gYmUgYXVnbWVudGVkLlxuICogQG5hbWUgRE9NUmVuZGVyYWJsZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEhUTUwgRWxlbWVudFxuICogQHJldHVybnMge0RPTVJlbmRlcmFibGV9XG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIEhUTUwgZWxlbWVudFxuICogLy8gSFRNTCDsl5jrpqzrqLztirjrpbwg7IOd7ISx7ZWp64uI64ukLlxuICogY29uc3Qgc2FtcGxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICpcbiAqIC8vIG9yIGdldCBleGlzdCBlbGVtZW50XG4gKiAvLyDrmJDtlZwgRE9N7IOB7JeQIOyhtOyerO2VmOuKlCBIVE1MIOyXmOumrOuovO2KuOulvCDsgqzsmqntlaAg7IiY64+EIOyeiOyKteuLiOuLpC5cbiAqIGNvbnN0IGV4aXN0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb28nKTtcbiAqXG4gKiAvLyBDcmVhdGUgRE9NIFJlbmRlcmFibGVcbiAqIC8vIERPTSBSZW5kZXJhYmxl7J2EIOyDneyEse2VqeuLiOuLpC5cbiAqIGNvbnN0IHNhbXBsZVJlbmRlcmFibGUgPSBuZXcgRE9NUmVuZGVyYWJsZShzYW1wbGVFbGVtZW50KTtcbiAqIGNvbnN0IGV4aXN0UmVuZGVyYWJsZSA9IG5ldyBET01SZW5kZXJhYmxlKGV4aXN0RWxlbWVudCk7XG4gKlxuICogLy8g7IOd7ISx7ZWcIHJlbmRlcmFibGXsnYQg7JeU7YSw7Yuw7JeQIOuTseuhne2VqeuLiOuLpC5cbiAqIGVudGl0eS5hZGRSZW5kZXJhYmxlKHNhbXBsZVJlbmRlcmFibGUpO1xuICogZW50aXR5LmFkZFJlbmRlcmFibGUoZXhpc3RSZW5kZXJhYmxlKTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRE9NUmVuZGVyYWJsZSBleHRlbmRzIE9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgLy8gdGhpcy5yZW5kZXJlciA9IG5ldyBET01SZW5kZXJlcigpO1xuICAgIGlmIChpc051bGwoZWxlbWVudC5wYXJlbnRFbGVtZW50KSkgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGV4dC5wbGFjZWhvbGRlcklkKS5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgIGNvbnN0IG9yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNvbnN0IGdob3N0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgZ2hvc3RFbGVtZW50LmlkID0gYGdob3N0LSR7Z2hvc3RJZH1gO1xuICAgIGdob3N0RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJywgJ2ltcG9ydGFudCcpO1xuICAgIC8vIGdob3N0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUgIWltcG9ydGFudCdcblxuICAgIEVudGl0eURhdGFPYmplY3QuYWRkRWxlbWVudChlbGVtZW50LCBuZXcgTWFwKFxuICAgICAgW1xuICAgICAgICBbJ29yaWdpbmFsJywgb3JpZ2luYWxFbGVtZW50XSxcbiAgICAgICAgWydnaG9zdCcsIGdob3N0RWxlbWVudF1cbiAgICAgIF0pKTtcbiAgICBnaG9zdElkKys7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICB0aGlzLmlzQWRkZWRUb0NhbWVyYSA9IGZhbHNlO1xuXG4gICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIC8vIHRoaXMuZWxlbWVudC5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgIHRoaXMuc3Vic2NyaWJlKE9CSkVDVF9FVkVOVC5PQkpFQ1RfQURERUQsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuaXNET01SZW5kZXJhYmxlKSB0aGlzLmFkZGVkKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoT0JKRUNUX0VWRU5ULk9CSkVDVF9SRU1PVkVELCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0LmlzRE9NUmVuZGVyYWJsZSkgdGhpcy5yZW1vdmVkKGUpO1xuICAgIH0pO1xuICB9XG5cbiAgYWRkZWQoZSkge1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC50cmFjaykgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICBsZXQgb2JqZWN0ID0gZS50YXJnZXQ7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG9iamVjdC5pc1NjZW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FkZGVkVG9DYW1lcmEpIHtcbiAgICAgICAgICBkb21SZW5kZXJlci5hcHBlbmRFbGVtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5pc0FkZGVkVG9DYW1lcmEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5wYXJlbnQpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZWQoZSkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCkge1xuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNET01SZW5kZXJhYmxlKCkge1xuICAgIHJldHVybiBfaXNET01SZW5kZXJhYmxlO1xuICB9O1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gX3R5cGU7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuLi9Db250ZXh0JztcbmltcG9ydCBTY2VuZSBmcm9tICcuLi9jb3JlL1NjZW5lJztcbmltcG9ydCB7ZGVnVG9SYWR9IGZyb20gJy4uL21hdGgvTWF0aCc7XG5pbXBvcnQgRW50aXR5T2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL29ic2VydmVyL0VudGl0eU9ic2VydmVyJztcbmltcG9ydCB7RW50aXR5RGF0YU9iamVjdH0gZnJvbSAnLi4vY29yZS9EYXRhJztcblxuY29uc3QgZXBzaWxvbiA9ICh2YWx1ZSkgPT4gTWF0aC5hYnModmFsdWUpIDwgMWUtMTAgPyAwIDogdmFsdWU7XG5jb25zdCBnZXRDYW1lcmFDU1NNYXRyaXggPSAoY2FtZXJhKSA9PiB7XG4gIGNvbnN0IGNhbWVyYU1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZWxlbWVudHMubWFwKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiAoaW5kZXggPT09IDEgfHwgaW5kZXggPT09IDUgfHwgaW5kZXggPT09IDkgfHwgaW5kZXggPT09IDEzKSA/IGVwc2lsb24oLWVsZW1lbnQpIDogZXBzaWxvbihlbGVtZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGBtYXRyaXgzZCgke2NhbWVyYU1hdHJpeC5qb2luKCcsJyl9KWA7XG59O1xuY29uc3QgZ2V0T2JqZWN0Q1NTTWF0cml4ID0gKHJlbmRlcmFibGUpID0+IHtcbiAgcmVuZGVyYWJsZS51cGRhdGVNYXRyaXgoKTtcbiAgY29uc3Qgb2JqZWN0TWF0cml4ID0gcmVuZGVyYWJsZS5tYXRyaXhXb3JsZC5lbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChpbmRleCA+PSA0ICYmIGluZGV4IDw9IDcpID8gZXBzaWxvbigtZWxlbWVudCkgOiBlcHNpbG9uKGVsZW1lbnQpO1xuICB9KTtcblxuICByZXR1cm4gYHRyYW5zbGF0ZSgtNTAlLC01MCUpIG1hdHJpeDNkKCR7b2JqZWN0TWF0cml4LmpvaW4oJywnKX0pYDtcbn07XG5cbmxldCBfY2FjaGVkU3R5bGVzO1xubGV0IF9jYW1lcmEgPSBudWxsO1xuXG5jb25zdCBfc2NlbmUgPSBuZXcgU2NlbmUoKTtcbmNvbnN0IF9kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb25zdCBfY2FtZXJhRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5jbGFzcyBET01SZW5kZXJlciBleHRlbmRzIEVudGl0eU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfY2FjaGVkU3R5bGVzID0ge307XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBfZG9tRWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICAgIF9kb21FbGVtZW50LmNsYXNzTmFtZSA9ICdhci1yZW5kZXJlcic7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLnRvcCA9ICcwJztcbiAgICBfZG9tRWxlbWVudC5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLm1hcmdpbiA9ICcwJztcbiAgICBfZG9tRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLnpJbmRleCA9ICcxMTAnO1xuXG4gICAgX2NhbWVyYUVsZW1lbnQuc3R5bGUuV2Via2l0VHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICAgIF9jYW1lcmFFbGVtZW50LnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBfZG9tRWxlbWVudC5hcHBlbmRDaGlsZChfY2FtZXJhRWxlbWVudCk7XG5cbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2ttb3ZlJywgKGUpID0+IHRoaXMucmVuZGVyKGUpKTtcbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2tzdGFydCcsIChlKSA9PiB0aGlzLnJlbmRlcihlKSk7XG4gICAgdGhpcy5zdWJzY3JpYmUoJ3RyYWNrZW5kJywgKGUpID0+IHRoaXMucmVuZGVyKGUpKTtcblxuICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICB9XG5cbiAgaW5pdFJlbmRlcmVyKGNhbWVyYSwgaWQsIHpJbmRleCwgekluZGV4SW5jcmVtZW50KSB7XG4gICAgX2NhbWVyYSA9IGNhbWVyYTtcbiAgICB0aGlzLndpZHRoID0gY29udGV4dC53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGNvbnRleHQuaGVpZ2h0O1xuICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgIF9kb21FbGVtZW50LmlkID0gaWQ7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUuekluZGV4ID0gekluZGV4ICsgekluZGV4SW5jcmVtZW50O1xuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QmVmb3JlKF9kb21FbGVtZW50LCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH1cblxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9XG5cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHNjZW5lKCkge1xuICAgIHJldHVybiBfc2NlbmU7XG4gIH1cblxuICB1cGRhdGVPcmllbnRhdGlvbihuZXdDb25maWcpIHtcbiAgICB0aGlzLndpZHRoID0gbmV3Q29uZmlnLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3Q29uZmlnLmhlaWdodDtcbiAgICB0aGlzLnNldFNpemUoKTtcbiAgfVxuXG4gIHNldFNpemUoKSB7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUud2lkdGggPSBfY2FtZXJhRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3RoaXMud2lkdGh9cHhgO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLmhlaWdodCA9IF9jYW1lcmFFbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaGVpZ2h0fXB4YDtcbiAgfVxuXG4gIGFkZChvYmplY3QpIHtcbiAgICBfc2NlbmUuYWRkKG9iamVjdCk7XG4gIH1cblxuICByZW1vdmUob2JqZWN0KSB7XG4gICAgX3NjZW5lLnJlbW92ZShvYmplY3QpO1xuICB9XG5cbiAgYXBwZW5kRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKEVudGl0eURhdGFPYmplY3QuZ2V0RWxlbWVudChlbGVtZW50KSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBnaG9zdCA9IEVudGl0eURhdGFPYmplY3QuZ2V0RWxlbWVudChlbGVtZW50KS5nZXQoJ2dob3N0Jyk7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IEVudGl0eURhdGFPYmplY3QuZ2V0RWxlbWVudChlbGVtZW50KS5nZXQoJ29yaWdpbmFsJyk7XG5cbiAgICAgIGlmIChvcmlnaW5hbC5wYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoZ2hvc3QsIGVsZW1lbnQpO1xuICAgICAgICBfY2FtZXJhRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWdpbmFsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGVsZW1lbnQsIG9yaWdpbmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhcHBlbmRBbGxFbGVtZW50cygpIHtcblxuICAgIEVudGl0eURhdGFPYmplY3QuZ2V0QWxsRWxlbWVudHMoKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBnaG9zdCA9IHZhbHVlLmdldCgnZ2hvc3QnKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0gdmFsdWUuZ2V0KCdvcmlnaW5hbCcpO1xuXG4gICAgICBvcmlnaW5hbC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChnaG9zdCwgb3JpZ2luYWwpO1xuICAgICAgX2NhbWVyYUVsZW1lbnQuYXBwZW5kQ2hpbGQoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0RWxlbWVudCgpIHtcbiAgICBFbnRpdHlEYXRhT2JqZWN0LmdldEFsbEVsZW1lbnRzKCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgZ2hvc3QgPSB2YWx1ZS5nZXQoJ2dob3N0Jyk7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlLmdldCgnb3JpZ2luYWwnKTtcblxuICAgICAgZ2hvc3QucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQob3JpZ2luYWwsIGdob3N0KTtcbiAgICAgIF9jYW1lcmFFbGVtZW50LnJlbW92ZUNoaWxkKGtleSk7XG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBfY2FtZXJhRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIG9uVHJhY2tNb3ZlKGUpIHt9XG4gIG9uVHJhY2tTdGFydChlKSB7fVxuICBvblRyYWNrRW5kKGUpIHt9XG5cbiAgcmVuZGVyKGUpIHtcbiAgICBpZiAoX2NhbWVyYSkge1xuICAgICAgY29uc3QgZm92ID0gMC41IC8gTWF0aC50YW4oZGVnVG9SYWQoX2NhbWVyYS5nZXRFZmZlY3RpdmVGT1YoKSAqIDAuNSkpICogdGhpcy5oZWlnaHQ7XG4gICAgICBjb25zdCBjYW1lcmFDU1NNYXRyaXggPSBgdHJhbnNsYXRlWigke2Zvdn1weCkke2dldENhbWVyYUNTU01hdHJpeChfY2FtZXJhKX1gO1xuICAgICAgY29uc3QgY2FtZXJhVHJhbnNmb3JtID0gYCR7Y2FtZXJhQ1NTTWF0cml4fXRyYW5zbGF0ZSgke3RoaXMud2lkdGggKiAwLjV9cHgsJHt0aGlzLmhlaWdodCAqIDAuNX1weClgO1xuXG4gICAgICBfZG9tRWxlbWVudC5zdHlsZS5XZWJraXRQZXJzcGVjdGl2ZSA9IGAke2Zvdn1weGA7XG4gICAgICBfZG9tRWxlbWVudC5zdHlsZS5wZXJzcGVjdGl2ZSA9IGAke2Zvdn1weGA7XG4gICAgICBfY2FtZXJhRWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSBjYW1lcmFUcmFuc2Zvcm07XG4gICAgICBfY2FtZXJhRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBjYW1lcmFUcmFuc2Zvcm07XG5cbiAgICAgIHRoaXMuc2V0U2l6ZSgpO1xuICAgICAgX3NjZW5lLnRyYXZlcnNlKChvYmopID0+IHtcbiAgICAgICAgaWYgKG9iai5lbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IG9iai5lbGVtZW50O1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0T2JqZWN0Q1NTTWF0cml4KG9iaik7XG4gICAgICAgICAgY29uc3QgY2FjaGVkU3R5bGUgPSBfY2FjaGVkU3R5bGVzW29iai5pZF07XG5cbiAgICAgICAgICBpZiAoY2FjaGVkU3R5bGUgPT09IHVuZGVmaW5lZCB8fCBjYWNoZWRTdHlsZSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gc3R5bGU7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHN0eWxlO1xuICAgICAgICAgICAgX2NhY2hlZFN0eWxlc1tvYmouaWRdID0gc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRvbVJlbmRlcmVyID0gbmV3IERPTVJlbmRlcmVyKCk7XG4iLCIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5hZGFwdGVyID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYWRhcHRlcl9mYWN0b3J5ID0gcmVxdWlyZSgnLi9hZGFwdGVyX2ZhY3RvcnkuanMnKTtcblxudmFyIGFkYXB0ZXIgPSAoMCwgX2FkYXB0ZXJfZmFjdG9yeS5hZGFwdGVyRmFjdG9yeSkoeyB3aW5kb3c6IHdpbmRvdyB9KTtcbm1vZHVsZS5leHBvcnRzID0gYWRhcHRlcjsgLy8gdGhpcyBpcyB0aGUgZGlmZmVyZW5jZSBmcm9tIGFkYXB0ZXJfY29yZS5cblxufSx7XCIuL2FkYXB0ZXJfZmFjdG9yeS5qc1wiOjJ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRhcHRlckZhY3RvcnkgPSBhZGFwdGVyRmFjdG9yeTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxudmFyIF9jaHJvbWVfc2hpbSA9IHJlcXVpcmUoJy4vY2hyb21lL2Nocm9tZV9zaGltJyk7XG5cbnZhciBjaHJvbWVTaGltID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2Nocm9tZV9zaGltKTtcblxudmFyIF9lZGdlX3NoaW0gPSByZXF1aXJlKCcuL2VkZ2UvZWRnZV9zaGltJyk7XG5cbnZhciBlZGdlU2hpbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9lZGdlX3NoaW0pO1xuXG52YXIgX2ZpcmVmb3hfc2hpbSA9IHJlcXVpcmUoJy4vZmlyZWZveC9maXJlZm94X3NoaW0nKTtcblxudmFyIGZpcmVmb3hTaGltID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2ZpcmVmb3hfc2hpbSk7XG5cbnZhciBfc2FmYXJpX3NoaW0gPSByZXF1aXJlKCcuL3NhZmFyaS9zYWZhcmlfc2hpbScpO1xuXG52YXIgc2FmYXJpU2hpbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9zYWZhcmlfc2hpbSk7XG5cbnZhciBfY29tbW9uX3NoaW0gPSByZXF1aXJlKCcuL2NvbW1vbl9zaGltJyk7XG5cbnZhciBjb21tb25TaGltID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvbW1vbl9zaGltKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuLy8gU2hpbW1pbmcgc3RhcnRzIGhlcmUuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGFkYXB0ZXJGYWN0b3J5KCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICB3aW5kb3cgPSBfcmVmLndpbmRvdztcblxuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgIHNoaW1DaHJvbWU6IHRydWUsXG4gICAgc2hpbUZpcmVmb3g6IHRydWUsXG4gICAgc2hpbUVkZ2U6IHRydWUsXG4gICAgc2hpbVNhZmFyaTogdHJ1ZVxuICB9O1xuXG4gIC8vIFV0aWxzLlxuICB2YXIgbG9nZ2luZyA9IHV0aWxzLmxvZztcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIHZhciBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzOiBicm93c2VyRGV0YWlscyxcbiAgICBjb21tb25TaGltOiBjb21tb25TaGltLFxuICAgIGV4dHJhY3RWZXJzaW9uOiB1dGlscy5leHRyYWN0VmVyc2lvbixcbiAgICBkaXNhYmxlTG9nOiB1dGlscy5kaXNhYmxlTG9nLFxuICAgIGRpc2FibGVXYXJuaW5nczogdXRpbHMuZGlzYWJsZVdhcm5pbmdzXG4gIH07XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGNocm9tZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gY2hyb21lU2hpbTtcblxuICAgICAgY2hyb21lU2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltUGVlckNvbm5lY3Rpb24od2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93KTtcblxuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlQWxsb3dFeHRtYXBNaXhlZCh3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24gfHwgIW9wdGlvbnMuc2hpbUZpcmVmb3gpIHtcbiAgICAgICAgbG9nZ2luZygnRmlyZWZveCBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xuXG4gICAgICBmaXJlZm94U2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUGVlckNvbm5lY3Rpb24od2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1PblRyYWNrKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUmVtb3ZlU3RyZWFtKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltU2VuZGVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltUlRDRGF0YUNoYW5uZWwod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUNyZWF0ZU9mZmVyKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlQW5zd2VyKHdpbmRvdyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdlZGdlJzpcbiAgICAgIGlmICghZWRnZVNoaW0gfHwgIWVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRWRnZSkge1xuICAgICAgICBsb2dnaW5nKCdNUyBlZGdlIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZWRnZS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZWRnZVNoaW07XG5cbiAgICAgIGVkZ2VTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGVkZ2VTaGltLnNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93KTtcbiAgICAgIGVkZ2VTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgZWRnZVNoaW0uc2hpbVJlcGxhY2VUcmFjayh3aW5kb3cpO1xuXG4gICAgICAvLyB0aGUgZWRnZSBzaGltIGltcGxlbWVudHMgdGhlIGZ1bGwgUlRDSWNlQ2FuZGlkYXRlIG9iamVjdC5cblxuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2FmYXJpJzpcbiAgICAgIGlmICghc2FmYXJpU2hpbSB8fCAhb3B0aW9ucy5zaGltU2FmYXJpKSB7XG4gICAgICAgIGxvZ2dpbmcoJ1NhZmFyaSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIHNhZmFyaS4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gc2FmYXJpU2hpbTtcblxuICAgICAgc2FmYXJpU2hpbS5zaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0ucmVtb3ZlQWxsb3dFeHRtYXBNaXhlZCh3aW5kb3cpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZ2dpbmcoJ1Vuc3VwcG9ydGVkIGJyb3dzZXIhJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG4vLyBCcm93c2VyIHNoaW1zLlxuXG59LHtcIi4vY2hyb21lL2Nocm9tZV9zaGltXCI6MyxcIi4vY29tbW9uX3NoaW1cIjo2LFwiLi9lZGdlL2VkZ2Vfc2hpbVwiOjEyLFwiLi9maXJlZm94L2ZpcmVmb3hfc2hpbVwiOjcsXCIuL3NhZmFyaS9zYWZhcmlfc2hpbVwiOjEwLFwiLi91dGlsc1wiOjExfV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoaW1HZXREaXNwbGF5TWVkaWEgPSBleHBvcnRzLnNoaW1HZXRVc2VyTWVkaWEgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9nZXR1c2VybWVkaWEgPSByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NoaW1HZXRVc2VyTWVkaWEnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0dXNlcm1lZGlhLnNoaW1HZXRVc2VyTWVkaWE7XG4gIH1cbn0pO1xuXG52YXIgX2dldGRpc3BsYXltZWRpYSA9IHJlcXVpcmUoJy4vZ2V0ZGlzcGxheW1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldERpc3BsYXlNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRkaXNwbGF5bWVkaWEuc2hpbUdldERpc3BsYXlNZWRpYTtcbiAgfVxufSk7XG5leHBvcnRzLnNoaW1NZWRpYVN0cmVhbSA9IHNoaW1NZWRpYVN0cmVhbTtcbmV4cG9ydHMuc2hpbU9uVHJhY2sgPSBzaGltT25UcmFjaztcbmV4cG9ydHMuc2hpbUdldFNlbmRlcnNXaXRoRHRtZiA9IHNoaW1HZXRTZW5kZXJzV2l0aER0bWY7XG5leHBvcnRzLnNoaW1HZXRTdGF0cyA9IHNoaW1HZXRTdGF0cztcbmV4cG9ydHMuc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMgPSBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cztcbmV4cG9ydHMuc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlID0gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlO1xuZXhwb3J0cy5zaGltQWRkVHJhY2tSZW1vdmVUcmFjayA9IHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrO1xuZXhwb3J0cy5zaGltUGVlckNvbm5lY3Rpb24gPSBzaGltUGVlckNvbm5lY3Rpb247XG5leHBvcnRzLmZpeE5lZ290aWF0aW9uTmVlZGVkID0gZml4TmVnb3RpYXRpb25OZWVkZWQ7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy5qcycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBzaGltTWVkaWFTdHJlYW0od2luZG93KSB7XG4gIHdpbmRvdy5NZWRpYVN0cmVhbSA9IHdpbmRvdy5NZWRpYVN0cmVhbSB8fCB3aW5kb3cud2Via2l0TWVkaWFTdHJlYW07XG59XG5cbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnb250cmFjaycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29udHJhY2snLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZikge1xuICAgICAgICBpZiAodGhpcy5fb250cmFjaykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayA9IGYpO1xuICAgICAgfSxcblxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fb250cmFja3BvbHkpIHtcbiAgICAgICAgdGhpcy5fb250cmFja3BvbHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIG9uYWRkc3RyZWFtIGRvZXMgbm90IGZpcmUgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgICAgLy8gc3RyZWFtLiBCdXQgc3RyZWFtLm9uYWRkdHJhY2sgaXMgaW1wbGVtZW50ZWQgc28gd2UgdXNlIHRoYXQuXG4gICAgICAgICAgZS5zdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcignYWRkdHJhY2snLCBmdW5jdGlvbiAodGUpIHtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IF90aGlzLmdldFJlY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0ZS50cmFjay5pZDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHsgdHJhY2s6IHRlLnRyYWNrIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7IHJlY2VpdmVyOiByZWNlaXZlciB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBlLnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gX3RoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRyYWNrLmlkO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0geyB0cmFjazogdHJhY2sgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7IHJlY2VpdmVyOiByZWNlaXZlciB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWUudHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICd0cmFuc2NlaXZlcicsIHsgdmFsdWU6IHsgcmVjZWl2ZXI6IGUucmVjZWl2ZXIgfSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KSB7XG4gIC8vIE92ZXJyaWRlcyBhZGRUcmFjay9yZW1vdmVUcmFjaywgZGVwZW5kcyBvbiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjay5cbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICEoJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgdmFyIHNoaW1TZW5kZXJXaXRoRHRtZiA9IGZ1bmN0aW9uIHNoaW1TZW5kZXJXaXRoRHRtZihwYywgdHJhY2spIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWNrOiB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgdmFyIG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgICAgICB2YXIgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghc2VuZGVyKSB7XG4gICAgICAgICAgc2VuZGVyID0gc2hpbVNlbmRlcldpdGhEdG1mKHRoaXMsIHRyYWNrKTtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnB1c2goc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgICAgIG9yaWdSZW1vdmVUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5fc2VuZGVycy5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2VuZGVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIF90aGlzMi5fc2VuZGVycy5wdXNoKHNoaW1TZW5kZXJXaXRoRHRtZihfdGhpczIsIHRyYWNrKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuXG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgdmFyIHNlbmRlciA9IF90aGlzMy5fc2VuZGVycy5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgIC8vIHJlbW92ZSBzZW5kZXJcbiAgICAgICAgICBfdGhpczMuX3NlbmRlcnMuc3BsaWNlKF90aGlzMy5fc2VuZGVycy5pbmRleE9mKHNlbmRlciksIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmICdnZXRTZW5kZXJzJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmICdjcmVhdGVEVE1GU2VuZGVyJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgISgnZHRtZicgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgdmFyIG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLl9wYyA9IF90aGlzNDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSwgJ2R0bWYnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSB0aGlzLl9wYy5jcmVhdGVEVE1GU2VuZGVyKHRoaXMudHJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbUdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgX2FyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHNlbGVjdG9yID0gX2FyZ3VtZW50c1swXSxcbiAgICAgICAgb25TdWNjID0gX2FyZ3VtZW50c1sxXSxcbiAgICAgICAgb25FcnIgPSBfYXJndW1lbnRzWzJdO1xuXG4gICAgLy8gSWYgc2VsZWN0b3IgaXMgYSBmdW5jdGlvbiB0aGVuIHdlIGFyZSBpbiB0aGUgb2xkIHN0eWxlIHN0YXRzIHNvIGp1c3RcbiAgICAvLyBwYXNzIGJhY2sgdGhlIG9yaWdpbmFsIGdldFN0YXRzIGZvcm1hdCB0byBhdm9pZCBicmVha2luZyBvbGQgdXNlcnMuXG5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHNwZWMtc3R5bGUgZ2V0U3RhdHMgaXMgc3VwcG9ydGVkLCByZXR1cm4gdGhvc2Ugd2hlbiBjYWxsZWQgd2l0aFxuICAgIC8vIGVpdGhlciBubyBhcmd1bWVudHMgb3IgdGhlIHNlbGVjdG9yIGFyZ3VtZW50IGlzIG51bGwuXG4gICAgaWYgKG9yaWdHZXRTdGF0cy5sZW5ndGggPT09IDAgJiYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHNlbGVjdG9yICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbXSk7XG4gICAgfVxuXG4gICAgdmFyIGZpeENocm9tZVN0YXRzXyA9IGZ1bmN0aW9uIGZpeENocm9tZVN0YXRzXyhyZXNwb25zZSkge1xuICAgICAgdmFyIHN0YW5kYXJkUmVwb3J0ID0ge307XG4gICAgICB2YXIgcmVwb3J0cyA9IHJlc3BvbnNlLnJlc3VsdCgpO1xuICAgICAgcmVwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXBvcnQpIHtcbiAgICAgICAgdmFyIHN0YW5kYXJkU3RhdHMgPSB7XG4gICAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IHJlcG9ydC50aW1lc3RhbXAsXG4gICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgICAgICAgICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgICAgICAgICB9W3JlcG9ydC50eXBlXSB8fCByZXBvcnQudHlwZVxuICAgICAgICB9O1xuICAgICAgICByZXBvcnQubmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgc3RhbmRhcmRTdGF0c1tuYW1lXSA9IHJlcG9ydC5zdGF0KG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhbmRhcmRSZXBvcnRbc3RhbmRhcmRTdGF0cy5pZF0gPSBzdGFuZGFyZFN0YXRzO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBzdGFuZGFyZFJlcG9ydDtcbiAgICB9O1xuXG4gICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgIHZhciBtYWtlTWFwU3RhdHMgPSBmdW5jdGlvbiBtYWtlTWFwU3RhdHMoc3RhdHMpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5rZXlzKHN0YXRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gW2tleSwgc3RhdHNba2V5XV07XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHZhciBzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyA9IGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfKHJlc3BvbnNlKSB7XG4gICAgICAgIG9uU3VjYyhtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBbc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8sIHNlbGVjdG9yXSk7XG4gICAgfVxuXG4gICAgLy8gcHJvbWlzZS1zdXBwb3J0XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIG9yaWdHZXRTdGF0cy5hcHBseShfdGhpczUsIFtmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgcmVzb2x2ZShtYWtlTWFwU3RhdHMoZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSkpO1xuICAgICAgfSwgcmVqZWN0XSk7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgd2luZG93LlJUQ1J0cFJlY2VpdmVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gc2VuZGVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSkge1xuICAgIHZhciBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICBzZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICAgIHJldHVybiBzZW5kZXIuX3BjID0gX3RoaXM2O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgICAgdmFyIHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbmRlcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICB2YXIgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8qIE5vdGU6IHRoaXMgd2lsbCBpbmNsdWRlIHN0YXRzIG9mIGFsbCBzZW5kZXJzIHRoYXRcbiAgICAgICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICAgICAqICAgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGlkZW50aWZ5IHRoZSBSVENSdHBTZW5kZXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXRpbHMuZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIHZhciBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gICAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgICB2YXIgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHJlY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICAgIHJldHVybiByZWNlaXZlci5fcGMgPSBfdGhpczc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgICAgfTtcbiAgICB9XG4gICAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICB2YXIgcmVjZWl2ZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB1dGlscy5maWx0ZXJTdGF0cyhyZXN1bHQsIHJlY2VpdmVyLnRyYWNrLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBSVENQZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh0cmFjaykuXG4gIHZhciBvcmlnR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICB2YXIgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgc2VuZGVyID0gdm9pZCAwO1xuICAgICAgdmFyIHJlY2VpdmVyID0gdm9pZCAwO1xuICAgICAgdmFyIGVyciA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgaWYgKHMudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHNlbmRlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZGVyID0gcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChyZWNlaXZlcikge1xuICAgICAgICAgICAgZXJyID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjZWl2ZXIgPSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnIgfHwgc2VuZGVyICYmIHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgICAgfSBlbHNlIGlmIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgfSBlbHNlIGlmIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdUaGVyZSBpcyBubyBzZW5kZXIgb3IgcmVjZWl2ZXIgZm9yIHRoZSB0cmFjay4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJykpO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXG4gIC8vIHRoZSBpbnRlcmFjdGlvbnMgd2l0aCBsZWdhY3kgZ2V0TG9jYWxTdHJlYW1zIGJlaGF2ZSBhcyBpbiBvdGhlciBicm93c2Vycy5cbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5tYXAoZnVuY3Rpb24gKHN0cmVhbUlkKSB7XG4gICAgICByZXR1cm4gX3RoaXM4Ll9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXVswXTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcblxuICAgIHZhciBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VuZGVyO1xuICB9O1xuXG4gIHZhciBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG5cbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHZhciBhbHJlYWR5RXhpc3RzID0gX3RoaXM5LmdldFNlbmRlcnMoKS5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBleGlzdGluZ1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKTtcbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIG5ld1NlbmRlcnMgPSB0aGlzLmdldFNlbmRlcnMoKS5maWx0ZXIoZnVuY3Rpb24gKG5ld1NlbmRlcikge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nU2VuZGVycy5pbmRleE9mKG5ld1NlbmRlcikgPT09IC0xO1xuICAgIH0pO1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSA9IFtzdHJlYW1dLmNvbmNhdChuZXdTZW5kZXJzKTtcbiAgfTtcblxuICB2YXIgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBkZWxldGUgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIHJldHVybiBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIG9yaWdSZW1vdmVUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2s7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBpZiAoc2VuZGVyKSB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW1JZCkge1xuICAgICAgICB2YXIgaWR4ID0gX3RoaXMxMC5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIF90aGlzMTAuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczEwLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXMxMC5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIC8vIHNoaW0gYWRkVHJhY2sgYW5kIHJlbW92ZVRyYWNrLlxuICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY1KSB7XG4gICAgcmV0dXJuIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpO1xuICB9XG5cbiAgLy8gYWxzbyBzaGltIHBjLmdldExvY2FsU3RyZWFtcyB3aGVuIGFkZFRyYWNrIGlzIHNoaW1tZWRcbiAgLy8gdG8gcmV0dXJuIHRoZSBvcmlnaW5hbCBzdHJlYW1zLlxuICB2YXIgb3JpZ0dldExvY2FsU3RyZWFtcyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICB2YXIgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gbmF0aXZlU3RyZWFtcy5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIF90aGlzMTEuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgdmFyIGFscmVhZHlFeGlzdHMgPSBfdGhpczEyLmdldFNlbmRlcnMoKS5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBpZGVudGl0eSBtYXBwaW5nIGZvciBjb25zaXN0ZW5jeSB3aXRoIGFkZFRyYWNrLlxuICAgIC8vIFVubGVzcyB0aGlzIGlzIGJlaW5nIHVzZWQgd2l0aCBhIHN0cmVhbSBmcm9tIGFkZFRyYWNrLlxuICAgIGlmICghdGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgdmFyIG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oc3RyZWFtLmdldFRyYWNrcygpKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgfVxuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgW3N0cmVhbV0pO1xuICB9O1xuXG4gIHZhciBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG5cbiAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFt0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gfHwgc3RyZWFtXSk7XG4gICAgZGVsZXRlIHRoaXMuX3JldmVyc2VTdHJlYW1zW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA/IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXS5pZCA6IHN0cmVhbS5pZF07XG4gICAgZGVsZXRlIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgfTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIHZhciBzdHJlYW1zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCAhPT0gMSB8fCAhc3RyZWFtc1swXS5nZXRUcmFja3MoKS5maW5kKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gdCA9PT0gdHJhY2s7XG4gICAgfSkpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYnV0IGFsbCB3ZSBjYW4gbWFuYWdlIHdpdGhvdXRcbiAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICsgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJywgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgfSk7XG4gICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHZhciBvbGRTdHJlYW0gPSB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgaWYgKG9sZFN0cmVhbSkge1xuICAgICAgLy8gdGhpcyBpcyB1c2luZyBvZGQgQ2hyb21lIGJlaGF2aW91ciwgdXNlIHdpdGggY2F1dGlvbjpcbiAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD03ODE1XG4gICAgICAvLyBOb3RlOiB3ZSByZWx5IG9uIHRoZSBoaWdoLWxldmVsIGFkZFRyYWNrL2R0bWYgc2hpbSB0b1xuICAgICAgLy8gY3JlYXRlIHRoZSBzZW5kZXIgd2l0aCBhIGR0bWYgc2VuZGVyLlxuICAgICAgb2xkU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcblxuICAgICAgLy8gVHJpZ2dlciBPTk4gYXN5bmMuXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMxMy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcbiAgICB9KTtcbiAgfTtcblxuICAvLyByZXBsYWNlIHRoZSBpbnRlcm5hbCBzdHJlYW0gaWQgd2l0aCB0aGUgZXh0ZXJuYWwgb25lIGFuZFxuICAvLyB2aWNlIHZlcnNhLlxuICBmdW5jdGlvbiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJuYWxJZCkge1xuICAgICAgdmFyIGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgdmFyIGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgZXh0ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHA6IHNkcFxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcm5hbElkKSB7XG4gICAgICB2YXIgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICB2YXIgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLCBpbnRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcDogc2RwXG4gICAgfSk7XG4gIH1cbiAgWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIHZhciBtZXRob2RPYmogPSBfZGVmaW5lUHJvcGVydHkoe30sIG1ldGhvZCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoaXNMZWdhY3lDYWxsKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgW2Z1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgIHZhciBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQoX3RoaXMxNCwgZGVzY3JpcHRpb24pO1xuICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NdKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBhcmd1bWVudHNbMl1dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQoX3RoaXMxNCwgZGVzY3JpcHRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gIH0pO1xuXG4gIHZhciBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgIWFyZ3VtZW50c1swXS50eXBlKSB7XG4gICAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgYXJndW1lbnRzWzBdID0gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQodGhpcywgYXJndW1lbnRzWzBdKTtcbiAgICByZXR1cm4gb3JpZ1NldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBUT0RPOiBtYW5nbGUgZ2V0U3RhdHM6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtc3RhdHMvI2RvbS1ydGNtZWRpYXN0cmVhbXN0YXRzLXN0cmVhbWlkZW50aWZpZXJcblxuICB2YXIgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHZhciBfdGhpczE1ID0gdGhpcztcblxuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBub3QgeWV0IGNoZWNrIGZvciBzZW5kZXIgaW5zdGFuY2VvZiBSVENSdHBTZW5kZXJcbiAgICAvLyBzaW5jZSB3ZSBzaGltIFJUUFNlbmRlci4gU28gd2UgY2hlY2sgaWYgc2VuZGVyLl9wYyBpcyBzZXQuXG4gICAgaWYgKCFzZW5kZXIuX3BjKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdBcmd1bWVudCAxIG9mIFJUQ1BlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrICcgKyAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJywgJ1R5cGVFcnJvcicpO1xuICAgIH1cbiAgICB2YXIgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHZhciBzdHJlYW0gPSB2b2lkIDA7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtaWQpIHtcbiAgICAgIHZhciBoYXNUcmFjayA9IF90aGlzMTUuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpLmZpbmQoZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBzZW5kZXIudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzVHJhY2spIHtcbiAgICAgICAgc3RyZWFtID0gX3RoaXMxNS5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBpZiAoc3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBsYXN0IHRyYWNrIG9mIHRoZSBzdHJlYW0sIHJlbW92ZSB0aGUgc3RyZWFtLiBUaGlzXG4gICAgICAgIC8vIHRha2VzIGNhcmUgb2YgYW55IHNoaW1tZWQgX3NlbmRlcnMuXG4gICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtKHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgc2FtZSBvZGQgY2hyb21lIGJlaGF2aW91ciBhcyBhYm92ZS5cbiAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHNlbmRlci50cmFjayk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpIHtcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNoaW0gaW1wbGljaXQgY3JlYXRpb24gb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uL1JUQ0ljZUNhbmRpZGF0ZVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzKSB7XG4gICAgWydzZXRMb2NhbERlc2NyaXB0aW9uJywgJ3NldFJlbW90ZURlc2NyaXB0aW9uJywgJ2FkZEljZUNhbmRpZGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgdmFyIG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIHZhciBtZXRob2RPYmogPSBfZGVmaW5lUHJvcGVydHkoe30sIG1ldGhvZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSBuZXcgKG1ldGhvZCA9PT0gJ2FkZEljZUNhbmRpZGF0ZScgPyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIDogd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbikoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgdmFyIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuIE5hdGl2ZSBzdXBwb3J0IHBsYW5uZWQgZm9yIENocm9tZSBNNzcuXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3OCAmJiBhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzBdLmNhbmRpZGF0ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3cpIHtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnbmVnb3RpYXRpb25uZWVkZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBwYyA9IGUudGFyZ2V0O1xuICAgIGlmIChwYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ3N0YWJsZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG59LHtcIi4uL3V0aWxzLmpzXCI6MTEsXCIuL2dldGRpc3BsYXltZWRpYVwiOjQsXCIuL2dldHVzZXJtZWRpYVwiOjV9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gc2hpbUdldERpc3BsYXlNZWRpYTtcbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBnZXRTb3VyY2VJZCkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBnZXRTb3VyY2VJZCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGhcbiAgLy8gdGhlIHNvdXJjZUlkIG9mIHRoZSBzY3JlZW4vd2luZG93L3RhYiB0byBiZSBzaGFyZWQuXG4gIGlmICh0eXBlb2YgZ2V0U291cmNlSWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKCdzaGltR2V0RGlzcGxheU1lZGlhOiBnZXRTb3VyY2VJZCBhcmd1bWVudCBpcyBub3QgJyArICdhIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIHJldHVybiBnZXRTb3VyY2VJZChjb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoc291cmNlSWQpIHtcbiAgICAgIHZhciB3aWR0aFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoO1xuICAgICAgdmFyIGhlaWdodFNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodDtcbiAgICAgIHZhciBmcmFtZVJhdGVTcGVjaWZpZWQgPSBjb25zdHJhaW50cy52aWRlbyAmJiBjb25zdHJhaW50cy52aWRlby5mcmFtZVJhdGU7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWFuZGF0b3J5OiB7XG4gICAgICAgICAgY2hyb21lTWVkaWFTb3VyY2U6ICdkZXNrdG9wJyxcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgICBtYXhGcmFtZVJhdGU6IGZyYW1lUmF0ZVNwZWNpZmllZCB8fCAzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAod2lkdGhTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heFdpZHRoID0gd2lkdGhTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U3BlY2lmaWVkKSB7XG4gICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLm1hbmRhdG9yeS5tYXhIZWlnaHQgPSBoZWlnaHRTcGVjaWZpZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuc2hpbUdldFVzZXJNZWRpYSA9IHNoaW1HZXRVc2VyTWVkaWE7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy5qcycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG52YXIgbG9nZ2luZyA9IHV0aWxzLmxvZztcblxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmICghbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICB2YXIgY29uc3RyYWludHNUb0Nocm9tZV8gPSBmdW5jdGlvbiBjb25zdHJhaW50c1RvQ2hyb21lXyhjKSB7XG4gICAgaWYgKCh0eXBlb2YgYyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYykpICE9PSAnb2JqZWN0JyB8fCBjLm1hbmRhdG9yeSB8fCBjLm9wdGlvbmFsKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgdmFyIGNjID0ge307XG4gICAgT2JqZWN0LmtleXMoYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVxdWlyZScgfHwga2V5ID09PSAnYWR2YW5jZWQnIHx8IGtleSA9PT0gJ21lZGlhU291cmNlJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgciA9IF90eXBlb2YoY1trZXldKSA9PT0gJ29iamVjdCcgPyBjW2tleV0gOiB7IGlkZWFsOiBjW2tleV0gfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgdmFyIG9sZG5hbWVfID0gZnVuY3Rpb24gb2xkbmFtZV8ocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdkZXZpY2VJZCcgPyAnc291cmNlSWQnIDogbmFtZTtcbiAgICAgIH07XG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XG4gICAgICAgIHZhciBvYyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgICBvYyA9IHt9O1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2goZnVuY3Rpb24gKG1peCkge1xuICAgICAgICAgIGlmIChyW21peF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICAgICAgY2MubWFuZGF0b3J5W29sZG5hbWVfKG1peCwga2V5KV0gPSByW21peF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoYy5hZHZhbmNlZCkge1xuICAgICAgY2Mub3B0aW9uYWwgPSAoY2Mub3B0aW9uYWwgfHwgW10pLmNvbmNhdChjLmFkdmFuY2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNjO1xuICB9O1xuXG4gIHZhciBzaGltQ29uc3RyYWludHNfID0gZnVuY3Rpb24gc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgZnVuYykge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYxKSB7XG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiBfdHlwZW9mKGNvbnN0cmFpbnRzLmF1ZGlvKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciByZW1hcCA9IGZ1bmN0aW9uIHJlbWFwKG9iaiwgYSwgYikge1xuICAgICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdhdXRvR2FpbkNvbnRyb2wnLCAnZ29vZ0F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgcmVtYXAoY29uc3RyYWludHMuYXVkaW8sICdub2lzZVN1cHByZXNzaW9uJywgJ2dvb2dOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICBjb25zdHJhaW50cy5hdWRpbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLmF1ZGlvKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIF90eXBlb2YoY29uc3RyYWludHMudmlkZW8pID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gU2hpbSBmYWNpbmdNb2RlIGZvciBtb2JpbGUgJiBzdXJmYWNlIHByby5cbiAgICAgIHZhciBmYWNlID0gY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgIGZhY2UgPSBmYWNlICYmICgodHlwZW9mIGZhY2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGZhY2UpKSA9PT0gJ29iamVjdCcgPyBmYWNlIDogeyBpZGVhbDogZmFjZSB9KTtcbiAgICAgIHZhciBnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyA9IGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2NjtcblxuICAgICAgaWYgKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSAmJiAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUgJiYgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB2b2lkIDA7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydiYWNrJywgJ3JlYXInXTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZnVuY3Rpb24gKGRldmljZXMpIHtcbiAgICAgICAgICAgIGRldmljZXMgPSBkZXZpY2VzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBkZXYgPSBkZXZpY2VzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuc29tZShmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5sYWJlbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKG1hdGNoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7IGV4YWN0OiBkZXYuZGV2aWNlSWQgfSA6IHsgaWRlYWw6IGRldi5kZXZpY2VJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgICAgICAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICB9XG4gICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gIH07XG5cbiAgdmFyIHNoaW1FcnJvcl8gPSBmdW5jdGlvbiBzaGltRXJyb3JfKGUpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFBlcm1pc3Npb25EaXNtaXNzZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgRGV2aWNlc05vdEZvdW5kRXJyb3I6ICdOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InLFxuICAgICAgICBUcmFja1N0YXJ0RXJyb3I6ICdOb3RSZWFkYWJsZUVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VGYWlsZWREdWVUb1NodXRkb3duOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VLaWxsU3dpdGNoT246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBUYWJDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgU2NyZWVuQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIERldmljZUNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50IHx8IGUuY29uc3RyYWludE5hbWUsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyAodGhpcy5tZXNzYWdlICYmICc6ICcpICsgdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdldFVzZXJNZWRpYV8gPSBmdW5jdGlvbiBnZXRVc2VyTWVkaWFfKGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBmdW5jdGlvbiAoYykge1xuICAgICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYShjLCBvblN1Y2Nlc3MsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcblxuICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAvLyBjb25zdHJhaW50cy5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgdmFyIG9yaWdHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGNzKSB7XG4gICAgICByZXR1cm4gc2hpbUNvbnN0cmFpbnRzXyhjcywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgaWYgKGMuYXVkaW8gJiYgIXN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmxlbmd0aCB8fCBjLnZpZGVvICYmICFzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJycsICdOb3RGb3VuZEVycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxufSx7XCIuLi91dGlscy5qc1wiOjExfV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNyBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuc2hpbVJUQ0ljZUNhbmRpZGF0ZSA9IHNoaW1SVENJY2VDYW5kaWRhdGU7XG5leHBvcnRzLnNoaW1NYXhNZXNzYWdlU2l6ZSA9IHNoaW1NYXhNZXNzYWdlU2l6ZTtcbmV4cG9ydHMuc2hpbVNlbmRUaHJvd1R5cGVFcnJvciA9IHNoaW1TZW5kVGhyb3dUeXBlRXJyb3I7XG5leHBvcnRzLnNoaW1Db25uZWN0aW9uU3RhdGUgPSBzaGltQ29ubmVjdGlvblN0YXRlO1xuZXhwb3J0cy5yZW1vdmVBbGxvd0V4dG1hcE1peGVkID0gcmVtb3ZlQWxsb3dFeHRtYXBNaXhlZDtcblxudmFyIF9zZHAgPSByZXF1aXJlKCdzZHAnKTtcblxudmFyIF9zZHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2RwKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpIHtcbiAgLy8gZm91bmRhdGlvbiBpcyBhcmJpdHJhcmlseSBjaG9zZW4gYXMgYW4gaW5kaWNhdG9yIGZvciBmdWxsIHN1cHBvcnQgZm9yXG4gIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3J0Y2ljZWNhbmRpZGF0ZS1pbnRlcmZhY2VcbiAgaWYgKCF3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgJiYgJ2ZvdW5kYXRpb24nIGluIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgPSBmdW5jdGlvbiBSVENJY2VDYW5kaWRhdGUoYXJncykge1xuICAgIC8vIFJlbW92ZSB0aGUgYT0gd2hpY2ggc2hvdWxkbid0IGJlIHBhcnQgb2YgdGhlIGNhbmRpZGF0ZSBzdHJpbmcuXG4gICAgaWYgKCh0eXBlb2YgYXJncyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXJncykpID09PSAnb2JqZWN0JyAmJiBhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5pbmRleE9mKCdhPScpID09PSAwKSB7XG4gICAgICBhcmdzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShhcmdzKSk7XG4gICAgICBhcmdzLmNhbmRpZGF0ZSA9IGFyZ3MuY2FuZGlkYXRlLnN1YnN0cigyKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUubGVuZ3RoKSB7XG4gICAgICAvLyBBdWdtZW50IHRoZSBuYXRpdmUgY2FuZGlkYXRlIHdpdGggdGhlIHBhcnNlZCBmaWVsZHMuXG4gICAgICB2YXIgbmF0aXZlQ2FuZGlkYXRlID0gbmV3IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZShhcmdzKTtcbiAgICAgIHZhciBwYXJzZWRDYW5kaWRhdGUgPSBfc2RwMi5kZWZhdWx0LnBhcnNlQ2FuZGlkYXRlKGFyZ3MuY2FuZGlkYXRlKTtcbiAgICAgIHZhciBhdWdtZW50ZWRDYW5kaWRhdGUgPSBPYmplY3QuYXNzaWduKG5hdGl2ZUNhbmRpZGF0ZSwgcGFyc2VkQ2FuZGlkYXRlKTtcblxuICAgICAgLy8gQWRkIGEgc2VyaWFsaXplciB0aGF0IGRvZXMgbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIGF1Z21lbnRlZENhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBhdWdtZW50ZWRDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogYXVnbWVudGVkQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBhdWdtZW50ZWRDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBhdWdtZW50ZWRDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBhdWdtZW50ZWRDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdjYW5kaWRhdGUnLCB7XG4gICAgICAgIHZhbHVlOiBuZXcgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSksXG4gICAgICAgIHdyaXRhYmxlOiAnZmFsc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHNjdHBJbkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2N0cEluRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkZXNjcmlwdGlvbi5zZHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHNlY3Rpb25zID0gX3NkcDIuZGVmYXVsdC5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICByZXR1cm4gc2VjdGlvbnMuc29tZShmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICB2YXIgbUxpbmUgPSBfc2RwMi5kZWZhdWx0LnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24gZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24oZGVzY3JpcHRpb24pIHtcbiAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciBzb2x1dGlvbiBmb3IgZGV0ZWN0aW5nIEZpcmVmb3g/XG4gICAgdmFyIG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAvLyBUZXN0IGZvciBOYU4gKHllcywgdGhpcyBpcyB1Z2x5KVxuICAgIHJldHVybiB2ZXJzaW9uICE9PSB2ZXJzaW9uID8gLTEgOiB2ZXJzaW9uO1xuICB9O1xuXG4gIHZhciBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUocmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gRXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBjYW4gc2VuZCBhdCBsZWFzdCA2NCBLaUIuXG4gICAgLy8gTm90ZTogQWx0aG91Z2ggQ2hyb21lIGlzIHRlY2huaWNhbGx5IGFibGUgdG8gc2VuZCB1cCB0byAyNTYgS2lCLCB0aGVcbiAgICAvLyAgICAgICBkYXRhIGRvZXMgbm90IHJlYWNoIHRoZSBvdGhlciBwZWVyIHJlbGlhYmx5LlxuICAgIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTg0MTlcbiAgICB2YXIgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94Jykge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Nykge1xuICAgICAgICBpZiAocmVtb3RlSXNGaXJlZm94ID09PSAtMSkge1xuICAgICAgICAgIC8vIEZGIDwgNTcgd2lsbCBzZW5kIGluIDE2IEtpQiBjaHVua3MgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgUFBJRFxuICAgICAgICAgIC8vIGZyYWdtZW50YXRpb24uXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMTYzODQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSG93ZXZlciwgb3RoZXIgRkYgKGFuZCBSQVdSVEMpIGNhbiByZWFzc2VtYmxlIFBQSUQtZnJhZ21lbnRlZFxuICAgICAgICAgIC8vIG1lc3NhZ2VzLiBUaHVzLCBzdXBwb3J0aW5nIH4yIEdpQiB3aGVuIHNlbmRpbmcuXG4gICAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjApIHtcbiAgICAgICAgLy8gQ3VycmVudGx5LCBhbGwgRkYgPj0gNTcgd2lsbCByZXNldCB0aGUgcmVtb3RlIG1heGltdW0gbWVzc2FnZSBzaXplXG4gICAgICAgIC8vIHRvIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gYSBkYXRhIGNoYW5uZWwgaXMgY3JlYXRlZCBhdCBhIGxhdGVyXG4gICAgICAgIC8vIHN0YWdlLiA6KFxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gNTcgPyA2NTUzNSA6IDY1NTM2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRkYgPj0gNjAgc3VwcG9ydHMgc2VuZGluZyB+MiBHaUJcbiAgICAgICAgY2FuU2VuZE1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNlbmRNYXhNZXNzYWdlU2l6ZTtcbiAgfTtcblxuICB2YXIgZ2V0TWF4TWVzc2FnZVNpemUgPSBmdW5jdGlvbiBnZXRNYXhNZXNzYWdlU2l6ZShkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgdmFyIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2ggPSBfc2RwMi5kZWZhdWx0Lm1hdGNoUHJlZml4KGRlc2NyaXB0aW9uLnNkcCwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgICBpZiAobWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHIoMTkpLCAxMCk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnZmlyZWZveCcgJiYgcmVtb3RlSXNGaXJlZm94ICE9PSAtMSkge1xuICAgICAgLy8gSWYgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZW1vdGUgU0RQIGFuZFxuICAgICAgLy8gYm90aCBsb2NhbCBhbmQgcmVtb3RlIGFyZSBGaXJlZm94LCB0aGUgcmVtb3RlIHBlZXIgY2FuIHJlY2VpdmVcbiAgICAgIC8vIH4yIEdpQi5cbiAgICAgIG1heE1lc3NhZ2VTaXplID0gMjE0NzQ4MzYzNztcbiAgICB9XG4gICAgcmV0dXJuIG1heE1lc3NhZ2VTaXplO1xuICB9O1xuXG4gIHZhciBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgdGhpcy5fc2N0cCA9IG51bGw7XG4gICAgLy8gQ2hyb21lIGRlY2lkZWQgdG8gbm90IGV4cG9zZSAuc2N0cCBpbiBwbGFuLWIgbW9kZS5cbiAgICAvLyBBcyB1c3VhbCwgYWRhcHRlci5qcyBoYXMgdG8gZG8gYW4gJ3VnbHkgd29yYWthcm91bmQnXG4gICAgLy8gdG8gY292ZXIgdXAgdGhlIG1lc3MuXG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdjaHJvbWUnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNzYpIHtcbiAgICAgIHZhciBfZ2V0Q29uZmlndXJhdGlvbiA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpLFxuICAgICAgICAgIHNkcFNlbWFudGljcyA9IF9nZXRDb25maWd1cmF0aW9uLnNkcFNlbWFudGljcztcblxuICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zY3RwID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB0aGlzLl9zY3RwO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgIHZhciBpc0ZpcmVmb3ggPSBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihhcmd1bWVudHNbMF0pO1xuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIHRoZSBsb2NhbCBwZWVyIGlzIGNhcGFibGUgb2Ygc2VuZGluZ1xuICAgICAgdmFyIGNhblNlbmRNTVMgPSBnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUoaXNGaXJlZm94KTtcblxuICAgICAgLy8gR2V0IHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBvZiB0aGUgcmVtb3RlIHBlZXIuXG4gICAgICB2YXIgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgIHZhciBtYXhNZXNzYWdlU2l6ZSA9IHZvaWQgMDtcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgIHZhciBzY3RwID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2N0cCwgJ21heE1lc3NhZ2VTaXplJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdykge1xuICBpZiAoISh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2NyZWF0ZURhdGFDaGFubmVsJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE5vdGU6IEFsdGhvdWdoIEZpcmVmb3ggPj0gNTcgaGFzIGEgbmF0aXZlIGltcGxlbWVudGF0aW9uLCB0aGUgbWF4aW11bVxuICAvLyAgICAgICBtZXNzYWdlIHNpemUgY2FuIGJlIHJlc2V0IGZvciBhbGwgZGF0YSBjaGFubmVscyBhdCBhIGxhdGVyIHN0YWdlLlxuICAvLyAgICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjY4MzFcblxuICBmdW5jdGlvbiB3cmFwRGNTZW5kKGRjLCBwYykge1xuICAgIHZhciBvcmlnRGF0YUNoYW5uZWxTZW5kID0gZGMuc2VuZDtcbiAgICBkYy5zZW5kID0gZnVuY3Rpb24gc2VuZCgpIHtcbiAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRhdGEubGVuZ3RoIHx8IGRhdGEuc2l6ZSB8fCBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZGMucmVhZHlTdGF0ZSA9PT0gJ29wZW4nICYmIHBjLnNjdHAgJiYgbGVuZ3RoID4gcGMuc2N0cC5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXNzYWdlIHRvbyBsYXJnZSAoY2FuIHNlbmQgYSBtYXhpbXVtIG9mICcgKyBwYy5zY3RwLm1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnRGF0YUNoYW5uZWxTZW5kLmFwcGx5KGRjLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgdmFyIG9yaWdDcmVhdGVEYXRhQ2hhbm5lbCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWw7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRGF0YUNoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVEYXRhQ2hhbm5lbCgpIHtcbiAgICB2YXIgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gIH07XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZnVuY3Rpb24gKGUpIHtcbiAgICB3cmFwRGNTZW5kKGUuY2hhbm5lbCwgZS50YXJnZXQpO1xuICAgIHJldHVybiBlO1xuICB9KTtcbn1cblxuLyogc2hpbXMgUlRDQ29ubmVjdGlvblN0YXRlIGJ5IHByZXRlbmRpbmcgaXQgaXMgdGhlIHNhbWUgYXMgaWNlQ29ubmVjdGlvblN0YXRlLlxuICogU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD02MTQ1I2MxMlxuICogZm9yIHdoeSB0aGlzIGlzIGEgdmFsaWQgaGFjayBpbiBDaHJvbWUuIEluIEZpcmVmb3ggaXQgaXMgc2xpZ2h0bHkgaW5jb3JyZWN0XG4gKiBzaW5jZSBEVExTIGZhaWx1cmVzIHdvdWxkIGJlIGhpZGRlbi4gU2VlXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjY1ODI3XG4gKiBmb3IgdGhlIEZpcmVmb3ggdHJhY2tpbmcgYnVnLlxuICovXG5mdW5jdGlvbiBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCAnY29ubmVjdGlvblN0YXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXRlZDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgIGNoZWNraW5nOiAnY29ubmVjdGluZydcbiAgICAgIH1bdGhpcy5pY2VDb25uZWN0aW9uU3RhdGVdIHx8IHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlO1xuICAgIH0sXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNiKSB7XG4gICAgICBpZiAodGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZTtcbiAgICAgIH1cbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB2YXIgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnQgPSBuZXcgRXZlbnQoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIGUpO1xuICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsb3dFeHRtYXBNaXhlZCh3aW5kb3cpIHtcbiAgLyogcmVtb3ZlIGE9ZXh0bWFwLWFsbG93LW1peGVkIGZvciBDaHJvbWUgPCBNNzEgKi9cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgZGVzYy5zZHAgPSBkZXNjLnNkcC5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiBsaW5lLnRyaW0oKSAhPT0gJ2E9ZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlU1JELmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbn0se1wiLi91dGlsc1wiOjExLFwic2RwXCI6MTN9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoaW1HZXREaXNwbGF5TWVkaWEgPSBleHBvcnRzLnNoaW1HZXRVc2VyTWVkaWEgPSB1bmRlZmluZWQ7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9nZXR1c2VybWVkaWEgPSByZXF1aXJlKCcuL2dldHVzZXJtZWRpYScpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3NoaW1HZXRVc2VyTWVkaWEnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2V0dXNlcm1lZGlhLnNoaW1HZXRVc2VyTWVkaWE7XG4gIH1cbn0pO1xuXG52YXIgX2dldGRpc3BsYXltZWRpYSA9IHJlcXVpcmUoJy4vZ2V0ZGlzcGxheW1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldERpc3BsYXlNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXRkaXNwbGF5bWVkaWEuc2hpbUdldERpc3BsYXlNZWRpYTtcbiAgfVxufSk7XG5leHBvcnRzLnNoaW1PblRyYWNrID0gc2hpbU9uVHJhY2s7XG5leHBvcnRzLnNoaW1QZWVyQ29ubmVjdGlvbiA9IHNoaW1QZWVyQ29ubmVjdGlvbjtcbmV4cG9ydHMuc2hpbVNlbmRlckdldFN0YXRzID0gc2hpbVNlbmRlckdldFN0YXRzO1xuZXhwb3J0cy5zaGltUmVjZWl2ZXJHZXRTdGF0cyA9IHNoaW1SZWNlaXZlckdldFN0YXRzO1xuZXhwb3J0cy5zaGltUmVtb3ZlU3RyZWFtID0gc2hpbVJlbW92ZVN0cmVhbTtcbmV4cG9ydHMuc2hpbVJUQ0RhdGFDaGFubmVsID0gc2hpbVJUQ0RhdGFDaGFubmVsO1xuZXhwb3J0cy5zaGltQWRkVHJhbnNjZWl2ZXIgPSBzaGltQWRkVHJhbnNjZWl2ZXI7XG5leHBvcnRzLnNoaW1DcmVhdGVPZmZlciA9IHNoaW1DcmVhdGVPZmZlcjtcbmV4cG9ydHMuc2hpbUNyZWF0ZUFuc3dlciA9IHNoaW1DcmVhdGVBbnN3ZXI7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBzaGltT25UcmFjayh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXIgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltUGVlckNvbm5lY3Rpb24od2luZG93KSB7XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcblxuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpICE9PSAnb2JqZWN0JyB8fCAhKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuOyAvLyBwcm9iYWJseSBtZWRpYS5wZWVyY29ubmVjdGlvbi5lbmFibGVkPWZhbHNlIGluIGFib3V0OmNvbmZpZ1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikge1xuICAgIC8vIHZlcnkgYmFzaWMgc3VwcG9ydCBmb3Igb2xkIHZlcnNpb25zLlxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbjtcbiAgfVxuXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgdmFyIG1ldGhvZE9iaiA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgbWV0aG9kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICAvLyBhcyB3ZWxsIGFzIGlnbm9yaW5nIHtzZHBNaWQsIGNhbmRpZGF0ZTogXCJcIn1cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2OCkge1xuICAgIHZhciBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcbiAgICAgIC8vIGluIG9sZGVyIHZlcnNpb25zLlxuICAgICAgaWYgKGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBtb2Rlcm5TdGF0c1R5cGVzID0ge1xuICAgIGluYm91bmRydHA6ICdpbmJvdW5kLXJ0cCcsXG4gICAgb3V0Ym91bmRydHA6ICdvdXRib3VuZC1ydHAnLFxuICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgbG9jYWxjYW5kaWRhdGU6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgIHJlbW90ZWNhbmRpZGF0ZTogJ3JlbW90ZS1jYW5kaWRhdGUnXG4gIH07XG5cbiAgdmFyIG5hdGl2ZUdldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHZhciBfYXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgc2VsZWN0b3IgPSBfYXJndW1lbnRzWzBdLFxuICAgICAgICBvblN1Y2MgPSBfYXJndW1lbnRzWzFdLFxuICAgICAgICBvbkVyciA9IF9hcmd1bWVudHNbMl07XG5cbiAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1MyAmJiAhb25TdWNjKSB7XG4gICAgICAgIC8vIFNoaW0gb25seSBwcm9taXNlIGdldFN0YXRzIHdpdGggc3BlYy1oeXBoZW5zIGluIHR5cGUgbmFtZXNcbiAgICAgICAgLy8gTGVhdmUgY2FsbGJhY2sgdmVyc2lvbiBhbG9uZTsgbWlzYyBvbGQgdXNlcyBvZiBmb3JFYWNoIGJlZm9yZSBNYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgICAgICBzdGF0LnR5cGUgPSBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUubmFtZSAhPT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEF2b2lkIFR5cGVFcnJvcjogXCJ0eXBlXCIgaXMgcmVhZC1vbmx5LCBpbiBvbGQgdmVyc2lvbnMuIDM0LTQzaXNoXG4gICAgICAgICAgc3RhdHMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdCwgaSkge1xuICAgICAgICAgICAgc3RhdHMuc2V0KGksIE9iamVjdC5hc3NpZ24oe30sIHN0YXQsIHtcbiAgICAgICAgICAgICAgdHlwZTogbW9kZXJuU3RhdHNUeXBlc1tzdGF0LnR5cGVdIHx8IHN0YXQudHlwZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdHM7XG4gICAgfSkudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzZW5kZXJzID0gb3JpZ0dldFNlbmRlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgc2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci5fcGMgPSBfdGhpcztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICBpZiAob3JpZ0FkZFRyYWNrKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgdmFyIHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG4gIH1cbiAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayA/IHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spIDogUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1SZWNlaXZlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAod2luZG93LlJUQ1J0cFNlbmRlciAmJiAnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgaWYgKG9yaWdHZXRSZWNlaXZlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycyA9IGZ1bmN0aW9uIGdldFJlY2VpdmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVjZWl2ZXJzID0gb3JpZ0dldFJlY2VpdmVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICByZWNlaXZlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVyLl9wYyA9IF90aGlzMjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICB9O1xuICB9XG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG4gIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjayk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1SZW1vdmVTdHJlYW0od2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB1dGlscy5kZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcbiAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgIGlmIChzZW5kZXIudHJhY2sgJiYgc3RyZWFtLmdldFRyYWNrcygpLmluY2x1ZGVzKHNlbmRlci50cmFjaykpIHtcbiAgICAgICAgX3RoaXMzLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTczODUxXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0FkZFRyYW5zY2VpdmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlcjtcbiAgaWYgKG9yaWdBZGRUcmFuc2NlaXZlcikge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIgPSBmdW5jdGlvbiBhZGRUcmFuc2NlaXZlcigpIHtcbiAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB2YXIgaW5pdFBhcmFtZXRlcnMgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc2hvdWxkUGVyZm9ybUNoZWNrID0gaW5pdFBhcmFtZXRlcnMgJiYgJ3NlbmRFbmNvZGluZ3MnIGluIGluaXRQYXJhbWV0ZXJzO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBJZiBzZW5kRW5jb2RpbmdzIHBhcmFtcyBhcmUgcHJvdmlkZWQsIHZhbGlkYXRlIGdyYW1tYXJcbiAgICAgICAgaW5pdFBhcmFtZXRlcnMuc2VuZEVuY29kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgaWYgKCdyaWQnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIHZhciByaWRSZWdleCA9IC9eW2EtejAtOV17MCwxNn0kL2k7XG4gICAgICAgICAgICBpZiAoIXJpZFJlZ2V4LnRlc3QoZW5jb2RpbmdQYXJhbS5yaWQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgUklEIHZhbHVlIHByb3ZpZGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ3NjYWxlUmVzb2x1dGlvbkRvd25CeScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgPj0gMS4wKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2NhbGVfcmVzb2x1dGlvbl9kb3duX2J5IG11c3QgYmUgPj0gMS4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnbWF4RnJhbWVyYXRlJyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0ubWF4RnJhbWVyYXRlKSA+PSAwKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignbWF4X2ZyYW1lcmF0ZSBtdXN0IGJlID49IDAuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluaXQgb3B0aW9ucyB3ZXJlIGFwcGxpZWQuIElmIG5vdCB3ZSBkbyB0aGlzIGluIGFuXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiB1Z2x5IGhhY2ssIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGlzIHdheSBtb3JlIHJvYnVzdCB0aGFuXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzZW5kZXIgcGFyYW1ldGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjcmVhdGVPZmZlclxuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgcGFyYW1zIHdlcmUgYXN5bmNocm9ub3VzbHkgYXBwbGllZCBzbyB3ZSBtaWdodCBtaXNzIHRoZVxuICAgICAgICAvLyBvcHBvcnR1bml0eSB0byByZWNyZWF0ZSBvZmZlci5cbiAgICAgICAgdmFyIHNlbmRlciA9IHRyYW5zY2VpdmVyLnNlbmRlcjtcblxuICAgICAgICB2YXIgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgaWYgKCEoJ2VuY29kaW5ncycgaW4gcGFyYW1zKSkge1xuICAgICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBpbml0UGFyYW1ldGVycy5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLnB1c2goc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKS5jYXRjaChmdW5jdGlvbiAoKSB7fSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXI7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzLFxuICAgICAgICBfYXJndW1lbnRzMiA9IGFyZ3VtZW50cztcblxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkoX3RoaXM0LCBfYXJndW1lbnRzMik7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbUNyZWF0ZUFuc3dlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnQ3JlYXRlQW5zd2VyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzLFxuICAgICAgICBfYXJndW1lbnRzMyA9IGFyZ3VtZW50cztcblxuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KF90aGlzNSwgX2FyZ3VtZW50czMpO1xuICAgICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG59LHtcIi4uL3V0aWxzXCI6MTEsXCIuL2dldGRpc3BsYXltZWRpYVwiOjgsXCIuL2dldHVzZXJtZWRpYVwiOjl9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBhZGFwdGVyLmpzIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaGltR2V0RGlzcGxheU1lZGlhID0gc2hpbUdldERpc3BsYXlNZWRpYTtcbmZ1bmN0aW9uIHNoaW1HZXREaXNwbGF5TWVkaWEod2luZG93LCBwcmVmZXJyZWRNZWRpYVNvdXJjZSkge1xuICBpZiAod2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgJ2dldERpc3BsYXlNZWRpYScgaW4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPSBmdW5jdGlvbiBnZXREaXNwbGF5TWVkaWEoY29uc3RyYWludHMpIHtcbiAgICBpZiAoIShjb25zdHJhaW50cyAmJiBjb25zdHJhaW50cy52aWRlbykpIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRE9NRXhjZXB0aW9uKCdnZXREaXNwbGF5TWVkaWEgd2l0aG91dCB2aWRlbyAnICsgJ2NvbnN0cmFpbnRzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgZXJyLm5hbWUgPSAnTm90Rm91bmRFcnJvcic7XG4gICAgICAvLyBmcm9tIGh0dHBzOi8vaGV5Y2FtLmdpdGh1Yi5pby93ZWJpZGwvI2lkbC1ET01FeGNlcHRpb24tZXJyb3ItbmFtZXNcbiAgICAgIGVyci5jb2RlID0gODtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMudmlkZW8gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0geyBtZWRpYVNvdXJjZTogcHJlZmVycmVkTWVkaWFTb3VyY2UgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8ubWVkaWFTb3VyY2UgPSBwcmVmZXJyZWRNZWRpYVNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gIH07XG59XG5cbn0se31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLnNoaW1HZXRVc2VyTWVkaWEgPSBzaGltR2V0VXNlck1lZGlhO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIHZhciBNZWRpYVN0cmVhbVRyYWNrID0gd2luZG93ICYmIHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrO1xuXG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEnLCAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuXG4gIGlmICghKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPiA1NSAmJiAnYXV0b0dhaW5Db250cm9sJyBpbiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkpKSB7XG4gICAgdmFyIHJlbWFwID0gZnVuY3Rpb24gcmVtYXAob2JqLCBhLCBiKSB7XG4gICAgICBpZiAoYSBpbiBvYmogJiYgIShiIGluIG9iaikpIHtcbiAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbmF0aXZlR2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYmluZChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoKHR5cGVvZiBjID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjKSkgPT09ICdvYmplY3QnICYmIF90eXBlb2YoYy5hdWRpbykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAoYy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZUdldFVzZXJNZWRpYShjKTtcbiAgICB9O1xuXG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcbiAgICAgIHZhciBuYXRpdmVHZXRTZXR0aW5ncyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmdldFNldHRpbmdzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYmogPSBuYXRpdmVHZXRTZXR0aW5ncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZW1hcChvYmosICdtb3pBdXRvR2FpbkNvbnRyb2wnLCAnYXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vek5vaXNlU3VwcHJlc3Npb24nLCAnbm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzKSB7XG4gICAgICB2YXIgbmF0aXZlQXBwbHlDb25zdHJhaW50cyA9IE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHM7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gJ2F1ZGlvJyAmJiAodHlwZW9mIGMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGMpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgICAgICAgcmVtYXAoYywgJ2F1dG9HYWluQ29udHJvbCcsICdtb3pBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgICByZW1hcChjLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZUFwcGx5Q29uc3RyYWludHMuYXBwbHkodGhpcywgW2NdKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbn0se1wiLi4vdXRpbHNcIjoxMX1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuc2hpbUxvY2FsU3RyZWFtc0FQSSA9IHNoaW1Mb2NhbFN0cmVhbXNBUEk7XG5leHBvcnRzLnNoaW1SZW1vdGVTdHJlYW1zQVBJID0gc2hpbVJlbW90ZVN0cmVhbXNBUEk7XG5leHBvcnRzLnNoaW1DYWxsYmFja3NBUEkgPSBzaGltQ2FsbGJhY2tzQVBJO1xuZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gc2hpbUdldFVzZXJNZWRpYTtcbmV4cG9ydHMuc2hpbUNvbnN0cmFpbnRzID0gc2hpbUNvbnN0cmFpbnRzO1xuZXhwb3J0cy5zaGltUlRDSWNlU2VydmVyVXJscyA9IHNoaW1SVENJY2VTZXJ2ZXJVcmxzO1xuZXhwb3J0cy5zaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyID0gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcjtcbmV4cG9ydHMuc2hpbUNyZWF0ZU9mZmVyTGVnYWN5ID0gc2hpbUNyZWF0ZU9mZmVyTGVnYWN5O1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxudmFyIHV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gc2hpbUxvY2FsU3RyZWFtc0FQSSh3aW5kb3cpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICB2YXIgX2FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgfVxuICAgICAgLy8gVHJ5IHRvIGVtdWxhdGUgQ2hyb21lJ3MgYmVoYXZpb3VyIG9mIGFkZGluZyBpbiBhdWRpby12aWRlbyBvcmRlci5cbiAgICAgIC8vIFNhZmFyaSBvcmRlcnMgYnkgdHJhY2sgaWQuXG4gICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gX2FkZFRyYWNrLmNhbGwoX3RoaXMsIHRyYWNrLCBzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgICBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gX2FkZFRyYWNrLmNhbGwoX3RoaXMsIHRyYWNrLCBzdHJlYW0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xuICAgICAgdmFyIHN0cmVhbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbc3RyZWFtXTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX2FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgncmVtb3ZlU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB2YXIgdHJhY2tzID0gc3RyZWFtLmdldFRyYWNrcygpO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIF90aGlzMi5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vbmFkZHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLl9vbmFkZHN0cmVhbSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0pO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWRkc3RyZWFtJywgdGhpcy5fb25hZGRzdHJlYW0gPSBmKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpczMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgX3RoaXMzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMzLl9yZW1vdGVTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMzLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnYWRkc3RyZWFtJyk7XG4gICAgICAgICAgICBldmVudC5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICBfdGhpczMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBwYyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoIXBjLl9yZW1vdGVTdHJlYW1zKSB7XG4gICAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGMuX3JlbW90ZVN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID49IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQ2FsbGJhY2tzQVBJKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwcm90b3R5cGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB2YXIgb3JpZ0NyZWF0ZUFuc3dlciA9IHByb3RvdHlwZS5jcmVhdGVBbnN3ZXI7XG4gIHZhciBzZXRMb2NhbERlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHZhciBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgdmFyIGFkZEljZUNhbmRpZGF0ZSA9IHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG5cbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHJvbWlzZSA9IG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgcHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBwcm9taXNlID0gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG5cbiAgdmFyIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIHdpdGhDYWxsYmFjayhkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gd2l0aENhbGxiYWNrKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuXG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIHdpdGhDYWxsYmFjayhjYW5kaWRhdGUsIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSB3aXRoQ2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHNoaW1HZXRVc2VyTWVkaWEod2luZG93KSB7XG4gIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcblxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIC8vIHNoaW0gbm90IG5lZWRlZCBpbiBTYWZhcmkgMTIuMVxuICAgIHZhciBtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgIHZhciBfZ2V0VXNlck1lZGlhID0gbWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoIW5hdmlnYXRvci5nZXRVc2VyTWVkaWEgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSkge1xuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIGNiLCBlcnJjYikge1xuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4oY2IsIGVycmNiKTtcbiAgICB9LmJpbmQobmF2aWdhdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQ29uc3RyYWludHMoY29uc3RyYWludHMpIHtcbiAgaWYgKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29uc3RyYWludHMsIHsgdmlkZW86IHV0aWxzLmNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuXG5mdW5jdGlvbiBzaGltUlRDSWNlU2VydmVyVXJscyh3aW5kb3cpIHtcbiAgLy8gbWlncmF0ZSBmcm9tIG5vbi1zcGVjIFJUQ0ljZVNlcnZlci51cmwgdG8gUlRDSWNlU2VydmVyLnVybHNcbiAgdmFyIE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgdmFyIG5ld0ljZVNlcnZlcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGNDb25maWcuaWNlU2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VydmVyID0gcGNDb25maWcuaWNlU2VydmVyc1tpXTtcbiAgICAgICAgaWYgKCFzZXJ2ZXIuaGFzT3duUHJvcGVydHkoJ3VybHMnKSAmJiBzZXJ2ZXIuaGFzT3duUHJvcGVydHkoJ3VybCcpKSB7XG4gICAgICAgICAgdXRpbHMuZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgIHNlcnZlciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VydmVyKSk7XG4gICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChzZXJ2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE9yaWdQZWVyQ29ubmVjdGlvbi5nZW5lcmF0ZUNlcnRpZmljYXRlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIod2luZG93KSB7XG4gIC8vIEFkZCBldmVudC50cmFuc2NlaXZlciBtZW1iZXIgb3ZlciBkZXByZWNhdGVkIGV2ZW50LnJlY2VpdmVyXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7IHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbUNyZWF0ZU9mZmVyTGVnYWN5KHdpbmRvdykge1xuICB2YXIgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICB9XG4gICAgICB2YXIgYXVkaW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbyc7XG4gICAgICB9KTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gZmFsc2UgJiYgYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9PT0gdHJ1ZSAmJiAhYXVkaW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBzdXBwb3J0IGJpdCB2YWx1ZXNcbiAgICAgICAgb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSAhIW9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvO1xuICAgICAgfVxuICAgICAgdmFyIHZpZGVvVHJhbnNjZWl2ZXIgPSB0aGlzLmdldFRyYW5zY2VpdmVycygpLmZpbmQoZnVuY3Rpb24gKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjay5raW5kID09PSAndmlkZW8nO1xuICAgICAgfSk7XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IGZhbHNlICYmIHZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignc2VuZG9ubHknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnc2VuZG9ubHknO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3JlY3Zvbmx5Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ2luYWN0aXZlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gPT09IHRydWUgJiYgIXZpZGVvVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG59LHtcIi4uL3V0aWxzXCI6MTF9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuZXh0cmFjdFZlcnNpb24gPSBleHRyYWN0VmVyc2lvbjtcbmV4cG9ydHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQgPSB3cmFwUGVlckNvbm5lY3Rpb25FdmVudDtcbmV4cG9ydHMuZGlzYWJsZUxvZyA9IGRpc2FibGVMb2c7XG5leHBvcnRzLmRpc2FibGVXYXJuaW5ncyA9IGRpc2FibGVXYXJuaW5ncztcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuZGV0ZWN0QnJvd3NlciA9IGRldGVjdEJyb3dzZXI7XG5leHBvcnRzLmNvbXBhY3RPYmplY3QgPSBjb21wYWN0T2JqZWN0O1xuZXhwb3J0cy53YWxrU3RhdHMgPSB3YWxrU3RhdHM7XG5leHBvcnRzLmZpbHRlclN0YXRzID0gZmlsdGVyU3RhdHM7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBsb2dEaXNhYmxlZF8gPSB0cnVlO1xudmFyIGRlcHJlY2F0aW9uV2FybmluZ3NfID0gdHJ1ZTtcblxuLyoqXG4gKiBFeHRyYWN0IGJyb3dzZXIgdmVyc2lvbiBvdXQgb2YgdGhlIHByb3ZpZGVkIHVzZXIgYWdlbnQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gdWFzdHJpbmcgdXNlckFnZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IXN0cmluZ30gZXhwciBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBhcyBtYXRjaCBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7IW51bWJlcn0gcG9zIHBvc2l0aW9uIGluIHRoZSB2ZXJzaW9uIHN0cmluZyB0byBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IGJyb3dzZXIgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFZlcnNpb24odWFzdHJpbmcsIGV4cHIsIHBvcykge1xuICB2YXIgbWF0Y2ggPSB1YXN0cmluZy5tYXRjaChleHByKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBwb3MgJiYgcGFyc2VJbnQobWF0Y2hbcG9zXSwgMTApO1xufVxuXG4vLyBXcmFwcyB0aGUgcGVlcmNvbm5lY3Rpb24gZXZlbnQgZXZlbnROYW1lVG9XcmFwIGluIGEgZnVuY3Rpb25cbi8vIHdoaWNoIHJldHVybnMgdGhlIG1vZGlmaWVkIGV2ZW50IG9iamVjdCAob3IgZmFsc2UgdG8gcHJldmVudFxuLy8gdGhlIGV2ZW50KS5cbmZ1bmN0aW9uIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgZXZlbnROYW1lVG9XcmFwLCB3cmFwcGVyKSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVBZGRFdmVudExpc3RlbmVyID0gcHJvdG8uYWRkRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwKSB7XG4gICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKGUpIHtcbiAgICAgIHZhciBtb2RpZmllZEV2ZW50ID0gd3JhcHBlcihlKTtcbiAgICAgIGlmIChtb2RpZmllZEV2ZW50KSB7XG4gICAgICAgIGNiKG1vZGlmaWVkRXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRNYXAgPSB0aGlzLl9ldmVudE1hcCB8fCB7fTtcbiAgICB0aGlzLl9ldmVudE1hcFtjYl0gPSB3cmFwcGVkQ2FsbGJhY2s7XG4gICAgcmV0dXJuIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgd3JhcHBlZENhbGxiYWNrXSk7XG4gIH07XG5cbiAgdmFyIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIgPSBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyO1xuICBwcm90by5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXAgfHwgIXRoaXMuX2V2ZW50TWFwIHx8ICF0aGlzLl9ldmVudE1hcFtjYl0pIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHZhciB1bndyYXBwZWRDYiA9IHRoaXMuX2V2ZW50TWFwW2NiXTtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbY2JdO1xuICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsIHVud3JhcHBlZENiXSk7XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb24nICsgZXZlbnROYW1lVG9XcmFwLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChjYikge1xuICAgICAgaWYgKHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWVUb1dyYXAsIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdID0gY2IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZUxvZyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArICh0eXBlb2YgYm9vbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYm9vbCkpICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgbG9nRGlzYWJsZWRfID0gYm9vbDtcbiAgcmV0dXJuIGJvb2wgPyAnYWRhcHRlci5qcyBsb2dnaW5nIGRpc2FibGVkJyA6ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZW5hYmxlZCc7XG59XG5cbi8qKlxuICogRGlzYWJsZSBvciBlbmFibGUgZGVwcmVjYXRpb24gd2FybmluZ3NcbiAqIEBwYXJhbSB7IWJvb2xlYW59IGJvb2wgc2V0IHRvIHRydWUgdG8gZGlzYWJsZSB3YXJuaW5ncy5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZVdhcm5pbmdzKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgKHR5cGVvZiBib29sID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihib29sKSkgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBkZXByZWNhdGlvbldhcm5pbmdzXyA9ICFib29sO1xuICByZXR1cm4gJ2FkYXB0ZXIuanMgZGVwcmVjYXRpb24gd2FybmluZ3MgJyArIChib29sID8gJ2Rpc2FibGVkJyA6ICdlbmFibGVkJyk7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAobG9nRGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgZGVwcmVjYXRpb24gd2FybmluZyBzdWdnZXN0aW5nIHRoZSBtb2Rlcm4gYW5kIHNwZWMtY29tcGF0aWJsZSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkTWV0aG9kLCBuZXdNZXRob2QpIHtcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdzXykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4ob2xkTWV0aG9kICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdNZXRob2QgKyAnIGluc3RlYWQuJyk7XG59XG5cbi8qKlxuICogQnJvd3NlciBkZXRlY3Rvci5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cbiAqICAgICBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBkZXRlY3RCcm93c2VyKHdpbmRvdykge1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcblxuICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuXG4gIHZhciByZXN1bHQgPSB7IGJyb3dzZXI6IG51bGwsIHZlcnNpb246IG51bGwgfTtcblxuICAvLyBGYWlsIGVhcmx5IGlmIGl0J3Mgbm90IGEgYnJvd3NlclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5uYXZpZ2F0b3IpIHtcbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG4gICAgLy8gRmlyZWZveC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9GaXJlZm94XFwvKFxcZCspXFwuLywgMSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24gJiYgIXdpbmRvdy5SVENJY2VHYXRoZXJlcikge1xuICAgIC8vIENocm9tZSwgQ2hyb21pdW0sIFdlYnZpZXcsIE9wZXJhLlxuICAgIC8vIFZlcnNpb24gbWF0Y2hlcyBDaHJvbWUvV2ViUlRDIHZlcnNpb24uXG4gICAgLy8gQ2hyb21lIDc0IHJlbW92ZWQgd2Via2l0R2V0VXNlck1lZGlhIG9uIGh0dHAgYXMgd2VsbCBzbyB3ZSBuZWVkIHRoZVxuICAgIC8vIG1vcmUgY29tcGxpY2F0ZWQgZmFsbGJhY2sgdG8gd2Via2l0UlRDUGVlckNvbm5lY3Rpb24uXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnY2hyb21lJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9DaHJvbShlfGl1bSlcXC8oXFxkKylcXC4vLCAyKTtcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykuKFxcZCspJC8pKSB7XG4gICAgLy8gRWRnZS5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdlZGdlJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9FZGdlXFwvKFxcZCspLihcXGQrKSQvLCAyKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKSkge1xuICAgIC8vIFNhZmFyaS5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdzYWZhcmknO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLywgMSk7XG4gICAgcmVzdWx0LnN1cHBvcnRzVW5pZmllZFBsYW4gPSB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgJiYgJ2N1cnJlbnREaXJlY3Rpb24nIGluIHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBmYWxsdGhyb3VnaDogbm90IHN1cHBvcnRlZC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdOb3QgYSBzdXBwb3J0ZWQgYnJvd3Nlci4nO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBzb21ldGhpbmcgeW91IHdhbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgdmFsIGlzIGFuIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYWxsIGVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXNcbiAqIGZyb20gYSBuZXN0ZWQgb2JqZWN0IC0tIGFuIGVuaGFuY2VkIGFuZCB2YW5pbGxhIHZlcnNpb25cbiAqIG9mIExvZGFzaCdzIGBjb21wYWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdE9iamVjdChkYXRhKSB7XG4gIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICB2YXIgaXNPYmogPSBpc09iamVjdChkYXRhW2tleV0pO1xuICAgIHZhciB2YWx1ZSA9IGlzT2JqID8gY29tcGFjdE9iamVjdChkYXRhW2tleV0pIDogZGF0YVtrZXldO1xuICAgIHZhciBpc0VtcHR5T2JqZWN0ID0gaXNPYmogJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2N1bXVsYXRvciwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIHZhbHVlKSk7XG4gIH0sIHt9KTtcbn1cblxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xuZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcbiAgaWYgKCFiYXNlIHx8IHJlc3VsdFNldC5oYXMoYmFzZS5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0U2V0LnNldChiYXNlLmlkLCBiYXNlKTtcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKCdJZCcpKSB7XG4gICAgICB3YWxrU3RhdHMoc3RhdHMsIHN0YXRzLmdldChiYXNlW25hbWVdKSwgcmVzdWx0U2V0KTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkcycpKSB7XG4gICAgICBiYXNlW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGlkKSwgcmVzdWx0U2V0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qIGZpbHRlciBnZXRTdGF0cyBmb3IgYSBzZW5kZXIvcmVjZWl2ZXIgdHJhY2suICovXG5mdW5jdGlvbiBmaWx0ZXJTdGF0cyhyZXN1bHQsIHRyYWNrLCBvdXRib3VuZCkge1xuICB2YXIgc3RyZWFtU3RhdHNUeXBlID0gb3V0Ym91bmQgPyAnb3V0Ym91bmQtcnRwJyA6ICdpbmJvdW5kLXJ0cCc7XG4gIHZhciBmaWx0ZXJlZFJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICB9XG4gIHZhciB0cmFja1N0YXRzID0gW107XG4gIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAndHJhY2snICYmIHZhbHVlLnRyYWNrSWRlbnRpZmllciA9PT0gdHJhY2suaWQpIHtcbiAgICAgIHRyYWNrU3RhdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgdHJhY2tTdGF0cy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFja1N0YXQpIHtcbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgIGlmIChzdGF0cy50eXBlID09PSBzdHJlYW1TdGF0c1R5cGUgJiYgc3RhdHMudHJhY2tJZCA9PT0gdHJhY2tTdGF0LmlkKSB7XG4gICAgICAgIHdhbGtTdGF0cyhyZXN1bHQsIHN0YXRzLCBmaWx0ZXJlZFJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG59XG5cbn0se31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIFNEUCBoZWxwZXJzLlxudmFyIFNEUFV0aWxzID0ge307XG5cbi8vIEdlbmVyYXRlIGFuIGFscGhhbnVtZXJpYyBpZGVudGlmaWVyIGZvciBjbmFtZSBvciBtaWRzLlxuLy8gVE9ETzogdXNlIFVVSURzIGluc3RlYWQ/IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2plZC85ODI4ODNcblNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKTtcbn07XG5cbi8vIFRoZSBSVENQIENOQU1FIHVzZWQgYnkgYWxsIHBlZXJjb25uZWN0aW9ucyBmcm9tIHRoZSBzYW1lIEpTLlxuU0RQVXRpbHMubG9jYWxDTmFtZSA9IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuXG4vLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuU0RQVXRpbHMuc3BsaXRMaW5lcyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgfSk7XG59O1xuLy8gU3BsaXRzIFNEUCBpbnRvIHNlc3Npb25wYXJ0IGFuZCBtZWRpYXNlY3Rpb25zLiBFbnN1cmVzIENSTEYuXG5TRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgcGFydHMgPSBibG9iLnNwbGl0KCdcXG5tPScpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uKHBhcnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIChpbmRleCA+IDAgPyAnbT0nICsgcGFydCA6IHBhcnQpLnRyaW0oKSArICdcXHJcXG4nO1xuICB9KTtcbn07XG5cbi8vIHJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG5TRFBVdGlscy5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xufTtcblxuLy8gcmV0dXJucyB0aGUgaW5kaXZpZHVhbCBtZWRpYSBzZWN0aW9ucy5cblNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoYmxvYik7XG4gIHNlY3Rpb25zLnNoaWZ0KCk7XG4gIHJldHVybiBzZWN0aW9ucztcbn07XG5cbi8vIFJldHVybnMgbGluZXMgdGhhdCBzdGFydCB3aXRoIGEgY2VydGFpbiBwcmVmaXguXG5TRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uKGJsb2IsIHByZWZpeCkge1xuICByZXR1cm4gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKS5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiBsaW5lLmluZGV4T2YocHJlZml4KSA9PT0gMDtcbiAgfSk7XG59O1xuXG4vLyBQYXJzZXMgYW4gSUNFIGNhbmRpZGF0ZSBsaW5lLiBTYW1wbGUgaW5wdXQ6XG4vLyBjYW5kaWRhdGU6NzAyNzg2MzUwIDIgdWRwIDQxODE5OTAyIDguOC44LjggNjA3NjkgdHlwIHJlbGF5IHJhZGRyIDguOC44Ljhcbi8vIHJwb3J0IDU1OTk2XCJcblNEUFV0aWxzLnBhcnNlQ2FuZGlkYXRlID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHM7XG4gIC8vIFBhcnNlIGJvdGggdmFyaWFudHMuXG4gIGlmIChsaW5lLmluZGV4T2YoJ2E9Y2FuZGlkYXRlOicpID09PSAwKSB7XG4gICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZSA9IHtcbiAgICBmb3VuZGF0aW9uOiBwYXJ0c1swXSxcbiAgICBjb21wb25lbnQ6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgcHJpb3JpdHk6IHBhcnNlSW50KHBhcnRzWzNdLCAxMCksXG4gICAgaXA6IHBhcnRzWzRdLFxuICAgIGFkZHJlc3M6IHBhcnRzWzRdLCAvLyBhZGRyZXNzIGlzIGFuIGFsaWFzIGZvciBpcC5cbiAgICBwb3J0OiBwYXJzZUludChwYXJ0c1s1XSwgMTApLFxuICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICB0eXBlOiBwYXJ0c1s3XVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSA4OyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XG4gICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgIGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCA9IHBhcnNlSW50KHBhcnRzW2kgKyAxXSwgMTApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICBjYW5kaWRhdGUudGNwVHlwZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgIGNhbmRpZGF0ZS51ZnJhZyA9IHBhcnRzW2kgKyAxXTsgLy8gZm9yIGJhY2t3YXJkIGNvbXBhYmlsaXR5LlxuICAgICAgICBjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBleHRlbnNpb24gaGFuZGxpbmcsIGluIHBhcnRpY3VsYXIgdWZyYWdcbiAgICAgICAgY2FuZGlkYXRlW3BhcnRzW2ldXSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59O1xuXG4vLyBUcmFuc2xhdGVzIGEgY2FuZGlkYXRlIG9iamVjdCBpbnRvIFNEUCBjYW5kaWRhdGUgYXR0cmlidXRlLlxuU0RQVXRpbHMud3JpdGVDYW5kaWRhdGUgPSBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgdmFyIHNkcCA9IFtdO1xuICBzZHAucHVzaChjYW5kaWRhdGUuZm91bmRhdGlvbik7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5jb21wb25lbnQpO1xuICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcmlvcml0eSk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5hZGRyZXNzIHx8IGNhbmRpZGF0ZS5pcCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcblxuICB2YXIgdHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICBzZHAucHVzaCgndHlwJyk7XG4gIHNkcC5wdXNoKHR5cGUpO1xuICBpZiAodHlwZSAhPT0gJ2hvc3QnICYmIGNhbmRpZGF0ZS5yZWxhdGVkQWRkcmVzcyAmJlxuICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgc2RwLnB1c2goJ3JhZGRyJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzKTtcbiAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZFBvcnQpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICBzZHAucHVzaCgndGNwdHlwZScpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS50Y3BUeXBlKTtcbiAgfVxuICBpZiAoY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKSB7XG4gICAgc2RwLnB1c2goJ3VmcmFnJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgfVxuICByZXR1cm4gJ2NhbmRpZGF0ZTonICsgc2RwLmpvaW4oJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBpY2Utb3B0aW9ucyBsaW5lLCByZXR1cm5zIGFuIGFycmF5IG9mIG9wdGlvbiB0YWdzLlxuLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG5TRFBVdGlscy5wYXJzZUljZU9wdGlvbnMgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHJldHVybiBsaW5lLnN1YnN0cigxNCkuc3BsaXQoJyAnKTtcbn07XG5cbi8vIFBhcnNlcyBhbiBydHBtYXAgbGluZSwgcmV0dXJucyBSVENSdHBDb2RkZWNQYXJhbWV0ZXJzLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0cG1hcDoxMTEgb3B1cy80ODAwMC8yXG5TRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoOSkuc3BsaXQoJyAnKTtcbiAgdmFyIHBhcnNlZCA9IHtcbiAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgfTtcblxuICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG5cbiAgcGFyc2VkLm5hbWUgPSBwYXJ0c1swXTtcbiAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gIHBhcnNlZC5jaGFubmVscyA9IHBhcnRzLmxlbmd0aCA9PT0gMyA/IHBhcnNlSW50KHBhcnRzWzJdLCAxMCkgOiAxO1xuICAvLyBsZWdhY3kgYWxpYXMsIGdvdCByZW5hbWVkIGJhY2sgdG8gY2hhbm5lbHMgaW4gT1JUQy5cbiAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gR2VuZXJhdGUgYW4gYT1ydHBtYXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvclxuLy8gUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIHZhciBjaGFubmVscyA9IGNvZGVjLmNoYW5uZWxzIHx8IGNvZGVjLm51bUNoYW5uZWxzIHx8IDE7XG4gIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArXG4gICAgICAoY2hhbm5lbHMgIT09IDEgPyAnLycgKyBjaGFubmVscyA6ICcnKSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGE9ZXh0bWFwIGxpbmUgKGhlYWRlcmV4dGVuc2lvbiBmcm9tIFJGQyA1Mjg1KS4gU2FtcGxlIGlucHV0OlxuLy8gYT1leHRtYXA6MiB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDp0b2Zmc2V0XG4vLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcblNEUFV0aWxzLnBhcnNlRXh0bWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGlkOiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgIGRpcmVjdGlvbjogcGFydHNbMF0uaW5kZXhPZignLycpID4gMCA/IHBhcnRzWzBdLnNwbGl0KCcvJylbMV0gOiAnc2VuZHJlY3YnLFxuICAgIHVyaTogcGFydHNbMV1cbiAgfTtcbn07XG5cbi8vIEdlbmVyYXRlcyBhPWV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuLy8gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uLlxuU0RQVXRpbHMud3JpdGVFeHRtYXAgPSBmdW5jdGlvbihoZWFkZXJFeHRlbnNpb24pIHtcbiAgcmV0dXJuICdhPWV4dG1hcDonICsgKGhlYWRlckV4dGVuc2lvbi5pZCB8fCBoZWFkZXJFeHRlbnNpb24ucHJlZmVycmVkSWQpICtcbiAgICAgIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdidcbiAgICAgICAgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uXG4gICAgICAgIDogJycpICtcbiAgICAgICcgJyArIGhlYWRlckV4dGVuc2lvbi51cmkgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyBhbiBmdG1wIGxpbmUsIHJldHVybnMgZGljdGlvbmFyeS4gU2FtcGxlIGlucHV0OlxuLy8gYT1mbXRwOjk2IHZicj1vbjtjbmc9b25cbi8vIEFsc28gZGVhbHMgd2l0aCB2YnI9b247IGNuZz1vblxuU0RQVXRpbHMucGFyc2VGbXRwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrdjtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnOycpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICBwYXJzZWRba3ZbMF0udHJpbSgpXSA9IGt2WzFdO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYW4gYT1mdG1wIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24oY29kZWMpIHtcbiAgdmFyIGxpbmUgPSAnJztcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucGFyYW1ldGVycyAmJiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5sZW5ndGgpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnNbcGFyYW1dKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgJz0nICsgY29kZWMucGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxpbmUgKz0gJ2E9Zm10cDonICsgcHQgKyAnICcgKyBwYXJhbXMuam9pbignOycpICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG4vLyBQYXJzZXMgYW4gcnRjcC1mYiBsaW5lLCByZXR1cm5zIFJUQ1BSdGNwRmVlZGJhY2sgb2JqZWN0LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXJ0Y3AtZmI6OTggbmFjayBycHNpXG5TRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIobGluZS5pbmRleE9mKCcgJykgKyAxKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgcGFyYW1ldGVyOiBwYXJ0cy5qb2luKCcgJylcbiAgfTtcbn07XG4vLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdGNwRmIgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZXMgPSAnJztcbiAgdmFyIHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgfVxuICBpZiAoY29kZWMucnRjcEZlZWRiYWNrICYmIGNvZGVjLnJ0Y3BGZWVkYmFjay5sZW5ndGgpIHtcbiAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICBjb2RlYy5ydGNwRmVlZGJhY2suZm9yRWFjaChmdW5jdGlvbihmYikge1xuICAgICAgbGluZXMgKz0gJ2E9cnRjcC1mYjonICsgcHQgKyAnICcgKyBmYi50eXBlICtcbiAgICAgIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufTtcblxuLy8gUGFyc2VzIGFuIFJGQyA1NTc2IHNzcmMgbWVkaWEgYXR0cmlidXRlLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcblNEUFV0aWxzLnBhcnNlU3NyY01lZGlhID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgc3AgPSBsaW5lLmluZGV4T2YoJyAnKTtcbiAgdmFyIHBhcnRzID0ge1xuICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyKDcsIHNwIC0gNyksIDEwKVxuICB9O1xuICB2YXIgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gIGlmIChjb2xvbiA+IC0xKSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxLCBjb2xvbiAtIHNwIC0gMSk7XG4gICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cihjb2xvbiArIDEpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzLmF0dHJpYnV0ZSA9IGxpbmUuc3Vic3RyKHNwICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufTtcblxuU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDEzKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICBzc3JjczogcGFydHMubWFwKGZ1bmN0aW9uKHNzcmMpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChzc3JjLCAxMCk7XG4gICAgfSlcbiAgfTtcbn07XG5cbi8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbi8vIHJldHVybnMgdGhlIE1JRCBvciB1bmRlZmluZWQgaWYgbm8gbWlkIGxpbmUgd2FzIGZvdW5kLlxuU0RQVXRpbHMuZ2V0TWlkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgaWYgKG1pZCkge1xuICAgIHJldHVybiBtaWQuc3Vic3RyKDYpO1xuICB9XG59O1xuXG5TRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigxNCkuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgIHZhbHVlOiBwYXJ0c1sxXVxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBmaW5nZXJwcmludCBsaW5lIGFzIGlucHV0LiBTZWUgYWxzbyBnZXRJY2VQYXJhbWV0ZXJzLlxuU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWZpbmdlcnByaW50OicpO1xuICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlLlxuICAvLyBOb3RlMjogJ2FsZ29yaXRobScgaXMgbm90IGNhc2Ugc2Vuc2l0aXZlIGV4Y2VwdCBpbiBFZGdlLlxuICByZXR1cm4ge1xuICAgIHJvbGU6ICdhdXRvJyxcbiAgICBmaW5nZXJwcmludHM6IGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50KVxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHBhcmFtcywgc2V0dXBUeXBlKSB7XG4gIHZhciBzZHAgPSAnYT1zZXR1cDonICsgc2V0dXBUeXBlICsgJ1xcclxcbic7XG4gIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmdW5jdGlvbihmcCkge1xuICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgfSk7XG4gIHJldHVybiBzZHA7XG59O1xuLy8gUGFyc2VzIElDRSBpbmZvcm1hdGlvbiBmcm9tIFNEUCBtZWRpYSBzZWN0aW9uIG9yIHNlc3Npb25wYXJ0LlxuLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4vLyAgIGdldCB0aGUgaWNlLXVmcmFnIGFuZCBpY2UtcHdkIGxpbmVzIGFzIGlucHV0LlxuU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAvLyBTZWFyY2ggaW4gc2Vzc2lvbiBwYXJ0LCB0b28uXG4gIGxpbmVzID0gbGluZXMuY29uY2F0KFNEUFV0aWxzLnNwbGl0TGluZXMoc2Vzc2lvbnBhcnQpKTtcbiAgdmFyIGljZVBhcmFtZXRlcnMgPSB7XG4gICAgdXNlcm5hbWVGcmFnbWVudDogbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLXVmcmFnOicpID09PSAwO1xuICAgIH0pWzBdLnN1YnN0cigxMiksXG4gICAgcGFzc3dvcmQ6IGxpbmVzLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gbGluZS5pbmRleE9mKCdhPWljZS1wd2Q6JykgPT09IDA7XG4gICAgfSlbMF0uc3Vic3RyKDEwKVxuICB9O1xuICByZXR1cm4gaWNlUGFyYW1ldGVycztcbn07XG5cbi8vIFNlcmlhbGl6ZXMgSUNFIHBhcmFtZXRlcnMgdG8gU0RQLlxuU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiAnYT1pY2UtdWZyYWc6JyArIHBhcmFtcy51c2VybmFtZUZyYWdtZW50ICsgJ1xcclxcbicgK1xuICAgICAgJ2E9aWNlLXB3ZDonICsgcGFyYW1zLnBhc3N3b3JkICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW10sXG4gICAgcnRjcDogW11cbiAgfTtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICBmb3IgKHZhciBpID0gMzsgaSA8IG1saW5lLmxlbmd0aDsgaSsrKSB7IC8vIGZpbmQgYWxsIGNvZGVjcyBmcm9tIG1saW5lWzMuLl1cbiAgICB2YXIgcHQgPSBtbGluZVtpXTtcbiAgICB2YXIgcnRwbWFwbGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgbWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICBpZiAocnRwbWFwbGluZSkge1xuICAgICAgdmFyIGNvZGVjID0gU0RQVXRpbHMucGFyc2VSdHBNYXAocnRwbWFwbGluZSk7XG4gICAgICB2YXIgZm10cHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChcbiAgICAgICAgbWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAvLyBPbmx5IHRoZSBmaXJzdCBhPWZtdHA6PHB0PiBpcyBjb25zaWRlcmVkLlxuICAgICAgY29kZWMucGFyYW1ldGVycyA9IGZtdHBzLmxlbmd0aCA/IFNEUFV0aWxzLnBhcnNlRm10cChmbXRwc1swXSkgOiB7fTtcbiAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnKVxuICAgICAgICAubWFwKFNEUFV0aWxzLnBhcnNlUnRjcEZiKTtcbiAgICAgIGRlc2NyaXB0aW9uLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgc3dpdGNoIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnUkVEJzpcbiAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLnB1c2goY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDogLy8gb25seSBSRUQgYW5kIFVMUEZFQyBhcmUgcmVjb2duaXplZCBhcyBGRUMgbWVjaGFuaXNtcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgfSk7XG4gIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICByZXR1cm4gZGVzY3JpcHRpb247XG59O1xuXG4vLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4vLyBwYXJhbWV0ZXJzLlxuU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGtpbmQsIGNhcHMpIHtcbiAgdmFyIHNkcCA9ICcnO1xuXG4gIC8vIEJ1aWxkIHRoZSBtbGluZS5cbiAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubGVuZ3RoID4gMCA/ICc5JyA6ICcwJzsgLy8gcmVqZWN0IGlmIG5vIGNvZGVjcy5cbiAgc2RwICs9ICcgVURQL1RMUy9SVFAvU0FWUEYgJztcbiAgc2RwICs9IGNhcHMuY29kZWNzLm1hcChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgfSkuam9pbignICcpICsgJ1xcclxcbic7XG5cbiAgc2RwICs9ICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJztcbiAgc2RwICs9ICdhPXJ0Y3A6OSBJTiBJUDQgMC4wLjAuMFxcclxcbic7XG5cbiAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBzZHAgKz0gU0RQVXRpbHMud3JpdGVSdHBNYXAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUZtdHAoY29kZWMpO1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gIH0pO1xuICB2YXIgbWF4cHRpbWUgPSAwO1xuICBjYXBzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgIG1heHB0aW1lID0gY29kZWMubWF4cHRpbWU7XG4gICAgfVxuICB9KTtcbiAgaWYgKG1heHB0aW1lID4gMCkge1xuICAgIHNkcCArPSAnYT1tYXhwdGltZTonICsgbWF4cHRpbWUgKyAnXFxyXFxuJztcbiAgfVxuICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuXG4gIGlmIChjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgIH0pO1xuICB9XG4gIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuLy8gUlRDUnRwRW5jb2RpbmdQYXJhbWV0ZXJzLlxuU0RQVXRpbHMucGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICB2YXIgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICB2YXIgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgLy8gZmlsdGVyIGE9c3NyYzouLi4gY25hbWU6LCBpZ25vcmUgUGxhbkItbXNpZFxuICB2YXIgc3NyY3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ocGFydHMpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gICAgfSk7XG4gIHZhciBwcmltYXJ5U3NyYyA9IHNzcmNzLmxlbmd0aCA+IDAgJiYgc3NyY3NbMF0uc3NyYztcbiAgdmFyIHNlY29uZGFyeVNzcmM7XG5cbiAgdmFyIGZsb3dzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjLWdyb3VwOkZJRCcpXG4gICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigxNykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocGFydCwgMTApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIGlmIChmbG93cy5sZW5ndGggPiAwICYmIGZsb3dzWzBdLmxlbmd0aCA+IDEgJiYgZmxvd3NbMF1bMF0gPT09IHByaW1hcnlTc3JjKSB7XG4gICAgc2Vjb25kYXJ5U3NyYyA9IGZsb3dzWzBdWzFdO1xuICB9XG5cbiAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpID09PSAnUlRYJyAmJiBjb2RlYy5wYXJhbWV0ZXJzLmFwdCkge1xuICAgICAgdmFyIGVuY1BhcmFtID0ge1xuICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgY29kZWNQYXlsb2FkVHlwZTogcGFyc2VJbnQoY29kZWMucGFyYW1ldGVycy5hcHQsIDEwKVxuICAgICAgfTtcbiAgICAgIGlmIChwcmltYXJ5U3NyYyAmJiBzZWNvbmRhcnlTc3JjKSB7XG4gICAgICAgIGVuY1BhcmFtLnJ0eCA9IHtzc3JjOiBzZWNvbmRhcnlTc3JjfTtcbiAgICAgIH1cbiAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIGlmIChoYXNSZWQpIHtcbiAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgIGVuY1BhcmFtLmZlYyA9IHtcbiAgICAgICAgICBzc3JjOiBwcmltYXJ5U3NyYyxcbiAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXG4gICAgICAgIH07XG4gICAgICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKGVuY1BhcmFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgIGVuY29kaW5nUGFyYW1ldGVycy5wdXNoKHtcbiAgICAgIHNzcmM6IHByaW1hcnlTc3JjXG4gICAgfSk7XG4gIH1cblxuICAvLyB3ZSBzdXBwb3J0IGJvdGggYj1BUyBhbmQgYj1USUFTIGJ1dCBpbnRlcnByZXQgQVMgYXMgVElBUy5cbiAgdmFyIGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gIGlmIChiYW5kd2lkdGgubGVuZ3RoKSB7XG4gICAgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPVRJQVM6JykgPT09IDApIHtcbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNyksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJhbmR3aWR0aFswXS5pbmRleE9mKCdiPUFTOicpID09PSAwKSB7XG4gICAgICAvLyB1c2UgZm9ybXVsYSBmcm9tIEpTRVAgdG8gY29udmVydCBiPUFTIHRvIFRJQVMgdmFsdWUuXG4gICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyKDUpLCAxMCkgKiAxMDAwICogMC45NVxuICAgICAgICAgIC0gKDUwICogNDAgKiA4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFuZHdpZHRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgaHR0cDovL2RyYWZ0Lm9ydGMub3JnLyNydGNydGNwcGFyYW1ldGVycypcblNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHJ0Y3BQYXJhbWV0ZXJzID0ge307XG5cbiAgLy8gR2V0cyB0aGUgZmlyc3QgU1NSQy4gTm90ZSB0aGEgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgLy8gU1NSQ3MuXG4gIHZhciByZW1vdGVTc3JjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iai5hdHRyaWJ1dGUgPT09ICdjbmFtZSc7XG4gICAgfSlbMF07XG4gIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgcnRjcFBhcmFtZXRlcnMuY25hbWUgPSByZW1vdGVTc3JjLnZhbHVlO1xuICAgIHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgPSByZW1vdGVTc3JjLnNzcmM7XG4gIH1cblxuICAvLyBFZGdlIHVzZXMgdGhlIGNvbXBvdW5kIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIHJlZHVjZWRTaXplXG4gIC8vIGNvbXBvdW5kIGlzICFyZWR1Y2VkU2l6ZVxuICB2YXIgcnNpemUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtcnNpemUnKTtcbiAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICBydGNwUGFyYW1ldGVycy5jb21wb3VuZCA9IHJzaXplLmxlbmd0aCA9PT0gMDtcblxuICAvLyBwYXJzZXMgdGhlIHJ0Y3AtbXV4IGF0dHLRlmJ1dGUuXG4gIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICB2YXIgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICBydGNwUGFyYW1ldGVycy5tdXggPSBtdXgubGVuZ3RoID4gMDtcblxuICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG59O1xuXG4vLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4vLyB0aGUgaWQgb2YgdGhlIE1lZGlhU3RyZWFtIGFuZCBNZWRpYVN0cmVhbVRyYWNrLlxuU0RQVXRpbHMucGFyc2VNc2lkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBwYXJ0cztcbiAgdmFyIHNwZWMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1zaWQ6Jyk7XG4gIGlmIChzcGVjLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHIoNykuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbiAgdmFyIHBsYW5CID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpXG4gICAgLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSk7XG4gICAgfSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uKG1zaWRQYXJ0cykge1xuICAgICAgcmV0dXJuIG1zaWRQYXJ0cy5hdHRyaWJ1dGUgPT09ICdtc2lkJztcbiAgICB9KTtcbiAgaWYgKHBsYW5CLmxlbmd0aCA+IDApIHtcbiAgICBwYXJ0cyA9IHBsYW5CWzBdLnZhbHVlLnNwbGl0KCcgJyk7XG4gICAgcmV0dXJuIHtzdHJlYW06IHBhcnRzWzBdLCB0cmFjazogcGFydHNbMV19O1xuICB9XG59O1xuXG4vLyBTQ1RQXG4vLyBwYXJzZXMgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgZmlyc3QgYW5kIGZhbGxzIGJhY2tcbi8vIHRvIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTA1XG5TRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbWxpbmUgPSBTRFBVdGlscy5wYXJzZU1MaW5lKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtYXhTaXplTGluZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonKTtcbiAgdmFyIG1heE1lc3NhZ2VTaXplO1xuICBpZiAobWF4U2l6ZUxpbmUubGVuZ3RoID4gMCkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF4U2l6ZUxpbmVbMF0uc3Vic3RyKDE5KSwgMTApO1xuICB9XG4gIGlmIChpc05hTihtYXhNZXNzYWdlU2l6ZSkpIHtcbiAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM2O1xuICB9XG4gIHZhciBzY3RwUG9ydCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cC1wb3J0OicpO1xuICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChzY3RwUG9ydFswXS5zdWJzdHIoMTIpLCAxMCksXG4gICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgbWF4TWVzc2FnZVNpemU6IG1heE1lc3NhZ2VTaXplXG4gICAgfTtcbiAgfVxuICB2YXIgc2N0cE1hcExpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwbWFwOicpO1xuICBpZiAoc2N0cE1hcExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGFydHMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6JylbMF1cbiAgICAgIC5zdWJzdHIoMTApXG4gICAgICAuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgIHByb3RvY29sOiBwYXJ0c1sxXSxcbiAgICAgIG1heE1lc3NhZ2VTaXplOiBtYXhNZXNzYWdlU2l6ZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIG91dHB1dHMgdGhlIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IHZlcnNpb24gdGhhdCBhbGwgYnJvd3NlcnNcbi8vIHN1cHBvcnQgYnkgbm93IHJlY2VpdmluZyBpbiB0aGlzIGZvcm1hdCwgdW5sZXNzIHdlIG9yaWdpbmFsbHkgcGFyc2VkXG4vLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxuLy8gcHJvdG9jb2wgb2YgRFRMUy9TQ1RQIC0tIHdpdGhvdXQgVURQLyBvciBUQ1AvKVxuU0RQVXRpbHMud3JpdGVTY3RwRGVzY3JpcHRpb24gPSBmdW5jdGlvbihtZWRpYSwgc2N0cCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGlmIChtZWRpYS5wcm90b2NvbCAhPT0gJ0RUTFMvU0NUUCcpIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnByb3RvY29sICsgJ1xcclxcbicsXG4gICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsXG4gICAgICAnYT1zY3RwLXBvcnQ6JyArIHNjdHAucG9ydCArICdcXHJcXG4nXG4gICAgXTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBbXG4gICAgICAnbT0nICsgbWVkaWEua2luZCArICcgOSAnICsgbWVkaWEucHJvdG9jb2wgKyAnICcgKyBzY3RwLnBvcnQgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ1xuICAgIF07XG4gIH1cbiAgaWYgKHNjdHAubWF4TWVzc2FnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgU0RQLlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtcnRjd2ViLWpzZXAtMjAjc2VjdGlvbi01LjIuMVxuLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4vLyBidXQgcmlnaHQgbm93IHRoaXMgc2hvdWxkIGJlIGFjY2VwdGFibGUgYW5kIHdpdGhpbiB0aGUgcmlnaHQgcmFuZ2VcblNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyKDIsIDIxKTtcbn07XG5cbi8vIFdyaXRlIGJvaWxkZXIgcGxhdGUgZm9yIHN0YXJ0IG9mIFNEUFxuLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbi8vIGJlIGdlbmVyYXRlZCByYW5kb21seVxuLy8gc2Vzc1ZlcnNpb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDJcbi8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG5TRFBVdGlscy53cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSA9IGZ1bmN0aW9uKHNlc3NJZCwgc2Vzc1Zlciwgc2Vzc1VzZXIpIHtcbiAgdmFyIHNlc3Npb25JZDtcbiAgdmFyIHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgaWYgKHNlc3NJZCkge1xuICAgIHNlc3Npb25JZCA9IHNlc3NJZDtcbiAgfSBlbHNlIHtcbiAgICBzZXNzaW9uSWQgPSBTRFBVdGlscy5nZW5lcmF0ZVNlc3Npb25JZCgpO1xuICB9XG4gIHZhciB1c2VyID0gc2Vzc1VzZXIgfHwgJ3RoaXNpc2FkYXB0ZXJvcnRjJztcbiAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gIHJldHVybiAndj0wXFxyXFxuJyArXG4gICAgICAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gK1xuICAgICAgICAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICtcbiAgICAgICdzPS1cXHJcXG4nICtcbiAgICAgICd0PTAgMFxcclxcbic7XG59O1xuXG5TRFBVdGlscy53cml0ZU1lZGlhU2VjdGlvbiA9IGZ1bmN0aW9uKHRyYW5zY2VpdmVyLCBjYXBzLCB0eXBlLCBzdHJlYW0pIHtcbiAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24odHJhbnNjZWl2ZXIua2luZCwgY2Fwcyk7XG5cbiAgLy8gTWFwIElDRSBwYXJhbWV0ZXJzICh1ZnJhZywgcHdkKSB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMoXG4gICAgdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXIuZ2V0TG9jYWxQYXJhbWV0ZXJzKCkpO1xuXG4gIC8vIE1hcCBEVExTIHBhcmFtZXRlcnMgdG8gU0RQLlxuICBzZHAgKz0gU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyhcbiAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpLFxuICAgIHR5cGUgPT09ICdvZmZlcicgPyAnYWN0cGFzcycgOiAnYWN0aXZlJyk7XG5cbiAgc2RwICs9ICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG5cbiAgaWYgKHRyYW5zY2VpdmVyLmRpcmVjdGlvbikge1xuICAgIHNkcCArPSAnYT0nICsgdHJhbnNjZWl2ZXIuZGlyZWN0aW9uICsgJ1xcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRyZWN2XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICBzZHAgKz0gJ2E9c2VuZG9ubHlcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgc2RwICs9ICdhPXJlY3Zvbmx5XFxyXFxuJztcbiAgfSBlbHNlIHtcbiAgICBzZHAgKz0gJ2E9aW5hY3RpdmVcXHJcXG4nO1xuICB9XG5cbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgIC8vIHNwZWMuXG4gICAgdmFyIG1zaWQgPSAnbXNpZDonICsgc3RyZWFtLmlkICsgJyAnICtcbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnRyYWNrLmlkICsgJ1xcclxcbic7XG4gICAgc2RwICs9ICdhPScgKyBtc2lkO1xuXG4gICAgLy8gZm9yIENocm9tZS5cbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICAgJyAnICsgbXNpZDtcbiAgICBpZiAodHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgICAnICcgKyBtc2lkO1xuICAgICAgc2RwICs9ICdhPXNzcmMtZ3JvdXA6RklEICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArICcgJyArXG4gICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJ1xcclxcbic7XG4gICAgfVxuICB9XG4gIC8vIEZJWE1FOiB0aGlzIHNob3VsZCBiZSB3cml0dGVuIGJ5IHdyaXRlUnRwRGVzY3JpcHRpb24uXG4gIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyICYmIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAnIGNuYW1lOicgKyBTRFBVdGlscy5sb2NhbENOYW1lICsgJ1xcclxcbic7XG4gIH1cbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIEdldHMgdGhlIGRpcmVjdGlvbiBmcm9tIHRoZSBtZWRpYVNlY3Rpb24gb3IgdGhlIHNlc3Npb25wYXJ0LlxuU0RQVXRpbHMuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAvLyBMb29rIGZvciBzZW5kcmVjdiwgc2VuZG9ubHksIHJlY3Zvbmx5LCBpbmFjdGl2ZSwgZGVmYXVsdCB0byBzZW5kcmVjdi5cbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgY2FzZSAnYT1zZW5kcmVjdic6XG4gICAgICBjYXNlICdhPXNlbmRvbmx5JzpcbiAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgY2FzZSAnYT1pbmFjdGl2ZSc6XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHIoMik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgfVxuICB9XG4gIGlmIChzZXNzaW9ucGFydCkge1xuICAgIHJldHVybiBTRFBVdGlscy5nZXREaXJlY3Rpb24oc2Vzc2lvbnBhcnQpO1xuICB9XG4gIHJldHVybiAnc2VuZHJlY3YnO1xufTtcblxuU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIHJldHVybiBtbGluZVswXS5zdWJzdHIoMik7XG59O1xuXG5TRFBVdGlscy5pc1JlamVjdGVkID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHJldHVybiBtZWRpYVNlY3Rpb24uc3BsaXQoJyAnLCAyKVsxXSA9PT0gJzAnO1xufTtcblxuU0RQVXRpbHMucGFyc2VNTGluZSA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBwYXJ0cyA9IGxpbmVzWzBdLnN1YnN0cigyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IHBhcnRzWzBdLFxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzFdLCAxMCksXG4gICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgIGZtdDogcGFydHMuc2xpY2UoMykuam9pbignICcpXG4gIH07XG59O1xuXG5TRFBVdGlscy5wYXJzZU9MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMikuc3BsaXQoJyAnKTtcbiAgcmV0dXJuIHtcbiAgICB1c2VybmFtZTogcGFydHNbMF0sXG4gICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICBzZXNzaW9uVmVyc2lvbjogcGFyc2VJbnQocGFydHNbMl0sIDEwKSxcbiAgICBuZXRUeXBlOiBwYXJ0c1szXSxcbiAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNV1cbiAgfTtcbn07XG5cbi8vIGEgdmVyeSBuYWl2ZSBpbnRlcnByZXRhdGlvbiBvZiBhIHZhbGlkIFNEUC5cblNEUFV0aWxzLmlzVmFsaWRTRFAgPSBmdW5jdGlvbihibG9iKSB7XG4gIGlmICh0eXBlb2YgYmxvYiAhPT0gJ3N0cmluZycgfHwgYmxvYi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaW5lc1tpXS5sZW5ndGggPCAyIHx8IGxpbmVzW2ldLmNoYXJBdCgxKSAhPT0gJz0nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRPRE86IGNoZWNrIHRoZSBtb2RpZmllciBhIGJpdCBtb3JlLlxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG59XG5cbn0se31dfSx7fSxbMV0pKDEpXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=