(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Letsee", [], factory);
	else if(typeof exports === 'object')
		exports["Letsee"] = factory();
	else
		root["Letsee"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Context.js":
/*!********************!*\
  !*** ./Context.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.context = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _os = null;
  var _width = null;
  var _height = null;
  var _orientation = null;
  var _isPortrait = null;
  var BodyId = "body-".concat((0, _Util.UUID)());
  var DomRendererId = "dom-".concat((0, _Util.UUID)());
  var VideoContainerId = "video-".concat((0, _Util.UUID)());
  var PlaceholderId = "placeholder-".concat((0, _Util.UUID)());

  var Context =
  /*#__PURE__*/
  function () {
    function Context() {
      _classCallCheck(this, Context);
    }

    _createClass(Context, [{
      key: "setConfig",
      value: function setConfig(config) {
        _width = config.width;
        _height = config.height;
        _orientation = config.orientation;
        _isPortrait = _orientation === 0 || _orientation === 180;
      }
    }, {
      key: "bodyId",
      get: function get() {
        return BodyId;
      },
      set: function set(value) {
        BodyId = value;
      }
    }, {
      key: "domRendererId",
      get: function get() {
        return DomRendererId;
      }
    }, {
      key: "videoContainerId",
      get: function get() {
        return VideoContainerId;
      }
    }, {
      key: "placeholderId",
      get: function get() {
        return PlaceholderId;
      }
    }, {
      key: "os",
      get: function get() {
        return _os;
      },
      set: function set(value) {
        _os = value;
      }
    }, {
      key: "orientation",
      get: function get() {
        return _orientation;
      },
      set: function set(value) {
        _orientation = value;
      }
    }, {
      key: "width",
      get: function get() {
        return _width;
      },
      set: function set(value) {
        _width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return _height;
      },
      set: function set(value) {
        _height = value;
      }
    }, {
      key: "isPortrait",
      get: function get() {
        return _isPortrait;
      }
    }, {
      key: "screenWidth",
      get: function get() {
        return _width;
      }
    }, {
      key: "screenHeight",
      get: function get() {
        return _height;
      }
    }]);

    return Context;
  }();

  var context = new Context();
  _exports.context = context;
});

/***/ }),

/***/ "./Letsee.js":
/*!*******************!*\
  !*** ./Letsee.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./libs/VideoManager */ "./libs/VideoManager.js"), __webpack_require__(/*! ./libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ./libs/CSSParser */ "./libs/CSSParser.js"), __webpack_require__(/*! ./Util */ "./Util.js"), __webpack_require__(/*! ./libs/EntityParser */ "./libs/EntityParser.js"), __webpack_require__(/*! Context */ "./Context.js"), __webpack_require__(/*! ./observers/observer/LetseeObserver */ "./observers/observer/LetseeObserver.js"), __webpack_require__(/*! ./observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js"), __webpack_require__(/*! ./engine */ "./engine.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _VideoManager, Message, _CSSParser, _Util, _EntityParser, _Context, _LetseeObserver2, _EntityObserver, _engine) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = _exports.renderModules = _exports.resetRenderModules = _exports.removeRenderModule = _exports.addRenderModule = void 0;
  _VideoManager = _interopRequireDefault(_VideoManager);
  Message = _interopRequireWildcard(Message);
  _EntityParser = _interopRequireDefault(_EntityParser);
  _LetseeObserver2 = _interopRequireDefault(_LetseeObserver2);
  _EntityObserver = _interopRequireDefault(_EntityObserver);
  _engine = _interopRequireDefault(_engine);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import MathUtil from './math/Math';
  // import {eventManager} from './event/EventManager';
  var instance;
  var tracker;

  var _sceanCanvas;

  var _videoElement;

  var videoLoadFlag = false;
  var firstLoadFlag = false;
  var _letseeEngineConfig = {
    runType: 'BROWSER',
    width: null,
    height: null,
    orientation: null,
    data: null,
    projectionParameter: null,
    external: null
  };

  var validateConfig = function validateConfig(_config) {
    var config = {
      appKey: "".concat("ad32ab3e5ab12c7d4e0774009eacd045:29640916e9a511a273705825d8d3f05fd9d093a3ba6588e4fcb4da9a03fcde89e7c31f9d6f16f1f9e11a79031b830f4b4c6215bd1f87d076b39ada3460ee180a763e7e5f77fa7ad5173a03ad109dd266"),
      trackerType: _config.trackerType || 'IMAGE',
      external: null,
      cameraParameter: {
        fov: 50,
        near: 0.1,
        far: 2000
      },
      zIndex: 100,
      zIndexIncrement: 10
    };
    if (_config.type) config.trackerType = _config.type;
    if (_config.external) config.external = _config.external;

    if (_config.cameraParameter) {
      if (_config.cameraParameter.fov && _config.cameraParameter.near && _config.cameraParameter.far) {
        config.cameraParameter = _config.cameraParameter;
      } else {
        throw new Error('fov, near, far are mandatory field.');
      }
    } // @author treetory : LOCAL 환경일 때, 앱키를 받아오는 것이 있으면 설정하고, 없으면 기본키 사용?


    if (true) {
      if (_config.appKey) config.appKey = _config.appKey;
      if (_config.videoUrl) config.appKey = _config.appKey;
      if (_config.debug) config.appKey = _config.appKey;
    }

    if (typeof _config.zIndex === 'number') config.zIndex = _config.zIndex;
    if (typeof _config.zIndexIncrement === 'number') config.zIndexIncrement = _config.zIndexIncrement;

    if (_config.bodyId) {
      config.bodyId = _config.bodyId;
      _Context.context.bodyId = _config.bodyId;
    } else {
      config.bodyId = _Context.context.bodyId;
    }

    config.domRendererId = _Context.context.domRendererId;
    config.videoId = _Context.context.videoContainerId;
    return config;
  };

  var refImageData = null; // render module start

  var _renderModule = new Map();

  var addRenderModule = function addRenderModule(moduleObject) {
    // subscribe
    if (!!moduleObject.name && !!moduleObject.onRender) {
      if (typeof moduleObject.onRender !== 'function') {
        console.log('Render Module\'s action is function');
        return false;
      }

      if (_renderModule.has(moduleObject.name)) {
        console.log('Duplicate module name');
        return false;
      }

      _renderModule.set(moduleObject.name, moduleObject.onRender);
    } else {
      console.log('You must set name and onRender');
      return false;
    }

    return true;
  };

  _exports.addRenderModule = addRenderModule;

  var removeRenderModule = function removeRenderModule(name) {
    if (!!name && _renderModule.has(name)) {
      _renderModule["delete"](name);
    }
  };

  _exports.removeRenderModule = removeRenderModule;

  var resetRenderModules = function resetRenderModules() {
    _renderModule.clear();
  };

  _exports.resetRenderModules = resetRenderModules;

  var renderModules = function renderModules() {
    return function (renderModuleMap) {
      var obj = {};
      renderModuleMap.forEach(function (v, k) {
        obj[k] = v;
      });
      return obj;
    }(_renderModule);
  }; // render module end


  _exports.renderModules = renderModules;

  var LetseePrivate =
  /*#__PURE__*/
  function (_LetseeObserver) {
    _inherits(LetseePrivate, _LetseeObserver);

    function LetseePrivate(_config) {
      var _this;

      _classCallCheck(this, LetseePrivate);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(LetseePrivate).call(this));
      if (instance) return _possibleConstructorReturn(_this, instance);
      document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADING);
      _this._isPause = false;
      (0, _Util.addViewport)();
      (0, _Util.createLetseeWrapper)();
      (0, _Util.createLoader)();
      _this.state = null;
      _this._updateFlag = false;
      _this.entityManager = new _EntityParser["default"]();
      _this.videoManager = new _VideoManager["default"]();

      _this.videoManager.subscribe(Message.LETSEE_EVENT.ON_STATUS, function (e) {
        // this.notify(LETSEE_EVENT.ON_STATUS, e);
        if (e.code === 202) videoLoadFlag = true;
        if (e.status === 'error') (0, _Util.createStatusScreen)(e.code);
      }); // @author treetory : LOCAL 환경일 때, validate 하는 것이 조건이 달라지게 하면 되지 않을까?


      _this.config = validateConfig(_config);
      document.querySelector('body').setAttribute('id', _this.config.bodyId);
      document.body.classList.add(Message.LETSEE_CSS.AR_MODE_ON); // Start dom place holder

      var domPlaceholder = document.createElement('div');
      domPlaceholder.id = _Context.context.placeholderId;
      domPlaceholder.style.setProperty('display', 'none', 'important');
      document.body.appendChild(domPlaceholder); // End dom place holder

      var cssData = _CSSParser.cssParser.parse(_this.config.bodyId);

      _this.entityObserver = new _EntityObserver["default"]();

      _this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_START, function (e) {
        _this.notify(Message.ENTITY_EVENT.TRACK_START, e);

        _this.trackStatusCss(Message.ENTITY_EVENT.TRACK_START);
      });

      _this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_MOVE, function (e) {
        _this.notify(Message.LETSEE_EVENT.TRACK_MOVE, e);

        _this.trackStatusCss(Message.ENTITY_EVENT.TRACK_MOVE);
      });

      _this.entityObserver.subscribe(Message.ENTITY_EVENT.TRACK_END, function (e) {
        _this.notify(Message.LETSEE_EVENT.TRACK_END, e);

        _this.trackStatusCss(Message.ENTITY_EVENT.TRACK_END);
      });

      var checkEntity = new Promise(function (resolve, reject) {
        _this.entityManager.initEntity(cssData).then(function (obj) {
          _this.state = obj;

          if (_this.config.trackerType === 'IMAGE') {
            (0, _Util.loadImage)(_this.state[0].entity.image).then(function (result) {
              refImageData = result;
              resolve(refImageData);
            })["catch"](function (error) {
              reject(error);
            });
          } else {
            resolve(null);
          }
        })["catch"](function (error) {
          reject(error);
        });
      });
      var checkEnv = new Promise(function (resolve, reject) {
        _this.videoManager.init(_this.config.zIndex, _this.config.zIndexIncrement).then(function () {
          _sceanCanvas = _this.videoManager.canvasElement;
          _videoElement = _this.videoManager.videoElement;
          _letseeEngineConfig.width = _this.videoManager.screenInfo.width;
          _letseeEngineConfig.height = _this.videoManager.screenInfo.height;
          _letseeEngineConfig.orientation = _this.videoManager.screenInfo.angle;
          _letseeEngineConfig.data = cssData;
          _letseeEngineConfig.domRendererId = _this.config.domRendererId;
          _letseeEngineConfig.zIndex = _this.config.zIndex;
          _letseeEngineConfig.zIndexIncrement = _this.config.zIndexIncrement;
          _letseeEngineConfig.projectionParameter = [_this.config.cameraParameter.fov, _this.videoManager.screenInfo.screenAspectRatio, _this.config.cameraParameter.near, _this.config.cameraParameter.far];
          _letseeEngineConfig.external = _config.external || null;
          _this.engine = new _engine["default"](_letseeEngineConfig); // this.dispatchEntityEvent();

          resolve();
        })["catch"](function (error) {
          console.warn(error);
          reject(error);
        });
      });
      var checkScript = new Promise(function (resolve, reject) {
        var script = document.createElement('script');

        switch (_this.config.trackerType) {
          default:
          case 'IMAGE':
            script.src = "".concat("./lib/").concat("ImageTracker.0.9.10.js");
            break;

          case 'MARKER':
            script.src = "".concat("./lib/").concat("MarkerTracker.0.9.6.js");
            break;

          case 'QRCODE':
            script.src = "".concat("./lib/").concat("QrTracker.0.9.4.js");
            break;
        } // if (type !== 'SLAM') {


        document.body.append(script); // Exposed Tracker from webpack

        script.onload = function () {
          return resolve(new Tracker(_assertThisInitialized(_this)));
        };

        script.onerror = function () {
          return reject(new Error("Script load error for ".concat(src)));
        }; // } else if (type === 'SLAM') {
        //   resolve(new Slam());
        // }

      });
      _this.promiseChain = [checkEntity, checkEnv, checkScript];
      window.addEventListener('orientationchange', function (e) {
        if (tracker) tracker.stopTracker = true;

        _this.videoManager.orientationChange();

        _letseeEngineConfig.width = _this.videoManager.screenInfo.width;
        _letseeEngineConfig.height = _this.videoManager.screenInfo.height;
        _letseeEngineConfig.orientation = _this.videoManager.screenInfo.angle;
        _letseeEngineConfig.projectionParameter = [_this.config.cameraParameter.fov, _this.videoManager.screenInfo.screenAspectRatio, _this.config.cameraParameter.near, _this.config.cameraParameter.far];

        _this.engine.onConfigurationChanged({
          'width': _letseeEngineConfig.width,
          'height': _letseeEngineConfig.height,
          'orientation': _letseeEngineConfig.angle,
          'aspect': _this.videoManager.screenInfo.screenAspectRatio
        });

        if (tracker) tracker.stopTracker = false; // this.dispatch(Message.EVENT_APP_ROTATIONCHANGE, e);

        _this.notify(Message.LETSEE_EVENT.ROTATION_CHANGE, e);
      });
      window.addEventListener('resize', function (ev) {
        console.log('resize'); // this.videoManager.canvasElement.width = window.innerWidth;
        // this.videoManager.canvasElement.height = window.innerHeight;

        if (_this.videoManager.screen !== undefined) {
          _this.videoManager.screen.fitWidthAndHeight();
        }
      });
      instance = _assertThisInitialized(_this);
      return _this;
    }

    _createClass(LetseePrivate, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          Promise.all(_this2.promiseChain).then(function (value) {
            tracker = value[2];
            return tracker.initTracker(_videoElement, _sceanCanvas, _this2.config.appKey);
          }).then(function () {
            // frameByteAddress = tracker.updateScreen(this.videoManager.screenWidth, this.videoManager.screenHeight);
            // if (this.config.trackerType === 'IMAGE') this.setReferenceImage(refImageData.img);
            if (_this2.config.trackerType === 'IMAGE') tracker.setRefImage(refImageData.img);
            if (_this2.config.trackerType === 'MARKER') tracker.createMarkerState(_this2.entityManager.markerList || null);
            if (_this2.config.trackerType === 'QRCODE') tracker.createMarkerState(_this2.entityManager.codeList || null); // if (this.config.trackerType === 'SLAM') tracker.createMarkerState(this.entityManager.codeList || null);

            _this2.renderAllTask();

            resolve();
          })["catch"](function (error) {
            console.log(error);
            reject(error);
          });
        });
      }
    }, {
      key: "pause",
      value: function pause(value) {
        this.isPause = true;
        document.body.classList.remove(Message.LETSEE_CSS.AR_MODE_ON);
        document.body.classList.add(Message.LETSEE_CSS.AR_MODE_OFF);
        document.body.classList.remove(Message.ENTITY_EVENT.TRACK_START, Message.ENTITY_EVENT.TRACK_MOVE, Message.ENTITY_EVENT.TRACK_END);
        if (value) this.videoManager.container.style.display = 'none';
        return true;
      }
    }, {
      key: "resume",
      value: function resume() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        document.body.classList.add(Message.LETSEE_CSS.AR_MODE_ON);
        document.body.classList.remove(Message.LETSEE_CSS.AR_MODE_OFF);
        this.videoManager.container.style.display = 'block';
        this.isPause = false;
        return true;
      }
    }, {
      key: "renderAllTask",
      value: function renderAllTask() {
        var _this3 = this;

        _renderModule.forEach(function (val) {
          return val(performance.now());
        });

        tracker.processFrame(this._isPause);

        if (videoLoadFlag && !firstLoadFlag) {
          firstLoadFlag = true;
          document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADED);
          document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);
          var checkLoader = setTimeout(function () {
            document.body.classList.add(Message.LETSEE_CSS.LETSEE_LOADED);
            document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);

            _this3.notify(Message.EVENT_APP_ONLOAD);

            clearTimeout(checkLoader);
          }, 2000);
        }

        ;
        window.requestAnimationFrame(function () {
          _this3.renderAllTask();
        });
      }
    }, {
      key: "dispatchTrackState",
      value: function dispatchTrackState(matrix, currentState) {
        var newState = [];

        if ((this.engine !== null || typeof this.engine !== 'undefined') && (matrix !== null || typeof matrix !== 'undefined') && currentState !== null && currentState !== Message.STATE_RECOGNIZE && typeof currentState !== 'undefined') {
          newState = this.state.map(function (obj) {
            obj.type = currentState;
            obj.matrix = JSON.parse('[' + matrix + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState); // this.dispatchEntityEvent(newState);
        } else {// console.log('[error] letsee is not loaded!');
          }
      }
    }, {
      key: "dispatchTrackStateMarker",
      value: function dispatchTrackStateMarker(matrix, currentState) {
        var markerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var newState = [];

        if ((this.engine !== null || typeof this.engine !== 'undefined') && (matrix !== null || typeof matrix !== 'undefined') && currentState !== null && currentState !== Message.STATE_RECOGNIZE && typeof currentState !== 'undefined') {
          newState = this.state.filter(function (obj) {
            return markerId.includes(obj.entity.letseeMarkerId);
          }).map(function (obj) {
            obj.type = currentState[markerId.indexOf(obj.entity.letseeMarkerId)];
            obj.matrix = JSON.parse('[' + matrix[markerId.indexOf(obj.entity.letseeMarkerId)] + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState);
        } else {// console.log('[error] letsee is not loaded!');
        }
      }
    }, {
      key: "dispatchTrackStateQr",
      value: function dispatchTrackStateQr(matrix, currentState) {
        var markerId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var newState = [];

        if (!(0, _Util.isNil)(this.engine) && !(0, _Util.isNil)(matrix) && !(0, _Util.isNil)(currentState) && currentState !== Message.ENTITY_EVENT.RECOGNIZE) {
          newState = this.state.filter(function (obj) {
            return markerId.includes(obj.entity.codeString);
          }).map(function (obj) {
            obj.type = currentState[markerId.indexOf(obj.entity.codeString)];
            obj.matrix = JSON.parse('[' + matrix[markerId.indexOf(obj.entity.codeString)] + ']');
            return obj;
          });
          this.engine.objectTracker.updateState(newState);
        } else {// console.log('[error] letsee is not loaded!');
        }
      }
    }, {
      key: "trackStatusCss",
      value: function trackStatusCss(status) {
        document.body.classList.remove(Message.ENTITY_EVENT.TRACK_START, Message.ENTITY_EVENT.TRACK_MOVE, Message.ENTITY_EVENT.TRACK_END);
        document.body.classList.add(status);
      }
    }, {
      key: "switchCamera",
      value: function switchCamera(src) {
        this.videoManager.setVideoSource(src);
      }
    }, {
      key: "requestFullscreen",
      value: function requestFullscreen() {
        console.log('requestFullscreen function is called.'); //this.videoManager.screen.fitWidthAndHeight();

        var _arRenderer = document.getElementsByClassName('ar-renderer');

        if (_arRenderer[0] !== undefined) {
          if (_arRenderer[0].requestFullscreen) {
            _arRenderer[0].requestFullscreen().then(function (e) {// this.videoManager.screen.fitWidthAndHeight();
            })["catch"](function (err) {
              console.log("Error attempting to enable full-screen mode: ".concat(err.message, " (").concat(err.name, ")"));
            });
          } else if (_arRenderer[0].mozRequestFullScreen) {
            _arRenderer[0].mozRequestFullScreen();
          } else if (_arRenderer[0].webkitRequestFullscreen) {
            _arRenderer[0].webkitRequestFullscreen();
          } else if (_arRenderer[0].msRequestFullscreen) {
            _arRenderer[0].msRequestFullscreen();
          }
        }
      }
    }, {
      key: "exitFullscreen",
      value: function exitFullscreen() {
        var _this4 = this;

        if (document.exitFullscreen) {
          document.exitFullscreen().then(function () {
            _this4.videoManager.screen.fitWidthAndHeight();
          })["catch"](function (err) {
            console.log(err);
          });
        } else if (document.mozCancelFullScreen) {
          /* Firefox */
          document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
          /* Chrome, Safari and Opera */
          document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
          /* IE/Edge */
          document.msExitFullscreen();
        }
      }
    }, {
      key: "isPause",
      get: function get() {
        return this._isPause;
      },
      set: function set(value) {
        if (typeof value !== 'boolean') throw new Error('Allowed value is boolean');
        if (this._isPause === value) return false;
        tracker.isPause = value;
        this._isPause = value;
        return true;
      }
    }, {
      key: "letseeEngineConfig",
      // Fixed getter/setter
      get: function get() {
        return _letseeEngineConfig;
      }
    }]);

    return LetseePrivate;
  }(_LetseeObserver2["default"]);

  _exports["default"] = LetseePrivate;
});

/***/ }),

/***/ "./Screen.js":
/*!*******************!*\
  !*** ./Screen.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  //import videoManager from './libs/VideoManager';
  var Screen =
  /*#__PURE__*/
  function () {
    function Screen(_width, _height, _videoManager) {
      _classCallCheck(this, Screen);

      console.log('Screen is constructed!');
      this.width = _width;
      this.height = _height;
      this.videoManager = _videoManager;
    }

    _createClass(Screen, [{
      key: "fitWidthAndHeight",
      value: function fitWidthAndHeight() {
        console.log('fitWidthAndHeight function is called.');
        this.videoManager.reconnectMediaStream();
        var color = window.getComputedStyle(document.querySelector('.ar-renderer'), ':backdrop').getPropertyValue('background');
        console.log(color);
        this.videoManager.canvasElement.width = window.innerWidth;
        this.videoManager.canvasElement.height = window.innerHeight;
        this.videoManager.screenInfo.width = window.innerWidth;
        this.videoManager.screenInfo.height = window.innerHeight; // if (this.videoManager.container !== undefined) {
        //
        // 	// Toggling fullscreen mode
        // 	if (!this.videoManager.container.fullscreenElement) {
        // 		if (this.videoManager.container.requestFullscreen) {
        // 			this.videoManager.container.requestFullscreen().then((e) => {
        // 				this.videoManager.reconnectMediaStream();
        // 				this.videoManager.canvasElement.width = window.innerWidth;
        // 				this.videoManager.canvasElement.height = window.innerHeight;
        // 				this.videoManager.screenInfo.width = window.innerWidth;
        // 				this.videoManager.screenInfo.height = window.innerHeight;
        // 			}).catch(err => {
        // 				console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
        // 			});
        //
        // 		} else if (this.videoManager.container.mozRequestFullScreen) {
        // 			this.videoManager.container.mozRequestFullScreen();
        // 		} else if (this.videoManager.container.webkitRequestFullscreen) {
        // 			this.videoManager.container.webkitRequestFullscreen();
        // 		} else if (this.videoManager.container.msRequestFullscreen) {
        // 			this.videoManager.container.msRequestFullscreen();
        // 		}
        // 	} else {
        // 		if (this.videoManager.container.exitFullscreen) {
        // 			this.videoManager.container.exitFullscreen();
        // 		}
        // 	}
        // }
      }
    }]);

    return Screen;
  }();

  var _default = Screen;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./Util.js":
/*!*****************!*\
  !*** ./Util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, Message) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.isNil = _exports.isNull = _exports.removeArrayItem = _exports.chunk = _exports.hasWbcam = _exports.getBrowserInfo = _exports.UUID = _exports.loadImage = _exports.addViewport = _exports.createStatusScreen = _exports.createLoader = _exports.createLetseeWrapper = void 0;
  Message = _interopRequireWildcard(Message);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  var style = document.createElement('style');
  var letseeWrapper = document.createElement('div');
  var letseeLoader = document.createElement('div');
  var letseeStatus = document.createElement('div');
  var defaultLoaderContent = '<div class="letseeLoader"><img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDQiIGhlaWdodD0iNDQiIHZpZXdCb3g9IjAgMCA0NCA0NCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBzdHJva2U9IiNmZmYiPiAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDBiMWM3IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS13aWR0aD0iMiI+ICAgIDxjaXJjbGUgY3g9IjIyIiBjeT0iMjIiIHI9IjEiPiAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiICAgICAgICAgICAgICAgYmVnaW49IjBzIiBkdXI9IjEuOHMiICAgICAgICAgICAgICAgdmFsdWVzPSIxOyAyMCIgICAgICAgICAgICAgICBjYWxjTW9kZT0ic3BsaW5lIiAgICAgICAgICAgICAgIGtleVRpbWVzPSIwOyAxIiAgICAgICAgICAgICAgIGtleVNwbGluZXM9IjAuMTY1LCAwLjg0LCAwLjQ0LCAxIiAgICAgICAgICAgICAgIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPiAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InN0cm9rZS1vcGFjaXR5IiAgICAgICAgICAgICAgIGJlZ2luPSIwcyIgZHVyPSIxLjhzIiAgICAgICAgICAgICAgIHZhbHVlcz0iMTsgMCIgICAgICAgICAgICAgICBjYWxjTW9kZT0ic3BsaW5lIiAgICAgICAgICAgICAgIGtleVRpbWVzPSIwOyAxIiAgICAgICAgICAgICAgIGtleVNwbGluZXM9IjAuMywgMC42MSwgMC4zNTUsIDEiICAgICAgICAgICAgICAgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIC8+ICAgIDwvY2lyY2xlPiAgICA8Y2lyY2xlIGN4PSIyMiIgY3k9IjIyIiByPSIxIj4gICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJyIiAgICAgICAgICAgICAgIGJlZ2luPSItMC45cyIgZHVyPSIxLjhzIiAgICAgICAgICAgICAgIHZhbHVlcz0iMTsgMjAiICAgICAgICAgICAgICAgY2FsY01vZGU9InNwbGluZSIgICAgICAgICAgICAgICBrZXlUaW1lcz0iMDsgMSIgICAgICAgICAgICAgICBrZXlTcGxpbmVzPSIwLjE2NSwgMC44NCwgMC40NCwgMSIgICAgICAgICAgICAgICByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgLz4gICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJzdHJva2Utb3BhY2l0eSIgICAgICAgICAgICAgICBiZWdpbj0iLTAuOXMiIGR1cj0iMS44cyIgICAgICAgICAgICAgICB2YWx1ZXM9IjE7IDAiICAgICAgICAgICAgICAgY2FsY01vZGU9InNwbGluZSIgICAgICAgICAgICAgICBrZXlUaW1lcz0iMDsgMSIgICAgICAgICAgICAgICBrZXlTcGxpbmVzPSIwLjMsIDAuNjEsIDAuMzU1LCAxIiAgICAgICAgICAgICAgIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiAvPiAgICA8L2NpcmNsZT4gIDwvZz48L3N2Zz4="></div>';
  var letseeStyle = ["@font-face{font-family:Roboto;font-style:normal;font-weight:400;src:url(https://cdn.letsee.io/font/roboto-400.woff) format('woff')}", ".letseeStatus,.letseeLoader{font-family: 'Roboto', sans-serif;}", "#letseeWrapper>div{display:none;position:fixed!important;width:100%!important;height:100%!important;z-index:10000000!important;background:#fff!important;top:0;left:0;right:0;bottom:0;text-align:center}", ".letseeLoader img{position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;width:50px!important;height:50px!important}", ".letsee-loading #letseeWrapper .letseeLoader{display:block}", ".letsee-status #letseeWrapper .letseeStatus{display:block}", "body.ar-mode-off .ar-renderer{display:none!important;}"];

  var statusHtml = function statusHtml(type) {
    var _html;

    switch (type) {
      case 101:
        _html = "<div class=\"title\"><h2>Use safari for awesome AR app with iPhone</h2></div><div class=\"body\"><p id=\"copyText\" class=\"url\">".concat(window.location.href, "</p><p class=\"text\">Copy url and paste to safari.</p></div><script>document.getElementById(\"copyText\").addEventListener(\"click\",function(){!function(e){const t=document.createElement(\"textArea\");let n,o;t.value=e,document.body.appendChild(t),navigator.userAgent.match(/ipad|iphone/i)?((n=document.createRange()).selectNodeContents(t),(o=window.getSelection()).removeAllRanges(),o.addRange(n),t.setSelectionRange(0,999999)):t.select(),document.execCommand(\"copy\"),document.body.removeChild(t)}(e.target.textContent)});</script>"); // eslint-disable-line

        break;

      case 102:
        _html = '<div class="title"><h2>Unsupported browser</h2></div><div class="body"><p class="text">Please use Chrome, Firefox, iOS 11, Android 5 or higher, Safari 11 or higher</p></div>'; // eslint-disable-line

        break;

      case 103:
        _html = '<div class="title"><h2>No camera detected</h2></div><div class="body"><p class="text">Please install an external webcam device.</p></div>'; // eslint-disable-line

        break;

      case 104:
        _html = '<div class="title"><h2>No mobile device detected</h2></div><div class="body"><p class="text">Please use mobile browser.</p></div>'; // eslint-disable-line

        break;

      case 105:
        _html = '<div class="title"><h2>Camera denied</h2></div><div class="body"><p class="text">Please allow camera permission.</p></div>'; // eslint-disable-line

        break;

      default:
        _html = '<div class="title"><h2>General error</h2></div><div class="body"><p class="text">General error</p></div>';
      // eslint-disable-line
    }

    return _html;
  };

  var statusCss = function statusCss(type) {
    var _css;

    switch (type) {
      case 101:
        _css = [];
        break;

      case 102:
        _css = [];
        break;

      case 103:
        _css = [];
        break;

      case 104:
        _css = [];
        break;

      case 105:
        _css = [];
        break;

      default:
        _css = [];
    }

    return _css;
  };

  var createLetseeWrapper = function createLetseeWrapper() {
    style.setAttribute('type', 'text/css');
    document.head.append(style);
    letseeStyle.forEach(function (val, index) {
      style.sheet.insertRule(val, index);
    });
    letseeWrapper.id = 'letseeWrapper';
    letseeLoader.classList.add('letseeLoader');
    letseeStatus.classList.add('letseeStatus');
    letseeWrapper.appendChild(letseeLoader);
    letseeWrapper.appendChild(letseeStatus);
    document.body.insertBefore(letseeWrapper, document.body.firstChild);
  };

  _exports.createLetseeWrapper = createLetseeWrapper;

  var createLoader = function createLoader() {
    var _html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultLoaderContent;

    var _css = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    if (_css) {
      _css.forEach(function (val, index) {
        style.sheet.insertRule(val, index);
      });
    }

    letseeLoader.innerHTML = '';
    letseeLoader.innerHTML = _html;
  };

  _exports.createLoader = createLoader;

  var createStatusScreen = function createStatusScreen(type) {
    document.body.classList.remove(Message.LETSEE_CSS.LETSEE_LOADING);
    document.body.classList.add(Message.LETSEE_CSS.LETSEE_STATUS);
    letseeStatus.setAttribute('data-status-code', type);
    letseeStatus.innerHTML = statusHtml(type);
    statusCss(type).forEach(function (val, index) {
      style.sheet.insertRule(val, index);
    });
  };

  _exports.createStatusScreen = createStatusScreen;

  var addViewport = function addViewport() {
    var viewPortTag = document.createElement('meta');
    viewPortTag.id = 'viewport';
    viewPortTag.name = 'viewport';
    viewPortTag.content = 'minimum-scale=1.0, width=device-width, maximum-scale=1, user-scalable=no, viewport-fit=cover';
    document.getElementsByTagName('head')[0].appendChild(viewPortTag);
  };

  _exports.addViewport = addViewport;

  var loadImage = function loadImage(path) {
    var img = new Image();
    img.src = path;
    img.crossOrigin = 'Anonymous';
    return new Promise(function (resolve, reject) {
      img.onload = function () {
        if (img.naturalWidth * img.naturalHeight > 640000) {
          reject('Too large refference image');
        } else {
          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          canvas.width = img.naturalWidth;
          canvas.height = img.naturalHeight;
          ctx.drawImage(img, 0, 0);

          var _ctx$getImageData = ctx.getImageData(0, 0, canvas.width, canvas.height),
              width = _ctx$getImageData.width,
              height = _ctx$getImageData.height,
              data = _ctx$getImageData.data;

          resolve({
            // uri: uri,
            img: {
              width: width,
              height: height,
              data: data
            }
          });
        }
      };
    });
  };

  _exports.loadImage = loadImage;

  var UUID = function UUID() {
    var d = new Date().getTime();

    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
      d += performance.now(); // use high-precision timer if available
    }

    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);
    });
  };

  _exports.UUID = UUID;

  var isWebRTCSupported = function isWebRTCSupported() {
    // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.
    var isWebRTCSupported = false;
    ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
      if (isWebRTCSupported) return;
      if (item in window) isWebRTCSupported = true;
    });
    return isWebRTCSupported;
  };

  var isMobile = {
    Android: function Android() {
      return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function BlackBerry() {
      return navigator.userAgent.match(/BlackBerry|BB10/i);
    },
    iOS: function iOS() {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function Opera() {
      return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function Windows() {
      return navigator.userAgent.match(/IEMobile/i);
    },
    any: function any() {
      return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
    },
    getOsName: function getOsName() {
      var osName = 'Unknown OS';
      if (isMobile.Android()) osName = 'Android';
      if (isMobile.BlackBerry()) osName = 'BlackBerry';
      if (isMobile.iOS()) osName = 'iOS';
      if (isMobile.Opera()) osName = 'Opera Mini';
      if (isMobile.Windows()) osName = 'Windows';
      return osName;
    }
  }; // https://www.websocket.org/js/stuff.js (DetectBrowser.js)

  var getBrowserInfo = function getBrowserInfo() {
    var navigator = window.navigator;
    var isMobileDevice = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''); // eslint-disable-line

    var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);
    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    var isFirefox = typeof window.InstallTrigger !== 'undefined';
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var isChrome = !!window.chrome && !isOpera;
    var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;
    var nVer = navigator.appVersion; // eslint-disable-line

    var nAgt = navigator.userAgent;
    var browserName = navigator.appName;
    var fullVersion = '' + parseFloat(navigator.appVersion);
    var majorVersion = parseInt(navigator.appVersion, 10);
    var nameOffset, verOffset, ix; // both and safri and chrome has same userAgent

    if (isSafari && !isChrome && nAgt.indexOf('CriOS') !== -1) {
      isSafari = false;
      isChrome = true;
    } // In Opera, the true version is after 'Opera' or after 'Version'


    if (isOpera) {
      browserName = 'Opera';

      try {
        fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
        majorVersion = fullVersion.split('.')[0];
      } catch (e) {
        fullVersion = '0.0.0.0';
        majorVersion = 0;
      } // In MSIE version <=10, the true version is after 'MSIE' in userAgent // In IE 11, look for the string after 'rv:'

    } else if (isIE) {
      verOffset = nAgt.indexOf('rv:');

      if (verOffset > 0) {
        // IE 11
        fullVersion = nAgt.substring(verOffset + 3);
      } else {
        // IE 10 or earlier
        verOffset = nAgt.indexOf('MSIE');
        fullVersion = nAgt.substring(verOffset + 5);
      }

      browserName = 'IE';
    } else if (isChrome) {
      // In Chrome, the true version is after 'Chrome'
      verOffset = nAgt.indexOf('Chrome');
      browserName = 'Chrome';
      fullVersion = nAgt.substring(verOffset + 7);
    } else if (isSafari) {
      // In Safari, the true version is after 'Safari' or after 'Version'
      verOffset = nAgt.indexOf('Safari');
      browserName = 'Safari';
      fullVersion = nAgt.substring(verOffset + 7);

      if ((verOffset = nAgt.indexOf('Version')) !== -1) {
        fullVersion = nAgt.substring(verOffset + 8);
      }

      if (navigator.userAgent.indexOf('Version/') !== -1) {
        fullVersion = navigator.userAgent.split('Version/')[1].split(' ')[0];
      }
    } else if (isFirefox) {
      // In Firefox, the true version is after 'Firefox'
      verOffset = nAgt.indexOf('Firefox');
      browserName = 'Firefox';
      fullVersion = nAgt.substring(verOffset + 8); // In most other browsers, 'name/version' is at the end of userAgent
    } else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
      browserName = nAgt.substring(nameOffset, verOffset);
      fullVersion = nAgt.substring(verOffset + 1);

      if (browserName.toLowerCase() === browserName.toUpperCase()) {
        browserName = navigator.appName;
      }
    }

    if (isEdge) {
      browserName = 'Edge';
      fullVersion = navigator.userAgent.split('Edge/')[1]; // fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
    } // trim the fullVersion string at semicolon/space/bracket if present


    if ((ix = fullVersion.search(/[; \)]/)) !== -1) {
      fullVersion = fullVersion.substring(0, ix);
    }

    majorVersion = parseInt('' + fullVersion, 10);

    if (isNaN(majorVersion)) {
      fullVersion = '' + parseFloat(navigator.appVersion);
      majorVersion = parseInt(navigator.appVersion, 10);
    }

    return {
      'fullVersion': fullVersion,
      'version': majorVersion,
      'name': browserName,
      'isPrivateBrowsing': false,
      'isMobileDevice': isMobileDevice,
      'isWebRTCSupported': isWebRTCSupported(),
      'osName': isMobile.getOsName()
    };
  };

  _exports.getBrowserInfo = getBrowserInfo;

  var hasWbcam = function hasWbcam(devices) {
    var hasWebcam = false;
    var deviceList = [];
    devices.forEach(function (device) {
      if (device.kind === 'videoinput') {
        hasWebcam = true;
        deviceList.push(device.deviceId);
      }
    }); // return {hasWebcam: hasWebcam, deviceList: deviceList};

    return hasWebcam; // devices.forEach((_device) => {
    //   const device = {};
    //
    //   for (const d in _device) {
    //     try {
    //       if (typeof _device[d] !== 'function') {
    //         device[d] = _device[d];
    //       }
    //     } catch (e) {}
    //   }
    //
    //
    //   // if it is MediaStreamTrack.getSources
    //   if (device.kind === 'audio') {
    //     device.kind = 'audioinput';
    //   }
    //
    //   if (device.kind === 'video') {
    //     device.kind = 'videoinput';
    //   }
    //
    //   if (!device.deviceId) {
    //     device.deviceId = device.id;
    //   }
    //
    //   if (!device.id) {
    //     device.id = device.deviceId;
    //   }
    //
    //   if (!device.label) {
    //     device.isCustomLabel = true;
    //
    //     if (device.kind === 'videoinput') {
    //       device.label = 'Camera ' + (videoInputDevices.length + 1);
    //     } else if (device.kind === 'audioinput') {
    //       device.label = 'Microphone ' + (audioInputDevices.length + 1);
    //     } else if (device.kind === 'audiooutput') {
    //       device.label = 'Speaker ' + (audioOutputDevices.length + 1);
    //     } else {
    //       device.label = 'Please invoke getUserMedia once.';
    //     }
    //
    //     if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
    //       if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
    //         device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
    //       }
    //     }
    //   } else {
    //     // Firefox on Android still returns empty label
    //     if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
    //       isWebsiteHasWebcamPermissions = true;
    //     }
    //
    //     if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
    //       isWebsiteHasMicrophonePermissions = true;
    //     }
    //   }
    //
    //   if (device.kind === 'audioinput') {
    //     hasMicrophone = true;
    //
    //     if (audioInputDevices.indexOf(device) === -1) {
    //       audioInputDevices.push(device);
    //     }
    //   }
    //
    //   if (device.kind === 'audiooutput') {
    //     hasSpeakers = true;
    //
    //     if (audioOutputDevices.indexOf(device) === -1) {
    //       audioOutputDevices.push(device);
    //     }
    //   }
    //
    //   if (device.kind === 'videoinput') {
    //     hasWebcam = true;
    //
    //     if (videoInputDevices.indexOf(device) === -1) {
    //       videoInputDevices.push(device);
    //     }
    //   }
    //
    //   // there is no 'videoouput' in the spec.
    //   MediaDevices.push(device);
    //
    //   alreadyUsedDevices[device.deviceId + device.label + device.kind] = device;
    // });
  };

  _exports.hasWbcam = hasWbcam;

  var chunk = function chunk(arr) {
    var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    var tmp = _toConsumableArray(arr);

    if (chunkSize <= 0) return cache;

    while (tmp.length) {
      cache.push(tmp.splice(0, chunkSize));
    }

    return cache;
  };
  /**
   * Removes all elements from `array` that are equal to `element`. The `array`
   * parameter is modified after this export function call.
   * @memberof module:Util
   * @method removeArrayItem
   * @param {Array} array
   * @param {*} element
   * @return {Array}
   * @example
   * let array = [1, 2, 3, 4];
   * removeArrayItem(array, 1);
   *
   * console.log(array);
   * // => [2, 3, 4]
   */


  _exports.chunk = chunk;

  var removeArrayItem = function removeArrayItem(array, element) {
    var idx = array.indexOf(element);
    if (idx > -1) array.splice(idx, 1);
  };

  _exports.removeArrayItem = removeArrayItem;

  var isNull = function isNull(value) {
    return value === null;
  };

  _exports.isNull = isNull;

  var isNil = function isNil(value) {
    return value == null;
  }; //
  // document.getElementById('copyText').addEventListener('click',function () {
  //   (function(text) {
  //     const textArea = document.createElement('textArea');
  //     let range,
  //       selection;
  //
  //     textArea.value = text;
  //     document.body.appendChild(textArea);
  //     if (navigator.userAgent.match(/ipad|iphone/i)) {
  //       range = document.createRange();
  //       range.selectNodeContents(textArea);
  //       selection = window.getSelection();
  //       selection.removeAllRanges();
  //       selection.addRange(range);
  //       textArea.setSelectionRange(0, 999999);
  //     } else {
  //       textArea.select();
  //     }
  //
  //     document.execCommand('copy');
  //     document.body.removeChild(textArea);
  //   })(e.target.textContent);
  // })

  /*
  function clipboard(text) {
    const textArea = document.createElement('textArea');
    let range,
      selection;
  
    textArea.value = text;
    document.body.appendChild(textArea);
    if (navigator.userAgent.match(/ipad|iphone/i)) {
      range = document.createRange();
      range.selectNodeContents(textArea);
      selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      textArea.setSelectionRange(0, 999999);
    } else {
      textArea.select();
    }
  
    document.execCommand('copy');
    document.body.removeChild(textArea);
  };*/


  _exports.isNil = isNil;
});

/***/ }),

/***/ "./core/Camera.js":
/*!************************!*\
  !*** ./core/Camera.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Object3D2, _Matrix, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);
  _Matrix = _interopRequireDefault(_Matrix);
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var _type = 'Camera';
  /**
   * Used to check whether this or derived classes are cameras. You should not
   * change this, as it is used internally by the renderer for optimisation.
   * @member {boolean} isCamera
   * @memberof Camera.prototype
   * @default true
   */

  var _isCamera = true;
  /**
   * @ignore
   * @class Camera
   * @classdesc
   * Abstract base class for cameras. This class should always be inherited when
   * you build a new camera. Note that this class is not intended to be called
   * directly; You probably want a {@link PerspectiveCamera} or
   * {@link OrthographicCamera} instead.
   * @extends Object3D
   */

  var Camera =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(Camera, _Object3D);

    function Camera() {
      var _this;

      _classCallCheck(this, Camera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this));
      _this.projectionMatrix = new _Matrix["default"]();
      _this.projectionMatrixInverse = new _Matrix["default"]();
      _this.matrixWorldInverse = new _Matrix["default"]();
      return _this;
    }

    _createClass(Camera, [{
      key: "lookAt",

      /**
       * This makes the camera look at the vector position in the global space as
       * long as the parent of this camera is the scene or at position `(0, 0, 0)`.
       * @method lookAt
       * @memberof Camera.prototype
       * @param  {Vector3} target Position in 3D space for the camera to point towards
       */
      value: function lookAt(target) {
        var m = new _Matrix["default"]();
        m.lookAt(this.position, target, this.up);
        this.quaternion.setFromRotationMatrix(m);
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }, {
      key: "isCamera",
      get: function get() {
        return _isCamera;
      }
      /**
       * This is the inverse of {@link Object3D#matrixWorld}.
       * {@link Object3D#matrixWorld} contains the {@link Matrix4} which has the
       * world transform of the {@link Camera}.
       * @member {Matrix4} matrixWorldInverse
       * @memberof Camera#
       * @readonly
       */
      // get matrixWorldInverse() {
      //   return new Matrix4().getInverse(this.matrixWorld);
      // }

      /**
       * This is the matrix which contains the projection.
       * @member {Matrix4} projectionMatrix
       * @memberof Camera#
       * @readonly
       */
      // get projectionMatrix() {
      //   return this.projectionMatrix;
      // }
      //
      // set projectionMatrix(value) {
      //   this.projectionMatrix = value;
      // }
      // get projectionMatrixInverse() {
      //   return this.projectionMatrixInverse;
      // }
      //
      // set projectionMatrixInverse(value) {
      //   this.projectionMatrixInverse = value;
      // }

    }, {
      key: "worldZ",
      get: function get() {
        return new _Vector["default"](0, 0, -1).applyQuaternion(this.worldQuaternion);
      }
    }]);

    return Camera;
  }(_Object3D2["default"]);

  var _default = Camera;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/Data.js":
/*!**********************!*\
  !*** ./core/Data.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EntityDataObject = _exports.EventDataObject = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // Observer Data Object
  var EventData = new Map();

  var EventDataObject =
  /*#__PURE__*/
  function () {
    function EventDataObject() {
      _classCallCheck(this, EventDataObject);
    }

    _createClass(EventDataObject, null, [{
      key: "addHandler",
      value: function addHandler(target, handlers) {
        EventData.set(target, handlers);
      }
    }, {
      key: "getTarget",
      value: function getTarget(target) {
        return EventData.get(target);
      }
    }, {
      key: "getHandler",
      value: function getHandler(target, type) {
        var eventName = type.toLowerCase();
        var currentTarget = EventData.get(target);

        if ((0, _Util.isNil)(currentTarget)) {
          return "".concat(target, " does not exist");
        }

        var eventHandler = currentTarget.get(type);
        return (0, _Util.isNil)(eventHandler) ? "".concat(target, " does not have ").concat(eventName) : eventHandler;
      }
    }]);

    return EventDataObject;
  }(); // Entity Data Object


  _exports.EventDataObject = EventDataObject;
  var EntityData = new Map();

  var EntityDataObject =
  /*#__PURE__*/
  function () {
    function EntityDataObject() {
      _classCallCheck(this, EntityDataObject);
    }

    _createClass(EntityDataObject, null, [{
      key: "addElement",
      value: function addElement(element, map) {
        EntityData.set(element, map);
      }
    }, {
      key: "getElement",
      value: function getElement(ele) {
        return EntityData.get(ele);
      }
    }, {
      key: "getAllElements",
      value: function getAllElements() {
        return EntityData;
      }
    }]);

    return EntityDataObject;
  }();

  _exports.EntityDataObject = EntityDataObject;
});

/***/ }),

/***/ "./core/Object3D.js":
/*!**************************!*\
  !*** ./core/Object3D.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ../math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../observers/Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Quaternion, _Euler, _Matrix, _Observer2, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _Matrix = _interopRequireDefault(_Matrix);
  _Observer2 = _interopRequireDefault(_Observer2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import {ENTITY_EVENT} from '../libs/MessageTypes';
  // import EntityEvent from '../event/EntityEvent';
  var objectId = 0;
  /**
   * Used to check whether this or derived classes are {@link Object3D}s. You
   * should not change this, as it is used internally for optimisation.
   * @member {boolean} isObject3D
   * @memberof Object3D#
   * @default true
   */

  var _isObject3D = true;
  var _type = 'Object3D';
  var handlers = new Map([[_MessageTypes.OBJECT_EVENT.OBJECT_ADDED, new Set()], [_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED, new Set()]]);
  /**
   * @class Object3D
   * @extends EventDispatcher
   * @classdesc
   * This is the base class for most objects and provides a set of properties and
   * methods for manipulating objects in 3D space. Note that this can be used for
   * grouping objects via the {@link Object3D#add} method which adds the object
   * as a child, however it is better to use {@link Group} for this.
   */
  // class Object3D extends EventDispatcher {

  var Object3D =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(Object3D, _Observer);

    function Object3D() {
      var _this;

      _classCallCheck(this, Object3D);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Object3D).call(this, "object_".concat(objectId), handlers));
      /**
       * Unique number for this object instance.
       * @member {number} id
       * @memberof Object3D#
       * @readonly
       */
      // this.id = objectId;
      // TODO @default

      /**
       * The object's local position.
       * @member {Vector3} position
       * @memberof Object3D#
       * @default (0, 0, 0)
       */

      _this.position = new _Vector["default"](0, 0, 0);
      /**
       * Object's local rotation as a {@link Quaternion}.
       * @member {Quaternion} quaternion
       * @memberof Object3D#
       */

      _this.quaternion = new _Quaternion["default"]();
      /**
       * The object's local scale.
       * @member {Vector3} scale
       * @memberof Object3D#
       * @default (1, 1, 1)
       */

      _this.scale = new _Vector["default"](1, 1, 1);
      /**
       * This is used by the {@link Object3D#lookAt} method, for example, to
       * determine the orientation of the result.
       * @member {Vector3} up
       * @memberof Object3D#
       * @default (0, 1, 0)
       */

      _this.up = new _Vector["default"](0, 1, 0);
      /**
       * Object gets rendered if `true`.
       * @member {boolean} visible
       * @memberof Object3D#
       * @default true
       */

      _this.visible = true;
      _this.track = false;
      /**
       * Object's parent in the
       * [scene graph](https://en.wikipedia.org/wiki/Scene_graph).
       * @member {Object3D|null} parent
       * @memberof Object3D#
       * @default null
       */

      _this.parent = null;
      /**
       * Array with object's children. See {@link Group} for info on manually
       * grouping objects.
       * @member {Object3D[]} children
       * @memberof Object3D#
       * @default []
       */

      _this.children = [];
      _this.matrix = new _Matrix["default"]();
      _this.matrixWorld = new _Matrix["default"]();
      _this.matrixAutoUpdate = true;
      _this.matrixWorldNeedsUpdate = false; // this.rotation = new Euler();
      // this.id = objectId;

      Object.defineProperty(_assertThisInitialized(_this), 'id', {
        value: "object_".concat(objectId)
      });
      objectId++;
      return _this;
    } // get id() {
    //   return objectId;
    // };
    // get parent() {
    //   return this.parent;
    // };
    //
    // set parent(value) {
    //   this.parent = value;
    // }
    //
    // get children() {
    //   return this.children;
    // };
    // get position() {
    //   return this.position;
    // };
    // get quaternion() {
    //   return this.quaternion;
    // };
    // get scale() {
    //   return this.scale;
    // };
    // get up() {
    //   return this.up;
    // };
    // get visible() {
    //   return this.visible;
    // };
    // get track() {
    //   return this.track;
    // };
    //
    // set track(value) {
    //   this.track = value;
    // }


    _createClass(Object3D, [{
      key: "translate",

      /**
       * @method translate
       * @memberof Object3D.prototype
       * @param  {number} x
       * @param  {number} y
       * @param  {number} z
       */
      value: function translate(x, y, z) {
        var xAxis = new _Vector["default"](1, 0, 0);
        var yAxis = new _Vector["default"](0, 1, 0);
        var zAxis = new _Vector["default"](0, 0, 1);
        xAxis.applyQuaternion(this.quaternion);
        yAxis.applyQuaternion(this.quaternion);
        zAxis.applyQuaternion(this.quaternion);
        this.position.add(xAxis.multiplyScalar(x));
        this.position.add(yAxis.multiplyScalar(y));
        this.position.add(zAxis.multiplyScalar(z));
      }
    }, {
      key: "translateX",
      value: function translateX(value) {
        var xAxis = new _Vector["default"](1, 0, 0);
        xAxis.applyQuaternion(this.quaternion);
        this.position.add(xAxis.multiplyScalar(value));
      }
    }, {
      key: "translateY",
      value: function translateY(value) {
        var yAxis = new _Vector["default"](0, 1, 0);
        yAxis.applyQuaternion(this.quaternion);
        this.position.add(yAxis.multiplyScalar(value));
      }
    }, {
      key: "translateZ",
      value: function translateZ(value) {
        var zAxis = new _Vector["default"](0, 0, 1);
        zAxis.applyQuaternion(this.quaternion);
        this.position.add(zAxis.multiplyScalar(value));
      }
    }, {
      key: "rotateX",

      /**
       * Rotates the object around x axis in local space.
       * @method rotateX
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */
      value: function rotateX(angle) {
        var axis = new _Vector["default"](1, 0, 0);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Rotates the object around y axis in local space.
       * @method rotateY
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */

    }, {
      key: "rotateY",
      value: function rotateY(angle) {
        var axis = new _Vector["default"](0, 1, 0);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Rotates the object around z axis in local space.
       * @method rotateZ
       * @memberof Object3D.prototype
       * @param {number} angle The angle to rotate in radians.
       */

    }, {
      key: "rotateZ",
      value: function rotateZ(angle) {
        var axis = new _Vector["default"](0, 0, 1);
        var q = new _Quaternion["default"]();
        q.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q);
        this.rotation.setFromQuaternion(this.quaternion);
        return this;
      }
      /**
       * Returns a vector of the scaling factors applied to the object for each axis
       * in world space.
       * @member {Vector3} worldScale
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "localToWorld",

      /**
       * The local transform matrix.
       * @member {Matrix4} matrix
       * @memberof Object3D#
       * @readonly
       */
      // get matrix() {
      //   return new Matrix4().compose(this.position, this.quaternion, this.scale);
      // }

      /**
       * The global transform of the object. If the object has no parent, then it's
       * identical to the local transform {@link Object3D#matrix}.
       * @member {Matrix4} matrixWorld
       * @memberof Object3D#
       * @readonly
       */
      // get matrixWorld() {
      //   const parent = this.parent;
      //   const matrix = this.matrix;
      //
      //   if (parent === null) {
      //     return matrix;
      //   }
      //
      //   return new Matrix4().multiplyMatrices(parent.matrixWorld, matrix);
      // }

      /**
       * Converts the vector from local space to world space.
       * @method localToWorld
       * @memberof Object3D.prototype
       * @param  {Vector3} vector A vector representing a position in local (object) space.
       * @return {Vector3}
       */
      value: function localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      }
      /**
       * Updates the vector from world space to local space.
       * @method worldToLocal
       * @memberof Object3D.prototype
       * @param  {Vector3} vector A world vector.
       * @return {Vector3}
       */

    }, {
      key: "worldToLocal",
      value: function worldToLocal(vector) {
        return vector.applyMatrix4(new _Matrix["default"]().getInverse(this.matrixWorld));
      }
      /**
       * Adds `object` as child of this object. An arbitrary number of objects may
       * be added. See {@link Group} for info on manually grouping objects.
       * @method add
       * @memberof Object3D.prototype
       * @param {Object3D} object
       */

    }, {
      key: "add",
      value: function add(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }

          return this;
        }

        if (object === this) {
          console.error('Letsee.Object3D.add: object can\'t be added as a child of itself.', object);
          return this;
        }

        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }

          object.parent = this;
          object.notify(_MessageTypes.OBJECT_EVENT.OBJECT_ADDED);
          this.children.push(object);
        } else {
          console.error('Letsee.Object3D.add: object not an instance of Letsee.Object3D.', object);
        }

        return this; // if (object && object !== this && object.isObject3D) {
        //   if (object.parent) {
        //     object.parent.remove(object);
        //   }
        //
        //   if (!this.isScene) {
        //     object.track = this.track;
        //   }
        //
        //   object.parent = this;
        //   object.dispatchEvent({type: 'added'});
        //
        //   // this.children = [
        //   //   ...this.children,
        //   //   object,
        //   // ];
        // }
        //
        // for (let i = 0; i < object.length; i += 1) {
        //   this.add(object[i]);
        // }
      }
      /**
       * Removes `object` as child of this object. An arbitrary number of objects
       * may be eremoved.
       * @method remove
       * @memberof Object3D.prototype
       * @param  {Object3D} object
       */

    }, {
      key: "remove",
      value: function remove(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }

          return this;
        }

        var index = this.children.indexOf(object);

        if (index !== -1) {
          object.parent = null;
          object.notify(_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED);
          this.children.splice(index, 1);
        }

        return this; //
        //
        // const index = this.children.indexOf(object);
        //
        // if (index > -1) {
        //   object.parent = null;
        //   object.dispatchEvent({type: 'removed'});
        //
        //   for (let child of object.children) {
        //   object.remove(child);
        // }
        //
        // this.children = [
        //   ...this.children.slice(0, index),
        //   ...this.children.slice(index + 1),
        // ];
        // }
        //
        // for (let i = 0; i < other.length; i += 1) {
        //   this.remove(other[i]);
        // }
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();

        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }

          this.matrixWorldNeedsUpdate = false;
          force = true;
        } // update children


        var children = this.children;

        for (var i = 0, l = children.length; i < l; i++) {
          children[i].updateMatrixWorld(force);
        }
      }
    }, {
      key: "updateWorldMatrix",
      value: function updateWorldMatrix(updateParents, updateChildren) {
        var parent = this.parent;

        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }

        if (this.matrixAutoUpdate) this.updateMatrix();

        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        } // update children


        if (updateChildren === true) {
          var children = this.children;

          for (var i = 0, l = children.length; i < l; i++) {
            children[i].updateWorldMatrix(false, true);
          }
        }
      }
    }, {
      key: "lookAt",
      value: function lookAt(vector3) {
        var m = new _Matrix["default"]();
        m.lookAt(vector3, this.position, this.up);
        this.quaternion.setFromRotationMatrix(m);
      }
    }, {
      key: "applyMatrix",
      value: function applyMatrix(matrix) {
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      /**
       * Returns a clone of this object and optionally all descendants.
       * @method clone
       * @memberof Object3D.prototype
       * @param  {boolean} [recursive=true] If true, descendants of the object are also cloned.
       * @return {Object3D}
       */

    }, {
      key: "clone",
      value: function clone() {
        var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return new Object3D().copy(this, recursive);
      }
      /**
       * Copy the given `source` object into this object.
       * @method copy
       * @memberof Object3D.prototype
       * @param  {Object3D} source
       * @param  {boolean} [recursive=true] If true, descendants of the object are also copied.
       */

    }, {
      key: "copy",
      value: function copy(source) {
        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.position.copy(source.position);
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.up.copy(source.copy);
        this.visible = source.visible;

        if (recursive === true || recursive === undefined) {
          for (var i = 0; i < source.children.length; i += 1) {
            var child = source.children[i];
            this.add(child.clone());
          }
        }

        return this;
      }
      /**
       * Executes the `callback` on this object and all descendants.
       * @method traverse
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverse",
      value: function traverse(callback) {
        callback(this);
        this.children.forEach(function (child) {
          child.traverse(callback);
        });
      }
      /**
       * Like {@link Object3D#traverse}, but the `callback` will only be executed
       * for visible objects. Descendants of invisible objects are not traversed.
       * @method traverseVisible
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverseVisible",
      value: function traverseVisible(callback) {
        if (this.visible) {
          callback(this);
          this.children.forEach(function (child) {
            child.traverseVisible(callback);
          });
        }
      }
      /**
       * Executes the `callback` on all ancestors.
       * @method traverseAncestors
       * @memberof Object3D.prototype
       * @param  {Function} callback A function with as first argument an {@link Object3D} object.
       */

    }, {
      key: "traverseAncestors",
      value: function traverseAncestors(callback) {
        var parent = this.parent;

        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
    }, {
      key: "traverseRenderable",
      value: function traverseRenderable(callback) {
        if (this.visible && this.track) {
          callback(this);
          this.children.forEach(function (child) {
            child.traverseRenderable(callback);
          });
        }
      }
    }, {
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Object3D.prototype), "subscribe", this)).call.apply(_get2, [this, this.id, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(Object3D.prototype), "unsubscribe", this).call(this, this.id, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        var e = event ? event : {};
        e.target = this;
        e.type = type;

        _get(_getPrototypeOf(Object3D.prototype), "notify", this).call(this, this.id, type, e);
      }
    }, {
      key: "isObject3D",
      get: function get() {
        return _isObject3D;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
      /**
       * Returns a vector representing the position of the object in world space.
       * @member {Vector3} worldPosition
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldPosition",
      get: function get() {
        return new _Vector["default"]().setFromMatrixPosition(this.matrixWorld);
      }
    }, {
      key: "rotation",
      get: function get() {
        return new _Euler["default"]().setFromQuaternion(this.quaternion, undefined, false);
      },
      set: function set(rotation) {
        if (rotation.isEuler) {
          this.quaternion.setFromEuler(rotation);
        } else if (rotation.isQuaternion) {
          this.quaternion.copy(rotation);
        } else if (rotation.isMatrix4) {
          this.quaternion.setFromMatrix(rotation);
        } else {
          console.warn('Rotation must be one of Euler, Quaternion or Matrix4');
        }
      }
      /**
       * Returns the euler angles representing the rotation of the object in world
       * space.
       * @member {Euler} worldRotation
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldRotation",
      get: function get() {
        return new _Euler["default"]().setFromQuaternion(this.worldQuaternion, this.rotation.order, false);
      }
      /**
       * Returns a quaternion representing the rotation of the object in world
       * space.
       * @member {Quaternion} worldQuaternion
       * @memberof Object3D#
       * @readonly
       */

    }, {
      key: "worldQuaternion",
      get: function get() {
        var result = new _Quaternion["default"]();
        this.matrixWorld.decompose(new _Vector["default"](), result, new _Vector["default"]());
        return result;
      }
    }, {
      key: "worldX",
      get: function get() {
        return new _Vector["default"](1, 0, 0).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldY",
      get: function get() {
        return new _Vector["default"](0, 1, 0).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldZ",
      get: function get() {
        return new _Vector["default"](0, 0, 1).applyQuaternion(this.worldQuaternion);
      }
    }, {
      key: "worldScale",
      get: function get() {
        var result = new _Vector["default"]();
        this.matrixWorld.decompose(new _Vector["default"](), new _Quaternion["default"](), result);
        return result;
      }
    }]);

    return Object3D;
  }(_Observer2["default"]);

  var _default = Object3D;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/PerspectiveCamera.js":
/*!***********************************!*\
  !*** ./core/PerspectiveCamera.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Camera */ "./core/Camera.js"), __webpack_require__(/*! ../math/Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Camera2, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Camera2 = _interopRequireDefault(_Camera2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  /**
   * @typedef {Object} PerspectiveCameraViewOffset
   * @property {number} fullWidth
   * @property {number} fullHeight
   * @property {number} offsetX
   * @property {number} offsetY
   * @property {number} width
   * @property {number} height
   */
  // type PerspectiveCameraViewOffset = {
  //   fullWidth,
  //   fullHeight,
  //   offsetX,
  //   offsetY,
  //   width,
  //   height,
  // };

  /*
  
  
  /!**
   * Camera frustum vertical field of view, from bottom to top of view, in
   * degrees.
   * @member {number} fov
   * @memberof PerspectiveCamera#
   * @default 50
   *!/
  let this.fov = 50;
  /!**
   * Gets or sets the zoom factor of the camera.
   * @member {number} zoom
   * @memberof PerspectiveCamera#
   * @default 1
   *!/
  let this.zoom = 1;
  
  /!**
   * Camera frustum near plane. The valid range is greater than `0` and less
   * than the current value of the {@link PerspectiveCamera#far} plane. Note
   * that, unlike for the {@link OrthographicCamera}, `0` is _not_ a valid value
   * for a {@link PerspectiveCamera}'s near plane.
   * @member {number} near
   * @memberof PerspectiveCamera#
   * @default 0.1
   *!/
  let this.near = 0.1;
  
  /!**
   * Camera frustum far plane. The valid range is between the current value of
   * the {@link PerspectiveCamera#near} plane and infinity.
   * @member {number} far
   * @memberof PerspectiveCamera#
   * @default 2000
   *!/
  let this.far = 2000;
  
  /!**
   * Object distance used for stereoscopy and depth-of-field effects. This
   * parameter does not influence the projection matrix unless a
   * {@link StereoCamera} is being used.
   * @member {number} focus
   * @memberof PerspectiveCamera#
   * @default 10
   *!/
  let this.focus = 10;
  
  /!**
   * Camera frustum aspect ratio, usually the canvas width / canvas height.
   * @member {number} aspect
   * @memberof PerspectiveCamera#
   * @default 1 (square canvas)
   *!/
  let this.aspect = 1;
  
  /!**
   * Frustum window specification or `null`. This is set using the
   * {@link PerspectiveCamera#setViewOffset} method and cleared using
   * {@link PerspectiveCamera#clearViewOffset}.
   * @member {PerspectiveCameraViewOffset} view
   * @memberof PerspectiveCamera#
   * @default null
   *!/
  let this.view = null;
  
  /!**
   * Film size used for the larger axis. This parameter does not influence the
   * projection matrix unless {@link PerspectiveCamera#filmOffset} is set to a
   * nonzero value.
   * @member {number} filmGauge
   * @memberof PerspectiveCamera#
   * @default 35 (millimeters)
   *!/
  let this.filmGauge = 35;
  
  /!**
   * Horizontal off-center offset in the same unit as
   * {@link PerspectiveCamera#filmGauge}.
   * @member {number} filmOffset
   * @memberof PerspectiveCamera#
   * @default 0
   *!/
  let this.filmOffset = 0;
  
  /!**
   * Camera projection matrix
   * @member {Matrix4} projectionMatrix
   * @memberof LetseeEngine.camera
   *!/
  // let _projectionMatrix = new Matrix4();
  
  /!**
   * Used to test whether this or derived classes are
   * {@link PerspectiveCamera}s. This should not be changed as it is used
   * internally by the renderer for optimisation.
   * @member {boolean} isPerspectiveCamera
   * @memberof PerspectiveCamera.prototype
   * @default true
   *!/*/
  var isPerspectiveCamera = true;
  var _type = 'PerspectiveCamera';
  /**
   * @namespace camera
   * @memberof letsee
   * @class PerspectiveCamera
   * @classdesc
   * Camera that uses
   * [perspective projection](https://en.wikipedia.org/wiki/Perspective_(graphical)).
   * This projection mode is designed to mimic the way the human eye sees. It is
   * the most common projection mode used for rendering a 3D scene.
   * @extends Camera
   * @example
   * var camera = new PerspectiveCamera(45, width/height, 1, 1000);
   * scene.add(camera);
   * @constructor
   * @param  {number} [fov]    Camera frustum vertical field of view.
   * @param  {number} [aspect] Camera frustum aspect ratio.
   * @param  {number} [near]   Camera frustum near plane.
   * @param  {number} [far]    Camera frustum far plane.
   */

  var PerspectiveCamera =
  /*#__PURE__*/
  function (_Camera) {
    _inherits(PerspectiveCamera, _Camera);

    function PerspectiveCamera(fov, aspect, near, far) {
      var _this;

      _classCallCheck(this, PerspectiveCamera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PerspectiveCamera).call(this));
      _this.fov = fov !== undefined ? fov : 50;
      _this.zoom = 1;
      _this.near = near !== undefined ? near : 0.1;
      _this.far = far !== undefined ? far : 2000;
      _this.focus = 10;
      _this.aspect = aspect !== undefined ? aspect : 1;
      _this.view = null;
      _this.filmGauge = 35;
      _this.filmOffset = 0;

      _this.updateProjectionMatrix();

      return _this;
    } //
    // get fov() {
    //   return this.fov;
    // }
    //
    // get zoom() {
    //   return this.zoom;
    // }
    //
    // get near() {
    //   return this.near;
    // }
    //
    // get far() {
    //   return this.far;
    // }
    //
    // get focus() {
    //   return this.focus;
    // }
    //
    // get aspect() {
    //   return this.aspect;
    // }
    //
    // get view() {
    //   return this.view;
    // }
    //
    // get filmGauge() {
    //   return this.filmGauge;
    // }
    //
    // get filmOffset() {
    //   return this.filmOffset;
    // }


    _createClass(PerspectiveCamera, [{
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(PerspectiveCamera.prototype), "copy", this).call(this, source);

        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : _objectSpread({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset; // _projectionMatrix = source.projectionMatrix;

        return this;
      }
    }, {
      key: "getEffectiveFOV",

      /**
       * Returns the current vertical field of view angle in degrees considering
       * {@link PerspectiveCamera#zoom}.
       * @member {number} effectiveFOV
       * @memberof PerspectiveCamera#
       * @readonly
       */
      value: function getEffectiveFOV() {
        return 2 * (0, _Math.radToDeg)(Math.atan(Math.tan(0.5 * (0, _Math.degToRad)(this.fov)) / this.zoom));
      }
    }, {
      key: "updateProjectionMatrix",
      // get projectionMatrix() {
      //   return _projectionMatrix;
      // }
      value: function updateProjectionMatrix() {
        var near = this.near,
            top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
            height = 2 * top,
            width = this.aspect * height,
            left = -0.5 * width,
            view = this.view;

        if (this.view !== null && this.view.enabled) {
          var fullWidth = view.fullWidth,
              fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }

        var skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.filmWidth();
        this.projectionMatrix = this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse = this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      }
    }, {
      key: "setViewPort",
      value: function setViewPort(rotationMatrix) {
        if (rotationMatrix.isMatrix4) {
          this.quaternion.setFromRotationMatrix(rotationMatrix);
          LetseeEngine.renderer.render();
        }
      }
    }, {
      key: "focalLength",
      set: function set(focalLength) {
        var vExtentSlope = 0.5 * this.filmHeight / focalLength;
        this.fov = 2 * (0, _Math.radToDeg)(Math.atan(vExtentSlope));
      }
      /**
       * The focal length of the current {@link PerspectiveCamera#fov} in respect to
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} focalLength
       * @memberof PerspectiveCamera#
       */
      ,
      get: function get() {
        var vExtentSlope = Math.tan(0.5 * (0, _Math.degToRad)(this.fov));
        return 0.5 * this.filmHeight / vExtentSlope;
      }
      /**
       * The width of the image on the film. If {@link PerspectiveCamera#aspect} is
       * greater than or equal to `1` (landscape format), the result equals
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} filmWidth
       * @memberof PerspectiveCamera#
       * @readonly
       */

    }, {
      key: "filmWidth",
      get: function get() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      /**
       * The height of the image on the film. If {@link PerspectiveCamera#aspect} is
       * less than or equal to `1` (portrait format), the result equals
       * {@link PerspectiveCamera#filmGauge}.
       * @member {number} filmHeight
       * @memberof PerspectiveCamera#
       * @readonly
       */

    }, {
      key: "filmHeight",
      get: function get() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
    }, {
      key: "viewOffset",
      set: function set(view) {
        this.view = view;

        if (this.view !== null) {
          this.aspect = this.view.fullWidth / this.view.fullHeight;
        }
      }
    }]);

    return PerspectiveCamera;
  }(_Camera2["default"]);

  var _default = PerspectiveCamera;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./core/Scene.js":
/*!***********************!*\
  !*** ./core/Scene.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Object3D */ "./core/Object3D.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Object3D2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

  function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  /**
   * @class Scene
   * @classdesc
   * Scenes allow you to set up what and where is to be rendered. This is where
   * you place objects, lights, and cameras.
   * @extends Object3D
   */
  var _type = 'Scene';
  var _isScene = true;

  var Scene =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(Scene, _Object3D);

    function Scene() {
      var _this;

      _classCallCheck(this, Scene);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this));

      _set(_getPrototypeOf(Scene.prototype), "track", true, _assertThisInitialized(_this), true);

      return _this;
    }

    _createClass(Scene, [{
      key: "isScene",
      get: function get() {
        return _isScene;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }]);

    return Scene;
  }(_Object3D2["default"]);

  _exports["default"] = Scene;
});

/***/ }),

/***/ "./core/TrackableManager.js":
/*!**********************************!*\
  !*** ./core/TrackableManager.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ../renderer/DOMRenderable */ "./renderer/DOMRenderable.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Entity, _DOMRenderable, _Euler) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.trackableManager = void 0;
  _Entity = _interopRequireDefault(_Entity);
  _DOMRenderable = _interopRequireDefault(_DOMRenderable);
  _Euler = _interopRequireDefault(_Euler);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _entities;

  var TrackableManager =
  /*#__PURE__*/
  function () {
    function TrackableManager() {
      _classCallCheck(this, TrackableManager);

      _entities = {};
    }

    _createClass(TrackableManager, [{
      key: "load",
      value: function load(entity) {
        if (entity instanceof _Entity["default"]) return window._native.loadEntity(entity.uri);
        return new Promise(function (resolve, reject) {
          reject('parameter is not entity');
        });
      }
    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        if (_entities[uri]) return _entities[uri];
        return null;
      }
    }, {
      key: "getEntities",
      value: function getEntities() {
        return Object.values(_entities);
      }
    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        if (_entities[uri]) return true;
        return false;
      }
    }, {
      key: "addEntity",
      value: function addEntity(entity) {
        _entities[entity.uri] = entity; // if (entity.type !== "object") {
        //     PlaceController.addEntity(entity);
        // }
      }
    }, {
      key: "removeEntity",
      value: function removeEntity(param) {
        var uri = param;

        if (param instanceof _Entity["default"]) {
          uri = param.uri;
        }

        if (this.hasEntity(uri)) {
          var entity = _entities[uri];

          if (entity.type !== 'object') {// PlaceController.removeEntity(entity);
          }

          _entities[uri].removeRenderables();

          delete _entities[uri];
        }
      }
    }, {
      key: "setEntity",
      value: function setEntity(entity) {
        var uri = entity.uri;

        if (_entities[uri]) {
          _entities[uri].setData(entity);
        } else {
          _entities[uri] = entity;
        }
      } // traverseEntity(callback: (entity: Entity) => void) {
      //   for (let entity of Object.values(this.entities)) {
      //     callback(entity);
      //   }
      // }

    }, {
      key: "setDatas",
      value: function setDatas(data) {
        var _this = this;

        if (!data) return;
        var objects = data; // const self = this;

        if (objects && objects.length > 0) {
          objects.forEach(function (object) {
            var e = object.entity;
            var currentEntity = new _Entity["default"](e.uri, e);

            _this.addEntity(currentEntity);

            var renderables = object.renderables;
            renderables.forEach(function (r) {
              var selector = r.selector,
                  translate = r.translate,
                  rotation = r.rotation;
              var elems = document.querySelectorAll(selector);
              elems.forEach(function (elem) {
                var _renderable$position;

                var renderable = new _DOMRenderable["default"](elem);

                (_renderable$position = renderable.position).set.apply(_renderable$position, _toConsumableArray(translate));

                renderable.rotation = _construct(_Euler["default"], _toConsumableArray(rotation));
                currentEntity.addRenderable(renderable);
              });
            });
          });
        } // const places = data.place;
        //
        // if (places && places.length > 0) {
        //   places.forEach(function (place) {
        //     const e = place.entity;
        //     const entity = new Entity(e.uri, e);
        //     const renderables = place.renderables;
        //
        //     if (entity.uri === 'geolocation') {
        //       entity.track = true;
        //     }
        //
        //     for (let j = 0; j < renderables.length; j += 1) {
        //       const r = renderables[j];
        //       const selector = r.selector;
        //       const pose = r.pose;
        //       const elems = document.querySelectorAll(selector);
        //
        //       for (let k = 0; k < elems.length; k += 1) {
        //         const elem = elems[k];
        //         let renderable = new GeoRenderable(elem);
        //
        //         renderable.setLocation(pose[0], pose[1], pose[2]);
        //
        //         entity.addRenderable(renderable);
        //       }
        //     }
        //   });
        // }

      }
    }]);

    return TrackableManager;
  }(); // export default new TrackableManager();
  // export default TrackableManager;


  var trackableManager = new TrackableManager();
  _exports.trackableManager = trackableManager;
});

/***/ }),

/***/ "./engine.js":
/*!*******************!*\
  !*** ./engine.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Context */ "./Context.js"), __webpack_require__(/*! ./renderer/DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ./libs/ObjectTracker */ "./libs/ObjectTracker.js"), __webpack_require__(/*! ./core/TrackableManager */ "./core/TrackableManager.js"), __webpack_require__(/*! ./core/PerspectiveCamera */ "./core/PerspectiveCamera.js"), __webpack_require__(/*! ./external/THREE */ "./external/THREE.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _DOMRenderer, _ObjectTracker, _TrackableManager, _PerspectiveCamera, _THREE) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _PerspectiveCamera = _interopRequireDefault(_PerspectiveCamera);
  _THREE = _interopRequireDefault(_THREE);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _instance;

  var _config = {};

  var Engine =
  /*#__PURE__*/
  function () {
    function Engine(config) {
      _classCallCheck(this, Engine);

      if (_instance) return _instance;
      _config = _objectSpread({}, config);
      this.camera = _construct(_PerspectiveCamera["default"], _toConsumableArray(_config.projectionParameter));

      _Context.context.setConfig(_config);

      _DOMRenderer.domRenderer.initRenderer(this.camera, _config.domRendererId, _config.zIndex, _config.zIndexIncrement);

      _ObjectTracker.objectTracker.camera = this.camera;

      if (config.external === 'THREE') {
        this.threeRenderer = new _THREE["default"](_config.projectionParameter, _config.zIndex, _config.zIndexIncrement);
      }

      _TrackableManager.trackableManager.setDatas(_config.data);

      var style = document.body.style;
      style.margin = 0;
      style.padding = 0; // document.getElementsByTagName('html')[0].removeAttribute('style');

      _instance = this;
    }

    _createClass(Engine, [{
      key: "onConfigurationChanged",
      value: function onConfigurationChanged(newConfig) {
        _Context.context.setConfig(newConfig);

        _DOMRenderer.domRenderer.updateOrientation(newConfig);

        if (config.external === 'THREE' && this.threeRenderer) this.threeRenderer.updateOrientation(newConfig);
      }
    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        return _TrackableManager.trackableManager.getEntity(uri);
      }
    }, {
      key: "getEntities",
      value: function getEntities() {
        return _TrackableManager.trackableManager.getEntities();
      }
    }, {
      key: "removeEntity",
      value: function removeEntity(uri) {
        _TrackableManager.trackableManager.removeEntity(uri);
      }
    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        return _TrackableManager.trackableManager.hasEntity(uri);
      }
    }, {
      key: "resetDomRenderable",
      value: function resetDomRenderable() {
        this.domRenderer.resetElement();
      }
    }, {
      key: "appendDomRenderable",
      value: function appendDomRenderable(element) {
        this.domRenderer.appendElement(element);
      }
    }, {
      key: "appendAllDomRenderables",
      value: function appendAllDomRenderables() {
        this.domRenderer.appendAllElements();
      }
    }, {
      key: "objectTracker",
      get: function get() {
        return _ObjectTracker.objectTracker;
      }
    }, {
      key: "domRenderer",
      get: function get() {
        return _DOMRenderer.domRenderer;
      }
    }]);

    return Engine;
  }();

  _exports["default"] = Engine;
});

/***/ }),

/***/ "./entity/Entity.js":
/*!**************************!*\
  !*** ./entity/Entity.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../renderer/DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../observers/Observer */ "./observers/Observer.js"), __webpack_require__(/*! ./EntityEvent */ "./entity/EntityEvent.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util, _Object3D, _DOMRenderer, _MessageTypes, _Observer2, _EntityEvent) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D = _interopRequireDefault(_Object3D);
  _Observer2 = _interopRequireDefault(_Observer2);
  _EntityEvent = _interopRequireDefault(_EntityEvent);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var handlers = new Map([[_MessageTypes.ENTITY_EVENT.TRACK_START, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_MOVE, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_END, new Set()]]);
  /**
   * Class representing a real world object that can be detected and be associated with HTML elements.
   * @class
   * @name Entity
   * @hideconstructor
   */

  var Entity =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(Entity, _Observer);

    function Entity(uri, data) {
      var _this;

      _classCallCheck(this, Entity);

      if (!uri) throw new Error('Entity requires an entity uri');
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Entity).call(this, uri, handlers));
      _this.uri = uri;
      _this.type = data && data.type ? data.type : 'object';
      _this.name = data && data.name ? data.name : '';
      _this.image = data && data.image ? data.image : '';
      _this.size = data && data.size ? data.size : {
        width: 0,
        height: 0,
        depth: 0,
        unit: 'mm'
      };
      _this.renderables = [];
      _this.object = new _Object3D["default"]();
      _this._visible = true;
      _this._track = false;
      return _this;
    }

    _createClass(Entity, [{
      key: "setData",
      value: function setData(data) {
        this.type = data && data.type ? data.type : 'object';
        this.name = data && data.name ? data.name : '';
        this.image = data && data.image ? data.image : '';
        this.size = data && data.size ? data.size : {
          width: 0,
          height: 0,
          depth: 0,
          unit: 'mm'
        };
      }
    }, {
      key: "translateX",
      value: function translateX(value) {
        this.object.translateX(value);
        return this;
      }
    }, {
      key: "translateY",
      value: function translateY(value) {
        this.object.translateY(value);
        return this;
      }
    }, {
      key: "translateZ",
      value: function translateZ(value) {
        this.object.translateZ(value);
        return this;
      }
    }, {
      key: "rotateX",
      value: function rotateX(value) {
        this.object.rotateX(value);
        return this;
      }
    }, {
      key: "rotateY",
      value: function rotateY(value) {
        this.object.rotateY(value);
        return this;
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(value) {
        this.object.rotateZ(value);
        return this;
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.object.updateMatrix();
        return this;
      }
      /**
       * 전달된 `Renderable`을 엔터티에 등록합니다. `Renderable`은 엔터티가 증강되면 화면에 보여집니다.
       * Registers the given `Renderable` to this entity. The `Renderable` will be
       * rendered when this entity is tracked.
       * @method Entity#addRenderable
       * @param {Renderable} renderable
       * @example
       * // Create a renderable HTML element
       * // html로 만들어진 renderable을 생성합니다.
       * var helloWorldElem = document.createElement('h1');
       * helloWorldElement.appendChild(document.createTextNode('Hello World!'));
       * var helloWorld = new DOMRenderable(helloWorldElem);
       *
       * // Register the renderable to the entity
       * // renderable을 엔터티에 등록합니다.
       * entity.addRenderable(helloWorld);
       */

    }, {
      key: "addRenderable",
      value: function addRenderable(renderable) {
        if (renderable) {
          if (this.renderables.length === 0) {
            _DOMRenderer.domRenderer.add(this.object);
          }

          this.renderables.push(renderable);
          this.object.add(renderable);

          if (this.track) {
            var track = this.track;
            renderable.traverse(function (obj) {
              obj.track = track;

              if (obj.element) {
                obj.element.style.display = '';
              }
            });
          }
        }
      }
      /**
       * 전달된 `Renderable`을 엔터티에서 삭제합니다. 삭제된 `Renderable`은 더이상 화면에 표시되지 않습니다.
       * Removes the given `Renderable` from this entity's renderables.
       * The `Renderable` will no longer be rendered
       * when this entity is tracked.
       * @method removeRenderable
       * @memberof Entity.prototype
       * @param {Renderable} renderable
       */

    }, {
      key: "removeRenderable",
      value: function removeRenderable(renderable) {
        if (renderable) {
          (0, _Util.removeArrayItem)(this.renderables, renderable);
          this.object.remove(renderable);

          if (this.renderables.length === 0) {
            _DOMRenderer.domRenderer.remove(this.object);
          }
        }
      }
      /**
       * Reset all `Renderables` registered to this entity.
       * 등록된 모든 `Renderables`을 삭제합니다.
       * @method Entity#resetRenderables
       */

    }, {
      key: "resetRenderables",
      value: function resetRenderables() {
        if (this.renderables.length > 0) {
          // for (let renderable of this.renderables) {
          //   this.object.remove(renderable);
          // }
          this.renderables = [];

          _DOMRenderer.domRenderer.remove(this.object);
        }
      }
      /**
       * Returns all the Renderables of this entity.
       * 등록된 모든 `Renderables`을 반환합니다.
       * @method Entity#getAllRenderables
       * @return {Renderable[]}
       */

    }, {
      key: "getAllRenderables",
      value: function getAllRenderables() {
        return this.renderables;
      }
      /**
       * Returns the Renderable with the given `uuid`, or `null` if no such
       * Renderable exists.
       * 지정된 UUID를 가진 `Renderables`을 반환합니다. 없으면 `null`을 반환합니다.
       * @method getRenderable
       * @memberof Entity.prototype
       * @param {string} uuid
       * @return {Renderable|null}
       */

    }, {
      key: "getRenderable",
      value: function getRenderable(uuid) {
        for (var i = this.renderables.length; i >= 0; i -= 1) {
          if (this.renderables[i].uuid === uuid) {
            return this.renderables[i];
          }
        }

        return null;
      } // getScreen() {
      //   const camera = LetseeEngine.camera;
      //
      //   if (camera) {
      //     const matrix = new Matrix4();
      //     matrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse.toCSS3D());
      //
      //     const v = this.object.position.clone();
      //     v.applyMatrix4(matrix);
      //
      //     const halfWidth = Context.width * 0.5;
      //     const halfHeight = Context.height * 0.5;
      //
      //     return new Vector2().set(
      //       (v.x + 1) * halfWidth,
      //       (-v.y + 1) * halfHeight
      //     );
      //
      //   } else {
      //     console.error('Camera is not initialized');
      //   }
      // }

    }, {
      key: "lookAt",
      value: function lookAt(position) {
        this.object.lookAt(position);
      }
    }, {
      key: "lootAtRenderables",
      value: function lootAtRenderables(position) {
        var _this2 = this;

        this.object.traverse(function (obj) {
          if (_this2.object !== obj) {
            obj.lookAt(position);
          }
        });
      }
    }, {
      key: "lookAtCamera",
      value: function lookAtCamera() {
        var cameraPose = LetseeEngine.camera.position;
        this.lootAtRenderables(cameraPose);
      } // addEventListener(type, listener) {
      //   eventManager.addEventListener(type, this.uri, listener);
      // }
      //
      // removeEventListener(type, callback) {
      //   eventManager.removeEventListener(type, this.uri, callback);
      // }

    }, {
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Entity.prototype), "subscribe", this)).call.apply(_get2, [this, this.uri, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(Entity.prototype), "unsubscribe", this).call(this, this.uri, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        if (event instanceof _EntityEvent["default"]) {
          _get(_getPrototypeOf(Entity.prototype), "notify", this).call(this, this.uri, type, event);
        }
      }
    }, {
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(visible) {
        this._visible = visible;
        this.object.traverse(function (obj) {
          obj.visible = visible;

          if (obj.element) {
            if (visible) {
              obj.element.style.display = '';
            } else {
              obj.element.style.display = 'none';
            }
          }
        });
      }
    }, {
      key: "track",
      get: function get() {
        return this._track;
      },
      set: function set(track) {
        this._track = track;
        this.object.traverse(function (obj) {
          obj.track = track;

          if (obj.element) {
            if (track) {
              obj.element.style.display = '';
            } else {
              obj.element.style.display = 'none';
            }
          }
        });
      }
    }, {
      key: "position",
      get: function get() {
        return this.object.position;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.object.matrix;
      }
    }, {
      key: "matrixWorld",
      get: function get() {
        return this.object.matrixWorld;
      }
    }, {
      key: "quaternion",
      get: function get() {
        return this.object.quaternion;
      }
    }, {
      key: "rotation",
      get: function get() {
        return this.object.rotation;
      }
    }, {
      key: "scale",
      get: function get() {
        return this.object.scale;
      },
      set: function set(scale) {
        if (scale) this.object.scale.setScalar(scale);
        return this;
      }
    }]);

    return Entity;
  }(_Observer2["default"]);

  _exports["default"] = Entity;
  ;
});

/***/ }),

/***/ "./entity/EntityEvent.js":
/*!*******************************!*\
  !*** ./entity/EntityEvent.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Matrix) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Matrix = _interopRequireDefault(_Matrix);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /**
   * @typedef {'trackstart'|'trackmove'|'trackend'} EntityEventType
   */
  // export type EntityEventType = 'trackstart' | 'trackmove' | 'trackend';

  /**
   * @callback EntityEventListener
   * @param {EntityEvent} event
   */
  // export type EntityEventListener = (event: EntityEvent) => void;

  /**
   * @class EntityEvent
   * @classdesc Class representing feature tracking events.
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2016. 03. 23.
   * @param {string} type
   * @param {Entity} entity
   * @param {Trackable} trackable
   * @param {number[]} [matrix]
   * @param {number} [scale=1]
   * @throws {Error} Throws an error if `type` or `entity` is not specified.
   */

  /*/!**
   * The type of this track event.
   * @member {string} type
   * @memberof EntityEvent#
   *!/
  let _type;
  
  /!**
   * The target of this track event.
   * @member {Entity} target
   * @memberof EntityEvent#
   *!/
  let _target;
  
  /!**
   * A 4x4 [matrix]{@link "https://en.wikipedia.org/wiki/Matrix_(mathematics)"}
   * in a
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
   * format that represents the translation and the rotation of the entity
   * relative to the device camera.
   * @todo column vs row, rotation/translation of what relative to what
   * @member {Matrix4} matrix
   * @memberof EntityEvent#
   * @default [
   * 1, 0, 0, 0,
   * 0, 1, 0, 0,
   * 0, 0, 1, 0,
   * 0, 0, 0, 1
   * ]
   *!/
  let _matrix;
  
  /!**
   *
   * @member {Object} pixelSize
   * @memberof EntityEvent#
   * @default {
   * width: 0.0,
   * height: 0.0,
   * depth: 0,0
   * }
   *!/
  let _pixelSize = {
    width: null,
    height: null,
    depth: null
  };
  
  let _scale;*/
  var EntityEvent = function EntityEvent(type, target, matrix, pixelSize, scale) {
    _classCallCheck(this, EntityEvent);

    if (!type || !target) throw new Error('EntityEvent requires an event type and entity');
    this.type = type;
    this.target = target;
    this.matrix = matrix || new _Matrix["default"]();
    this.pixelSize = pixelSize || {
      width: 0.0,
      height: 0.0,
      depth: 0.0
    };
    this.scale = scale || 1.0;
  };

  _exports["default"] = EntityEvent;
});

/***/ }),

/***/ "./entity/EntityEventType.js":
/*!***********************************!*\
  !*** ./entity/EntityEventType.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  var EventType = {
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend'
  };
  var _default = EventType;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./external/THREE.js":
/*!***************************!*\
  !*** ./external/THREE.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Context */ "./Context.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _Matrix, _EntityObserver2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Matrix = _interopRequireDefault(_Matrix);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  var _this = void 0;

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  var _type = 'LetseeThree';
  var _instance = null;
  var _renderer = null;
  var _camera = null;
  var _scene = null;
  var _autoRender = true;

  var _canvas = document.createElement('canvas');

  var LETSEE_THREE = null;

  var _entityGroup = new Map();

  var renderScene = function renderScene(event) {
    if (_autoRender) {
      // this.clear(true, true, true);
      _renderer.state.reset();

      _renderer.render(_scene, _camera); // this.onRenderCallback(event);

    }
  };

  var getThreeGroup = function getThreeGroup(uri) {
    if (_entityGroup.get(uri) == null) {
      var group = new LETSEE_THREE.Group();
      group.name = uri;

      _entityGroup.set(uri, group);

      _scene.add(group);

      return group;
    }

    return _entityGroup.get(uri);
  };

  var _addObjectToEntity = function _addObjectToEntity(uri, object) {
    var group = getThreeGroup(uri);
    group.add(object);
  };

  var _removeObjectFromEntity = function removeObjectFromEntity(uri, object) {
    if (_this.objects[uri]) {
      _this.objects[uri].remove(object);

      if (_this.objects[uri].children.length === 0) {
        delete _this.objects[uri];
      }
    }
  };

  var onTrackStartCallback = function onTrackStartCallback(e) {};

  var onTrackMoveCallback = function onTrackMoveCallback(e) {};

  var onTrackEndCallback = function onTrackEndCallback(e) {};

  var onTrackMove = function onTrackMove(e) {
    if (_entityGroup.get(e.target.uri) != null) {
      // const object = this.objects[e.target.uri];
      // const group = this.getThreeGroup(e.target.uri);
      var group = _entityGroup.get(e.target.uri);

      group.matrix.compose(group.position, group.quaternion, group.scale);
      group.matrixAutoUpdate = false; // e.event was dispatched from ObjectTracker.
      // Invert X axis was already applied at ObjectTracker

      var matrix = e.matrix;
      matrix.decompose(_camera.position, _camera.quaternion, _camera.scale);

      _camera.updateMatrix();

      var tmp = new _Matrix["default"]().getInverse(_camera.matrix);

      _camera.matrix.identity();

      _camera.applyMatrix(tmp);

      _camera.updateMatrix();

      _camera.updateMatrixWorld();

      _camera.matrixWorldInverse.getInverse(_camera.matrixWorld);

      group.visible = true;
      renderScene(e);
      onTrackMoveCallback(e);
    }
  };

  var onTrackStart = function onTrackStart(e) {
    if (_entityGroup.get(e.target.uri) != null) _entityGroup.get(e.target.uri).visible = true;
    renderScene(e);
    onTrackStartCallback(e);
  };

  var onTrackEnd = function onTrackEnd(e) {
    if (_entityGroup.get(e.target.uri) != null) _entityGroup.get(e.target.uri).visible = false;
    renderScene(e);
    onTrackEndCallback(e);
  };

  var init = function init(cameraParam, zIndex, zIndexIncrement) {
    LETSEE_THREE = window.THREE;
    _canvas.className = 'ar-renderer';
    _canvas.style.position = 'absolute';
    _canvas.style.top = 0;
    _canvas.style.left = 0;
    _canvas.style.margin = 0;
    _canvas.style.padding = 0;
    _canvas.style.zIndex = zIndex + zIndexIncrement;
    document.body.insertBefore(_canvas, document.body.firstChild);
    _camera = _construct(LETSEE_THREE.PerspectiveCamera, _toConsumableArray(cameraParam));
    _scene = new LETSEE_THREE.Scene();
    _renderer = new LETSEE_THREE.WebGLRenderer({
      alpha: true,
      canvas: _canvas
    });
    _camera.matrixAutoUpdate = false;

    _camera.lookAt(_scene.position);

    _renderer.setSize(_Context.context.screenWidth, _Context.context.screenHeight);

    _scene.add(_camera); // eventManager.addEventListener('trackmove', (e) => onTrackMove(e));
    // eventManager.addEventListener('trackstart', (e) => onTrackStart(e));
    // eventManager.addEventListener('trackend', (e) => onTrackEnd(e));

  };

  var LetseeThree =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(LetseeThree, _EntityObserver);

    function LetseeThree(param, zIndex, zIndexIncrement) {
      var _this2;

      _classCallCheck(this, LetseeThree);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(LetseeThree).call(this));
      if (!window.THREE) throw new Error('THREE is not definded. please import vendor.js library.');
      if (_instance) return _possibleConstructorReturn(_this2, _instance);
      init(param, zIndex, zIndexIncrement);

      _this2.subscribe('trackmove', function (e) {
        return onTrackMove(e);
      });

      _this2.subscribe('trackstart', function (e) {
        return onTrackStart(e);
      });

      _this2.subscribe('trackend', function (e) {
        return onTrackEnd(e);
      });

      _instance = _assertThisInitialized(_this2);
      return _this2;
    }

    _createClass(LetseeThree, [{
      key: "addObjectToEntity",
      value: function addObjectToEntity(uri, object) {
        _addObjectToEntity(uri, object);
      }
    }, {
      key: "entityGroup",
      value: function entityGroup(uri) {
        if (_entityGroup.get(uri) == null) {
          throw new Error('No entity group founded');
        }

        return _entityGroup.get(uri);
      }
    }, {
      key: "removeObjectFromEntity",
      value: function removeObjectFromEntity(uri, object) {
        _removeObjectFromEntity(uri, object);
      }
    }, {
      key: "updateOrientation",
      value: function updateOrientation(newConfig) {
        _renderer.setSize(newConfig.width, newConfig.height);

        _camera.aspect = newConfig.aspect;

        _camera.updateProjectionMatrix();
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }, {
      key: "camera",
      get: function get() {
        return _camera;
      }
    }, {
      key: "scene",
      get: function get() {
        return _scene;
      }
    }]);

    return LetseeThree;
  }(_EntityObserver2["default"]);

  _exports["default"] = LetseeThree;
});

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ./Util */ "./Util.js"), __webpack_require__(/*! ./Letsee */ "./Letsee.js"), __webpack_require__(/*! ./observers/observer/LetseeObserver */ "./observers/observer/LetseeObserver.js"), __webpack_require__(/*! ./math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ./math/Matrix3 */ "./math/Matrix3.js"), __webpack_require__(/*! ./math/Vector2 */ "./math/Vector2.js"), __webpack_require__(/*! ./math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ./core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ./entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ./entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ./renderer/DOMRenderable */ "./renderer/DOMRenderable.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _MessageTypes, _Util, _Letsee, _LetseeObserver, _Matrix, _Matrix2, _Vector, _Vector2, _Quaternion, _Euler, _Object3D, _Entity, _EntityEvent, _DOMRenderable) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.letsee = void 0;
  _Letsee = _interopRequireWildcard(_Letsee);
  _LetseeObserver = _interopRequireDefault(_LetseeObserver);
  _Matrix = _interopRequireDefault(_Matrix);
  _Matrix2 = _interopRequireDefault(_Matrix2);
  _Vector = _interopRequireDefault(_Vector);
  _Vector2 = _interopRequireDefault(_Vector2);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _Object3D = _interopRequireDefault(_Object3D);
  _Entity = _interopRequireDefault(_Entity);
  _EntityEvent = _interopRequireDefault(_EntityEvent);
  _DOMRenderable = _interopRequireDefault(_DOMRenderable);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _letsee = null;
  var _currentPauseStatus = false; // eslint-disable-line

  var _hideScreen = false;
  var letseeEvent = new _LetseeObserver["default"]();
  var VERSION = '0.9.20.0028';
  var VERSION_STRING =  true ?  true ? "VERSION: ".concat(VERSION, "_local") : undefined : undefined; // eslint-disable-line

  /**
   * @typedef {("IMAGE"|"MARKER"|"QRCODE")} TrackerType - 사용 가능한 트랙커 타입
   */

  /**
   * @typedef {object} EntityEvent
   * @property {"trackstart"|"trackmove"|"trackend"} type - 현재 트랙킹 상태
   * @property {object} matrix
   * @property {Array} matrix.elements
   * @property {number} scale
   * @property {object} pixelSize
   * @property {number} pixelSize.width
   * @property {number} pixelSize.height
   * @property {number} pixelSize.depth
   * @property {("mm")} pixelSize.unit
   * @property {Entity} target
   */

  /**
   * @typedef {object} LetseeStatus
   * @property {number} code - 상태 코드
   * @property {string} message - 상태 메세지
   * @description
   * LetseeStatus는 Letsee Engine 작동중 발생하는 각종 상태 변경이나 예외 상황을 정의한 코드를 나타냅니다.
   * 상태 코드와 설명 메시지는 아래의 표와 같습니다.
   *
   * |CODE |MESSAGE  |
   * |---	|---	|
   * |101  | Use chrome with ios|
   * |102  | Unsupported browser|
   * |103  | No camera detected|
   * |104  | No mobile device detected|
   * |200  | Camera initialize start|
   * |201  | Camera initialize done|
   * |202  | Video start|
   */

  /**
   * Letsee 객체를 생성합니다.
   * @class
   * @name Letsee
   * @param {object} config - 렛시 콘피그
   * @param {string} config.appKey - Letsee Web AR SDK 인증 키
   * @param {TrackerType} config.trackerType - 트랙커 타입
   * @returns {Letsee}
   */

  var Letsee =
  /*#__PURE__*/
  function () {
    function Letsee() {
      _classCallCheck(this, Letsee);

      if (true) {
        console.warn('\n' + '    ▓█████▄  ▄▄▄       ███▄    █   ▄████ ▓█████  ██▀███   ▐██▌ \n' + '    ▒██▀ ██▌▒████▄     ██ ▀█   █  ██▒ ▀█▒▓█   ▀ ▓██ ▒ ██▒ ▐██▌ \n' + '    ░██   █▌▒██  ▀█▄  ▓██  ▀█ ██▒▒██░▄▄▄░▒███   ▓██ ░▄█ ▒ ▐██▌ \n' + '    ░▓█▄   ▌░██▄▄▄▄██ ▓██▒  ▐▌██▒░▓█  ██▓▒▓█  ▄ ▒██▀▀█▄   ▓██▒ \n' + '    ░▒████▓  ▓█   ▓██▒▒██░   ▓██░░▒▓███▀▒░▒████▒░██▓ ▒██▒ ▒▄▄  \n' + '    ▒▒▓  ▒  ▒▒   ▓▒█░░ ▒░   ▒ ▒  ░▒   ▒ ░░ ▒░ ░░ ▒▓ ░▒▓░ ░▀▀▒  \n' + '    ░ ▒  ▒   ▒   ▒▒ ░░ ░░   ░ ▒░  ░   ░  ░ ░  ░  ░▒ ░ ▒░ ░  ░  \n' + '    ░ ░  ░   ░   ▒      ░   ░ ░ ░ ░   ░    ░     ░░   ░     ░  \n' + '    ░          ░  ░         ░       ░    ░  ░   ░      ░       \n' + '    ░                                                          \n' + '\n' + '\n');
        console.warn("[SECURITY NOTICE] This is '".concat( true ? 'Local' : undefined, "' version. USE SAFELY. SDK Version: ").concat(VERSION)); // eslint-disable-line
      }

      console.log('Letsee!');
    }

    _createClass(Letsee, [{
      key: "init",
      value: function init(config) {
        var _this = this;

        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (_letsee) throw new Error('Letsee already initialized.');
        _letsee = new _Letsee["default"](config);

        _letsee.init().then(function () {
          if (callback && typeof callback !== 'function') throw new Error('Callback must be function');else if (callback) callback(_this);
          console.log('Letsee loaded!');
        });
      }
    }, {
      key: "pause",
      value: function pause() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (_currentPauseStatus) return false;
        _hideScreen = val;
        _currentPauseStatus = true;
        if (val) _letsee.engine.resetDomRenderable();
        return _letsee.pause(val);
      }
    }, {
      key: "resume",
      value: function resume() {
        if (!_currentPauseStatus) return false;
        _currentPauseStatus = false;
        if (_hideScreen) _letsee.engine.appendAllDomRenderables();
        return _hideScreen ? _letsee.resume(true) : _letsee.resume();
      }
    }, {
      key: "onLoad",
      // Dispatch at render
      // onRender(callback) {}
      // Dispatch at app resumed
      // onResume(callback) {}
      // Dispatch at app started
      // onStart(callback) {}
      // Dispatch at app
      // onPaused(callback) {}
      // Dispatch before render
      // onUpdate(callback) {}

      /**
       * 렛시 엔진이 시작된 후에 전달됩니다. `onload`이벤트의 숏컷 입니다.
       * @method Letsee#onLoad
       * @param {Function} callback
       */
      value: function onLoad(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.ON_LOAD, callback);
      }
      /**
       * 증강 대상의 트랙킹 시작과 함께 전달되는 이벤트 입니다. `trackstart` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackStart
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackStart",
      value: function onTrackStart(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.TRACK_START, callback);
      }
      /**
       * 증강 대상의 트랙킹중 전달되는 이벤트 입니다. `trackmove` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackMove
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackMove",
      value: function onTrackMove(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.TRACK_MOVE, callback);
      }
      /**
       * 증강 대상의 트랙킹이 멈추면 전달되는 이벤트 입니다. `trackend` 이벤트의 숏컷 입니다.
       * @method Letsee#onTrackEnd
       * @param {Function} callback
       * @param {EntityEvent} callback.event
       */

    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.TRACK_END, callback);
      }
      /**
       * 렛시 객체의 상태를 전달하는 이벤트 입니다. . `app_status` 이벤트의 숏컷 입니다.
       * @method Letsee#onStatus
       * @param {Function} callback
       * @param {LetseeStatus} callback.event
       */

    }, {
      key: "onStatus",
      value: function onStatus(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.ON_STATUS, callback);
      }
      /**
       * 기기의 가로/세로 변환 후 전달되는 이벤트 입니다. window의 `orientationchange` 이벤트와는 달리 화면 방향 전환에따른 Letsee 내부의 연산이 완료된 후 전달됩니다.
       * 콜백은 window의 `orientationchange`와 동일합니다.
       * @method Letsee#onOrientationChange
       * @param {Function} callback
       * @param {event} callback.event
       */

    }, {
      key: "onOrientationChange",
      value: function onOrientationChange(callback) {
        letseeEvent.subscribe(_MessageTypes.LETSEE_EVENT.ROTATION_CHANGE, callback);
      }
      /**
       * Letsee 객체에 이벤트를 등록합니다.
       * @method Letsee#addEventListener
       * @param {string} EventType
       * @param {Function} callback
       * @param {event} callback.event
       */

    }, {
      key: "addEventListener",
      value: function addEventListener(type, callback) {
        letseeEvent.subscribe(type, callback);
      }
      /**
       * Letsee 객체에서 이벤트를 삭제합니다.
       * @method Letsee#removeEventListener
       * @param {string} EventType
       * @param {Function} callback
       */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, callback) {
        letseeEvent.unsubscribe(type, callback);
      }
      /**
       * 커스텀 로딩 화면을 등록합니다. 전달된 html 소스는 `id=letseeLoaderWrapper`인 `div`태그에 추가됩니다.
       * @method Letsee#setLoadingScreen
       * @param {string} html - 사용할 로딩 화면의 html 코드
       * @param {Array} css - 입력한 html코드를 위한 css
       * @example
       * // string형태로 html코드를 생성합니다.
       * const customLoader = "<p><span>Loading...</span></p>";
       * // css를 string으로 생성하고 Array에 담습니다.
       * const customLoaderCss = [
       * `#letseeLoaderWrapper p {
       *    position: absolute;
       *    left: 50%;
       *    top: 50%;
       *    transform: translate(-50%, -50%);
       *  }`,
       * `#letseeLoaderWrapper p span {
       *    color: #666666;
       * }`];
       * // html과 css를 등록합니다.
       * myApp.setLoadingScreen(customLoader, customLoaderCss);
       */

    }, {
      key: "setLoadingScreen",
      value: function setLoadingScreen(html, css) {
        if (!!html && !!css) (0, _Util.createLoader)(html, css);else console.log('You need setup both html and css');
      }
      /**
       * 렌더링시에 작동할 커스텀 모듈을 등록합니다. 등록된 모듈은 Letsee의 렌더링 루프에 맞추어 실행됩니다.
       * @method Letsee#addRenderModule
       * @param {object} moduleObject
       * @param {string} moduleObject.name - 커스텀 모듈의 이름입니다. 유니크하여야 합니다.
       * @param {Function} moduleObject.onRender - 실행될 렌더 모듈 입니다.
       * @param {number} moduleObject.onRender.tick - ms단위로 반환되는 시간입니다.
       * @returns {boolean}
       * @example
       * const customModule = (tick) => console.log(tick);
       * myApp.addRenderModule({
       *     name: 'myCustomModule',
       *     onRender: customModule
       * });
       */

    }, {
      key: "addRenderModule",
      value: function addRenderModule(moduleObject) {
        // subscribe
        return (0, _Letsee.addRenderModule)(moduleObject);
      }
      /**
       * 해당 이름을 가진 렌더 모듈을 삭제합니다.
       * @method Letsee#removeRenderModule
       * @param {string} name - 삭제하고자 하는 모듈 이름
       */

    }, {
      key: "removeRenderModule",
      value: function removeRenderModule(name) {
        return (0, _Letsee.removeRenderModule)(name);
      }
      /**
       * 등록된 모든 렌더 모듈을 삭제합니다.
       * @method Letsee#resetRenderModules
       */

    }, {
      key: "resetRenderModules",
      value: function resetRenderModules() {
        return (0, _Letsee.resetRenderModules)();
      }
      /**
       * 등록된 렌더 모듈을 반환합니다.
       * @member {Array} Letsee#renderModule
       * @readonly
       */

    }, {
      key: "getAllEntities",

      /**
       * 등록된 모든 엔터티를 반환합니다.
       * @method Letsee#getEntities
       * @returns {Array}
       */
      value: function getAllEntities() {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.engine.getEntities();
      }
      /**
       * 주어진 uri를 가진 엔터티를 반환합니다.
       * @method Letsee#getEntity
       * @param {string} uri
       * @returns {Entity} Entity
       */

    }, {
      key: "getEntity",
      value: function getEntity(uri) {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.engine.getEntity(uri);
      }
      /**
       * 지정된 uri를 가진 엔터티를 삭제합니다.
       * @method Letsee#removeEntity
       * @param {string} uri
       */

    }, {
      key: "removeEntity",
      value: function removeEntity(uri) {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.engine.removeEntity(uri);
      }
      /**
       * 지정된 uri를 가진 엔터티가 있는지 확인합니다.
       * @method Letsee#hasEntity
       * @param {string} uri
       * @returns {boolean}
       */

    }, {
      key: "hasEntity",
      value: function hasEntity(uri) {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.engine.hasEntity(uri);
      }
      /**
       * vendor.js의 `WebglRenderer`를 취득합니다.
       * @member {THREE.WebglRenderer} Letsee#threeRenderer
       * @readonly
       */

    }, {
      key: "setVideoSource",
      value: function setVideoSource(src) {
        return _letsee.videoManager.setVideoSource(src);
      }
    }, {
      key: "requestFullscreen",
      value: function requestFullscreen() {
        _letsee.requestFullscreen();
      }
    }, {
      key: "exitFullscreen",
      value: function exitFullscreen() {
        _letsee.exitFullscreen();
      }
    }, {
      key: "getSourceDeviceList",
      value: function getSourceDeviceList() {
        return _letsee.videoManager.getSourceDeviceList();
      }
    }, {
      key: "isPause",
      get: function get() {
        return _letsee.isPause;
      }
    }, {
      key: "renderModules",
      get: function get() {
        return (0, _Letsee.renderModules)();
      }
    }, {
      key: "threeRenderer",
      get: function get() {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.engine.threeRenderer;
      }
      /**
       * 디바이스 정보를 반환합니다.
       * @member {object} Letsee#device
       * @property {number} width
       * @property {number} height
       * @readonly
       */

    }, {
      key: "device",
      get: function get() {
        return (0, _Util.isNil)(_letsee) ? new Error('Run letsee.init first') : _letsee.videoManager.screenInfo;
      }
      /**
       * Letsee Web AR SDK의 버전을 반환합니다.
       * @member {string} Letsee#version
       * @readonly
       */

    }, {
      key: "version",
      get: function get() {
        return VERSION_STRING;
      }
    }, {
      key: "cssSelector",
      get: function get() {
        if ((0, _Util.isNil)(_letsee)) {
          return new Error('Run letsee.init first');
        }

        return {
          bodyId: _letsee.config.bodyId,
          domRendererId: _letsee.config.domRendererId,
          videoId: _letsee.config.videoId
        };
      }
    }]);

    return Letsee;
  }(); // export default Letsee;


  var letsee = new Letsee();
  _exports.letsee = letsee;
  window.letsee = letsee; // export helper classes

  letsee.Matrix4 = _Matrix["default"];
  letsee.Matrix3 = _Matrix2["default"];
  letsee.Vector2 = _Vector["default"];
  letsee.Vector3 = _Vector2["default"];
  letsee.Quaternion = _Quaternion["default"];
  letsee.Euler = _Euler["default"];
  letsee.Object3D = _Object3D["default"];
  letsee.Entity = _Entity["default"];
  letsee.EntityObserver = _EntityEvent["default"];
  letsee.DOMRenderable = _DOMRenderable["default"];
});

/***/ }),

/***/ "./libs/CSSParser.js":
/*!***************************!*\
  !*** ./libs/CSSParser.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cssParser = void 0;

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // const HTTP = '&@http@;';
  // const HTTPS = '&@https@;';
  var ATTR_TRANSLATE = 'translate';
  var ATTR_ROTATE = 'rotate';
  var PROPERTY_TARGET = '-letsee-target';
  var PROPERTY_TRANSFORM = '-letsee-transform';
  var ANGLE_UNIT = {
    degree: 'deg',
    radian: 'rad',
    turn: 'turn',
    gradian: 'grad'
  };
  var TRANSLATE_REG = new RegExp("".concat(ATTR_TRANSLATE, "(.[0-9,.-]+)"), 'g');
  var ROTATE_REG = new RegExp("".concat(ATTR_ROTATE, "(.([0-9,.-]|").concat(ANGLE_UNIT.degree, "|").concat(ANGLE_UNIT.radian, "|").concat(ANGLE_UNIT.turn, "|").concat(ANGLE_UNIT.gradian, ")+)"), 'g'); // eslint-disable-line

  var URI_REG = /uri\(['"].[^'|"]+['"]\)/g; // const URI_REG = /uri\(('|")(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w\.-]+)+[\w\-\._~:/?#[\]@!\$&'\(\)\*\+,;=.]+('|")\)/g;

  /**
   * @class CSSParser
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2017. 03. 10.
   */

  var CSSParser =
  /*#__PURE__*/
  function () {
    function CSSParser() {
      _classCallCheck(this, CSSParser);

      this.dataMap = {};
      this.domRendererId = null;
    }
    /**
     * @method parse
     * @memberof CSSParser.prototype
     * @return {[type]} [description]
     */


    _createClass(CSSParser, [{
      key: "parse",
      value: function parse(id) {
        this.dataMap = {};
        this.domRendererId = id;
        var styleTags = document.getElementsByTagName('style');

        for (var i = 0; i < styleTags.length; i += 1) {
          var tag = styleTags[i];

          if (tag.media === 'place') {
            var style = this.removeComment(tag.innerHTML);
            this.parseData(style);
            this.removeMedia(tag, style);
          }
        }

        return Object.values(this.dataMap);
      }
      /**
       * @method removeComment
       * @memberof CSSParser
       * @param  {string} text
       * @return {string}
       */

    }, {
      key: "removeComment",
      value: function removeComment(text) {
        return text.replace(/\/\*(.|[\r\n])*?\*\//g, '');
      }
      /**
       * @method parseData
       * @memberof CSSParser.prototype
       * @param  {string} text
       */

    }, {
      key: "parseData",
      value: function parseData(text) {
        var _this = this;

        var styles = text.split('}');
        styles.pop();
        styles.forEach(function (style) {
          var seperateStyle = style.split('{');
          var selector = seperateStyle[0].trim();
          var propertyValues = seperateStyle[1].split(';');
          var renderable = {
            selector: selector,
            translate: [0.0, 0.0, 0.0],
            rotation: [0, 0, 0]
          };
          var entity = null;
          propertyValues.pop();
          propertyValues.forEach(function (prop) {
            prop = prop.trim().replace(/\s/g, '');
            var key = prop.substring(0, prop.indexOf(':'));
            var value = prop.substring(prop.indexOf(':') + 1);

            switch (key) {
              case PROPERTY_TARGET:
                var parseValue = _this.parseTarget(value);

                entity = {
                  type: parseValue[0],
                  uri: parseValue[1]
                };
                break;

              case PROPERTY_TRANSFORM:
                var _this$parsePosition = _this.parsePosition(value),
                    translate = _this$parsePosition.translate,
                    rotate = _this$parsePosition.rotate;

                renderable.translate[0] = translate[0];
                renderable.translate[1] = translate[1];
                renderable.translate[2] = translate[2];
                renderable.rotation[0] = rotate[0];
                renderable.rotation[1] = rotate[1];
                renderable.rotation[2] = rotate[2]; // if (container === 'geo') {
                //   entity = {
                //     type: 'geo',
                //     uri: 'geolocation'
                //   };
                // }

                break;
            }
          });

          if (entity) {
            if (!_this.dataMap[entity.uri]) {
              _this.dataMap[entity.uri] = {
                entity: entity,
                renderables: []
              };
            }

            var data = _this.dataMap[entity.uri]; // TODO: get entity description

            data.entity = entity;
            data.renderables.push(renderable);
          }
        });
      }
    }, {
      key: "parseTarget",
      value: function parseTarget(value) {
        var str = value.replace(/\s/g, '');
        var uri = str.match(URI_REG) ? str.match(URI_REG)[0].replace(/uri\(['"]|['"]\)/g, '') : '';
        return ['object', uri];
      }
      /**
       * @method parseValue
       * @memberof CSSParser
       * @param  {string} value
       * @return {{rotate: Array, translate: Array}}
       */

    }, {
      key: "parsePosition",
      value: function parsePosition(value) {
        var str = value.replace(/\s/g, '');
        var propPosition = str.match(TRANSLATE_REG) ? str.match(TRANSLATE_REG)[0].replace(new RegExp("".concat(ATTR_TRANSLATE, "\\(|\\)"), 'g'), '') : ''; // eslint-disable-line

        var propRotation = str.match(ROTATE_REG) ? str.match(ROTATE_REG)[0].replace(new RegExp("".concat(ATTR_ROTATE, "\\(|\\)"), 'g'), '') : ''; // eslint-disable-line

        return {
          translate: !!propPosition ? _toConsumableArray(this.getTranslate(propPosition)) : [0, 0, 0],
          // eslint-disable-line
          rotate: !!propRotation ? _toConsumableArray(this.getRotation(propRotation)) : [0, 0, 0] // eslint-disable-line

        };
      }
    }, {
      key: "getTranslate",
      value: function getTranslate(values) {
        return values.split(',').map(function (value) {
          if ((0, _Util.isNull)(value.match(/[0-9]/))) throw new Error('Numeric value not provided');
          return parseFloat(value);
        });
      }
    }, {
      key: "getRotation",
      value: function getRotation(values) {
        return values.split(',').map(function (value) {
          if (value.match(new RegExp(ANGLE_UNIT.degree))) return parseFloat(value.replace(ANGLE_UNIT.degree, '')) * (Math.PI / 180); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.radian))) return parseFloat(value.replace(ANGLE_UNIT.radian, '')); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.gradian))) return parseFloat(value.replace(ANGLE_UNIT.gradian, '')) * 360 / 400 * (Math.PI / 180); // eslint-disable-line

          if (value.match(new RegExp(ANGLE_UNIT.turn))) return parseFloat(value.replace(ANGLE_UNIT.turn, '')) * 360 * (Math.PI / 180); // eslint-disable-line

          if ((0, _Util.isNull)(value.match(/[0-9]/))) throw new Error('Numeric value not provided');
          throw new Error("Allowed unit are \"".concat(ANGLE_UNIT.degree, "\", \"").concat(ANGLE_UNIT.radian, "\", \"").concat(ANGLE_UNIT.gradian, "\", \"").concat(ANGLE_UNIT.turn, "\".")); // eslint-disable-line
        });
      }
    }, {
      key: "splitAndRemoveTail",
      value: function splitAndRemoveTail(value, separatorm, remove) {
        var tempArray = value.replace(remove, '');
        tempArray.split(separator);
        return tempArray;
      }
      /**
       * @method getBase
       * @memberof CSSParser
       * @return {string}
       */

    }, {
      key: "getBase",
      value: function getBase() {
        var url = window.location.href;
        var pathArray = url.split('/');
        var last = pathArray[pathArray.length - 1];

        if (last.indexOf('.html') > -1) {
          pathArray.pop();
        }

        var base = pathArray.join('/');

        if (base.substr(base.length - 1) !== '/') {
          base += '/';
        }

        return base;
      }
      /**
       * @method removeMedia
       * @memberof CSSParser
       * @param  {Element} tagElem
       * @param style
       */

    }, {
      key: "removeMedia",
      value: function removeMedia(tagElem, style) {
        var _this2 = this;

        var head = document.head;
        var newStyle = document.createElement('style');
        var modifiedStyle = style // .replace(/(-letsee-target).+;/g, '')
        // .replace(/(-letsee-transform).+;/g, '')
        .replace(new RegExp("(".concat(PROPERTY_TARGET, ").+;"), 'g'), '').replace(new RegExp("(".concat(PROPERTY_TRANSFORM, ").+;"), 'g'), '').replace(/\n/g, '').replace(/({\s+)/g, '{').replace(/(;\s+)/g, ';').split('}');
        modifiedStyle.pop();
        var placeStyle = modifiedStyle.map(function (val) {
          var selector = val.split('{')[0].split(',');
          var value = val.split('{')[1];
          var newSelector = selector.map(function (sel) {
            return "#".concat(_this2.domRendererId, ".ar-mode-on ").concat(sel.trim());
          });
          return "".concat(newSelector.join(','), "{").concat(value, "}");
        });
        newStyle.setAttribute('type', 'text/css');
        placeStyle.unshift("body#".concat(this.domRendererId, ".ar-mode-on{overflow:hidden;}"));
        newStyle.appendChild(document.createTextNode(placeStyle.join('')));
        head.replaceChild(newStyle, tagElem);
      }
    }]);

    return CSSParser;
  }();

  var cssParser = new CSSParser();
  _exports.cssParser = cssParser;
});

/***/ }),

/***/ "./libs/EntityParser.js":
/*!******************************!*\
  !*** ./libs/EntityParser.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var instance = null;
  var template = {
    entity: {
      type: 'object',
      uri: null,
      letseeMarkerId: null,
      codeString: null,
      name: null,
      image: null,
      size: {
        width: null,
        height: null,
        depth: 0.0,
        unit: 'mm'
      }
    },
    pixelSize: {
      width: null,
      height: null,
      depth: null,
      unit: 'px'
    },
    scale: null
  };
  var _entityState = [],
      _markerList = [],
      _codeList = [];

  var Fetcher =
  /*#__PURE__*/
  function () {
    function Fetcher(url) {
      _classCallCheck(this, Fetcher);

      this.entity = {};
      this.entity.uri = url.toString();
    }

    _createClass(Fetcher, [{
      key: "fetchEntity",
      get: function get() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          fetch(_this.entity.uri).then(function (response) {
            return response.json();
          }).then(function (data) {
            // temp.entity.uri = data;
            _this.entity.letseeMarkerId = data.letseeMarkerId || null;
            _this.entity.codeString = data.codeString || null;
            _this.entity.name = data.name || null;
            _this.entity.image = data.image || null;
            _this.entity.size = {
              width: data.size.width || 0,
              height: data.size.height || 0,
              depth: data.size.height || 0,
              unit: data.size.unit || 'mm'
            };
            _this.pixelSize = {
              width: data.size.width || 0,
              height: data.size.height || 0,
              depth: data.size.height || 0,
              unit: data.size.unit || 'mm'
            };
            _this.scale = data.scale || 1;
            if (_this.entity.letseeMarkerId !== null) _markerList.push(_this.entity.letseeMarkerId);
            if (_this.entity.codeString !== null) _codeList.push(_this.entity.codeString);
            var json = JSON.stringify(_this);

            var entity = _objectSpread({}, template, {}, JSON.parse(json));

            _entityState.push(entity);

            resolve(entity);
          })["catch"](function (error) {
            reject(error);
          });
        });
      }
    }]);

    return Fetcher;
  }();

  var EntityParser =
  /*#__PURE__*/
  function () {
    function EntityParser() {
      _classCallCheck(this, EntityParser);

      if (!instance) instance = this;
      this.entityList = [];
    }

    _createClass(EntityParser, [{
      key: "initEntity",
      value: function initEntity(entity) {
        this.entityList = entity.map(function (object) {
          return object.entity.uri;
        }).map(function (object) {
          return new Fetcher(object);
        });
        return Promise.all(this.entityList.map(function (object) {
          return object.fetchEntity;
        })).then(function (data) {
          return data;
        });
      }
    }, {
      key: "entityState",
      get: function get() {
        return _entityState;
      }
    }, {
      key: "markerList",
      get: function get() {
        return _markerList;
      }
    }, {
      key: "codeList",
      get: function get() {
        return _codeList;
      }
    }]);

    return EntityParser;
  }();

  _exports["default"] = EntityParser;
});

/***/ }),

/***/ "./libs/MessageTypes.js":
/*!******************************!*\
  !*** ./libs/MessageTypes.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LETSEE_CSS = _exports.LETSEE_EVENT = _exports.ENTITY_EVENT = _exports.OBJECT_EVENT = _exports.STATE_RECOGNIZE = _exports.STATE_TRACK_END = _exports.STATE_TRACK_MOVE = _exports.STATE_TRACK_START = _exports.EVENT_APP_ROTATIONCHANGE = _exports.EVENT_APP_ONLOAD = _exports.EVENT_APP_STATUS = void 0;
  var EVENT_APP_STATUS = 'app_status';
  _exports.EVENT_APP_STATUS = EVENT_APP_STATUS;
  var EVENT_APP_ONLOAD = 'onload';
  _exports.EVENT_APP_ONLOAD = EVENT_APP_ONLOAD;
  var EVENT_APP_ROTATIONCHANGE = 'rotationchange';
  _exports.EVENT_APP_ROTATIONCHANGE = EVENT_APP_ROTATIONCHANGE;
  var STATE_TRACK_START = 'trackstart';
  _exports.STATE_TRACK_START = STATE_TRACK_START;
  var STATE_TRACK_MOVE = 'trackmove';
  _exports.STATE_TRACK_MOVE = STATE_TRACK_MOVE;
  var STATE_TRACK_END = 'trackend';
  _exports.STATE_TRACK_END = STATE_TRACK_END;
  var STATE_RECOGNIZE = 'recognize';
  _exports.STATE_RECOGNIZE = STATE_RECOGNIZE;
  var OBJECT_EVENT = {
    OBJECT_ADDED: 'added',
    OBJECT_REMOVED: 'removed'
  };
  _exports.OBJECT_EVENT = OBJECT_EVENT;
  var ENTITY_EVENT = {
    TARGET: 'EntityEvent',
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend',
    RECOGNIZE: 'recognize'
  };
  _exports.ENTITY_EVENT = ENTITY_EVENT;
  var LETSEE_EVENT = {
    TARGET: 'LetseeEvent',
    ON_LOAD: 'onload',
    ON_STATUS: 'app_status',
    ROTATION_CHANGE: 'rotationchange',
    TRACK_START: 'trackstart',
    TRACK_MOVE: 'trackmove',
    TRACK_END: 'trackend'
  };
  _exports.LETSEE_EVENT = LETSEE_EVENT;
  var LETSEE_CSS = {
    AR_MODE_ON: 'ar-mode-on',
    AR_MODE_OFF: 'ar-mode-off',
    LETSEE_LOADING: 'letsee-loading',
    LETSEE_LOADED: 'letsee-loaded',
    LETSEE_STATUS: 'letsee-status'
  };
  _exports.LETSEE_CSS = LETSEE_CSS;
});

/***/ }),

/***/ "./libs/ObjectTracker.js":
/*!*******************************!*\
  !*** ./libs/ObjectTracker.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../entity/Entity */ "./entity/Entity.js"), __webpack_require__(/*! ../math/Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ../math/Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ../math/Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ../math/Euler */ "./math/Euler.js"), __webpack_require__(/*! ../core/TrackableManager */ "./core/TrackableManager.js"), __webpack_require__(/*! ../entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ../entity/EntityEventType */ "./entity/EntityEventType.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Entity, _Matrix, _Vector, _Quaternion, _Euler, _TrackableManager, _EntityEvent, _EntityEventType, _EntityObserver2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.objectTracker = void 0;
  _Entity = _interopRequireDefault(_Entity);
  _Matrix = _interopRequireDefault(_Matrix);
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Euler = _interopRequireDefault(_Euler);
  _EntityEvent = _interopRequireDefault(_EntityEvent);
  _EntityEventType = _interopRequireDefault(_EntityEventType);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var translateMatrix = new _Matrix["default"]();
  var rotationMatrix = new _Matrix["default"]();

  var ObjectTracker =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(ObjectTracker, _EntityObserver);

    /**
     * @ignore
     * @member {Object<string, Entity>} targets
     * @memberof LetseeEngine.renderer
     */
    // targets: {[uri: string]: Entity};
    function ObjectTracker() {
      var _this;

      _classCallCheck(this, ObjectTracker);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ObjectTracker).call(this));
      _this.targets = {};
      _this.camera = null;
      _this.useCamera = false;
      return _this;
    }
    /**
     * Returns `true` if currently tracking an entity with `uri`.
     * @method isTracking
     * @memberof LetseeEngine.renderer
     * @param {string} [uri]
     * @return {boolean} Tracking 여부
     */


    _createClass(ObjectTracker, [{
      key: "isTracking",
      value: function isTracking(uri) {
        if (uri) {
          if (this.targets[uri]) return true;
        } else {
          if (Object.keys(this.targets).length > 0) return true;
        }

        return false;
      }
      /**
       * Returns the number of currently tracked objects.
       * @method getTrackingCount
       * @memberof LetseeEngine.tracker
       * @return {number}
       */

    }, {
      key: "getTarget",

      /**
       *
       * @param uri
       * @returns {*}
       */
      value: function getTarget(uri) {
        return this.targets[uri];
      }
    }, {
      key: "addTarget",
      value: function addTarget(target) {
        this.targets[target.uri] = target;
      }
    }, {
      key: "removeTarget",
      value: function removeTarget(target) {
        delete this.targets[target.uri];
      }
      /**
       * Clears the renderer by dispatching a `'trackend'` event for all entities
       * that are currently tracked.
       * 모든 TrackEvent를 clear
       * Tracking 중인 대상에 대해서는 TrackEnd 이벤트 발생
       * @method clear
       * @memberof LetseeEngine.renderer
       */

    }, {
      key: "clear",
      value: function clear() {
        for (var _i = 0, _Object$values = Object.values(this.targets); _i < _Object$values.length; _i++) {
          var entity = _Object$values[_i];
          this.onTrackEnd(new _EntityEvent["default"]('trackend', entity), true);
        }

        this.targets = {}; // LetseeEngine.renderer.render();
      }
      /**
       * @ignore
       * @method onUpdateState
       * @memberof LetseeEngine.tracker
       * @param  {Array} state
       */

    }, {
      key: "updateState",
      value: function updateState(state) {
        var _this2 = this;

        if (state === undefined || state.length === 0) {
          this.clear();
          return;
        }

        state.forEach(function (event) {
          var e = event.entity;
          var entity = _TrackableManager.trackableManager.getEntity(e.uri) || new _Entity["default"](e.uri, e);
          entity.setData(e);
          entity.object.updateMatrix();
          entity.object.updateMatrixWorld();
          var matrix = new _Matrix["default"]().fromArray(event.matrix);
          var entityEvent = new _EntityEvent["default"](event.type, entity, matrix, event.pixelSize, event.scale);

          if (entityEvent) {
            if (event.type === _EntityEventType["default"].TRACK_START) {
              _this2.onTrackStart(entityEvent);
            } else if (event.type === _EntityEventType["default"].TRACK_MOVE) {
              _this2.onTrackMove(entityEvent);
            } else if (event.type === _EntityEventType["default"].TRACK_END) {
              _this2.onTrackEnd(entityEvent);
            }
          }
        });
      }
      /**
       * @ignore
       * @method onTrackStart
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackStart",
      value: function onTrackStart(event) {
        var target = event.target;
        target.track = true;
        this.addTarget(target);

        if (target.uri !== 'unknown') {
          target.scale = event.scale;
          this.notify('trackstart', event);
          target.notify('trackstart', event);
        }
      }
      /**
       * @ignore
       * @method onTrackMove
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackMove",
      value: function onTrackMove(event) {
        var entity = event.target;
        var entityObject = entity.object; // Start invert X Axis

        var rotateM = new _Matrix["default"]();
        var q = new _Quaternion["default"]().setFromEuler(new _Euler["default"](Math.PI, 0, 0));
        rotateM.makeRotationFromQuaternion(q);
        event.matrix.multiply(rotateM); // End invert X axis
        // Apply pose to camera or object.

        if (this.useCamera) {
          event.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);
          this.camera.updateMatrix();
          var tmp = new _Matrix["default"]().getInverse(this.camera.matrix);
          this.camera.matrix.identity();
          this.camera.applyMatrix(tmp);
          this.camera.updateMatrix();
          this.camera.updateMatrixWorld();
          this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld);
        } else {
          var _event$matrix$decompo = event.matrix.decomposedValue,
              position = _event$matrix$decompo.position,
              quaternion = _event$matrix$decompo.quaternion,
              scale = _event$matrix$decompo.scale;
          translateMatrix.makeTranslation.apply(translateMatrix, _toConsumableArray(position.toArray()));
          rotationMatrix.makeRotationFromQuaternion(quaternion);
          entityObject.matrix.multiply(translateMatrix);
          entityObject.matrix.multiply(rotationMatrix);
          entityObject.matrixAutoUpdate = false;
          entityObject.updateMatrixWorld(true);
        }

        if (entity.uri !== 'unknown') {
          this.notify('trackmove', event);
          entity.notify('trackmove', event);
        }
      }
      /**
       * @ignore
       * @method onTrackEnd
       * @memberof LetseeEngine.renderer
       * @param  {EntityEvent} event
       */

    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(event) {
        var target = event.target;
        target.track = false;
        this.removeTarget(target);

        if (target.uri !== 'unknown') {
          this.notify('trackend', event);
          target.notify('trackend', event);
        }
      }
    }, {
      key: "count",
      get: function get() {
        return Object.keys(this.targets).length;
      }
    }]);

    return ObjectTracker;
  }(_EntityObserver2["default"]);

  var objectTracker = new ObjectTracker();
  _exports.objectTracker = objectTracker;
});

/***/ }),

/***/ "./libs/VideoManager.js":
/*!******************************!*\
  !*** ./libs/VideoManager.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../vendor/adapter_no_edge */ "./vendor/adapter_no_edge.js"), __webpack_require__(/*! ../Screen */ "./Screen.js"), __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../observers/observer/LetseeObserver */ "./observers/observer/LetseeObserver.js"), __webpack_require__(/*! ./MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../Context */ "./Context.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _adapter_no_edge, _Screen, _Util, _LetseeObserver2, _MessageTypes, _Context) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _adapter_no_edge = _interopRequireDefault(_adapter_no_edge);
  _Screen = _interopRequireDefault(_Screen);
  _LetseeObserver2 = _interopRequireDefault(_LetseeObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import * as Message from './MessageTypes';
  // import {VIDEO_EVENT} from './MessageTypes';
  // import LetseeEvent from './LetseeEvent';
  // import VideoObserver from '../observers/observer/VideoObserver';
  var instance;

  var _container = document.createElement('div');

  var _videoElement = document.createElement('video');

  var _sceneCanvas = document.createElement('canvas');

  var _screenWidth;

  var _screenHeight;

  var _angle = 0;

  var _screenAspectRatio;

  var _type = null;
  var _browser = 'unknown';
  var _os = 'unknown';
  var _videoAttached = false; // eslint-disable-line

  var _isPortrait = true; // eslint-disable-line

  var deviceList = [];
  var isFirstCameraInit = true; // 초기 카메라 Init 시에

  /*
  const _constraints = () => {
    return {
      video: {
        facingMode: 'environment',
        width: {
          min: 1024,
          ideal: 1280,
          max: 1920
        },
        height: {
          min: 576,
          ideal: 720,
          max: 1080
        }
      },
      audio: false
    };
  };
  */

  var getUserMediaConstraints = function getUserMediaConstraints(src) {
    var constraints = {};
    constraints.audio = false;
    constraints.video = {};

    if (src === 'environment') {
      constraints.video.facingMode = 'environment';
      /**
       * 후면 카메라의 디바이스 장치에 대한 예외 출력. (Exception about front-back camera device)
       * || 구문 이후로 추가하여 추가적인 Label 등록이 가능. (Add Label using || syntax for add exception device)
       * s10 : camera2 0, facing back
       */

      var exceptionDevices = deviceList.filter(function (device) {
        return device.label === 'camera2 0, facing back' || device.label === 'additional ....';
      });
      console.log('[[exception device]]');
      console.warn(exceptionDevices);

      if (exceptionDevices.length >= 1) {
        constraints.video.deviceId = exceptionDevices[0].deviceId;
      }
    } else if (src === 'user') {
      constraints.video.facingMode = 'user';
    } else {
      constraints.video.deviceId = src;
    }

    constraints.video.width = {};
    constraints.video.width.min = 1024;
    constraints.video.width.ideal = 1280;
    constraints.video.width.max = 1920;
    constraints.video.height = {};
    constraints.video.height.min = 576;
    constraints.video.height.ideal = 720;
    constraints.video.height.max = 1080;
    console.log('[[constraints]]');
    console.warn(constraints);
    return constraints;
  }; // TEST
  // let a = navigator.mediaDevices.enumerateDevices();
  // a.then((devices) => {
  // 	console.log(devices.length);
  // 	devices.forEach(_d => {
  // 		console.log(_d.deviceId, _d.kind, _d.label);
  // 	})
  // });
  // TEST


  var getMedia = function getMedia(constraints) {
    if (window.stream) {
      window.stream.getTracks().forEach(function (track) {
        track.stop();
      });
    }

    return new Promise(function (resolve, reject) {
      navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {
        resolve(stream);
      })["catch"](function (e) {
        reject(e);
      });
    });
  };

  var checkCamera = function checkCamera(devices) {
    return new Promise(function (resolve, reject) {
      var hasWebcam = false;
      deviceList = [];
      devices.forEach(function (device) {
        if (device.kind === 'videoinput') {
          hasWebcam = true;
          deviceList.push({
            deviceId: device.deviceId,
            label: device.label
          });
        }
      });

      if (!hasWebcam) {
        reject('No videoInput Stream');
      } else {
        if (isFirstCameraInit) {
          resolve(getUserMediaConstraints('environment'));
          isFirstCameraInit = false;
        }
      }
    });
  };

  var gotStream = function gotStream(mediaStream) {
    _videoElement.srcObject = mediaStream;
    _videoAttached = true;
  };
  /**
   * remove current video stream, and connect new stream.
   */


  var removeStream = function removeStream(mediaStream) {
    if (window.stream) {
      window.stream.getTracks().forEach(function (track) {
        track.stop();
      });
    }

    window.stream = mediaStream;
    _videoElement.srcObject = null;
    _videoAttached = false;
  };

  var _initCameraContainer = function _initCameraContainer(zIndex, zIndexIncrement) {
    _videoElement.setAttribute('playsinline', true);

    _videoElement.autoplay = true;
    _videoElement.muted = true;
    _videoElement.style.position = 'fixed';
    _videoElement.style.top = '0px';
    _videoElement.style.left = '0px';
    _videoElement.style.zIndex = '-100';
    _videoElement.style.width = '100%';
    _videoElement.style.border = '1px solid pink';
    _videoElement.style.visibility = 'hidden'; // _videoElement.style.objectFit = 'cover';
    // // _videoElement.style.width = '100vw';
    // _videoElement.style.height = '100vh';

    _sceneCanvas.style.position = 'fixed';
    _sceneCanvas.style.top = '0px';
    _sceneCanvas.style.left = '0px';
    _sceneCanvas.style.zIndex = '0';
    _sceneCanvas.style.border = '1px solid blue';

    _container.appendChild(_videoElement);

    _container.appendChild(_sceneCanvas);

    _container.style.position = 'fixed';
    _container.style.top = '0px';
    _container.style.right = '0px';
    _container.style.bottom = '0px';
    _container.style.left = '0px';
    _container.style.width = '100%';
    _container.style.height = '100%';
    _container.style.zIndex = zIndex;
    _container.style.border = '1px solid red';
    document.body.style.margin = '0px';
    document.body.style.padding = '0px';
    document.body.appendChild(_container);
  };

  var _attachSourceToVideo = function _attachSourceToVideo(videoUrl) {
    var sourceMP4 = document.createElement('source');
    sourceMP4.src = videoUrl;
    sourceMP4.type = 'video/mp4';

    _videoElement.appendChild(sourceMP4);

    _videoElement.addEventListener('canplay', function () {
      return true;
    });
  }; // const _updateCurrentScreenSize = () => {
  //   _screenWidth = Math.floor((this.isPortrait) ? this.screenWidth : this.screenHeight);
  //   _screenHeight = Math.floor((this.isPortrait) ? this.screenHeight : this.screenWidth);
  // };


  var _setAspectRatio = function _setAspectRatio() {
    var angle = typeof screen.orientation === 'undefined' || !screen.orientation ? window.orientation : screen.orientation.angle; // eslint-disable-line

    var type = typeof screen.orientation === 'undefined' || !screen.orientation ? 'safari' : 'chrome';
    _angle = angle;
    _type = type;

    if ((_angle === 90 || _angle === -90 || _angle === 270 || _angle === -270) && _type !== 'chrome') {
      _screenWidth = screen.height;
      _screenHeight = screen.width;
    } else {
      _screenWidth = screen.width;
      _screenHeight = screen.height;
    }

    _screenAspectRatio = _screenWidth / _screenHeight;
    _isPortrait = _screenAspectRatio <= 1;
    _sceneCanvas.width = _screenWidth;
    _sceneCanvas.height = _screenHeight;
    _sceneCanvas.style.width = "".concat(_screenWidth, "px");
    _sceneCanvas.style.height = "".concat(_screenHeight, "px");
    _sceneCanvas.style.transform = 'translateZ(0)';
    return {
      width: _screenWidth,
      height: _screenHeight
    };
  };

  var _initCanvas = function _initCanvas() {
    return _setAspectRatio();
  };

  var videoManager =
  /*#__PURE__*/
  function (_LetseeObserver) {
    _inherits(videoManager, _LetseeObserver);

    function videoManager() {
      var _this;

      _classCallCheck(this, videoManager);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(videoManager).call(this));
      if (instance) return _possibleConstructorReturn(_this, instance);

      _videoElement.addEventListener('loadeddata', function () {
        // this.dispatch(Message.EVENT_APP_STATUS, {
        _this.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
          status: 'success',
          code: 202,
          message: 'Video start'
        });
      });

      _this.container = _container;
      _this.containerId = _Context.context.videoContainerId;

      _this.container.setAttribute('id', _this.containerId);

      instance = _assertThisInitialized(_this); // update deviceList when device connection state changed.

      navigator.mediaDevices.addEventListener('devicechange', function (e) {
        navigator.mediaDevices.enumerateDevices().then(function (devices) {
          deviceList = [];
          devices.forEach(function (device) {
            if (device.kind === 'videoinput') {
              deviceList.push({
                deviceId: device.deviceId,
                label: device.label
              });
            }
          });
        })["catch"](function (err) {
          console.log(err);
        });
      });
      return _this;
    }

    _createClass(videoManager, [{
      key: "init",
      value: function init(zIndex, zIndexIncrement) {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          _initCameraContainer(zIndex, zIndexIncrement);

          if (_this2.videoUrl) {
            _attachSourceToVideo(_this2.videoUrl);
          } else {
            _this2.getAttachedVideo().then(function () {
              // this.dispatch(Message.EVENT_APP_STATUS, {
              _this2.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
                code: 200,
                message: 'Camera initialize start'
              });

              return navigator.mediaDevices.enumerateDevices();
            }).then(checkCamera).then(function (constraints) {
              return getMedia(constraints);
            }).then(function (stream) {
              removeStream(stream);
              gotStream(stream); // this.dispatch(Message.EVENT_APP_STATUS, {

              _this2.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
                code: 201,
                message: 'Camera initialize done'
              });

              var _screenSize = _initCanvas();

              _this2.screen = new _Screen["default"](_screenSize.width, _screenSize.height, _this2);
              resolve();
            })["catch"](function (error) {
              reject(error);
            });
          }
        });
      }
    }, {
      key: "getAttachedVideo",
      value: function getAttachedVideo() {
        var _this3 = this;

        return new Promise(function (resolve, reject) {
          var browserInfo = (0, _Util.getBrowserInfo)();
          var browserName = browserInfo.name.toLowerCase();
          var osName = browserInfo.osName.toLowerCase();

          if (browserName.match(/chrome/i)) {
            _browser = 'chrome';
          } else if (browserName.match(/safari/i)) {
            _browser = 'safari';
          } else {
            _browser = 'unknown';
          }

          if (osName.match(/ios/i)) {
            _os = 'ios';
          } else if (osName.match(/android/i)) {
            _os = 'android';
          } else {
            _os = 'unknown';
          }

          if (_os === 'ios' && _browser !== 'safari') {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 101,
              message: 'Please use safari with ios'
            });

            reject('Please use safari with ios');
          }

          if (browserInfo.isWebRTCSupported === false) {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 102,
              message: 'Unsupported browser'
            });

            reject('Please use Chrome, Firefox, iOS 11, Android 5 or higher, Safari 11 or higher');
          }

          if (!browserInfo.isMobileDevice) {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 104,
              message: 'No mobile device detected'
            });

            reject('No mobile device');
          }

          if (screen.height * screen.width > 921600) {
            // this.dispatch(Message.EVENT_APP_STATUS, {
            _this3.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              status: 'error',
              code: 106,
              message: 'Screen size is too large.'
            });

            reject('Screen size is too large');
          }

          resolve();
        });
      }
    }, {
      key: "orientationChange",
      value: function orientationChange() {
        _setAspectRatio();
      }
    }, {
      key: "setVideoSource",
      value: function setVideoSource(src) {
        if (/[^\s]+\.mp4\b/.test(src)) {
          _attachSourceToVideo(src);
        } else {
          var constraints = getUserMediaConstraints(src);
          this.reconnectMediaStream(constraints);
        }
      }
    }, {
      key: "getSourceDeviceList",
      value: function getSourceDeviceList() {
        return deviceList;
      } // Fixed getter/setter

    }, {
      key: "reconnectMediaStream",

      /*
      setFullscreen() {
        console.log('setFullscreen function is called.');
        // console.log(this.container);
         if (this.container !== undefined) {
          if (this.container.requestFullscreen) {
            this.container.requestFullscreen().then((e) => {
              // console.log(this.videoElement);
              // console.log(this.canvasElement);
               this.reconnectMediaStream();
               this.canvasElement.width = window.innerWidth;
              this.canvasElement.height = window.innerHeight;
             }).catch(err => {
              console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
           } else if (this.container.mozRequestFullScreen) {
            this.container.mozRequestFullScreen();
          } else if (this.container.webkitRequestFullscreen) {
            this.container.webkitRequestFullscreen();
          } else if (this.container.msRequestFullscreen) {
            this.container.msRequestFullscreen();
          }
        }
      };
      */
      // constraint를 이용하여 미디어 Stream을 얻어오는 메서드.
      // get mediaStream using constraints.
      value: function reconnectMediaStream(constraints) {
        var _this4 = this;

        return new Promise(function (resolve, reject) {
          getMedia(constraints).then(function (stream) {
            removeStream();
            window.stream = stream;
            gotStream(stream);

            _this4.notify(_MessageTypes.LETSEE_EVENT.ON_STATUS, {
              code: 201,
              message: 'Camera initialize done'
            });

            _initCanvas();

            resolve();
          })["catch"](function (error) {
            reject(error);
          });
        });
      }
    }, {
      key: "screenInfo",
      get: function get() {
        return {
          width: _screenWidth,
          height: _screenHeight,
          angle: _angle,
          screenAspectRatio: _screenAspectRatio
        };
      }
    }, {
      key: "videoElement",
      get: function get() {
        return _videoElement;
      }
    }, {
      key: "canvasElement",
      get: function get() {
        return _sceneCanvas;
      }
    }]);

    return videoManager;
  }(_LetseeObserver2["default"]);

  var _default = videoManager;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./math/Euler.js":
/*!***********************!*\
  !*** ./math/Euler.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Matrix4 */ "./math/Matrix4.js"), __webpack_require__(/*! ./Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Quaternion, _Vector, _Matrix, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Quaternion = _interopRequireDefault(_Quaternion);
  _Vector = _interopRequireDefault(_Vector);
  _Matrix = _interopRequireDefault(_Matrix);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  /**
   * @typedef {'XYZ'|'YZX'|'ZXY'|'XZY'|'YXZ'|'ZYX'} EulerRotationOrder
   */
  // type EulerRotationOrder = 'XYZ' | 'YZX' | 'ZXY' | 'XZY' | 'YXZ' | 'ZYX';

  /**
   * By default this is an empty function, however it can be set via
   * {@link Euler#onChange}. It getse called after changing the {@link Euler#x},
   * {@link Euler#y}, {@link Euler#z}, or {@link Euler#order} properties, and
   * also after calling most setter functions.
   * @member {Function} onChangeCallback
   * @memberof Euler#
   * @default function() { }
   */
  var onChangeCallback = function onChangeCallback() {};

  var _isEuler = true;
  var DefaultOrder = 'XYZ';
  var RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
  /**
   * @class Euler
   * @classdesc
   * A class representing
   * [Euler Angles](http://en.wikipedia.org/wiki/Euler_angles). Euler angles
   * describe a rotational transformation by rotating an object on its various
   * axes in specified amounts per axis, and a specified axis order.
   * @example
   * var a = new Euler(0, 1, 1.57, 'XYZ');
   * var b = new Vector3(1, 0, 1);
   * b.applyEuler(a);
   * @param {number} [x=0] The angle of the x axis in radians.
   * @param {number} [y=0] The angle of the y axis in radians.
   * @param {number} [z=0] The angle of the z axis in radians.
   * @param {EulerRotationOrder} [order='XYZ'] A string representing the order that the rotations are applied. (Must be upper case).
   */

  var Euler =
  /*#__PURE__*/
  function () {
    function Euler() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultOrder;

      _classCallCheck(this, Euler);

      // constants for optimisation
      this.setFromQuaternionQ;
      this.reorderQ;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    /**
     * The current value of the x component. If this is changed,
     * {@link Euler#onChangeCallback} will be called.
     * @member {number} x
     * @memberof Euler#
     * @default 0
     */


    _createClass(Euler, [{
      key: "set",

      /**
       * Sets the angles of this euler transform and optionally the
       * {@link Euler#order} and then call {@link Euler#onChangeCallback}.
       * @method set
       * @memberof Euler.prototype
       * @param {number} x The angle of the x axis in radians.
       * @param {number} y The angle of the y axis in radians.
       * @param {number} z The angle of the z axis in radians.
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       */
      value: function set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        onChangeCallback();
        return this;
      }
      /**
       * Returns a new {@link Euler} with the same parameters as this one.
       * @method clone
       * @memberof Euler.prototype
       * @return {Euler}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Euler(this._x, this._y, this._z, this._order);
      }
      /**
       * Copies value of `euler` to this euler.
       * @method copy
       * @memberof Euler.prototype
       * @param  {Euler} e
       */

    }, {
      key: "copy",
      value: function copy(e) {
        this._x = e.x;
        this._y = e.y;
        this._z = e.z;
        this._order = e.order;
        onChangeCallback();
        return this;
      }
      /**
       * Sets the angles of this euler transform from a pure rotation matrix based
       * on the orientation specified by `order`.
       * @method setFromRotationMatrix
       * @memberof Euler.prototype
       * @param {Matrix4} m A {@link Matrix4} of which the upper 3x3 of matrix is a pure [rotation matrix](https://en.wikipedia.org/wiki/Rotation_matrix) (i.e. unscaled).
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       * @param {boolean} [update=true] Whether to call {@link Euler#onChangeCallback} after applying the matrix.
       */

    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m, order) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;

        var _te = _slicedToArray(te, 12),
            m11 = _te[0],
            m21 = _te[1],
            m31 = _te[2],
            m41 = _te[3],
            m12 = _te[4],
            m22 = _te[5],
            m32 = _te[6],
            m42 = _te[7],
            m13 = _te[8],
            m23 = _te[9],
            m33 = _te[10],
            m43 = _te[11];

        order = order || this._order;

        if (order === 'XYZ') {
          this._y = Math.asin((0, _Math.clamp)(m13, -1, 1));

          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-(0, _Math.clamp)(m23, -1, 1));

          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin((0, _Math.clamp)(m32, -1, 1));

          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-(0, _Math.clamp)(m31, -1, 1));

          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin((0, _Math.clamp)(m21, -1, 1));

          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-(0, _Math.clamp)(m12, -1, 1));

          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          console.warn("Euler: .setFromRotationMatrix() given unsupported order: ".concat(order));
        }

        this._order = order;

        if (update !== false) {
          onChangeCallback();
        }

        return this;
      }
      /**
       * Sets the angles of this euler transform from a normalized quaternion based
       * on the orientation specified by `order`.
       * @method setFromQuaternion
       * @memberof Euler.prototype
       * @param {Quaternion} q A normalized quaternion.
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       * @param {boolean} [update=true] Whether to call {@link Euler#onChangeCallback} after applying the matrix.
       */

    }, {
      key: "setFromQuaternion",
      value: function setFromQuaternion(q, order) {
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (typeof this.setFromQuaternionQ === 'undefined') {
          this.setFromQuaternionQ = new _Matrix["default"]();
        }

        this.setFromQuaternionQ.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(this.setFromQuaternionQ, order, update);
      }
      /**
       * Sets the {@link Euler#x}, {@link Euler#y}, and {@link Euler#z}, and
       * optionally update the {@link Euler#order}. {@link Euler#onChangeCallback}
       * is called after these changes are made.
       * @method setFromVector3
       * @memberof Euler.prototype
       * @param {Vector3} v
       * @param {EulerRotationOrder} [order] A string representing the order that the rotations are applied.
       */

    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
        return this.set(v.x, v.y, v.z, order);
      }
      /**
       * Resets the euler angle with a `newOrder` by creating a quaternion from this
       * euler angle and then setting this euler angle with the quaternion and the
       * `newOrder`.
       *
       * _WARNING_: this discards revolution information.
       * @method reorder
       * @memberof Euler.prototype
       * @param  {EulerRotationOrder} [newOrder]
       */

    }, {
      key: "reorder",
      value: function reorder(newOrder) {
        if (typeof this.reorderQ === 'undefined') {
          this.reorderQ = new _Quaternion["default"]();
        }

        this.reorderQ.setFromEuler(this);
        return this.setFromQuaternion(this.reorderQ, newOrder);
      }
      /**
       * Checks for strict equality of this euler and `euler`.
       * @method equals
       * @memberof Euler.prototype
       * @param  {Euler} euler
       * @return {Boolean}
       */

    }, {
      key: "equals",
      value: function equals(euler) {
        return euler.x === this._x && euler.y === this._y && euler.z === this._z && euler.order === this._order;
      }
      /**
       * Assigns this euler's {@link Euler#x} angle to `array[0]`. Assigns this
       * euler's {@link Euler#y} angle to `array[1]`. Assigns this euler's
       * {@link Euler#z} angle to `array[2]`. Optionally assigns this euler's
       * {@link Euler#order} to `array[3]`.
       * @method fromArray
       * @memberof Euler.prototype
       * @param  {Array} array Array of length 3 or 4. The optional 4th argument corresponds to {@link Euler#order}.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];

        if (array[3] !== undefined && array[3] !== null) {
          this._order = array[3];
        }

        onChangeCallback();
        return this;
      }
      /**
       * Returns an array of the form `[x, y, z, order]`.
       * @method toArray
       * @memberof Euler.prototype
       * @param  {Array} [array=[]] Array to store the euler in.
       * @param  {number} [offset=0] Offset in the array.
       * @return {Array}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      }
      /**
       * Returns the euler's {@link Euler#x}, {@link Euler#y}, and {@link Euler#z}
       * properties as a {@link Vector3}.
       * @method toVector3
       * @memberof Euler.prototype
       * @param  {Vector3} [optionalResult]
       * @return {Vector3}
       */

    }, {
      key: "toVector3",
      value: function toVector3(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        }

        return new _Vector["default"](this._x, this._y, this._z);
      }
      /**
       * Sets the value of the {@link Euler#onChangeCallback} function.
       * @method onChange
       * @memberof Euler.prototype
       * @param {Function} callback
       */

    }, {
      key: "onChange",
      value: function onChange(callback) {
        onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        onChangeCallback();
      }
      /**
       * The current value of the y component. If this is changed,
       * {@link Euler#onChangeCallback} will be called.
       * @member {number} y
       * @memberof Euler#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        onChangeCallback();
      }
      /**
       * The current value of the z component. If this is changed,
       * {@link Euler#onChangeCallback} will be called.
       * @member {number} z
       * @memberof Euler#
       * @default 0
       */

    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        onChangeCallback();
      }
    }, {
      key: "isEuler",
      get: function get() {
        return _isEuler;
      }
      /**
       * The order in which to apply rotations. Default is `'XYZ'`, which means
       * that the object will first be rotated around its X axis, then its Y axis,
       * and finally its Z axis. Other possibilities are: `'YZX'`, `'ZXY'`,
       * `'XZY'`, `'YXZ'`, and `'ZYX'`. These must be in upper case.
       *
       * Letsee uses _intrinsic_ (Tait-Bryan) ordering, also known as this._yaw_,
       * _pitch_, and _roll_. This means that rotations are performed with respect
       * to the _local_ coordinate system. That is, for order `'XYZ'`, the rotation
       * is first around world-X, then around local-Y (which may now be different
       * from the world Y-axis), then local-Z (which may be different from the
       * world Z-axis).
       *
       * Some implementations may use _extrinsic_ (proper) ordering, in which case
       * rotations are performed with respect to the _world_ coordinate system, so
       * that for order `'XYZ'`, the rotations are around world-X, world-Y, and
       * world-Z.
       *
       * Converting between the two types is relatively straightforward, you just
       * need to reverse the order and the rotation, so that an intrinsic
       * (Letsee) Euler rotation of angles `a`, `b`, `c` about `'XYZ'` will be
       * equivalent to an extrinsic Euler rotation of angles `c`, `b`, `a` abbout
       * `'ZYX'`.
       *
       * If this is changed, {@link Euler#onChangeCallback} will be called.
       * @member {EulerRotationOrder} order
       * @memberof Euler#
       * @default 'XYZ'
       */

    }, {
      key: "order",
      get: function get() {
        return this._order;
      },
      set: function set(value) {
        this._order = value;
        onChangeCallback();
      }
    }]);

    return Euler;
  }();

  _exports["default"] = Euler;
});

/***/ }),

/***/ "./math/Math.js":
/*!**********************!*\
  !*** ./math/Math.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Vector2 */ "./math/Vector2.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Vector2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = _exports.nextPowerOfTwo = _exports.nearestPowerOfTwo = _exports.isPowerOfTwo = _exports.randFloatSpread = _exports.randFloat = _exports.randInt = _exports.smootherstep = _exports.smoothstep = _exports.lerp = _exports.mapLinear = _exports.euclideanModulo = _exports.clamp = _exports.worldToScreen = _exports.radToDeg = _exports.degToRad = _exports.RAD2DEG = _exports.DEG2RAD = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Vector2 = _interopRequireDefault(_Vector2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  var DEG2RAD = Math.PI / 180;
  _exports.DEG2RAD = DEG2RAD;
  var RAD2DEG = 180 / Math.PI;
  /**
   * Converts degress to radians.
   * @method degToRad
   * @memberof module:Math
   * @param  {number} degrees
   * @return {number}
   */

  _exports.RAD2DEG = RAD2DEG;

  var degToRad = function degToRad(degrees) {
    return degrees * DEG2RAD;
  };
  /**
   * Converts radians to degrees.
   * @method radToDeg
   * @memberof module:Math
   * @param  {number} radians
   * @return {number}
   */


  _exports.degToRad = degToRad;

  var radToDeg = function radToDeg(radians) {
    return radians * RAD2DEG;
  };
  /**
   * Vector3 값을 현재 Screen 내에 Vector2 값으로 변환
   * @memberof module:Math
   * @method worldToScreen
   * @param {Vector3} position
   * @return {Vector2}
   */


  _exports.radToDeg = radToDeg;

  var worldToScreen = function worldToScreen(position) {
    var camera = LetseeEngine.camera;

    if (camera) {
      var v = position.clone();
      v.project(camera);
      return new _Vector2["default"]().set((v.x + 1) * (screen.width / 2), (-v.y + 1) * (screen.height / 2));
    }

    console.error('Camera is not initialized');
    return null;
  };
  /**
   * Clamps the `value` to be between `min` and `max`.
   * @method clamp
   * @memberof module:Util
   * @param  {number} value Value to be clamped.
   * @param  {number} min   Minimum value.
   * @param  {number} max   Maximum value.
   * @return {number}
   */


  _exports.worldToScreen = worldToScreen;

  var clamp = function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  };
  /**
   * Compute the Euclidean module of `m % n`, that is:
   * ```
   * ((n % m) + m) % m
   * ```
   * @method euclideanModulo
   * @memberof module:Util
   * @param  {number} n
   * @param  {number} m
   * @return {number}
   */
  // https://en.wikipedia.org/wiki/Modulo_operation


  _exports.clamp = clamp;

  var euclideanModulo = function euclideanModulo(n, m) {
    return (n % m + m) % m;
  };
  /**
   * Linear mapping of `x` from range `[a1, a2]` to range `[b1, b2]`.
   * @method mapLinear
   * @memberof module:Util
   * @param  {number} x  Value to be mapped.
   * @param  {number} a1 Minimum value for range A.
   * @param  {number} a2 Maximum value for range A.
   * @param  {number} b1 Minimum value for range B.
   * @param  {number} b2 Maximum value for range B.
   * @return {number}
   */


  _exports.euclideanModulo = euclideanModulo;

  var mapLinear = function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  };
  /**
   * Returns a value
   * [linearly interpolated](https://en.wikipedia.org/wiki/Linear_interpolation)
   * from two known points based on the given interval - `t = 0` will return `x`
   * and `t = 1` will return `y`.
   * @method lerp
   * @memberof module:Util
   * @param  {number} x Start point.
   * @param  {number} y End point.
   * @param  {number} t Interpolation factor in the closed inverval `[0, 1]`.
   * @return {number}
   */


  _exports.mapLinear = mapLinear;

  var lerp = function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  };
  /**
   * Returns a value between `0` and `1` that represents the percentage that `x`
   * has moved between `min` and `max`, but smoothed or slowed down the closer `x`
   * is to the `min` and `max`. See
   * [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for details.
   * @method smoothstep
   * @memberof module:Util
   * @param  {number} x   The value to evaluate based on its position between `min` and `max`.
   * @param  {number} min Any `x` value below `min` will be `0`.
   * @param  {number} max Any `x` value above `max` will be `1`.
   * @return {number}
   */


  _exports.lerp = lerp;

  var smoothstep = function smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  };
  /**
   * Returns a value between `0` and `1`. A
   * [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
   * that has zero 1st and 2nd order derivatives at `x = 0` and `x = 1`.
   * @method smootherstep
   * @memberof module:Util
   * @param  {number} x   The value to evaluate based on its position between `min` and `max`.
   * @param  {number} min Any `x` value below `min` will be `0`.
   * @param  {number} max Any `x` value above `max` will be `1`.
   * @return {number}
   */


  _exports.smoothstep = smoothstep;

  var smootherstep = function smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  };
  /**
   * Random integer in the interval `low` to `high`.
   * @method randInt
   * @memberof module:Util
   * @param  {number} low
   * @param  {number} high
   * @return {number}
   */


  _exports.smootherstep = smootherstep;

  var randInt = function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  };
  /**
   * Random float in the interval `low` to `high`.
   * @method randFloat
   * @memberof module:Util
   * @param  {number} low
   * @param  {number} high
   * @return {number}
   */


  _exports.randInt = randInt;

  var randFloat = function randFloat(low, high) {
    return low + Math.random() * (high - low);
  };
  /**
   * Random float in the interval `-range/2` to `range/2`.
   * @method randFloatSpread
   * @memberof module:Util
   * @param  {number} range
   * @return {number}
   */


  _exports.randFloat = randFloat;

  var randFloatSpread = function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  };
  /**
   * Returns `true` if `value` is a power of 2.
   * @method isPowerOfTwo
   * @memberof module:Util
   * @param  {number}  value
   * @return {Boolean}
   */


  _exports.randFloatSpread = randFloatSpread;

  var isPowerOfTwo = function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  };
  /**
   * Return the nearest power of 2 to a given number `value`.
   * @method nearestPowerOfTwo
   * @memberof module:Util
   * @param  {number} value
   * @return {number}
   */


  _exports.isPowerOfTwo = isPowerOfTwo;

  var nearestPowerOfTwo = function nearestPowerOfTwo(value) {
    return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
  };
  /**
   * Return the nearest power of 2 that is bigger than `value`.
   * @method nextPowerOfTwo
   * @memberof module:Util
   * @param  {number} value
   * @return {number}
   */


  _exports.nearestPowerOfTwo = nearestPowerOfTwo;

  var nextPowerOfTwo = function nextPowerOfTwo(value) {
    var result = value;
    result -= 1;
    result |= result >> 1;
    result |= result >> 2;
    result |= result >> 4;
    result |= result >> 8;
    result |= result >> 16;
    result += 1;
    return result;
  };
  /**
   * An object with several utility functions.
   * @module Util
   * @author JooHyun Lee (ljh@letsee.io)
   * @since 2016. 03. 17.
   * @ignore
   */


  _exports.nextPowerOfTwo = nextPowerOfTwo;
  var MathUtil = {
    degToRad: degToRad,
    radToDeg: radToDeg,
    worldToScreen: worldToScreen,
    clamp: clamp,
    euclideanModulo: euclideanModulo,
    mapLinear: mapLinear,
    lerp: lerp,
    smoothstep: smoothstep,
    smootherstep: smootherstep,
    randInt: randInt,
    randFloat: randFloat,
    randFloatSpread: randFloatSpread,
    isPowerOfTwo: isPowerOfTwo,
    nearestPowerOfTwo: nearestPowerOfTwo,
    nextPowerOfTwo: nextPowerOfTwo
  };
  window.Math.degToRad = degToRad;
  window.Math.radToDeg = radToDeg;
  window.Math.worldToScreen = worldToScreen;
  var _default = MathUtil;
  _exports["default"] = _default;
});

/***/ }),

/***/ "./math/Matrix3.js":
/*!*************************!*\
  !*** ./math/Matrix3.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Matrix4 from './Matrix4';

  /**
   * A
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)
   * list of matrix values.
   * @member {Float32Array} elements
   * @memberof Matrix3#
   * @default [
   * 1, 0, 0,
   * 0, 1, 0,
   * 0, 0, 1
   * ]
   */
  // let this._elements;

  /**
   * Used to check whether this or derived classes are {@link Matrix3}s. You
   * should not change this, as it is used internally for optimisation.
   * @property isMatrix3
   * @type {Boolean}
   * @default true
   */
  var _isMatrix3 = true;
  /**
   * @class Matrix3
   * @classdesc
   * A class representing a 3x3
   * [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)).
   * @example
   * var m = new Matrix3();
   */

  var Matrix3 =
  /*#__PURE__*/
  function () {
    function Matrix3() {
      _classCallCheck(this, Matrix3);

      this._elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }

    _createClass(Matrix3, [{
      key: "set",

      /**
       * Sets the 3x3 matrix values to the given
       * [row-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order)
       * sequence of values.
       * @method set
       * @memberof Matrix3.prototype
       * @param {number} n11 Value to put in row 1, col 1.
       * @param {number} n12 Value to put in row 1, col 2.
       * @param {number} n13 Value to put in row 1, col 3.
       * @param {number} n21 Value to put in row 2, col 1.
       * @param {number} n22 Value to put in row 2, col 2.
       * @param {number} n23 Value to put in row 2, col 3.
       * @param {number} n31 Value to put in row 3, col 1.
       * @param {number} n32 Value to put in row 3, col 2.
       * @param {number} n33 Value to put in row 3, col 3.
       */
      value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this._elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      /**
       * Resets this matrix to the 3x3 identity matrix:
       * ```
       * 1 0 0
       * 0 1 0
       * 0 0 1
       * ```
       * @method identity
       * @memberof Matrix3.prototype
       */

    }, {
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      /**
       * Creates a new matrix with identical elements to this one.
       * @method clone
       * @memberof Matrix3.prototype
       * @return {Matrix3}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Matrix3().fromArray(this._elements);
      }
      /**
       * Copies the elements of matrix `m` into this matrix.
       * @method copy
       * @memberof Matrix3.prototype
       * @param  {Matrix3} m
       */

    }, {
      key: "copy",
      value: function copy(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      }
      /**
       * Set this matrix to the upper 3x3 matrix of the {@link Matrix4} `m`.
       * @method setFromMatrix4
       * @memberof Matrix3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrix4",
      value: function setFromMatrix4(m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
      /**
       * Multiplies (applies) this matrix to every 3D vector in the `attribute`.
       * @method applyToBufferAttribute
       * @memberof Matrix3.prototype
       * @param  {BufferAttribute} attribute An attribute of floats that represet 3D vectors.
       * @return {BufferAttribute}
       */

    }, {
      key: "applyToBufferAttribute",
      value: function applyToBufferAttribute(attribute) {
        var v1 = new _Vector["default"]();

        for (var i = 0, l = attribute.count; i < l; i += 1) {
          v1.x = attribute.getX(i);
          v1.y = attribute.getY(i);
          v1.z = attribute.getZ(i);
          v1.applyMatrix3(this);
          attribute.setXYZ(i, v1.x, v1.y, v1.z);
        }

        return attribute;
      }
      /**
       * Multiplies every component of the matrix by the scalar value `s`.
       * @method multiplyScalar
       * @memberof Matrix3.prototype
       * @param {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this._elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      /**
       * Computes and returns the
       * [determinant](https://en.wikipedia.org/wiki/Determinant) of this matrix.
       * @method determinant
       * @memberof Matrix3.prototype
       * @return {number}
       */

    }, {
      key: "determinant",
      value: function determinant() {
        var te = this._elements;
        var a = te[0];
        var b = te[1];
        var c = te[2];
        var d = te[3];
        var e = te[4];
        var f = te[5];
        var g = te[6];
        var h = te[7];
        var i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      }
      /**
       * Set this matrix to the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of the passed
       * matrix `matrix`, using the
       * [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
       * If `throwOnDegenerate` is not set and the matrix is not invertible, set
       * this to the 3x3 identity matrix.
       * @method getInverse
       * @memberof Matrix3.prototype
       * @param  {Matrix3} matrix The matrix to take the inverse of.
       * @param  {boolean} [throwOnDegenerate=false] If true, throw an error if the matrix is degenerate (not invertible).
       */

    }, {
      key: "getInverse",
      value: function getInverse(matrix) {
        var throwOnDegenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var me = matrix.elements;
        var te = this._elements;
        var n11 = me[0];
        var n21 = me[1];
        var n31 = me[2];
        var n12 = me[3];
        var n22 = me[4];
        var n32 = me[5];
        var n13 = me[6];
        var n23 = me[7];
        var n33 = me[8];
        var t11 = n33 * n22 - n32 * n23;
        var t12 = n32 * n13 - n33 * n12;
        var t13 = n23 * n12 - n22 * n13;
        var det = n11 * t11 + n21 * t12 + n31 * t13;

        if (det === 0) {
          var msg = 'Matrix3.getInverse(): can\'t invert matrix, determinant is 0';

          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }

          return this.identity();
        }

        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix in place.
       * @method transpose
       * @memberof Matrix3.prototype
       */

    }, {
      key: "transpose",
      value: function transpose() {
        var tmp;
        var m = this._elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      }
      /**
       * Sets this matrix as the upper left 3x3 of the
       * [normal matrix](https://en.wikipedia.org/wiki/Normal_matrix) of the passed
       * `matrix4`. The normal matrix is the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix)
       * [transpose](https://en.wikipedia.org/wiki/Transpose) of the matrix
       * `matrix4`.
       * @method getNormalMatrix
       * @memberof Matrix3.prototype
       * @param {Matrix4} matrix4
       */

    }, {
      key: "getNormalMatrix",
      value: function getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix into the
       * supplied array, and returns itself unchanged.
       * @method transposeIntoArray
       * @memberof Matrix3.prototype
       * @param {Array} r Array to store the resulting vector in.
       */

    }, {
      key: "transposeIntoArray",
      value: function transposeIntoArray(r) {
        var m = this._elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      }
      /**
       * Sets the elements of this matrix based on an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method fromArray
       * @memberof Matrix3.prototype
       * @param  {Array} array The array to read the elements from.
       * @param  {number} [offset=0] Index of first element in the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var index = offset || 0;

        for (var i = 0; i < 9; i += 1) {
          this._elements[i] = array[i + index];
        }

        return this;
      }
      /**
       * Writes the elements of this matrix to an array in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method toArray
       * @memberof Matrix3.prototype
       * @param  {Array} [array=[]]  Array to store the resulting vector in. If not given a new array will be created.
       * @param  {number} [offset=0] Offset in the array at which to put the result.
       * @return {Array}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (array === undefined) {
          array = [];
        }

        var index = offset || 0;
        var te = this._elements;

        for (var i = 0; i < te.length; i += 1) {
          array[index + i] = te[i];
        }

        return array;
      }
    }, {
      key: "elements",
      get: function get() {
        return this._elements;
      }
    }, {
      key: "isMatrix3",
      get: function get() {
        return _isMatrix3;
      }
    }]);

    return Matrix3;
  }();

  _exports["default"] = Matrix3;
});

/***/ }),

/***/ "./math/Matrix4.js":
/*!*************************!*\
  !*** ./math/Matrix4.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js"), __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js"), __webpack_require__(/*! ./Math */ "./math/Math.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector, _Quaternion, _Math) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);
  _Quaternion = _interopRequireDefault(_Quaternion);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // constants for optimisation
  var extractRotationV;
  var lookAtX;
  var lookAtY;
  var lookAtZ;
  var decomposeV;
  var decomposeM;
  /**
   * A
   * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
   * list of matrix values.
   * @member {number[]} elements
   * @memberof Matrix4#
   * @default [
   * 1, 0, 0, 0,
   * 0, 1, 0, 0,
   * 0, 0, 1, 0,
   * 0, 0, 0, 1
   * ]
   */
  // let this.elements = [
  //   1, 0, 0, 0,
  //   0, 1, 0, 0,
  //   0, 0, 1, 0,
  //   0, 0, 0, 1
  // ];

  var onChangeCallback = function onChangeCallback() {};

  var _isMatrix4 = true;
  /**
   * @class Matrix4
   * @classdesc
   * A class representing a 4x4
   * [matrix](https://en.wikipedia.org/wiki/Matrix_(mathematics)). The most
   * common use of a 4x4 matrix in 3D computer graphics is as a
   * [transformation matrix](https://en.wikipedia.org/wiki/Transformation_matrix).
   * For an introduction to transformation matrices as used in WebGL, check out
   * this
   * [tutorial](http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices).
   * This allows a {@link Vector3} representing a point in 3D space to undergo
   * transformations such as translation, rotation, shear, scale, reflection,
   * orthogonal or perspective projection and so on, by being multiplied by the
   * matrix. This is known as _applying_ the matrix to the vector.
   *
   * Every {@link Object3D} has vendor associated {@link Matrix4}s:
   * * {@link Object3D#matrix}: this stores the local transform of the object.
   * * {@link Object3D#matrixWorld}: the global or world transform of the object. This is the objects transformation relative to its parent. If the object has no parent, then this is identical to the local transform.
   * * {@link Object3D#modelViewMatrix}: TODO.
   *
   * {@link Camera}s have two additional {@link Matrix4}s:
   * * {@link Camera#matrixWorldInverse}: The inverse of the {@link Object3D#matrixWorld} described above.
   * * {@link Camera#projectionMatrix}: TODO.
   */

  var Matrix4 =
  /*#__PURE__*/
  function () {
    function Matrix4() {
      _classCallCheck(this, Matrix4);

      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    } //
    // get elements() {
    //   return this.elements;
    // }


    _createClass(Matrix4, [{
      key: "set",

      /**
       * Set the {@link Matrix4#elements} of this matrix to the supplied row-major
       * values `n11`, `n12`, ..., `n44`.
       * @method set
       * @memberof Matrix4.prototype
       * @param {number} n11
       * @param {number} n12
       * @param {number} n13
       * @param {number} n14
       * @param {number} n21
       * @param {number} n22
       * @param {number} n23
       * @param {number} n24
       * @param {number} n31
       * @param {number} n32
       * @param {number} n33
       * @param {number} n34
       * @param {number} n41
       * @param {number} n42
       * @param {number} n43
       * @param {number} n44
       */
      value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        this.onChangeCallback();
        return this;
      }
      /**
       * Resets this matrix to the
       * [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix).
       * @method identity
       * @memberof Matrix4.prototype
       */

    }, {
      key: "identity",
      value: function identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Creates a new matrix with identical {@link Matrix4#elements} to this one.
       * @method clone
       * @memberof Matrix4.prototype
       * @return {Matrix4}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Matrix4().fromArray(this.elements);
      }
      /**
       * Copies the {@link Matrix4#elements} of matrix `m` into this matrix.
       * @method copy
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "copy",
      value: function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        this.onChangeCallback();
        return this;
      }
      /**
       * Copies the translation component of the supplied matrix `m` into this
       * matrix's translation component.
       * @method copyPosition
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "copyPosition",
      value: function copyPosition(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        this.onChangeCallback();
        return this;
      }
      /**
       * Extracts the [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra))
       * of this matrix into the vendor axis vectors provided. If this matrix is:
       * ```
       * a b c d
       * e f g h
       * i j k l
       * m n o p
       * ```
       * then the `xAxis`, `yAxis`, `zAxis` will be set to:
       * ```
       * xAxis = (a, e, i)
       * yAxis = (d, f, j)
       * zAxis = (c, g, k)
       * ```
       * @method extractBasis
       * @memberof Matrix4.prototype
       * @param {Vector3} xAxis
       * @param {Vector3} yAxis
       * @param {Vector3} zAxis
       */

    }, {
      key: "extractBasis",
      value: function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      /**
       * Set this to the
       * [basis](https://en.wikipedia.org/wiki/Basis_(linear_algebra)) matrix
       * consisting of the vendor provided basis vectors:
       * ```
       * xAxis.x  yAxis.x  zAxis.x  0
       * xAxis.y  yAxis.y  zAxis.y  0
       * xAxis.z  yAxis.z  zAxis.z  0
       *    0        0        0     0
       * ```
       * @method makeBasis
       * @memberof Matrix4.prototype
       * @param {Vector3} xAxis
       * @param {Vector3} yAxis
       * @param {Vector3} zAxis
       */

    }, {
      key: "makeBasis",
      value: function makeBasis(xAxis, yAxis, zAxis) {
        return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      }
      /**
       * Extracts the rotation component of the supplied matrix `m` into this
       * matrix's rotation component.
       * @method extractRotation
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "extractRotation",
      value: function extractRotation(m) {
        if (typeof extractRotationV === 'undefined') {
          extractRotationV = new _Vector["default"]();
        }

        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / extractRotationV.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / extractRotationV.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / extractRotationV.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
       * the orientation specified by the given {@link Euler} angle. The rest of the
       * matrix is set to the identity. Depending on the {@link Euler#order} of the
       * `euler`, there are six possible outcomes. See
       * [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
       * for a complete list.
       * @method makeRotationFromEuler
       * @memberof Matrix4.prototype
       * @param  {Euler} euler
       */

    }, {
      key: "makeRotationFromEuler",
      value: function makeRotationFromEuler(euler) {
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z,
            order = euler.order;
        var cx = Math.cos(x);
        var sx = Math.sin(x);
        var cy = Math.cos(y);
        var sy = Math.sin(y);
        var cz = Math.cos(z);
        var sz = Math.sin(z);

        if (order === 'XYZ') {
          te[0] = cy * cz;
          te[4] = -cy * sz;
          te[8] = sy;
          te[1] = cx * sz + sx * cz * sy;
          te[5] = cx * cz - sx * sz * sy;
          te[9] = -sx * cy;
          te[2] = sx * sz - cx * cz * sy;
          te[6] = sx * cz + cx * sz * sy;
          te[10] = cx * cy;
        } else if (order === 'YXZ') {
          te[0] = cy * cz + sy * sz * sx;
          te[4] = sy * cz * sx - cy * sz;
          te[8] = cx * sy;
          te[1] = cx * sz;
          te[5] = cx * cz;
          te[9] = -sx;
          te[2] = cy * sz * sx - sy * cz;
          te[6] = sy * sz + cy * cz * sx;
          te[10] = cx * cy;
        } else if (order === 'ZXY') {
          te[0] = cy * cz - sy * sz * sx;
          te[4] = -cx * sz;
          te[8] = sy * cz + cy * sz * sx;
          te[1] = cy * sz + sy * cz * sx;
          te[5] = cx * cz;
          te[9] = sy * sz - cy * cz * sx;
          te[2] = -cx * sy;
          te[6] = sx;
          te[10] = cx * cy;
        } else if (order === 'ZYX') {
          te[0] = cy * cz;
          te[4] = sx * cz * sy - cx * sz;
          te[8] = cx * cz * sy + sx * sz;
          te[1] = cy * sz;
          te[5] = sx * sz * sy + cx * cz;
          te[9] = cx * sz * sy - sx * cz;
          te[2] = -sy;
          te[6] = sx * cy;
          te[10] = cx * cy;
        } else if (order === 'YZX') {
          te[0] = cy * cz;
          te[4] = sx * sy - cx * cy * sz;
          te[8] = sx * cy * sz + cx * sy;
          te[1] = sz;
          te[5] = cx * cz;
          te[9] = -sx * cz;
          te[2] = -sy * cz;
          te[6] = cx * sy * sz + sx * cy;
          te[10] = cx * cy - sx * sy * sz;
        } else if (order === 'XZY') {
          te[0] = cy * cz;
          te[4] = -sz;
          te[8] = sy * cz;
          te[1] = cx * cy * sz + sx * sy;
          te[5] = cx * cz;
          te[9] = cx * sy * sz - sx * cy;
          te[2] = sx * cy * sz - cx * sy;
          te[6] = sx * cz;
          te[10] = sx * sy * sz + cx * cy;
        } // last column


        te[3] = 0;
        te[7] = 0;
        te[11] = 0; // bottom row

        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the rotation component of this matrix to the rotation specified by
       * `q`, as outlined
       * [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion). The rest
       * of the matrix is set to the identity. So, given `q = w + xi + yj + zk`,
       * the resulting matrix will be:
       * <pre class="code prettyprint prettyprinted" style=""><code><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2y<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2z<sup>2</sup></span><span class="pln">     </span><span class="lit">2xy</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2zw</span><span class="pln">       </span><span class="lit">2xz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2yw</span><span class="pln">     </span><span class="lit">0</span>
       * <span class="pln"> </span><span class="lit">2xy</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2zw</span><span class="pln">      </span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2x<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2z<sup>2</sup></span><span class="pln">     </span><span class="lit">2yz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2xw</span><span class="pln">     </span><span class="lit">0</span>
       * <span class="pln"> </span><span class="lit">2xz</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2yw</span><span class="pln">        </span><span class="lit">2yz</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2xw</span><span class="pln">     </span><span class="lit">1</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2x<sup>2</sup></span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">2y<sup>2</sup></span><span class="pln">   </span><span class="lit">0</span>
       * <span class="pln">     </span><span class="lit">0</span><span class="pln">                </span><span class="lit">0</span><span class="pln">               </span><span class="lit">0</span><span class="pln">         </span><span class="lit">1</span></code></pre>
       * @method makeRotationFromQuaternion
       * @memberof Matrix4.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "makeRotationFromQuaternion",
      value: function makeRotationFromQuaternion(q) {
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        return this.set(1 - (yy + zz), xy - wz, xz + wy, 0, xy + wz, 1 - (xx + zz), yz - wx, 0, xz - wy, yz + wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
      }
      /**
       * Constructs a rotation matrix, looking from `eye` towards `target` oriented
       * by the `up` vector.
       * @method lookAt
       * @memberof Matrix4.prototype
       * @param  {Vector3} eye
       * @param  {Vector3} target
       * @param  {Vector3} up
       */

    }, {
      key: "lookAt",
      value: function lookAt(eye, target, up) {
        if (typeof lookAtX === 'undefined') {
          lookAtX = new _Vector["default"]();
        }

        if (typeof lookAtY === 'undefined') {
          lookAtY = new _Vector["default"]();
        }

        if (typeof lookAtZ === 'undefined') {
          lookAtZ = new _Vector["default"]();
        }

        var te = this.elements;
        lookAtZ.subVectors(eye, target);

        if (lookAtZ.lengthSq() === 0) {
          lookAtZ._z = 1;
        }

        lookAtZ.normalize();
        lookAtX.crossVectors(up, lookAtZ);

        if (lookAtX.lengthSq() === 0) {
          lookAtZ._z += 0.0001;
          lookAtX.crossVectors(up, lookAtZ);
        }

        lookAtX.normalize();
        lookAtY.crossVectors(lookAtZ, lookAtX);
        te[0] = lookAtX._x;
        te[4] = lookAtY._x;
        te[8] = lookAtZ._x;
        te[1] = lookAtX._y;
        te[5] = lookAtY._y;
        te[9] = lookAtZ._y;
        te[2] = lookAtX._z;
        te[6] = lookAtY._z;
        te[10] = lookAtZ._z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Post-multiplies this matrix by `m`.
       * @method multiply
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "multiply",
      value: function multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      /**
       * Pre-multiplies this matrix by `m`.
       * @method premultiply
       * @memberof Matrix4.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "premultiply",
      value: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      /**
       * Sets this matrix to `a × b`.
       * @method multiplyMatrices
       * @memberof Matrix4.prototype
       * @param {Matrix4} a
       * @param {Matrix4} b
       */

    }, {
      key: "multiplyMatrices",
      value: function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;

        var _ae = _slicedToArray(ae, 16),
            a11 = _ae[0],
            a21 = _ae[1],
            a31 = _ae[2],
            a41 = _ae[3],
            a12 = _ae[4],
            a22 = _ae[5],
            a32 = _ae[6],
            a42 = _ae[7],
            a13 = _ae[8],
            a23 = _ae[9],
            a33 = _ae[10],
            a43 = _ae[11],
            a14 = _ae[12],
            a24 = _ae[13],
            a34 = _ae[14],
            a44 = _ae[15];

        var _be = _slicedToArray(be, 16),
            b11 = _be[0],
            b21 = _be[1],
            b31 = _be[2],
            b41 = _be[3],
            b12 = _be[4],
            b22 = _be[5],
            b32 = _be[6],
            b42 = _be[7],
            b13 = _be[8],
            b23 = _be[9],
            b33 = _be[10],
            b43 = _be[11],
            b14 = _be[12],
            b24 = _be[13],
            b34 = _be[14],
            b44 = _be[15];

        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies every component of the matrix by a scalar value `s`.
       * @method multiplyScalar
       * @memberof Matrix4.prototype
       * @param  {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this.elements;

        for (var i = 0; i < te.length; i++) {
          te[i] *= s;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Computes and returns the
       * [determinant](https://en.wikipedia.org/wiki/Determinant) of this matrix.
       * Based on the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm).
       * @method determinant
       * @memberof Matrix4.prototype
       * @return {number}
       */

    }, {
      key: "determinant",
      value: function determinant() {
        var te = this.elements;

        var _te = _slicedToArray(te, 16),
            n11 = _te[0],
            n21 = _te[1],
            n31 = _te[2],
            n41 = _te[3],
            n12 = _te[4],
            n22 = _te[5],
            n32 = _te[6],
            n42 = _te[7],
            n13 = _te[8],
            n23 = _te[9],
            n33 = _te[10],
            n43 = _te[11],
            n14 = _te[12],
            n24 = _te[13],
            n34 = _te[14],
            n44 = _te[15]; // TODO: make this more efficient
        // ( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )


        var a = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var b = n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31;
        var c = n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31;
        var d = -n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31;
        return n41 * a + n42 * b + n43 * c + n44 * d;
      }
      /**
       * [Transposes](https://en.wikipedia.org/wiki/Transpose) this matrix.
       * @method transpose
       * @memberof Matrix4.prototype
       */

    }, {
      key: "transpose",
      value: function transpose() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the position component for this matrix from vector `v`, without
       * affecting the rest of the matrix - i.e. if the matrix is currently:
       * ```
       * a  b  c  d
       * e  f  g  h
       * i  j  k  l
       * m  n  o  p
       * ```
       * this becomes:
       * ```
       * a  b  c v.x
       * e  f  g v.y
       * i  j  k v.z
       * m  n  o  p
       * ```
       * @method setPosition
       * @memberof Matrix4.prototype
       * @param {Vector3} v
       */

    }, {
      key: "setPosition",
      value: function setPosition(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this matrix to the
       * [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of the passed
       * matrix `m`, using the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm).
       * If `throwOnDegenerate` is not set and the matrix is not invertible, sets
       * this to the 4x4 identity matrix.
       * @method getInverse
       * @memberof Matrix4.prototype
       * @param {Matrix4} m The matrix to take the inverse of.
       * @param {boolean} [throwOnDegenerate=false] If true, throw an error if the matrix is degenerate (not invertible).
       */

    }, {
      key: "getInverse",
      value: function getInverse(m) {
        var throwOnDegenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var te = this.elements;
        var me = m.elements;

        var _me = _slicedToArray(me, 16),
            n11 = _me[0],
            n21 = _me[1],
            n31 = _me[2],
            n41 = _me[3],
            n12 = _me[4],
            n22 = _me[5],
            n32 = _me[6],
            n42 = _me[7],
            n13 = _me[8],
            n23 = _me[9],
            n33 = _me[10],
            n43 = _me[11],
            n14 = _me[12],
            n24 = _me[13],
            n34 = _me[14],
            n44 = _me[15];

        var t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        var t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        var t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        var t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

        if (det === 0) {
          var msg = 'Matrix4.getInverse(): can\'t invert matrix, determinant is 0';

          if (throwOnDegenerate === true) {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }

          this.onChangeCallback();
          return this.identity();
        }

        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies the columns of this matrix by vector `v`.
       * @method scale
       * @memberof Matrix4.prototype
       * @param {Vector3} v
       */

    }, {
      key: "scale",
      value: function scale(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Gets the maximum scale value of the 3 axes.
       * @method getMaxScaleOnAxis
       * @memberof Matrix4.prototype
       * @return {number}
       */

    }, {
      key: "getMaxScaleOnAxis",
      value: function getMaxScaleOnAxis() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      /**
       * Sets this matrix as a translation transform:
       * ```
       * 1  0  0  x
       * 0  1  0  y
       * 0  0  1  z
       * 0  0  0  1
       * ```
       * @method makeTranslation
       * @memberof Matrix4.prototype
       * @param {number} x The amount to translate in the x axis.
       * @param {number} y The amount to translate in the y axis.
       * @param {number} z The amount to translate in the z axis.
       */

    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y, z) {
        return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the x axis by
       * `theta`. The resulting matrix will be:
       * ```
       * 1    0      0      0
       * 0  cos(θ) -sin(θ)  0
       * 0  sin(θ)  cos(θ)  0
       * 0    0      0      1
       * ```
       * @method makeRotationX
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationX",
      value: function makeRotationX(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the y axis by
       * `theta`. The resulting matrix will be:
       * ```
       *  cos(θ)  0  sin(θ)  0
       *    0     1    0     0
       * -sin(θ)  0  cos(θ)  0
       *    0     0    0     1
       * ```
       * @method makeRotationY
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationY",
      value: function makeRotationY(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a rotational transformation around the z axis by
       * `theta`. The resulting matrix will be:
       * ```
       * cos(θ) -sin(θ)  0  0
       * sin(θ)  cos(θ)  0  0
       *   0       0     1  0
       *   0       0     0  1
       * ```
       * @method makeRotationZ
       * @memberof Matrix4.prototype
       * @param {number} theta Rotation angle in radians.
       */

    }, {
      key: "makeRotationZ",
      value: function makeRotationZ(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as rotation transform around `axis` by `theta`. This is a
       * somewhat controversial but mathematically sound alternative to rotating
       * via {@link Quaternion}s. See the discussion
       * [here](http://www.gamedev.net/reference/articles/article1199.asp).
       * @method makeRotationAxis
       * @memberof Matrix4.prototype
       * @param {Vector3} axis
       * @param {number} angle
       */

    }, {
      key: "makeRotationAxis",
      value: function makeRotationAxis(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x;
        var ty = t * y;
        return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a scale transform:
       * ```
       * x  0  0  0
       * 0  y  0  0
       * 0  0  z  0
       * 0  0  0  1
       * ```
       * @method makeScale
       * @memberof Matrix4.prototype
       * @param {number} x The amount to scale in the x axis.
       * @param {number} y The amount to scale in the y axis.
       * @param {number} z The amount to scale in the z axis.
       */

    }, {
      key: "makeScale",
      value: function makeScale(x, y, z) {
        return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix as a shear transform:
       * ```
       * 1  y  z  0
       * x  1  z  0
       * x  y  1  0
       * 0  0  0  1
       * ```
       * @method makeShear
       * @memberof Matrix4.prototype
       * @param {number} x The amount to shear in the x axis.
       * @param {number} y The amount to shear in the y axis.
       * @param {number} z The amount to shear in the z axis.
       */

    }, {
      key: "makeShear",
      value: function makeShear(x, y, z) {
        return this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      }
      /**
       * Sets this matrix to the transformation composed of `position`,
       * `quaternion`, and `scale`. Internally this calls
       * {@link Matrix4#makeRotationFromQuaternion} followed by
       * {@link Matrix4#scale}, then finally {@link Matrix4#setPosition}.
       * @method compose
       * @memberof Matrix4.prototype
       * @param  {Vector3} position
       * @param  {Quaternion} quaternion
       * @param  {Vector3} scale
       */

    }, {
      key: "compose",
      value: function compose(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      }
      /**
       * Decomposes this matrix into it's `position`, 'quaternion', and 'scale'
       * components.
       * @method decompose
       * @memberof Matrix4.prototype
       * @param  {Vector3} position
       * @param  {Quaternion} quaternion
       * @param  {Vector3} scale
       */

    }, {
      key: "decompose",
      value: function decompose() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var quaternion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (typeof decomposeV === 'undefined') {
          decomposeV = new _Vector["default"]();
        }

        if (typeof decomposeM === 'undefined') {
          decomposeM = new Matrix4();
        }

        var te = this.elements;
        var sx = decomposeV.set(te[0], te[1], te[2]).length();
        var sy = decomposeV.set(te[4], te[5], te[6]).length();
        var sz = decomposeV.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

        var det = this.determinant();

        if (det < 0) {
          sx = -sx;
        }

        position.set(te[12], te[13], te[14]); // scale the rotation part
        // at this point matrix is incomplete so we can't use .copy()

        decomposeM.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        decomposeM.elements[0] *= invSX;
        decomposeM.elements[1] *= invSX;
        decomposeM.elements[2] *= invSX;
        decomposeM.elements[4] *= invSY;
        decomposeM.elements[5] *= invSY;
        decomposeM.elements[6] *= invSY;
        decomposeM.elements[8] *= invSZ;
        decomposeM.elements[9] *= invSZ;
        decomposeM.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(decomposeM);
        scale.set(sx, sy, sz);
        return this;
      }
    }, {
      key: "makeFrustum",

      /**
       * Creates a
       * [perspective projection](https://en.wikipedia.org/wiki/3D_projection#Perspective_projection)
       * matrix.
       * @method makeFrustum
       * @memberof Matrix4.prototype
       * @param {number} left
       * @param {number} right
       * @param {number} top
       * @param {number} bottom
       * @param {number} near
       * @param {number} far
       */
      value: function makeFrustum(left, right, top, bottom, near, far) {
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near); //     return this.set(
        //         x, 0, a, 0,
        //         0, y, b, 0,
        //         0, 0, c, d,
        //         0, 0, -1, 0,
        //     );

        return this.set(0, -x, a, 0, -y, 0, b, 0, 0, 0, -c, d, 0, 0, 1, 0);
      }
    }, {
      key: "makePerspective",
      value: function makePerspective(fov, aspect, near, far) {
        var ymin = near * Math.tan((0, _Math.degToRad)(fov * 0.5));
        var ymax = -ymin;
        var xmin = ymax * aspect;
        var xmax = ymin * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      }
      /**
       * Creates an
       * [orthographic projection](https://en.wikipedia.org/wiki/Orthographic_projection)
       * matrix. This is used internally by
       * {@link OrthographicCamera#updateProjectionMatrix}.
       * @method makeOrthographic
       * @memberof Matrix4.prototype
       * @param {number} left
       * @param {number} right
       * @param {number} top
       * @param {number} bottom
       * @param {number} near
       * @param {number} far
       */

    }, {
      key: "makeOrthographic",
      value: function makeOrthographic(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z = (far + near) * p;
        return this.set(2 * w, 0, 0, -x, 0, 2 * h, 0, -y, 0, 0, -2 * p, -z, 0, 0, 0, 1);
      }
      /**
       * Return true if this matrix and `matrix` are equal.
       * @method equals
       * @memberof Matrix4.prototype
       * @param  {Matrix4} matrix
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;

        for (var i = 0; i < 16; i += 1) {
          if (te[i] !== me[i]) {
            return false;
          }
        }

        return true;
      }
      /**
       * Sets the {@link Matrix4#elements} of this matrix based on an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method fromArray
       * @memberof Matrix4.prototype
       * @param  {Array} array The array to read the {@link Matrix4#elements} from.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;

        for (var i = 0; i < te.length; i += 1) {
          te[i] = array[i + offset];
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Writes the elements of this matrix to an `array` in
       * [column-major](https://en.wikipedia.org/wiki/Row-_and_column-major_order#Column-major_order)
       * format.
       * @method toArray
       * @memberof Matrix4.prototype
       * @param  {Array} [array=[]] Array to store the resulting vector in.
       * @param  {number} [offset=0] Offset in the array at which to put the result.
       * @return {Array}        [description]
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;

        for (var i = 0; i < 16; i += 1) {
          array[offset + i] = te[i];
        }

        return array;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "isMatrix4",
      get: function get() {
        return _isMatrix4;
      }
    }, {
      key: "decomposedValue",
      get: function get() {
        var position = new _Vector["default"]();
        var quaternion = new _Quaternion["default"]();
        var scale = new _Vector["default"]();

        if (typeof decomposeV === 'undefined') {
          decomposeV = new _Vector["default"]();
        }

        if (typeof decomposeM === 'undefined') {
          decomposeM = new Matrix4();
        }

        var te = this.elements;
        var sx = decomposeV.set(te[0], te[1], te[2]).length();
        var sy = decomposeV.set(te[4], te[5], te[6]).length();
        var sz = decomposeV.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale

        var det = this.determinant();

        if (det < 0) {
          sx = -sx;
        }

        position.set(te[12], te[13], te[14]); // scale the rotation part
        // at this point matrix is incomplete so we can't use .copy()

        decomposeM.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        decomposeM.elements[0] *= invSX;
        decomposeM.elements[1] *= invSX;
        decomposeM.elements[2] *= invSX;
        decomposeM.elements[4] *= invSY;
        decomposeM.elements[5] *= invSY;
        decomposeM.elements[6] *= invSY;
        decomposeM.elements[8] *= invSZ;
        decomposeM.elements[9] *= invSZ;
        decomposeM.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(decomposeM);
        scale.set(sx, sy, sz);
        return {
          position: position,
          quaternion: quaternion,
          scale: scale
        };
      }
    }]);

    return Matrix4;
  }();

  _exports["default"] = Matrix4;
});

/***/ }),

/***/ "./math/Quaternion.js":
/*!****************************!*\
  !*** ./math/Quaternion.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Vector3 */ "./math/Vector3.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Vector) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Vector = _interopRequireDefault(_Vector);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Euler from './Euler';
  // import Matrix4 from './Matrix4';
  var EPSILON = Number.EPSILON;

  if (typeof EPSILON === 'undefined') {
    EPSILON = Math.pow(2, -52);
  } // constants for optimisation


  var setFromUnitVectorsEPS = 0.000001;
  var setFromUnitVectorsV; // let this.x = 0, this.y = 0, this.z = 0, this.w = 1;

  /**
   * This function is called whenever and of the following occur:
   * * The {@link Quaternion#x}, {@link Quaternion#y}, {@link Quaternion#z}, or {@link Quaternion#w} properties are changed.
   * * The {@link Quaternion#set}, {@link Quaternion#copy}, {@link Quaternion$clone}, {@link Quaternion#setFromAxisAngle}, {@link Quaternion$setFromRotationMatrix}, {@link Quaternion#conjugate}, {@link Quaternion#normalize}, {@link Quaternion#multiplyQuaternions}, {@link Quaternion#slerp}, {@link Quaternion#fromArray} functions are called.
   * * {@link Quaternion#setFromEuler} function is called with its `update` argument set to `true`.
   * By default, it is an empty function, however you can change it if needed using {@link Quaternion#onChange}.
   * @property onChangeCallback
   * @type {Function}
   * @default function() {}
   */

  var onChangeCallback = function onChangeCallback() {};

  var _isQuaternion = true;
  /**
   * @class Quaternion
   * @classdesc
   * Implementation of a [quaternion](http://en.wikipedia.org/wiki/Quaternion).
   * This is used for
   * [rotating things](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)
   * without encountering the dreaded
   * [gimbal lock](http://en.wikipedia.org/wiki/Gimbal_lock) issue, amongst other
   * advantages.
   * @example
   * var quaternion = new Quaternion();
   * quaternion.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
   *
   * var vector = new Vector3(1, 0, 0);
   * vector.applyQuaternion(quaternion);
   * @param {number} [x=0]
   * @param {number} [y=0]
   * @param {number} [z=0]
   * @param {number} [w=1]
   */

  var Quaternion =
  /*#__PURE__*/
  function () {
    function Quaternion() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      _classCallCheck(this, Quaternion);

      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} x
     * @memberof Quaternion#
     * @default 0
     */
    // get x() {
    //   return this.x;
    // }
    //
    // set x(value) {
    //   this.x = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} y
     * @memberof Quaternion#
     * @default 0
     */
    // get y() {
    //   return this.y;
    // }
    //
    // set y(value) {
    //   this.y = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} z
     * @memberof Quaternion#
     * @default 0
     */
    // get z() {
    //   return this.z;
    // }
    //
    // set z(value) {
    //   this.z = value;
    //   this.onChangeCallback();
    // }

    /**
     * Changing this property will result in {@link Quaternion#onChangeCallback}
     * being called.
     * @member {number} w
     * @memberof Quaternion#
     * @default 1
     */
    // get w() {
    //   return this.w;
    // }
    //
    // set w(value) {
    //   this.w = value;
    //   this.onChangeCallback();
    // }


    _createClass(Quaternion, [{
      key: "set",

      /**
       * Sets {@link Quaternion#x}, {@link Quaternion#y}, {@link Quaternion#z}, and
       * {@link Quaternion#w} properties of this quaternion.
       * @method set
       * @memberof Quaternion.prototype
       * @param {number} x
       * @param {number} y
       * @param {number} z
       * @param {number} w
       */
      value: function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        this.onChangeCallback();
        return this;
      }
      /**
       * Creates a new {@link Quaternion} with identical {@link Quaternion#x},
       * {@link Quaternion#y}, {@link Quaternion#z}, and {@link Quaternion#w}
       * properties to this one.
       * @method clone
       * @memberof Quaternion.prototype
       * @return {Quaternion}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Quaternion(this.x, this.y, this.z, this.w);
      }
      /**
       * Copies the {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties of `quaternion`
       * into this quaternion.
       * @method copy
       * @memberof Quaternion.prototype
       * @param {Quaternion} quaternion
       */

    }, {
      key: "copy",
      value: function copy(quaternion) {
        this.x = quaternion.x;
        this.y = quaternion.y;
        this.z = quaternion.z;
        this.w = quaternion.w;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion from the rotation specified by {@link Euler} angle.
       * @method setFromEuler
       * @memberof Quaternion.prototype
       * @param {Euler} euler
       * @param {boolean} update
       */

    }, {
      key: "setFromEuler",
      value: function setFromEuler(euler) {
        var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        // content/SpinCalc.m
        var c1 = Math.cos(euler.x / 2);
        var c2 = Math.cos(euler.y / 2);
        var c3 = Math.cos(euler.z / 2);
        var s1 = Math.sin(euler.x / 2);
        var s2 = Math.sin(euler.y / 2);
        var s3 = Math.sin(euler.z / 2);
        var order = euler.order;

        if (order === 'XYZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'YXZ') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'ZXY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'ZYX') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (order === 'YZX') {
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 + s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (order === 'XZY') {
          this.x = s1 * c2 * c3 - c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
        }

        if (update !== false) {
          this.onChangeCallback();
        }

        return this;
      }
      /**
       * Sets this quaternion from rotation specified by `axis` and `angle`. Adapted
       * from the method
       * [here](http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm).
       * `axis` is assumed to be normalized, `angle` is in radians.
       * @method setFromAxisAngle
       * @memberof Quaternion.prototype
       * @param {Vector3} axis
       * @param {number} number
       */

    }, {
      key: "setFromAxisAngle",
      value: function setFromAxisAngle(axis, angle) {
        var halfAngle = angle / 2;
        var s = Math.sin(halfAngle);
        this.x = axis.x * s;
        this.y = axis.y * s;
        this.z = axis.z * s;
        this.w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion from rotation component of `m`. Adapted from the
       * method
       * [here](http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm).
       * @method setFromRotationMatrix
       * @memberof Quaternion.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        var te = m.elements;

        var _te = _slicedToArray(te, 12),
            m11 = _te[0],
            m21 = _te[1],
            m31 = _te[2],
            m41 = _te[3],
            m12 = _te[4],
            m22 = _te[5],
            m32 = _te[6],
            m42 = _te[7],
            m13 = _te[8],
            m23 = _te[9],
            m33 = _te[10],
            m43 = _te[11];

        var trace = m11 + m22 + m33;
        var s;

        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this.w = 0.25 / s;
          this.x = (m32 - m23) * s;
          this.y = (m13 - m31) * s;
          this.z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this.w = (m32 - m23) / s;
          this.x = 0.25 * s;
          this.y = (m12 + m21) / s;
          this.z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this.w = (m13 - m31) / s;
          this.x = (m12 + m21) / s;
          this.y = 0.25 * s;
          this.z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this.w = (m21 - m12) / s;
          this.x = (m13 + m31) / s;
          this.y = (m23 + m32) / s;
          this.z = 0.25 * s;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this quaternion to the rotation required to rotate direction vector
       * `vFrom` to direction vector `vTo`. Adapted from the method
       * [here](http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors).
       * `vFrom` and `vTo` are assumed to be normalized.
       * @method setFromUnitVectors
       * @memberof Quaternion.prototype
       * @param {Vector3} vFrom
       * @param {Vector3} vTo
       */

    }, {
      key: "setFromUnitVectors",
      value: function setFromUnitVectors(vFrom, vTo) {
        // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
        if (typeof setFromUnitVectorsV === 'undefined') {
          setFromUnitVectorsV = new _Vector["default"]();
        }

        var r = vFrom.dot(vTo) + 1;

        if (r < setFromUnitVectorsEPS) {
          r = 0;

          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            setFromUnitVectorsV.set(-vFrom.y, vFrom.x, 0);
          } else {
            setFromUnitVectorsV.set(0, -vFrom.z, vFrom.y);
          }
        } else {
          setFromUnitVectorsV.crossVectors(vFrom, vTo);
        }

        this.x = setFromUnitVectorsV.x;
        this.y = setFromUnitVectorsV.y;
        this.z = setFromUnitVectorsV.z;
        this.w = r;
        return this.normalize();
      }
      /**
       * Inverts this quaternion - calculate the {@link Quaternion#conjugate} and
       * then [normalizes]{@link Quaternion#normalize} the result.
       * @method inverse
       * @memberof Quaternion.prototype
       */

    }, {
      key: "inverse",
      value: function inverse() {
        return this.conjugate().normalize();
      }
      /**
       * Returns the rotational conjugate of this quaternion. The conjugate of a
       * quaternion represents the same rotation in the opposite direction about
       * the rotational axis.
       * @method conjugate
       * @memberof Quaternion.prototype
       */

    }, {
      key: "conjugate",
      value: function conjugate() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        this.onChangeCallback();
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * quaternions `v` and this one.
       * @method dot
       * @memberof Quaternion.prototype
       * @param {Quaternion} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) of this quaternion, considered as a 4 dimensional
       * vector. This can be useful if you are comparing the lengths of two
       * quaternions, as this is slightly more efficient calculation than
       * {@link Quaternion#length}.
       * @method lengthSq
       * @memberof Quaternion.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) of this quaternion, considered as a 4 dimensional
       * vector.
       * @method length
       * @memberof Quaternion.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      /**
       * [Normalizes](https://en.wikipedia.org/wiki/Normalized_vector) this
       * quaternion - that is, calculates the quaternion that performs the same
       * rotation as this one, but has {@link Quaternion#length} equal to `1`.
       * @method normalize
       * @memberof Quaternion.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        var l = this.length();

        if (l === 0) {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 1;
        } else {
          l = 1 / l;
          this.x = this.x * l;
          this.y = this.y * l;
          this.z = this.z * l;
          this.w = this.w * l;
        }

        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this quaternion by `q`.
       * @method multiply
       * @memberof Quaternion.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "multiply",
      value: function multiply(q) {
        return this.multiplyQuaternions(this, q);
      }
      /**
       * Pre-multiplies this quaternion by `q`.
       * @method premultiply
       * @memberof Quaternion.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "premultiply",
      value: function premultiply(q) {
        return this.multiplyQuaternions(q, this);
      }
      /**
       * Sets this quaternion to `a × b`. Adapted from the method outlined
       * [here](http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm).
       * @method multiplyQuaternions
       * @memberof Quaternion.prototype
       * @param {Quaternion} a
       * @param {Quaternion} b
       */

    }, {
      key: "multiplyQuaternions",
      value: function multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        var qax = a.x;
        var qay = a.y;
        var qaz = a.z;
        var qaw = a.w;
        var qbx = b.x;
        var qby = b.y;
        var qbz = b.z;
        var qbw = b.w;
        this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      }
      /**
       * Handles the spherical linear interpolation between quaternions. `t`
       * represents the amount of rotation between this quaternion (where `t = 0`)
       * and `qb` (where `t = 1`). This quaternion is set to the result. Also see
       * the static version of the {@link Quaternion.slerp}.
       * @method slerp
       * @memberof Quaternion.prototype
       * @param  {Quaternion} qb The other quaternion rotation
       * @param  {number} t  Interpolation factor in the closed interval `[0, 1]`.
       * @example
       * // rotate a mesh towards a target quaternion
       * mesh.quaternion.slerp(endQuaternion, 0.01);
       */

    }, {
      key: "slerp",
      value: function slerp(qb, t) {
        if (t === 0) {
          return this;
        }

        if (t === 1) {
          return this.copy(qb);
        }

        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

        if (cosHalfTheta < 0) {
          this.w = -qb.w;
          this.x = -qb.x;
          this.y = -qb.y;
          this.z = -qb.z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }

        if (cosHalfTheta >= 1.0) {
          this.w = w;
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        }

        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
          this.w = 0.5 * (w + this.w);
          this.x = 0.5 * (x + this.x);
          this.y = 0.5 * (y + this.y);
          this.z = 0.5 * (z + this.z);
          return this;
        }

        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
        var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this.w = w * ratioA + this.w * ratioB;
        this.x = x * ratioA + this.x * ratioB;
        this.y = y * ratioA + this.y * ratioB;
        this.z = z * ratioA + this.z * ratioB;
        this.onChangeCallback();
        return this;
      }
      /**
       * Compares the {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties of `quaternion`
       * to the equivalent properties of this quaternion to determine if they
       * represent the same rotation.
       * @method equals
       * @memberof Quaternion.prototype
       * @param {Quaternion} q Quaternion that this quaternion will be compared to.
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(q) {
        return q.x === this.x && q.y === this.y && q.z === this.z && q.w === this.w;
      }
      /**
       * Sets this quaternion's {@link Quaternion#x}, {@link Quaternion#y},
       * {@link Quaternion#z}, and {@link Quaternion#w} properties from the `array`.
       * @method fromArray
       * @memberof Quaternion.prototype
       * @param {number[]} array Array of format `(x, y, z, w)` used to construct the quaternion.
       * @param {number} [offset=0] An offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        this.onChangeCallback();
        return this;
      }
      /**
       * Returns the numerical elements of this quaternion in an array of format
       * `[x, y, z, w]`.
       * @method toArray
       * @memberof Quaternion.prototype
       * @param {number[]} [array=[]] An optional array to store the quaternion. If not specified a new array will be created.
       * @param {number} [offset=0] If specified, the result will be copied into the `array`.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset + 0] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      }
      /**
       * Sets the {@link Quaternion#onChangeCallback} method.
       * @method onChange
       * @memberof Quaternion.prototype
       * @param {Function} callback
       */

    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "isQuaternion",
      get: function get() {
        return _isQuaternion;
      }
    }], [{
      key: "slerp",

      /**
       * Unlike the [normal]{@link Quaternion#slerp} method, the static version of
       * {@link Quaternion.slerp} sets a target quaternion to the result of the
       * slerp operation.
       * @method slerp
       * @memberof Quaternion
       * @param {Quaternion} qStart The starting quaternion (where `t = 0`).
       * @param {Quaternion} qEnd The ending quaternion (where `t = 1`).
       * @param {Quaternion} qTarget The target quaternion that gets set with the result.
       * @param {number} t Interpolation factor in the closed interval `[0, 1]`.
       * @return {Quaternion}
       * @example
       * // Code setup
       * var startQuaternion = new Quaternion().set(0, 0, 0, 1).normalize();
       * var endQuaternion = new Quaternion().set(1, 1, 1, 1).normalize();
       * var t = 0;
       *
       * // Update a mesh's rotation in the loop
       * t = (t + 0.01) % 1; // constant angular momentum
       * Quaternion.slerp(startQuaternion, endQuaternion, mesh.quaternion, t);
       */
      value: function slerp(qStart, qEnd, qTarget, t) {
        return qTarget.copy(qStart).slerp(qEnd, t);
      }
      /**
       * Like the static {@link Quaternion.slerp} method, but operates directly on
       * flat arrays of numbers.
       * @method slerpFlat
       * @memberof Quaternion
       * @param {number[]} dst The output array.
       * @param {number} dstOffset An offset into the output array.
       * @param {number[]} src0 The source array of the starting quaternion.
       * @param {number} srcOffset0 An offset into the array `src0`.
       * @param {number[]} src1 The source array of the target quaternion.
       * @param {number} srcOffset1 An offset into the array `src1`.
       * @param {number} t Normalized interpolation factor (between `0` and `1`).
       */

    }, {
      key: "slerpFlat",
      value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        var x0 = src0[srcOffset0 + 0];
        var y0 = src0[srcOffset0 + 1];
        var z0 = src0[srcOffset0 + 2];
        var w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1 + 0];
        var y1 = src1[srcOffset1 + 1];
        var z1 = src1[srcOffset1 + 2];
        var w1 = src1[srcOffset1 + 3];

        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          var s = 1 - t;
          var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
          var dir = cos >= 0 ? 1 : -1;
          var sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

          if (sqrSin > EPSILON) {
            var sin = Math.sqrt(sqrSin);
            var len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t = Math.sin(t * len) / sin;
          }

          var tDir = t * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

          if (s === 1 - t) {
            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }

        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
    }]);

    return Quaternion;
  }();

  _exports["default"] = Quaternion;
});

/***/ }),

/***/ "./math/Vector2.js":
/*!*************************!*\
  !*** ./math/Vector2.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _isVector2 = true;
  /**
   * @class Vector2
   * @classdesc
   * Class representing a 2D [vector](https://en.wikipedia.org/wiki/Vector_space).
   * A 2D vector is an ordered pair of numbers (labeled `x` and `y`), which can be
   * used to represent a number of things, such as:
   * * A point in 2D space (i.e. a position on a plane).
   * * A direction and length across a plane. For Letsee, the length will always be the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) (straight-line distance) from `(0, 0)` to `(x, y)` and the direction is also measured from `(0, 0)` towards `(x, y)`.
   * * Any arbitrary ordered pair of numbers.
   * These are other things a 2D vector can be used to represent, such as momentum
   * vectors, complex numbers and so on, however these are the most common uses.
   * @example
   * var a = new Vector2(0, 1);
   *
   * // no arguments; will be initialised to (0, 0)
   * var b = new Vector2();
   *
   * var d = a.distanceTo(b);
   * @param  {number} [x=0] The {@link Vector2#x} value of the vector.
   * @param  {number} [y=0] The {@link Vector2#y} value of the vector.
   */

  var Vector2 =
  /*#__PURE__*/
  function () {
    function Vector2() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      _classCallCheck(this, Vector2);

      this._x = x;
      this._y = y;
    }
    /**
     * Alias for {@link Vector2#x}.
     * @member {number} width
     * @memberof Vector2#
     */


    _createClass(Vector2, [{
      key: "set",

      /**
       * Sets the {@link Vector2#x} and {@link Vector2#y} components of this vector.
       * @method set
       * @memberof Vector2.prototype
       * @param {number} x
       * @param {number} y
       */
      value: function set(x, y) {
        this._x = x;
        this._y = y;
        return this;
      }
      /**
       * Sets the {@link Vector2#x} and {@link Vector2#y} values of this vector both
       * equal to `scalar`.
       * @method setScalar
       * @memberof Vector2.prototype
       * @param {number} scalar
       */

    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this._x = scalar;
        this._y = scalar;
        return this;
      }
      /**
       * Replace this vector's {@link Vector2#x} value with `x`.
       * @method setX
       * @memberof Vector2.prototype
       * @param {number} x
       */

    }, {
      key: "setX",
      value: function setX(x) {
        this._x = x;
        return this;
      }
      /**
       * Replace this vector's {@link Vector2#y} value with `y`.
       * @method setY
       * @memberof Vector2.prototype
       * @param {number} y
       */

    }, {
      key: "setY",
      value: function setY(y) {
        this._y = y;
        return this;
      }
      /**
       * If `index` equals to `0`, set {@link Vector2#x} to `value`.
       * If `index` equals to `1`, set {@link Vector2#y} to `value`.
       * @method setComponent
       * @memberof Vector2.prototype
       * @param {0|1} index
       * @param {number} value
       */

    }, {
      key: "setComponent",
      value: function setComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1;
        var value = arguments.length > 1 ? arguments[1] : undefined;

        switch (index) {
          case 0:
            this._x = value;
            break;

          case 1:
            this._y = value;
            break;

          default:
            throw new Error("index is out of range: ".concat(index));
        }

        return this;
      }
      /**
       * If `index` equals to `0`, returns {@link Vector2#x}.
       * If `index` equals to `1`, returns {@link Vector2#y}.
       * @method getComponent
       * @memberof Vector2.prototype
       * @param  {0|1} index
       * @return {number}
       */

    }, {
      key: "getComponent",
      value: function getComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1;

        switch (index) {
          case 0:
            return this._x;

          case 1:
            return this._y;

          default:
            throw new Error("index is out of range: ".concat(index));
        }
      }
      /**
       * Returns a new {@link Vector2} with the same {@link Vector2#x} and
       * {@link Vector2#y} values as this one.
       * @method clone
       * @memberof Vector2.prototype
       * @return {Vector2}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Vector2(this._x, this._y);
      }
      /**
       * Copies the values of the passed {@link Vector2}'s {@link Vector2#x} and
       * {@link Vector2#y} properties to this vector.
       * @method copy
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "copy",
      value: function copy(v) {
        this._x = v.x;
        this._y = v.y;
        return this;
      }
      /**
       * Adds `v` to this vector.
       * @method add
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "add",
      value: function add(v) {
        this._x += v.x;
        this._y += v.y;
        return this;
      }
      /**
       * Adds the scalar value `s` to this vector's {@link Vector2#x} and
       * {@link Vector2#y} values.
       * @method addScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this._x += s;
        this._y += s;
        return this;
      }
      /**
       * Sets this vector to `a + b`.
       * @method addVectors
       * @memberof Vector2.prototype
       * @param {Vector2} a
       * @param {Vector2} b
       */

    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this._x = a.x + b.x;
        this._y = a.y + b.y;
        return this;
      }
      /**
       * Adds the multiple of `v` and `s` to this vector.
       * @method addScaledVector
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @param {number} s
       */

    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this._x += v.x * s;
        this._y += v.y * s;
        return this;
      }
      /**
       * Subtracts `v` from this vector.
       * @method sub
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "sub",
      value: function sub(v) {
        this._x -= v.x;
        this._y -= v.y;
        return this;
      }
      /**
       * Subtracts `s` from this vector's {@link Vector2#x} and {@link Vector2#y}
       * components.
       * @method subScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this._x -= s;
        this._y -= s;
        return this;
      }
      /**
       * Sets this vector to `a - b`.
       * @method subVectors
       * @memberof Vector2.prototype
       * @param  {Vector2} a
       * @param  {Vector2} b
       */

    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this._x = a.x - b.x;
        this._y = a.y - b.y;
        return this;
      }
      /**
       * Multiplies this vector by `v`.
       * @method multiply
       * @memberof Vector2.prototype
       * @param  {Vector2} v
       */

    }, {
      key: "multiply",
      value: function multiply(v) {
        this._x *= v.x;
        this._y *= v.y;
        return this;
      }
      /**
       * Multiplies this vector by scalar `s`.
       * @method multiplyScalar
       * @memberof Vector2.prototype
       * @param  {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        if (isFinite(s)) {
          this._x *= s;
          this._y *= s;
        } else {
          this._x = 0;
          this._y = 0;
        }

        return this;
      }
      /**
       * Divides this vector by `v`.
       * @method divide
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "divide",
      value: function divide(v) {
        this._x /= v.x;
        this._y /= v.y;
        return this;
      }
      /**
       * Divides this vector by scalar `s`. Sets vector to `(0, 0)` if `s = 0`.
       * @method divideScalar
       * @memberof Vector2.prototype
       * @param {number} s
       */

    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        return this.multiplyScalar(1 / s);
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is greater
       * than `v`'s {@link Vector2#x} or {@link Vector2#y} value, replace that value
       * with the corresponding min value.
       * @method min
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "min",
      value: function min(v) {
        this._x = Math.min(this._x, v.x);
        this._y = Math.min(this._y, v.y);
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is less than
       * `v`'s {@link Vector2#x} or {@link Vector2#y} value, replace that value with
       * the corresponding max value.
       * @method max
       * @memberof Vector2.prototype
       * @param {Vector2} v
       */

    }, {
      key: "max",
      value: function max(v) {
        this._x = Math.max(this._x, v.x);
        this._y = Math.max(this._y, v.y);
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} value is greater
       * than the `max` vector's {@link Vector2#x} or {@link Vector2#y} value, it is
       * replaced by the corresponding value. If this vector's {@link Vector2#x} or
       * {@link Vector2#y} value is less than the `min` vector's {@link Vector2#x}
       * or {@link Vector2#y} value, it is replaced by the corresponding value.
       * @method clamp
       * @memberof Vector2.prototype
       * @param {Vector2} min The minimum {@link Vector2#x} and {@link Vector2#y} values.
       * @param {Vector2} max The maximum {@link Vector2#x} and {@link Vector2#y} values in the desired range.
       */

    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min.x, Math.min(max.x, this._x));
        this._y = Math.max(min.y, Math.min(max.y, this._y));
        return this;
      }
      /**
       * If this vector's {@link Vector2#x} or {@link Vector2#y} values are greater
       * than the `max` value, they are replaced by the `max` value. If this
       * vector's {@link Vector2#x} or {@link Vector2#y} values are less than the
       * `min` value, they are replaced by the `min` value.
       * @method clampScalar
       * @memberof Vector2.prototype
       * @param {number} minVal The minimum value the components will be clamped to.
       * @param {number} maxVal The maximum value the components will be clamped to.
       */

    }, {
      key: "clampScalar",
      value: function clampScalar(minVal, maxVal) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(minVal, Math.min(maxVal, this._x));
        this._y = Math.max(minVal, Math.min(maxVal, this._y));
        return this;
      }
      /**
       * If this vector's length is greater than the `max` value, it is replaced by
       * the `max` value. If this vector's length is less than the `min` value, it
       * is replaced by the `min` value.
       * @method clampLength
       * @memberof Vector2.prototype
       * @param {number} min The minimum value the length will be clamped to.
       * @param {number} max The maximum value the length will be clamped to.
       */

    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      }
      /**
       * The components of the vector are rounded down to the nearest integer value.
       * @method floor
       * @memberof Vector2.prototype
       */

    }, {
      key: "floor",
      value: function floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y);
        return this;
      }
      /**
       * The {@link Vector2#x} and {@link Vector2#y} components of the vector are
       * rounded up to the nearest integer value.
       * @method ceil
       * @memberof Vector2.prototype
       */

    }, {
      key: "ceil",
      value: function ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y);
        return this;
      }
      /**
       * The components of the vector are rounded to the nearest integer value.
       * @method round
       * @memberof Vector2.prototype
       */

    }, {
      key: "round",
      value: function round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y);
        return this;
      }
      /**
       * The components of the vector are rounded towards zero (up if negative, down
       * if positive) to an integer value.
       * @method roundToZero
       * @memberof Vector2.prototype
       */

    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x);
        this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y);
        return this;
      }
      /**
       * Inverts this vector - i.e. sets `x = -x` and `y = -y`.
       * @method negate
       * @memberof Vector2.prototype
       */

    }, {
      key: "negate",
      value: function negate() {
        this._x = -this._x;
        this._y = -this._y;
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * this vector and `v`.
       * @method dot
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this._x * v.x + this._y * v.y;
      }
      /**
       * Computes the square of the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0)` to `(x, y)`. If you are comparing the
       * lengths of vectors, you should compare the length squared instead as it is
       * slightly more efficient to calculate.
       * @method lengthSq
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this._x * this._x + this._y * this._y;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0)` to `(x, y)`.
       * @method length
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y);
      }
      /**
       * Computes the
       * [Manhattan length](http://en.wikipedia.org/wiki/Taxicab_geometry) of this
       * vector.
       * @method lengthManhattan
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "lengthManhattan",
      value: function lengthManhattan() {
        return Math.abs(this._x) + Math.abs(this._y);
      }
      /**
       * Convert this vector to be a
       * [unit vector](https://en.wikipedia.org/wiki/Unit_vector) - that is, sets it
       * equal to the vector with the same direction as this one, but
       * {@link Vector2#length} 1.
       * @method normalize
       * @memberof Vector2.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
      /**
       * Computes the angle in radians of this vector with respect to the positive
       * x-axis.
       * @method angle
       * @memberof Vector2.prototype
       * @return {number}
       */

    }, {
      key: "angle",
      value: function angle() {
        var angle = Math.atan2(this._y, this._x);
        if (angle < 0) angle += 2 * Math.PI;
        return angle;
      }
      /**
       * Computes the distance from this vector to `v`.
       * @method distanceTo
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      /**
       * Computes the squared distance from this vector to `v`. If you are just
       * comparing the distance with another distance, you should compare the
       * distance squared instead as it is slightly more efficient to calculate.
       * @method distanceToSquared
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this._x - v.x;
        var dy = this._y - v.y;
        return dx * dx + dy * dy;
      }
      /**
       * Computes the
       * [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry)
       * from this vector to `v`.
       * @method distanceToManhattan
       * @memberof Vector2.prototype
       * @param {Vector2} v
       * @return {number}
       */

    }, {
      key: "distanceToManhattan",
      value: function distanceToManhattan(v) {
        return Math.abs(this._x - v.x) + Math.abs(this._y - v.y);
      }
      /**
       * Sets this vector to the vector with the same direction as this one, but
       * {@link Vector2#length} `length`.
       * @method setLength
       * @memberof Vector2.prototype
       * @param {number} length
       */

    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.multiplyScalar(length / this.length());
      }
      /**
       * Linearly interpolate between this vector and `v`, where `alpha` is the
       * distance along the line - `alphq = 0` will be this vector, and `alpha = 1`
       * will be `v`.
       * @method lerp
       * @memberof Vector2.prototype
       * @param {Vector2} v {@link Vector2} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this._x += (v.x - this._x) * alpha;
        this._y += (v.y - this._y) * alpha;
        return this;
      }
      /**
       * Sets this vector to be the vector linearly interpolated between `v1` and
       * `v2` where `alpha` is the distance along the line connecting the two
       * vectors - `alpha = 0` will be `v1`, and `alpha = 1` will be `v2`.
       * @method lerpVectors
       * @memberof Vector2.prototype
       * @param {Vector2} v1 The starting {@link Vector2}.
       * @param {Vector2} v2 {@link Vector2} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
      /**
       * Checks for strict equality of this vector and `v`.
       * @method equals
       * @memberof Vector2.prototype
       * @param  {Vector2} v
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this._x && v.y === this._y;
      }
      /**
       * Sets this vector's {@link Vector2#x} to be `array[0 + offset]` and
       * {@link Vector2#y} to be `array[1 + offset]`.
       * @method fromArray
       * @memberof Vector2.prototype
       * @param  {Array} array The source array.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        return this;
      }
      /**
       * Returns an array `[x, y]`, or copies of {@link Vector2#x} and
       * {@link Vector2#y} into the provided `array`.
       * @method toArray
       * @memberof Vector2.prototype
       * @param  {number[]} [array=[]]  Array to store the vector to. If this is not provided a new array will be created.
       * @param  {number} [offset=0] Optional offset into the array.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        return array;
      }
      /**
       * Rotate the vector around `center` by `angle` in radians.
       * @method rotateAround
       * @memberof Vector2.prototype
       * @param {Vector2} center The point around which to rotate.
       * @param {number} angle The angle to rotate, in radians.
       */

    }, {
      key: "rotateAround",
      value: function rotateAround(center, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var x = this._x - center.x;
        var y = this._y - center.y;
        this._x = x * c - y * s + center.x; // eslint-disable-line no-mixed-operators

        this._y = x * s + y * c + center.y;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
      }
      /**
       * Alias for {@link Vector2#y}.
       * @member {number} height
       * @memberof Vector2#
       */

    }, {
      key: "height",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
      }
      /**
       * @member {number} x
       * @memberof Vector2#
       * @default 0
       */

    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} y
       * @memberof Vector2#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this.onChangeCallback();
      }
    }, {
      key: "isVector2",
      get: function get() {
        return _isVector2;
      }
    }]);

    return Vector2;
  }();

  _exports["default"] = Vector2;
});

/***/ }),

/***/ "./math/Vector3.js":
/*!*************************!*\
  !*** ./math/Vector3.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./Math */ "./math/Math.js"), __webpack_require__(/*! ./Quaternion */ "./math/Quaternion.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Math, _Quaternion) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Quaternion = _interopRequireDefault(_Quaternion);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  // import Euler from './Euler';
  // import Camera from '../camera/Camera';
  // constants for optimisation
  var applyEulerQ;
  var applyAxisAngleQ; // let projectM;
  // let unprojectM;

  var projectOnPlaneV;
  var reflectV; // let this._x = 0, this._y = 0, this._z = 0;

  var onChangeCallback = function onChangeCallback() {};

  var _isVector3 = true;
  /**
   * @class Vector3
   * @classdesc
   * Class representing a 3D [vector](https://en.wikipedia.org/wiki/Vector_space).
   * A 3D vector is an ordered triplet of numbers (labeled `x`, `y`, and `z`),
   * which can be used to represent a number of things, such as:
   * * A point in 3D space.
   * * A direction and length in 3D space. For Letsee, the length will always be
   * the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance)
   * (straight-line distance) from `(0, 0, 0)` to `(x, y, z)` and the direction is
   * also measured from `(0, 0, 0)` towards `(x, y, z)`.
   * * Any arbitrary ordered triplet of numbers.
   * There are other things a 3D vector can be used to represent, such as momentum
   * vectors and so on, however these are the most common uses.
   * @example
   * var a = new Vector3(0, 1, 0);
   *
   * // no arguments; will be initialised to (0, 0, 0)
   * var b = new Vector3();
   *
   * var d = a.distanceTo(b);
   * @param {number} [x=0] The x value of the vector.
   * @param {number} [y=0] The y value of the vector.
   * @param {number} [z=0] The z value of the vector.
   */

  var Vector3 =
  /*#__PURE__*/
  function () {
    function Vector3() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      _classCallCheck(this, Vector3);

      this._x = x;
      this._y = y;
      this._z = z;
    }
    /**
     * @member {number} x
     * @memberof Vector3#
     * @default 0
     */


    _createClass(Vector3, [{
      key: "set",

      /**
       * Sets the {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z}
       * components of this vector.
       * @method set
       * @memberof Vector3.prototype
       * @param {number} x
       * @param {number} y
       * @param {number} z
       */
      value: function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets the {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z} values
       * of this vector all equal to `scalar`.
       * @method setScalar
       * @memberof Vector3.prototype
       * @param {number} scalar
       */

    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this._x = scalar;
        this._y = scalar;
        this._z = scalar;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#x} value with `x`.
       * @method setX
       * @memberof Vector3.prototype
       * @param {number} x
       */

    }, {
      key: "setX",
      value: function setX(x) {
        this._x = x;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#y} value with `y`.
       * @method setY
       * @memberof Vector3.prototype
       * @param {number} y
       */

    }, {
      key: "setY",
      value: function setY(y) {
        this._y = y;
        this.onChangeCallback();
        return this;
      }
      /**
       * Replace this vector's {@link Vector3#z} value with `z`.
       * @method setZ
       * @memberof Vector3.prototype
       * @param {number} z
       */

    }, {
      key: "setZ",
      value: function setZ(z) {
        this._z = z;
        this.onChangeCallback();
        return this;
      }
      /**
       * If `index` equals `0` set {@link Vector3#x} to `value`.
       * If `index` equals `1` set {@link Vector3#y} to `value`.
       * If `index` equals `2` set {@link Vector3#z} to `value`.
       * @method setComponent
       * @memberof Vector3.prototype
       * @param {0|1|2} index
       * @param {number} value
       */

    }, {
      key: "setComponent",
      value: function setComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1 | 2;
        var value = arguments.length > 1 ? arguments[1] : undefined;

        switch (index) {
          case 0:
            this._x = value;
            this.onChangeCallback();
            break;

          case 1:
            this._y = value;
            this.onChangeCallback();
            break;

          case 2:
            this._z = value;
            this.onChangeCallback();
            break;

          default:
            throw new Error("index is out of range: ".concat(index));
        }

        return this;
      }
      /**
       * If `index` equals `0` returns the {@link Vector3#x} value.
       * If `index` equals `1` returns the {@link Vector3#y} value.
       * If `index` equals `2` returns the {@link Vector3#z} value.
       * @method getComponent
       * @memberof Vector3.prototype
       * @param {0|1|2} index
       * @return {number}
       */

    }, {
      key: "getComponent",
      value: function getComponent() {
        var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0 | 1 | 2;

        switch (index) {
          case 0:
            return this._x;

          case 1:
            return this._y;

          case 2:
            return this._z;

          default:
            throw new Error("index is out of range: ".concat(index));
        }
      }
      /**
       * Returns a new {@link Vector3} with the same {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values as this one.
       * @method clone
       * @memberof Vector3.prototype
       * @return {Vector3}
       */

    }, {
      key: "clone",
      value: function clone() {
        return new Vector3(this._x, this._y, this._z);
      }
      /**
       * Copies the values of the passed {@link Vector3}'s {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} properties to this vector.
       * @method copy
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "copy",
      value: function copy(v) {
        this._x = v.x;
        this._y = v.y;
        this._z = v.z; // this.onChangeCallback();

        return this;
      }
      /**
       * Adds `v` to this vector.
       * @method add
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "add",
      value: function add(v) {
        this._x += v.x;
        this._y += v.y;
        this._z += v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Adds the scalar value `s` to this vector's {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values.
       * @method addScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this._x += s;
        this._y += s;
        this._z += s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to `a + b`.
       * @method addVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this._x = a.x + b.x;
        this._y = a.y + b.y;
        this._z = a.z + b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Adds the multiple of `v` and `s` to this vector.
       * @method addScaledVector
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @param {number} s
       */

    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this._x += v.x * s;
        this._y += v.y * s;
        this._z += v.z * s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Subtracts `v` from this vector.
       * @method sub
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "sub",
      value: function sub(v) {
        this._x -= v.x;
        this._y -= v.y;
        this._z -= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Subtracts `s` from this vector's {@link Vector3#x}, {@link Vector3#y}, and
       * {@link Vector3#z} components.
       * @method subScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this._x -= s;
        this._y -= s;
        this._z -= s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to `a - b`.
       * @method subVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this._x = a.x - b.x;
        this._y = a.y - b.y;
        this._z = a.z - b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this vector by `v`.
       * @method multiply
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "multiply",
      value: function multiply(v) {
        this._x *= v.x;
        this._y *= v.y;
        this._z *= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Multiplies this vector by scalar `s`.
       * @method multiplyScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector equal to `a × b`.
       * @method multiplyVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "multiplyVectors",
      value: function multiplyVectors(a, b) {
        this._x = a.x * b.x;
        this._y = a.y * b.y;
        this._z = a.z * b.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Applies euler transform to this vector by converting the {@link Euler}
       * object to a {@link Quaternion} and applying.
       * @method applyEuler
       * @memberof Vector3.prototype
       * @param {Euler} euler
       */

    }, {
      key: "applyEuler",
      value: function applyEuler(euler) {
        if (typeof applyEulerQ === 'undefined') {
          applyEulerQ = new _Quaternion["default"]();
        }

        return this.applyQuaternion(applyEulerQ.setFromEuler(euler));
      }
      /**
       * Applies a rotation specified by an `axis` and an `angle` to this vector.
       * @method applyAxisAngle
       * @memberof Vector3.prototype
       * @param {Vector3} axis A normalized {@link Vector3}.
       * @param {number} angle An angle in radians.
       */

    }, {
      key: "applyAxisAngle",
      value: function applyAxisAngle(axis, angle) {
        if (typeof applyAxisAngleQ === 'undefined') {
          applyAxisAngleQ = new _Quaternion["default"]();
        }

        return this.applyQuaternion(applyAxisAngleQ.setFromAxisAngle(axis, angle));
      }
      /**
       * Multiplies this vector (with an implicit `1` in the 4th dimension) and `m`,
       * and divides by perspective.
       * @method applyMatrix4
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var e = m.elements;
        this._x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this._y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this._z = e[2] * x + e[6] * y + e[10] * z + e[14];
        var w = e[3] * x + e[7] * y + e[11] * z + e[15];
        return this.divideScalar(w);
      }
      /**
       * Applies a {@link Quaternion} transform this vector.
       * @method applyQuaternion
       * @memberof Vector3.prototype
       * @param {Quaternion} q
       */

    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w; // calculate quat * vector

        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

        this._x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this._y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this._z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        this.onChangeCallback();
        return this;
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) the vector
       * with the `camera`.
       * @method project
       * @memberof Vector3.prototype
       * @param {Camera} camera Camera to use in the projection.
       */

    }, {
      key: "project",
      value: function project(camera) {
        // if (typeof projectM === 'undefined') {
        //   projectM = new Matrix4();
        // }
        //
        // projectM.multiplyMatrices(camera.projectionMatrix, projectM.getInverse(camera.matrixWorld));
        // return this.applyMatrix4(projectM);
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      /**
       * [Unprojects](https://en.wikipedia.org/wiki/Vector_projection) the vector
       * with the `camera`'s projection matrix.
       * @method unproject
       * @memberof Vector3.prototype
       * @param {Camera} camera Camera to use in the projection.
       */

    }, {
      key: "unproject",
      value: function unproject(camera) {
        // if (typeof unprojectM === 'undefined') {
        //   unprojectM = new Matrix4();
        // }
        //
        // unprojectM.multiplyMatrices(camera.matrixWorld, unprojectM.getInverse(camera.projectionMatrix));
        // return this.applyMatrix4(unprojectM);
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      /**
       * Transforms the direction of this vector by a matrix (the upper left 3 x 3
       * subset of the `m`) and then [normalizes]{@link Vector3#normalize} the
       * result.
       * @method transformDirection
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        // input affine matrix
        // vector interpreted as a direction
        var x = this._x;
        var y = this._y;
        var z = this._z;
        var e = m.elements;
        this._x = e[0] * x + e[4] * y + e[8] * z;
        this._y = e[1] * x + e[5] * y + e[9] * z;
        this._z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      }
      /**
       * Divides this vector by `v`.
       * @method divide
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "divide",
      value: function divide(v) {
        this._x /= v.x;
        this._y /= v.y;
        this._z /= v.z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Divides this vector by scalar `s`. Sets vector to `(0, 0, 0)` if `s = 0`.
       * @method divideScalar
       * @memberof Vector3.prototype
       * @param {number} s
       */

    }, {
      key: "divideScalar",
      value: function divideScalar(s) {
        return this.multiplyScalar(1 / s);
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is greater than `v`'s {@link Vector3#x}, {@link Vector3#y}, or
       * {@link Vector3#z} value, replace that value with the corresponding min
       * value.
       * @method min
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "min",
      value: function min(v) {
        this._x = Math.min(this._x, v.x);
        this._y = Math.min(this._y, v.y);
        this._z = Math.min(this._z, v.z);
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is less than `v`'s {@link Vector3#x}, {@link Vector3#y}, or
       * {@link Vector3#z} value, replace that value with the corresponding max
       * value.
       * @method max
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "max",
      value: function max(v) {
        this._x = Math.max(this._x, v.x);
        this._y = Math.max(this._y, v.y);
        this._z = Math.max(this._z, v.z);
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * value is greater than the `max` vector's {@link Vector3#x},
       * {@link Vector3#y}, or {@link Vector3#z} value, it is replaced by the
       * corresponding value. If this vector's {@link Vector3#x}, {@link Vector3#y},
       * or {@link Vector3#z} value is less than the `min` vector's
       * {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z} value, it is
       * replaced by the corresponding value.
       * @method clamp
       * @memberof Vector3.prototype
       * @param {Vector3} min
       * @param {Vector3} max
       */

    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min.x, Math.min(max.x, this._x));
        this._y = Math.max(min.y, Math.min(max.y, this._y));
        this._z = Math.max(min.z, Math.min(max.z, this._z));
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * values are greater than the `max` value, it is replaced by the `max` value.
       * If this vector's {@link Vector3#x}, {@link Vector3#y}, or {@link Vector3#z}
       * values are less than the `min` value, it is replaced by the `min` value.
       * @method clampScalar
       * @memberof Vector3.prototype
       * @param {number} min The minimum value the components will be clamped to.
       * @param {number} max The maximum value the components will be clamped to.
       */

    }, {
      key: "clampScalar",
      value: function clampScalar(min, max) {
        // This function assumes min < max, if this assumption isn't true it will not operate correctly
        this._x = Math.max(min, Math.min(max, this._x));
        this._y = Math.max(min, Math.min(max, this._y));
        this._z = Math.max(min, Math.min(max, this._z));
        this.onChangeCallback();
        return this;
      }
      /**
       * If this vector's length is greater than the `max` value, it is replaced by
       * the `max` value. If this vector's length is less than the `min` value, it
       * is replaced by the `min` value.
       * @method clampLength
       * @memberof Vector3.prototype
       * @param {number} min The minimum value the length will be clamped to.
       * @param {number} max The maximum value the length will be clamped to.
       */

    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.multiplyScalar(Math.max(min, Math.min(max, length)) / length);
      }
      /**
       * The components of the vector are rounded down to the nearest integer value.
       * @method floor
       * @memberof Vector3.prototype
       */

    }, {
      key: "floor",
      value: function floor() {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y);
        this._z = Math.floor(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The {@link Vector3#x}, {@link Vector3#y}, and {@link Vector3#z} components
       * of the vector are rounded up to the nearest integer value.
       * @method ceil
       * @memberof Vector3.prototype
       */

    }, {
      key: "ceil",
      value: function ceil() {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y);
        this._z = Math.ceil(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The components of the vector are rounded to the nearest integer value.
       * @method round
       * @memberof Vector3.prototype
       */

    }, {
      key: "round",
      value: function round() {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y);
        this._z = Math.round(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * The components of the vector are rounded towards zero (up if negative,
       * down if positive) to an integer value.
       * @method roundToZero
       * @memberof Vector3.prototype
       */

    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this._x = this._x < 0 ? Math.ceil(this._x) : Math.floor(this._x);
        this._y = this._y < 0 ? Math.ceil(this._y) : Math.floor(this._y);
        this._z = this._z < 0 ? Math.ceil(this._z) : Math.floor(this._z);
        this.onChangeCallback();
        return this;
      }
      /**
       * Inverts this vector - i.e. sets `x = -x`, `y = -y`, and `z = -z`.
       * @method negate
       * @memberof Vector3.prototype
       */

    }, {
      key: "negate",
      value: function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this.onChangeCallback();
        return this;
      }
      /**
       * Calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) of
       * this vector and `v`.
       * @method dot
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "dot",
      value: function dot(v) {
        return this._x * v.x + this._y * v.y + this._z * v.z;
      }
      /**
       * Computes the square of the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0, 0)` to `(x, y, z)`. If you are
       * comparing lengths of vectors, you should compare the length squared
       * instead as it is slightly more efficient to calculate.
       * @method lengthSq
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z;
      }
      /**
       * Computes the
       * [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance)
       * (straight-line length) from `(0, 0, 0)` to `(x, y, z)`.
       * @method length
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
      }
      /**
       * Computes the
       * [Manhattan length](http://en.wikipedia.org/wiki/Taxicab_geometry) of this
       * vector.
       * @method lengthManhattan
       * @memberof Vector3.prototype
       * @return {number}
       */

    }, {
      key: "lengthManhattan",
      value: function lengthManhattan() {
        return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
      }
      /**
       * Convert this vector to a
       * [unit vector](https://en.wikipedia.org/wiki/Unit_vector) - that is, sets
       * it equal to the vector with the same direction as this one, but
       * {@link Vector3#length} `1`.
       * @method normalize
       * @memberof Vector3.prototype
       */

    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length());
      }
      /**
       * Sets this vector to the vector with the same direction as this one, but
       * {@link Vector3#length} `length`.
       * @method setLength
       * @memberof Vector3.prototype
       * @param {number} length
       */

    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.multiplyScalar(length / this.length());
      }
      /**
       * Linearly interpolate between this vector and `v`, where `alpha` is the
       * distance along the line - `alpha = 0` will be this vector, and `alpha = 1`
       * will be `v`.
       * @method lerp
       * @memberof Vector3.prototype
       * @param {Vector3} v {@link Vector3} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this._x += (v.x - this._x) * alpha;
        this._y += (v.y - this._y) * alpha;
        this._z += (v.z - this._z) * alpha;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to be the vector linearly interpolated between `v1` and
       * `v2` where `alpha` is the distance along the line connecting the two
       * vectors - `alpha = 0` will be `v1`, and `alpha = 1` will be `v2`.
       * @method lerpVectors
       * @memberof Vector3.prototype
       * @param {Vector3} v1 The starting {@link Vector3}.
       * @param {Vector3} v2 {@link Vector3} to interpolate towards.
       * @param {number} alpha Interpolation factor in the closed interval `[0, 1]`.
       */

    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
      }
      /**
       * Sets this vector to
       * [cross product](https://en.wikipedia.org/wiki/Cross_product) of itself and
       * `v`.
       * @method cross
       * @memberof Vector3.prototype
       * @param {Vector3} v
       */

    }, {
      key: "cross",
      value: function cross(v) {
        var x = this._x;
        var y = this._y;
        var z = this._z;
        this._x = y * v.z - z * v.y;
        this._y = z * v.x - x * v.z;
        this._z = x * v.y - y * v.x;
        this.onChangeCallback();
        return this;
      }
      /**
       * Sets this vector to
       * [cross product](https://en.wikipedia.org/wiki/Cross_product) of `a` and
       * `b`.
       * @method crossVectors
       * @memberof Vector3.prototype
       * @param {Vector3} a
       * @param {Vector3} b
       */

    }, {
      key: "crossVectors",
      value: function crossVectors(a, b) {
        var ax = a.x;
        var ay = a.y;
        var az = a.z;
        var bx = b.x;
        var by = b.y;
        var bz = b.z;
        this._x = ay * bz - az * by;
        this._y = az * bx - ax * bz;
        this._z = ax * by - ay * bx;
        this.onChangeCallback();
        return this;
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) this vector
       * onto another `vector`.
       * @method projectOnVector
       * @memberof Vector3.prototype
       * @param {Vector3} vector
       */

    }, {
      key: "projectOnVector",
      value: function projectOnVector(vector) {
        var scalar = vector.dot(this) / vector.lengthSq();
        return this.copy(vector).multiplyScalar(scalar);
      }
      /**
       * [Projects](https://en.wikipedia.org/wiki/Vector_projection) this vector
       * onto a plane by subtracting this vector projected onto the plane's normal
       * from this vector.
       * @method projectOnPlane
       * @memberof Vector3.prototype
       * @param {Vector3} planeNormal A vector representing a plane normal.
       */

    }, {
      key: "projectOnPlane",
      value: function projectOnPlane(planeNormal) {
        if (typeof projectOnPlaneV === 'undefined') {
          projectOnPlaneV = new Vector3();
        }

        projectOnPlaneV.copy(this).projectOnVector(planeNormal);
        return this.sub(projectOnPlaneV);
      }
      /**
       * Reflect the vector off of plane orthogonal to `normal`. `normal` is
       * assumed to have unit length.
       * @method reflect
       * @memberof Vector3.prototype
       * @param {Vector3} normal The normal to the reflecting plane.
       */

    }, {
      key: "reflect",
      value: function reflect(normal) {
        if (typeof reflectV === 'undefined') {
          reflectV = new Vector3();
        }

        return this.sub(reflectV.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
      /**
       * Returns the angle between this vector and vector `v` in radians.
       * @method angleTo
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "angleTo",
      value: function angleTo(v) {
        var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq()); // clamp, to handle numerical problems

        return Math.acos((0, _Math.clamp)(theta, -1, 1));
      }
      /**
       * Computes the distance from this vector to `v`.
       * @method distanceTo
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      /**
       * Computes the squared distance from this vector to `v`. If you are just
       * comparing the distance with another distance, you should compare the
       * distance squared instead as it is slightly more efficient to calculate.
       * @method distanceToSquared
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this._x - v.x;
        var dy = this._y - v.y;
        var dz = this._z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
      /**
       * Computes the
       * [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry) from
       * this vector to `v`.
       * @method distanceToManhattan
       * @memberof Vector3.prototype
       * @param {Vector3} v
       * @return {number}
       */

    }, {
      key: "distanceToManhattan",
      value: function distanceToManhattan(v) {
        return Math.abs(this._x - v.x) + Math.abs(this._y - v.y) + Math.abs(this._z - v.z);
      }
      /**
       * Set this vector to the position elements of the
       * [transform matrix](https://en.wikipedia.org/wiki/Transformation_matrix)
       * `m`.
       * @method setFromMatrixPosition
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrixPosition",
      value: function setFromMatrixPosition(m) {
        // return this.setFromMatrixColumn(m, 3);
        var e = m.elements;
        this._x = e[12];
        this._y = e[13];
        this._z = e[14];
        return this;
      }
      /**
       * Sets this vector to the scale elements of the
       * [transform matrix](https://en.wikipedia.org/wiki/Transformation_matrix)
       * `m`.
       * @method setFromMatrixScale
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       */

    }, {
      key: "setFromMatrixScale",
      value: function setFromMatrixScale(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this._x = sx;
        this._y = sy;
        this._z = sz;
        this.onChangeCallback(); // TODO redundant

        return this;
      }
      /**
       * Sets this vector's {@link Vector3#x}, {@link Vector3#y}, and
       * {@link Vector3#z} equal to the column of the `matrix` specified by the
       * `index`.
       * @method setFromMatrixColumn
       * @memberof Vector3.prototype
       * @param {Matrix4} m
       * @param {number} index
       */

    }, {
      key: "setFromMatrixColumn",
      value: function setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
      /**
       * Checks for strict equality of this vector and `v`.
       * @method equals
       * @memberof Vector3.prototype
       * @param  {Vector3} v
       * @return {boolean}
       */

    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this._x && v.y === this._y && v.z === this._z;
      }
      /**
       * Sets this vector's {@link Vector3#x} value to be `array[0 + offset]`,
       * {@link Vector3#y} value to be `array[1 + offset]`, {@link Vector3#z} value
       * to be `array[2 + offset]`.
       * @method fromArray
       * @memberof Vector3.prototype
       * @param  {number[]} array  The source array.
       * @param  {number} [offset=0] Offset into the array.
       */

    }, {
      key: "fromArray",
      value: function fromArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this._x = array[offset + 0];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this.onChangeCallback();
        return this;
      }
      /**
       * Returns an array `[x, y, z]`, or copies {@link Vector3#x},
       * {@link Vector3#y}, and {@link Vector3#z} values into the provided `array`.
       * @method toArray
       * @memberof Vector3.prototype
       * @param  {number[]} [array=[]] Array to store the vector to. If this is not provided a new array will be created.
       * @param  {number} [offset=0] Optional offset into the array.
       * @return {number[]}
       */

    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset + 0] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        return array;
      }
    }, {
      key: "onChange",
      value: function onChange(callback) {
        this.onChangeCallback = callback;
        return this;
      }
    }, {
      key: "onChangeCallback",
      value: function onChangeCallback() {}
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} y
       * @memberof Vector3#
       * @default 0
       */

    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this.onChangeCallback();
      }
      /**
       * @member {number} z
       * @memberof Vector3#
       * @default 0
       */

    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this.onChangeCallback();
      }
    }, {
      key: "isVector3",
      get: function get() {
        return _isVector3;
      }
    }]);

    return Vector3;
  }();

  _exports["default"] = Vector3;
});

/***/ }),

/***/ "./observers/Observer.js":
/*!*******************************!*\
  !*** ./observers/Observer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../core/Data */ "./core/Data.js"), __webpack_require__(/*! ../Util */ "./Util.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Data, _Util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var Observer =
  /*#__PURE__*/
  function () {
    function Observer(target, handlers) {
      _classCallCheck(this, Observer);

      if ((0, _Util.isNil)(_Data.EventDataObject.getTarget(target))) {
        _Data.EventDataObject.addHandler(target, handlers);
      }
    }

    _createClass(Observer, [{
      key: "subscribe",
      value: function subscribe(target, type, callback) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler.add(callback);
        } else {
          console.warn(handler);
        }
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(target, type, callback) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler["delete"](callback);
        } else {
          console.warn(handler);
        }
      }
    }, {
      key: "notify",
      value: function notify(target, type, args) {
        var handler = _Data.EventDataObject.getHandler(target, type);

        if (handler instanceof Set) {
          handler.forEach(function (value) {
            return value(args);
          });
        } else {
          console.warn(handler);
        }
      }
    }]);

    return Observer;
  }();

  _exports["default"] = Observer;
});

/***/ }),

/***/ "./observers/observer/EntityObserver.js":
/*!**********************************************!*\
  !*** ./observers/observer/EntityObserver.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../../entity/EntityEvent */ "./entity/EntityEvent.js"), __webpack_require__(/*! ../../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Observer2, _EntityEvent, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Observer2 = _interopRequireDefault(_Observer2);
  _EntityEvent = _interopRequireDefault(_EntityEvent);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  // import Matrix4 from '../math/Matrix4';[
  var EntityType = {
    type: null,
    target: null,
    matrix: null,
    pixelSize: {
      width: 0.0,
      height: 0.0,
      depth: 0.0
    },
    scale: 1.0
  };
  var handlers = new Map([[_MessageTypes.ENTITY_EVENT.TRACK_START, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_MOVE, new Set()], [_MessageTypes.ENTITY_EVENT.TRACK_END, new Set()]]);
  var target = _MessageTypes.ENTITY_EVENT.TARGET;

  var EntityObserver =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(EntityObserver, _Observer);

    function EntityObserver() {
      _classCallCheck(this, EntityObserver);

      return _possibleConstructorReturn(this, _getPrototypeOf(EntityObserver).call(this, target, handlers));
    }

    _createClass(EntityObserver, [{
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(EntityObserver.prototype), "subscribe", this)).call.apply(_get2, [this, target, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(EntityObserver.prototype), "unsubscribe", this).call(this, target, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        if (event instanceof _EntityEvent["default"]) {
          _get(_getPrototypeOf(EntityObserver.prototype), "notify", this).call(this, target, type, event);
        } else {// console.
        }
      }
    }]);

    return EntityObserver;
  }(_Observer2["default"]);

  _exports["default"] = EntityObserver;
});

/***/ }),

/***/ "./observers/observer/LetseeObserver.js":
/*!**********************************************!*\
  !*** ./observers/observer/LetseeObserver.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Observer */ "./observers/Observer.js"), __webpack_require__(/*! ../../libs/MessageTypes */ "./libs/MessageTypes.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Observer2, _MessageTypes) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Observer2 = _interopRequireDefault(_Observer2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var handlers = new Map([[_MessageTypes.LETSEE_EVENT.ON_LOAD, new Set()], [_MessageTypes.LETSEE_EVENT.ON_STATUS, new Set()], [_MessageTypes.LETSEE_EVENT.ROTATION_CHANGE, new Set()], [_MessageTypes.LETSEE_EVENT.TRACK_START, new Set()], [_MessageTypes.LETSEE_EVENT.TRACK_MOVE, new Set()], [_MessageTypes.LETSEE_EVENT.TRACK_END, new Set()]]);
  var target = _MessageTypes.LETSEE_EVENT.TARGET;

  var LetseeObserver =
  /*#__PURE__*/
  function (_Observer) {
    _inherits(LetseeObserver, _Observer);

    function LetseeObserver() {
      _classCallCheck(this, LetseeObserver);

      return _possibleConstructorReturn(this, _getPrototypeOf(LetseeObserver).call(this, target, handlers));
    }

    _createClass(LetseeObserver, [{
      key: "subscribe",
      value: function subscribe(type, callback) {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(LetseeObserver.prototype), "subscribe", this)).call.apply(_get2, [this, target, type, callback].concat(args));
      }
    }, {
      key: "unsubscribe",
      value: function unsubscribe(type, callback) {
        _get(_getPrototypeOf(LetseeObserver.prototype), "unsubscribe", this).call(this, target, type, callback);
      }
    }, {
      key: "notify",
      value: function notify(type, event) {
        _get(_getPrototypeOf(LetseeObserver.prototype), "notify", this).call(this, target, type, event);
      }
    }]);

    return LetseeObserver;
  }(_Observer2["default"]);

  _exports["default"] = LetseeObserver;
});

/***/ }),

/***/ "./renderer/DOMRenderable.js":
/*!***********************************!*\
  !*** ./renderer/DOMRenderable.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./DOMRenderer */ "./renderer/DOMRenderer.js"), __webpack_require__(/*! ../core/Object3D */ "./core/Object3D.js"), __webpack_require__(/*! ../core/Data */ "./core/Data.js"), __webpack_require__(/*! ../libs/MessageTypes */ "./libs/MessageTypes.js"), __webpack_require__(/*! ../Util */ "./Util.js"), __webpack_require__(/*! ../Context */ "./Context.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _DOMRenderer, _Object3D2, _Data, _MessageTypes, _Util, _Context) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports["default"] = void 0;
  _Object3D2 = _interopRequireDefault(_Object3D2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var _type = 'DOMRenderable';
  var _isDOMRenderable = true;
  var ghostId = 0;
  /**
   * @class Class representing a HTML element that can be augmented.
   * @name DOMRenderable
   * @param {HTMLElement} element - HTML Element
   * @returns {DOMRenderable}
   * @example
   * // Create HTML element
   * // HTML 엘리먼트를 생성합니다.
   * const sampleElement = document.createElement('div');
   *
   * // or get exist element
   * // 또한 DOM상에 존재하는 HTML 엘리먼트를 사용할 수도 있습니다.
   * const existElement = document.getElementById('foo');
   *
   * // Create DOM Renderable
   * // DOM Renderable을 생성합니다.
   * const sampleRenderable = new DOMRenderable(sampleElement);
   * const existRenderable = new DOMRenderable(existElement);
   *
   * // 생성한 renderable을 엔터티에 등록합니다.
   * entity.addRenderable(sampleRenderable);
   * entity.addRenderable(existRenderable);
   */

  var DOMRenderable =
  /*#__PURE__*/
  function (_Object3D) {
    _inherits(DOMRenderable, _Object3D);

    function DOMRenderable(element) {
      var _this;

      _classCallCheck(this, DOMRenderable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMRenderable).call(this)); // this.renderer = new DOMRenderer();

      if ((0, _Util.isNull)(element.parentElement)) document.getElementById(_Context.context.placeholderId).appendChild(element);
      var originalElement = element.cloneNode(true);
      var ghostElement = document.createElement('div');
      ghostElement.id = "ghost-".concat(ghostId);
      ghostElement.style.setProperty('display', 'none', 'important'); // ghostElement.style.display = 'none !important'

      _Data.EntityDataObject.addElement(element, new Map([['original', originalElement], ['ghost', ghostElement]]));

      ghostId++;
      _this.element = element;
      _this.element.style.position = 'absolute';
      _this.element.style.display = 'none';
      _this.element.style.willChange = 'transform';
      _this.isAddedToCamera = false; // this.element.style.backfaceVisibility = 'hidden';
      // this.element.style.WebkitBackfaceVisibility = 'hidden';

      _this.subscribe(_MessageTypes.OBJECT_EVENT.OBJECT_ADDED, function (e) {
        if (e.target.isDOMRenderable) _this.added(e);
      });

      _this.subscribe(_MessageTypes.OBJECT_EVENT.OBJECT_REMOVED, function (e) {
        if (e.target.isDOMRenderable) _this.removed(e);
      });

      return _this;
    }

    _createClass(DOMRenderable, [{
      key: "added",
      value: function added(e) {
        if (this.parent && this.parent.track) this.element.style.display = '';
        var object = e.target;

        while (true) {
          if (object.isScene) {
            if (!this.isAddedToCamera) {
              _DOMRenderer.domRenderer.appendElement(this.element);

              this.isAddedToCamera = true;
            }

            break;
          }

          if (object.parent) {
            object = object.parent;
          } else {
            break;
          }
        }
      }
    }, {
      key: "removed",
      value: function removed(e) {
        if (this.element.parentNode && this.element.parentNode.removeChild) {
          this.element.parentNode.removeChild(this.element);
        }
      }
    }, {
      key: "isDOMRenderable",
      get: function get() {
        return _isDOMRenderable;
      }
    }, {
      key: "type",
      get: function get() {
        return _type;
      }
    }]);

    return DOMRenderable;
  }(_Object3D2["default"]);

  _exports["default"] = DOMRenderable;
});

/***/ }),

/***/ "./renderer/DOMRenderer.js":
/*!*********************************!*\
  !*** ./renderer/DOMRenderer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ../Context */ "./Context.js"), __webpack_require__(/*! ../core/Scene */ "./core/Scene.js"), __webpack_require__(/*! ../math/Math */ "./math/Math.js"), __webpack_require__(/*! ../observers/observer/EntityObserver */ "./observers/observer/EntityObserver.js"), __webpack_require__(/*! ../core/Data */ "./core/Data.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (_exports, _Context, _Scene, _Math, _EntityObserver2, _Data) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.domRenderer = void 0;
  _Scene = _interopRequireDefault(_Scene);
  _EntityObserver2 = _interopRequireDefault(_EntityObserver2);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  var epsilon = function epsilon(value) {
    return Math.abs(value) < 1e-10 ? 0 : value;
  };

  var getCameraCSSMatrix = function getCameraCSSMatrix(camera) {
    var cameraMatrix = camera.matrixWorldInverse.elements.map(function (element, index) {
      return index === 1 || index === 5 || index === 9 || index === 13 ? epsilon(-element) : epsilon(element);
    });
    return "matrix3d(".concat(cameraMatrix.join(','), ")");
  };

  var getObjectCSSMatrix = function getObjectCSSMatrix(renderable) {
    renderable.updateMatrix();
    var objectMatrix = renderable.matrixWorld.elements.map(function (element, index) {
      return index >= 4 && index <= 7 ? epsilon(-element) : epsilon(element);
    });
    return "translate(-50%,-50%) matrix3d(".concat(objectMatrix.join(','), ")");
  };

  var _cachedStyles;

  var _camera = null;

  var _scene = new _Scene["default"]();

  var _domElement = document.createElement('div');

  var _cameraElement = document.createElement('div');

  var DOMRenderer =
  /*#__PURE__*/
  function (_EntityObserver) {
    _inherits(DOMRenderer, _EntityObserver);

    function DOMRenderer() {
      var _this;

      _classCallCheck(this, DOMRenderer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DOMRenderer).call(this));
      _cachedStyles = {};
      _domElement.style.overflow = 'hidden';
      _domElement.style.WebkitTransformStyle = 'preserve-3d';
      _domElement.style.transformStyle = 'preserve-3d';
      _domElement.className = 'ar-renderer';
      _domElement.style.position = 'fixed';
      _domElement.style.top = '0';
      _domElement.style.left = '0';
      _domElement.style.margin = '0';
      _domElement.style.padding = '0';
      _domElement.style.zIndex = '110';
      _cameraElement.style.WebkitTransformStyle = 'preserve-3d';
      _cameraElement.style.transformStyle = 'preserve-3d';

      _domElement.appendChild(_cameraElement);

      _this.subscribe('trackmove', function (e) {
        return _this.render(e);
      });

      _this.subscribe('trackstart', function (e) {
        return _this.render(e);
      });

      _this.subscribe('trackend', function (e) {
        return _this.render(e);
      });

      _this._width = 0;
      _this._height = 0;
      return _this;
    }

    _createClass(DOMRenderer, [{
      key: "initRenderer",
      value: function initRenderer(camera, id, zIndex, zIndexIncrement) {
        _camera = camera;
        this.width = _Context.context.width;
        this.height = _Context.context.height;
        this.setSize();
        _domElement.id = id;
        _domElement.style.zIndex = zIndex + zIndexIncrement;
        document.body.insertBefore(_domElement, document.body.firstChild);
      }
    }, {
      key: "updateOrientation",
      value: function updateOrientation(newConfig) {
        this.width = newConfig.width;
        this.height = newConfig.height;
        this.setSize();
      }
    }, {
      key: "setSize",
      value: function setSize() {
        _domElement.style.width = _cameraElement.style.width = "".concat(this.width, "px");
        _domElement.style.height = _cameraElement.style.height = "".concat(this.height, "px");
      }
    }, {
      key: "add",
      value: function add(object) {
        _scene.add(object);
      }
    }, {
      key: "remove",
      value: function remove(object) {
        _scene.remove(object);
      }
    }, {
      key: "appendElement",
      value: function appendElement(element) {
        if (_Data.EntityDataObject.getElement(element) != null) {
          var ghost = _Data.EntityDataObject.getElement(element).get('ghost');

          var original = _Data.EntityDataObject.getElement(element).get('original');

          if (original.parentElement === null) {
            element.parentElement.replaceChild(ghost, element);

            _cameraElement.appendChild(element);
          } else {
            original.parentElement.replaceChild(element, original);
          }
        }
      }
    }, {
      key: "appendAllElements",
      value: function appendAllElements() {
        _Data.EntityDataObject.getAllElements().forEach(function (value, key) {
          var ghost = value.get('ghost');
          var original = value.get('original');
          original.parentElement.replaceChild(ghost, original);

          _cameraElement.appendChild(key);
        });
      }
    }, {
      key: "resetElement",
      value: function resetElement() {
        _Data.EntityDataObject.getAllElements().forEach(function (value, key) {
          var ghost = value.get('ghost');
          var original = value.get('original');
          ghost.parentElement.replaceChild(original, ghost);

          _cameraElement.removeChild(key);
        });
      }
    }, {
      key: "removeElement",
      value: function removeElement(element) {
        _cameraElement.removeChild(element);
      }
    }, {
      key: "onTrackMove",
      value: function onTrackMove(e) {}
    }, {
      key: "onTrackStart",
      value: function onTrackStart(e) {}
    }, {
      key: "onTrackEnd",
      value: function onTrackEnd(e) {}
    }, {
      key: "render",
      value: function render(e) {
        if (_camera) {
          var fov = 0.5 / Math.tan((0, _Math.degToRad)(_camera.getEffectiveFOV() * 0.5)) * this.height;
          var cameraCSSMatrix = "translateZ(".concat(fov, "px)").concat(getCameraCSSMatrix(_camera));
          var cameraTransform = "".concat(cameraCSSMatrix, "translate(").concat(this.width * 0.5, "px,").concat(this.height * 0.5, "px)");
          _domElement.style.WebkitPerspective = "".concat(fov, "px");
          _domElement.style.perspective = "".concat(fov, "px");
          _cameraElement.style.WebkitTransform = cameraTransform;
          _cameraElement.style.transform = cameraTransform;
          this.setSize();

          _scene.traverse(function (obj) {
            if (obj.element) {
              var element = obj.element;
              var style = getObjectCSSMatrix(obj);
              var cachedStyle = _cachedStyles[obj.id];

              if (cachedStyle === undefined || cachedStyle !== style) {
                element.style.WebkitTransform = style;
                element.style.transform = style;
                _cachedStyles[obj.id] = style;
              }
            }
          });
        }
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
      }
    }, {
      key: "scene",
      get: function get() {
        return _scene;
      }
    }]);

    return DOMRenderer;
  }(_EntityObserver2["default"]);

  var domRenderer = new DOMRenderer();
  _exports.domRenderer = domRenderer;
});

/***/ }),

/***/ "./vendor/adapter_no_edge.js":
/*!***********************************!*\
  !*** ./vendor/adapter_no_edge.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function () {
  "use strict";

  function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

  (function (f) {
    if (( false ? undefined : _typeof2(exports)) === "object" && typeof module !== "undefined") {
      module.exports = f();
    } else if (true) {
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else { var g; }
  })(function () {
    var define, module, exports;
    return function () {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof require && require;
              if (!f && c) return require(i, !0);
              if (u) return u(i, !0);
              var a = new Error("Cannot find module '" + i + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }

            var p = n[i] = {
              exports: {}
            };
            e[i][0].call(p.exports, function (r) {
              var n = e[i][1][r];
              return o(n || r);
            }, p, p.exports, r, e, n, t);
          }

          return n[i].exports;
        }

        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
          o(t[i]);
        }

        return o;
      }

      return r;
    }()({
      1: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        var _adapter_factory = require('./adapter_factory.js');

        var adapter = (0, _adapter_factory.adapterFactory)({
          window: window
        });
        module.exports = adapter; // this is the difference from adapter_core.
      }, {
        "./adapter_factory.js": 2
      }],
      2: [function (require, module, exports) {
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.adapterFactory = adapterFactory;

        var _utils = require('./utils');

        var utils = _interopRequireWildcard(_utils);

        var _chrome_shim = require('./chrome/chrome_shim');

        var chromeShim = _interopRequireWildcard(_chrome_shim);

        var _edge_shim = require('./edge/edge_shim');

        var edgeShim = _interopRequireWildcard(_edge_shim);

        var _firefox_shim = require('./firefox/firefox_shim');

        var firefoxShim = _interopRequireWildcard(_firefox_shim);

        var _safari_shim = require('./safari/safari_shim');

        var safariShim = _interopRequireWildcard(_safari_shim);

        var _common_shim = require('./common_shim');

        var commonShim = _interopRequireWildcard(_common_shim);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        } // Shimming starts here.

        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */


        function adapterFactory() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              window = _ref.window;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            shimChrome: true,
            shimFirefox: true,
            shimEdge: true,
            shimSafari: true
          }; // Utils.

          var logging = utils.log;
          var browserDetails = utils.detectBrowser(window);
          var adapter = {
            browserDetails: browserDetails,
            commonShim: commonShim,
            extractVersion: utils.extractVersion,
            disableLog: utils.disableLog,
            disableWarnings: utils.disableWarnings
          }; // Shim browser if found.

          switch (browserDetails.browser) {
            case 'chrome':
              if (!chromeShim || !chromeShim.shimPeerConnection || !options.shimChrome) {
                logging('Chrome shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming chrome.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = chromeShim;
              chromeShim.shimGetUserMedia(window);
              chromeShim.shimMediaStream(window);
              chromeShim.shimPeerConnection(window);
              chromeShim.shimOnTrack(window);
              chromeShim.shimAddTrackRemoveTrack(window);
              chromeShim.shimGetSendersWithDtmf(window);
              chromeShim.shimGetStats(window);
              chromeShim.shimSenderReceiverGetStats(window);
              chromeShim.fixNegotiationNeeded(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;

            case 'firefox':
              if (!firefoxShim || !firefoxShim.shimPeerConnection || !options.shimFirefox) {
                logging('Firefox shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming firefox.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = firefoxShim;
              firefoxShim.shimGetUserMedia(window);
              firefoxShim.shimPeerConnection(window);
              firefoxShim.shimOnTrack(window);
              firefoxShim.shimRemoveStream(window);
              firefoxShim.shimSenderGetStats(window);
              firefoxShim.shimReceiverGetStats(window);
              firefoxShim.shimRTCDataChannel(window);
              firefoxShim.shimAddTransceiver(window);
              firefoxShim.shimCreateOffer(window);
              firefoxShim.shimCreateAnswer(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimConnectionState(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;

            case 'edge':
              if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
                logging('MS edge shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming edge.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = edgeShim;
              edgeShim.shimGetUserMedia(window);
              edgeShim.shimGetDisplayMedia(window);
              edgeShim.shimPeerConnection(window);
              edgeShim.shimReplaceTrack(window); // the edge shim implements the full RTCIceCandidate object.

              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              break;

            case 'safari':
              if (!safariShim || !options.shimSafari) {
                logging('Safari shim is not included in this adapter release.');
                return adapter;
              }

              logging('adapter.js shimming safari.'); // Export to the adapter global object visible in the browser.

              adapter.browserShim = safariShim;
              safariShim.shimRTCIceServerUrls(window);
              safariShim.shimCreateOfferLegacy(window);
              safariShim.shimCallbacksAPI(window);
              safariShim.shimLocalStreamsAPI(window);
              safariShim.shimRemoteStreamsAPI(window);
              safariShim.shimTrackEventTransceiver(window);
              safariShim.shimGetUserMedia(window);
              commonShim.shimRTCIceCandidate(window);
              commonShim.shimMaxMessageSize(window);
              commonShim.shimSendThrowTypeError(window);
              commonShim.removeAllowExtmapMixed(window);
              break;

            default:
              logging('Unsupported browser!');
              break;
          }

          return adapter;
        } // Browser shims.

      }, {
        "./chrome/chrome_shim": 3,
        "./common_shim": 6,
        "./edge/edge_shim": 12,
        "./firefox/firefox_shim": 7,
        "./safari/safari_shim": 10,
        "./utils": 11
      }],
      3: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        var _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          }
        });

        var _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          }
        });
        exports.shimMediaStream = shimMediaStream;
        exports.shimOnTrack = shimOnTrack;
        exports.shimGetSendersWithDtmf = shimGetSendersWithDtmf;
        exports.shimGetStats = shimGetStats;
        exports.shimSenderReceiverGetStats = shimSenderReceiverGetStats;
        exports.shimAddTrackRemoveTrackWithNative = shimAddTrackRemoveTrackWithNative;
        exports.shimAddTrackRemoveTrack = shimAddTrackRemoveTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.fixNegotiationNeeded = fixNegotiationNeeded;

        var _utils = require('../utils.js');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function shimMediaStream(window) {
          window.MediaStream = window.MediaStream || window.webkitMediaStream;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('ontrack' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get: function get() {
                return this._ontrack;
              },
              set: function set(f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                }

                this.addEventListener('track', this._ontrack = f);
              },
              enumerable: true,
              configurable: true
            });
            var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              var _this = this;

              if (!this._ontrackpoly) {
                this._ontrackpoly = function (e) {
                  // onaddstream does not fire when a track is added to an existing
                  // stream. But stream.onaddtrack is implemented so we use that.
                  e.stream.addEventListener('addtrack', function (te) {
                    var receiver = void 0;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(function (r) {
                        return r.track && r.track.id === te.track.id;
                      });
                    } else {
                      receiver = {
                        track: te.track
                      };
                    }

                    var event = new Event('track');
                    event.track = te.track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];

                    _this.dispatchEvent(event);
                  });
                  e.stream.getTracks().forEach(function (track) {
                    var receiver = void 0;

                    if (window.RTCPeerConnection.prototype.getReceivers) {
                      receiver = _this.getReceivers().find(function (r) {
                        return r.track && r.track.id === track.id;
                      });
                    } else {
                      receiver = {
                        track: track
                      };
                    }

                    var event = new Event('track');
                    event.track = track;
                    event.receiver = receiver;
                    event.transceiver = {
                      receiver: receiver
                    };
                    event.streams = [e.stream];

                    _this.dispatchEvent(event);
                  });
                };

                this.addEventListener('addstream', this._ontrackpoly);
              }

              return origSetRemoteDescription.apply(this, arguments);
            };
          } else {
            // even if RTCRtpTransceiver is in window, it is only used and
            // emitted in unified-plan. Unfortunately this means we need
            // to unconditionally wrap the event.
            utils.wrapPeerConnectionEvent(window, 'track', function (e) {
              if (!e.transceiver) {
                Object.defineProperty(e, 'transceiver', {
                  value: {
                    receiver: e.receiver
                  }
                });
              }

              return e;
            });
          }
        }

        function shimGetSendersWithDtmf(window) {
          // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && !('getSenders' in window.RTCPeerConnection.prototype) && 'createDTMFSender' in window.RTCPeerConnection.prototype) {
            var shimSenderWithDtmf = function shimSenderWithDtmf(pc, track) {
              return {
                track: track,

                get dtmf() {
                  if (this._dtmf === undefined) {
                    if (track.kind === 'audio') {
                      this._dtmf = pc.createDTMFSender(track);
                    } else {
                      this._dtmf = null;
                    }
                  }

                  return this._dtmf;
                },

                _pc: pc
              };
            }; // augment addTrack when getSenders is not available.


            if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                this._senders = this._senders || [];
                return this._senders.slice(); // return a copy of the internal state.
              };

              var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

              window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
                var sender = origAddTrack.apply(this, arguments);

                if (!sender) {
                  sender = shimSenderWithDtmf(this, track);

                  this._senders.push(sender);
                }

                return sender;
              };

              var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

              window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
                origRemoveTrack.apply(this, arguments);

                var idx = this._senders.indexOf(sender);

                if (idx !== -1) {
                  this._senders.splice(idx, 1);
                }
              };
            }

            var origAddStream = window.RTCPeerConnection.prototype.addStream;

            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              var _this2 = this;

              this._senders = this._senders || [];
              origAddStream.apply(this, [stream]);
              stream.getTracks().forEach(function (track) {
                _this2._senders.push(shimSenderWithDtmf(_this2, track));
              });
            };

            var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              var _this3 = this;

              this._senders = this._senders || [];
              origRemoveStream.apply(this, [stream]);
              stream.getTracks().forEach(function (track) {
                var sender = _this3._senders.find(function (s) {
                  return s.track === track;
                });

                if (sender) {
                  // remove sender
                  _this3._senders.splice(_this3._senders.indexOf(sender), 1);
                }
              });
            };
          } else if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && 'getSenders' in window.RTCPeerConnection.prototype && 'createDTMFSender' in window.RTCPeerConnection.prototype && window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
            var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this4 = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this4;
              });
              return senders;
            };

            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get: function get() {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = this._pc.createDTMFSender(this.track);
                  } else {
                    this._dtmf = null;
                  }
                }

                return this._dtmf;
              }
            });
          }
        }

        function shimGetStats(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var origGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            var _this5 = this;

            var _arguments = Array.prototype.slice.call(arguments),
                selector = _arguments[0],
                onSucc = _arguments[1],
                onErr = _arguments[2]; // If selector is a function then we are in the old style stats so just
            // pass back the original getStats format to avoid breaking old users.


            if (arguments.length > 0 && typeof selector === 'function') {
              return origGetStats.apply(this, arguments);
            } // When spec-style getStats is supported, return those when called with
            // either no arguments or the selector argument is null.


            if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== 'function')) {
              return origGetStats.apply(this, []);
            }

            var fixChromeStats_ = function fixChromeStats_(response) {
              var standardReport = {};
              var reports = response.result();
              reports.forEach(function (report) {
                var standardStats = {
                  id: report.id,
                  timestamp: report.timestamp,
                  type: {
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate'
                  }[report.type] || report.type
                };
                report.names().forEach(function (name) {
                  standardStats[name] = report.stat(name);
                });
                standardReport[standardStats.id] = standardStats;
              });
              return standardReport;
            }; // shim getStats with maplike support


            var makeMapStats = function makeMapStats(stats) {
              return new Map(Object.keys(stats).map(function (key) {
                return [key, stats[key]];
              }));
            };

            if (arguments.length >= 2) {
              var successCallbackWrapper_ = function successCallbackWrapper_(response) {
                onSucc(makeMapStats(fixChromeStats_(response)));
              };

              return origGetStats.apply(this, [successCallbackWrapper_, selector]);
            } // promise-support


            return new Promise(function (resolve, reject) {
              origGetStats.apply(_this5, [function (response) {
                resolve(makeMapStats(fixChromeStats_(response)));
              }, reject]);
            }).then(onSucc, onErr);
          };
        }

        function shimSenderReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender && window.RTCRtpReceiver)) {
            return;
          } // shim sender stats.


          if (!('getStats' in window.RTCRtpSender.prototype)) {
            var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

            if (origGetSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                var _this6 = this;

                var senders = origGetSenders.apply(this, []);
                senders.forEach(function (sender) {
                  return sender._pc = _this6;
                });
                return senders;
              };
            }

            var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

            if (origAddTrack) {
              window.RTCPeerConnection.prototype.addTrack = function addTrack() {
                var sender = origAddTrack.apply(this, arguments);
                sender._pc = this;
                return sender;
              };
            }

            window.RTCRtpSender.prototype.getStats = function getStats() {
              var sender = this;
              return this._pc.getStats().then(function (result) {
                return (
                  /* Note: this will include stats of all senders that
                   *   send a track with the same id as sender.track as
                   *   it is not possible to identify the RTCRtpSender.
                   */
                  utils.filterStats(result, sender.track, true)
                );
              });
            };
          } // shim receiver stats.


          if (!('getStats' in window.RTCRtpReceiver.prototype)) {
            var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

            if (origGetReceivers) {
              window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
                var _this7 = this;

                var receivers = origGetReceivers.apply(this, []);
                receivers.forEach(function (receiver) {
                  return receiver._pc = _this7;
                });
                return receivers;
              };
            }

            utils.wrapPeerConnectionEvent(window, 'track', function (e) {
              e.receiver._pc = e.srcElement;
              return e;
            });

            window.RTCRtpReceiver.prototype.getStats = function getStats() {
              var receiver = this;
              return this._pc.getStats().then(function (result) {
                return utils.filterStats(result, receiver.track, false);
              });
            };
          }

          if (!('getStats' in window.RTCRtpSender.prototype && 'getStats' in window.RTCRtpReceiver.prototype)) {
            return;
          } // shim RTCPeerConnection.getStats(track).


          var origGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            if (arguments.length > 0 && arguments[0] instanceof window.MediaStreamTrack) {
              var track = arguments[0];
              var sender = void 0;
              var receiver = void 0;
              var err = void 0;
              this.getSenders().forEach(function (s) {
                if (s.track === track) {
                  if (sender) {
                    err = true;
                  } else {
                    sender = s;
                  }
                }
              });
              this.getReceivers().forEach(function (r) {
                if (r.track === track) {
                  if (receiver) {
                    err = true;
                  } else {
                    receiver = r;
                  }
                }

                return r.track === track;
              });

              if (err || sender && receiver) {
                return Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError'));
              } else if (sender) {
                return sender.getStats();
              } else if (receiver) {
                return receiver.getStats();
              }

              return Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError'));
            }

            return origGetStats.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrackWithNative(window) {
          // shim addTrack/removeTrack with native variants in order to make
          // the interactions with legacy getLocalStreams behave as in other browsers.
          // Keeps a mapping stream.id => [stream, rtpsenders...]
          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            var _this8 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            return Object.keys(this._shimmedLocalStreams).map(function (streamId) {
              return _this8._shimmedLocalStreams[streamId][0];
            });
          };

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            if (!stream) {
              return origAddTrack.apply(this, arguments);
            }

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            var sender = origAddTrack.apply(this, arguments);

            if (!this._shimmedLocalStreams[stream.id]) {
              this._shimmedLocalStreams[stream.id] = [stream, sender];
            } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
              this._shimmedLocalStreams[stream.id].push(sender);
            }

            return sender;
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this9 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = _this9.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            });
            var existingSenders = this.getSenders();
            origAddStream.apply(this, arguments);
            var newSenders = this.getSenders().filter(function (newSender) {
              return existingSenders.indexOf(newSender) === -1;
            });
            this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};
            delete this._shimmedLocalStreams[stream.id];
            return origRemoveStream.apply(this, arguments);
          };

          var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;

          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            var _this10 = this;

            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            if (sender) {
              Object.keys(this._shimmedLocalStreams).forEach(function (streamId) {
                var idx = _this10._shimmedLocalStreams[streamId].indexOf(sender);

                if (idx !== -1) {
                  _this10._shimmedLocalStreams[streamId].splice(idx, 1);
                }

                if (_this10._shimmedLocalStreams[streamId].length === 1) {
                  delete _this10._shimmedLocalStreams[streamId];
                }
              });
            }

            return origRemoveTrack.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrack(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window); // shim addTrack and removeTrack.

          if (window.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
            return shimAddTrackRemoveTrackWithNative(window);
          } // also shim pc.getLocalStreams when addTrack is shimmed
          // to return the original streams.


          var origGetLocalStreams = window.RTCPeerConnection.prototype.getLocalStreams;

          window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
            var _this11 = this;

            var nativeStreams = origGetLocalStreams.apply(this);
            this._reverseStreams = this._reverseStreams || {};
            return nativeStreams.map(function (stream) {
              return _this11._reverseStreams[stream.id];
            });
          };

          var origAddStream = window.RTCPeerConnection.prototype.addStream;

          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            var _this12 = this;

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            stream.getTracks().forEach(function (track) {
              var alreadyExists = _this12.getSenders().find(function (s) {
                return s.track === track;
              });

              if (alreadyExists) {
                throw new DOMException('Track already exists.', 'InvalidAccessError');
              }
            }); // Add identity mapping for consistency with addTrack.
            // Unless this is being used with a stream from addTrack.

            if (!this._reverseStreams[stream.id]) {
              var newStream = new window.MediaStream(stream.getTracks());
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              stream = newStream;
            }

            origAddStream.apply(this, [stream]);
          };

          var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
            delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
            delete this._streams[stream.id];
          };

          window.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
            var _this13 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            }

            var streams = [].slice.call(arguments, 1);

            if (streams.length !== 1 || !streams[0].getTracks().find(function (t) {
              return t === track;
            })) {
              // this is not fully correct but all we can manage without
              // [[associated MediaStreams]] internal slot.
              throw new DOMException('The adapter.js addTrack polyfill only supports a single ' + ' stream which is associated with the specified track.', 'NotSupportedError');
            }

            var alreadyExists = this.getSenders().find(function (s) {
              return s.track === track;
            });

            if (alreadyExists) {
              throw new DOMException('Track already exists.', 'InvalidAccessError');
            }

            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};
            var oldStream = this._streams[stream.id];

            if (oldStream) {
              // this is using odd Chrome behaviour, use with caution:
              // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
              // Note: we rely on the high-level addTrack/dtmf shim to
              // create the sender with a dtmf sender.
              oldStream.addTrack(track); // Trigger ONN async.

              Promise.resolve().then(function () {
                _this13.dispatchEvent(new Event('negotiationneeded'));
              });
            } else {
              var newStream = new window.MediaStream([track]);
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              this.addStream(newStream);
            }

            return this.getSenders().find(function (s) {
              return s.track === track;
            });
          }; // replace the internal stream id with the external one and
          // vice versa.


          function replaceInternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, 'g'), externalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          function replaceExternalStreamId(pc, description) {
            var sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(function (internalId) {
              var externalStream = pc._reverseStreams[internalId];
              var internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, 'g'), internalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp: sdp
            });
          }

          ['createOffer', 'createAnswer'].forEach(function (method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];

            var methodObj = _defineProperty({}, method, function () {
              var _this14 = this;

              var args = arguments;
              var isLegacyCall = arguments.length && typeof arguments[0] === 'function';

              if (isLegacyCall) {
                return nativeMethod.apply(this, [function (description) {
                  var desc = replaceInternalStreamId(_this14, description);
                  args[0].apply(null, [desc]);
                }, function (err) {
                  if (args[1]) {
                    args[1].apply(null, err);
                  }
                }, arguments[2]]);
              }

              return nativeMethod.apply(this, arguments).then(function (description) {
                return replaceInternalStreamId(_this14, description);
              });
            });

            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });
          var origSetLocalDescription = window.RTCPeerConnection.prototype.setLocalDescription;

          window.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
            if (!arguments.length || !arguments[0].type) {
              return origSetLocalDescription.apply(this, arguments);
            }

            arguments[0] = replaceExternalStreamId(this, arguments[0]);
            return origSetLocalDescription.apply(this, arguments);
          }; // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier


          var origLocalDescription = Object.getOwnPropertyDescriptor(window.RTCPeerConnection.prototype, 'localDescription');
          Object.defineProperty(window.RTCPeerConnection.prototype, 'localDescription', {
            get: function get() {
              var description = origLocalDescription.get.apply(this);

              if (description.type === '') {
                return description;
              }

              return replaceInternalStreamId(this, description);
            }
          });

          window.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
            var _this15 = this;

            if (this.signalingState === 'closed') {
              throw new DOMException('The RTCPeerConnection\'s signalingState is \'closed\'.', 'InvalidStateError');
            } // We can not yet check for sender instanceof RTCRtpSender
            // since we shim RTPSender. So we check if sender._pc is set.


            if (!sender._pc) {
              throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' + 'does not implement interface RTCRtpSender.', 'TypeError');
            }

            var isLocal = sender._pc === this;

            if (!isLocal) {
              throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError');
            } // Search for the native stream the senders track belongs to.


            this._streams = this._streams || {};
            var stream = void 0;
            Object.keys(this._streams).forEach(function (streamid) {
              var hasTrack = _this15._streams[streamid].getTracks().find(function (track) {
                return sender.track === track;
              });

              if (hasTrack) {
                stream = _this15._streams[streamid];
              }
            });

            if (stream) {
              if (stream.getTracks().length === 1) {
                // if this is the last track of the stream, remove the stream. This
                // takes care of any shimmed _senders.
                this.removeStream(this._reverseStreams[stream.id]);
              } else {
                // relying on the same odd chrome behaviour as above.
                stream.removeTrack(sender.track);
              }

              this.dispatchEvent(new Event('negotiationneeded'));
            }
          };
        }

        function shimPeerConnection(window) {
          var browserDetails = utils.detectBrowser(window);

          if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.webkitRTCPeerConnection;
          }

          if (!window.RTCPeerConnection) {
            return;
          } // shim implicit creation of RTCSessionDescription/RTCIceCandidate


          if (browserDetails.version < 53) {
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              var methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });

              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          } // support for addIceCandidate(null or undefined)


          var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

          window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
            if (!arguments[0]) {
              if (arguments[1]) {
                arguments[1].apply(null);
              }

              return Promise.resolve();
            } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
            // in older versions. Native support planned for Chrome M77.


            if (browserDetails.version < 78 && arguments[0] && arguments[0].candidate === '') {
              return Promise.resolve();
            }

            return nativeAddIceCandidate.apply(this, arguments);
          };
        }

        function fixNegotiationNeeded(window) {
          utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function (e) {
            var pc = e.target;

            if (pc.signalingState !== 'stable') {
              return;
            }

            return e;
          });
        }
      }, {
        "../utils.js": 11,
        "./getdisplaymedia": 4,
        "./getusermedia": 5
      }],
      4: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;

        function shimGetDisplayMedia(window, getSourceId) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }

          if (!window.navigator.mediaDevices) {
            return;
          } // getSourceId is a function that returns a promise resolving with
          // the sourceId of the screen/window/tab to be shared.


          if (typeof getSourceId !== 'function') {
            console.error('shimGetDisplayMedia: getSourceId argument is not ' + 'a function');
            return;
          }

          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            return getSourceId(constraints).then(function (sourceId) {
              var widthSpecified = constraints.video && constraints.video.width;
              var heightSpecified = constraints.video && constraints.video.height;
              var frameRateSpecified = constraints.video && constraints.video.frameRate;
              constraints.video = {
                mandatory: {
                  chromeMediaSource: 'desktop',
                  chromeMediaSourceId: sourceId,
                  maxFrameRate: frameRateSpecified || 3
                }
              };

              if (widthSpecified) {
                constraints.video.mandatory.maxWidth = widthSpecified;
              }

              if (heightSpecified) {
                constraints.video.mandatory.maxHeight = heightSpecified;
              }

              return window.navigator.mediaDevices.getUserMedia(constraints);
            });
          };
        }
      }, {}],
      5: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimGetUserMedia = shimGetUserMedia;

        var _utils = require('../utils.js');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        var logging = utils.log;

        function shimGetUserMedia(window) {
          var navigator = window && window.navigator;

          if (!navigator.mediaDevices) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          var constraintsToChrome_ = function constraintsToChrome_(c) {
            if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) !== 'object' || c.mandatory || c.optional) {
              return c;
            }

            var cc = {};
            Object.keys(c).forEach(function (key) {
              if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                return;
              }

              var r = _typeof(c[key]) === 'object' ? c[key] : {
                ideal: c[key]
              };

              if (r.exact !== undefined && typeof r.exact === 'number') {
                r.min = r.max = r.exact;
              }

              var oldname_ = function oldname_(prefix, name) {
                if (prefix) {
                  return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                }

                return name === 'deviceId' ? 'sourceId' : name;
              };

              if (r.ideal !== undefined) {
                cc.optional = cc.optional || [];
                var oc = {};

                if (typeof r.ideal === 'number') {
                  oc[oldname_('min', key)] = r.ideal;
                  cc.optional.push(oc);
                  oc = {};
                  oc[oldname_('max', key)] = r.ideal;
                  cc.optional.push(oc);
                } else {
                  oc[oldname_('', key)] = r.ideal;
                  cc.optional.push(oc);
                }
              }

              if (r.exact !== undefined && typeof r.exact !== 'number') {
                cc.mandatory = cc.mandatory || {};
                cc.mandatory[oldname_('', key)] = r.exact;
              } else {
                ['min', 'max'].forEach(function (mix) {
                  if (r[mix] !== undefined) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname_(mix, key)] = r[mix];
                  }
                });
              }
            });

            if (c.advanced) {
              cc.optional = (cc.optional || []).concat(c.advanced);
            }

            return cc;
          };

          var shimConstraints_ = function shimConstraints_(constraints, func) {
            if (browserDetails.version >= 61) {
              return func(constraints);
            }

            constraints = JSON.parse(JSON.stringify(constraints));

            if (constraints && _typeof(constraints.audio) === 'object') {
              var remap = function remap(obj, a, b) {
                if (a in obj && !(b in obj)) {
                  obj[b] = obj[a];
                  delete obj[a];
                }
              };

              constraints = JSON.parse(JSON.stringify(constraints));
              remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
              remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
              constraints.audio = constraintsToChrome_(constraints.audio);
            }

            if (constraints && _typeof(constraints.video) === 'object') {
              // Shim facingMode for mobile & surface pro.
              var face = constraints.video.facingMode;
              face = face && ((typeof face === 'undefined' ? 'undefined' : _typeof(face)) === 'object' ? face : {
                ideal: face
              });
              var getSupportedFacingModeLies = browserDetails.version < 66;

              if (face && (face.exact === 'user' || face.exact === 'environment' || face.ideal === 'user' || face.ideal === 'environment') && !(navigator.mediaDevices.getSupportedConstraints && navigator.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
                delete constraints.video.facingMode;
                var matches = void 0;

                if (face.exact === 'environment' || face.ideal === 'environment') {
                  matches = ['back', 'rear'];
                } else if (face.exact === 'user' || face.ideal === 'user') {
                  matches = ['front'];
                }

                if (matches) {
                  // Look for matches in label, or use last cam for back (typical).
                  return navigator.mediaDevices.enumerateDevices().then(function (devices) {
                    devices = devices.filter(function (d) {
                      return d.kind === 'videoinput';
                    });
                    var dev = devices.find(function (d) {
                      return matches.some(function (match) {
                        return d.label.toLowerCase().includes(match);
                      });
                    });

                    if (!dev && devices.length && matches.includes('back')) {
                      dev = devices[devices.length - 1]; // more likely the back cam
                    }

                    if (dev) {
                      constraints.video.deviceId = face.exact ? {
                        exact: dev.deviceId
                      } : {
                        ideal: dev.deviceId
                      };
                    }

                    constraints.video = constraintsToChrome_(constraints.video);
                    logging('chrome: ' + JSON.stringify(constraints));
                    return func(constraints);
                  });
                }
              }

              constraints.video = constraintsToChrome_(constraints.video);
            }

            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          };

          var shimError_ = function shimError_(e) {
            if (browserDetails.version >= 64) {
              return e;
            }

            return {
              name: {
                PermissionDeniedError: 'NotAllowedError',
                PermissionDismissedError: 'NotAllowedError',
                InvalidStateError: 'NotAllowedError',
                DevicesNotFoundError: 'NotFoundError',
                ConstraintNotSatisfiedError: 'OverconstrainedError',
                TrackStartError: 'NotReadableError',
                MediaDeviceFailedDueToShutdown: 'NotAllowedError',
                MediaDeviceKillSwitchOn: 'NotAllowedError',
                TabCaptureError: 'AbortError',
                ScreenCaptureError: 'AbortError',
                DeviceCaptureError: 'AbortError'
              }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString: function toString() {
                return this.name + (this.message && ': ') + this.message;
              }
            };
          };

          var getUserMedia_ = function getUserMedia_(constraints, onSuccess, onError) {
            shimConstraints_(constraints, function (c) {
              navigator.webkitGetUserMedia(c, onSuccess, function (e) {
                if (onError) {
                  onError(shimError_(e));
                }
              });
            });
          };

          navigator.getUserMedia = getUserMedia_.bind(navigator); // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
          // function which returns a Promise, it does not accept spec-style
          // constraints.

          if (navigator.mediaDevices.getUserMedia) {
            var origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

            navigator.mediaDevices.getUserMedia = function (cs) {
              return shimConstraints_(cs, function (c) {
                return origGetUserMedia(c).then(function (stream) {
                  if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {
                    stream.getTracks().forEach(function (track) {
                      track.stop();
                    });
                    throw new DOMException('', 'NotFoundError');
                  }

                  return stream;
                }, function (e) {
                  return Promise.reject(shimError_(e));
                });
              });
            };
          }
        }
      }, {
        "../utils.js": 11
      }],
      6: [function (require, module, exports) {
        /*
         *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimRTCIceCandidate = shimRTCIceCandidate;
        exports.shimMaxMessageSize = shimMaxMessageSize;
        exports.shimSendThrowTypeError = shimSendThrowTypeError;
        exports.shimConnectionState = shimConnectionState;
        exports.removeAllowExtmapMixed = removeAllowExtmapMixed;

        var _sdp = require('sdp');

        var _sdp2 = _interopRequireDefault(_sdp);

        var _utils = require('./utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }

        function shimRTCIceCandidate(window) {
          // foundation is arbitrarily chosen as an indicator for full support for
          // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
          if (!window.RTCIceCandidate || window.RTCIceCandidate && 'foundation' in window.RTCIceCandidate.prototype) {
            return;
          }

          var NativeRTCIceCandidate = window.RTCIceCandidate;

          window.RTCIceCandidate = function RTCIceCandidate(args) {
            // Remove the a= which shouldn't be part of the candidate string.
            if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) === 'object' && args.candidate && args.candidate.indexOf('a=') === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substr(2);
            }

            if (args.candidate && args.candidate.length) {
              // Augment the native candidate with the parsed fields.
              var nativeCandidate = new NativeRTCIceCandidate(args);

              var parsedCandidate = _sdp2["default"].parseCandidate(args.candidate);

              var augmentedCandidate = Object.assign(nativeCandidate, parsedCandidate); // Add a serializer that does not serialize the extra attributes.

              augmentedCandidate.toJSON = function toJSON() {
                return {
                  candidate: augmentedCandidate.candidate,
                  sdpMid: augmentedCandidate.sdpMid,
                  sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                  usernameFragment: augmentedCandidate.usernameFragment
                };
              };

              return augmentedCandidate;
            }

            return new NativeRTCIceCandidate(args);
          };

          window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype; // Hook up the augmented candidate in onicecandidate and
          // addEventListener('icecandidate', ...)

          utils.wrapPeerConnectionEvent(window, 'icecandidate', function (e) {
            if (e.candidate) {
              Object.defineProperty(e, 'candidate', {
                value: new window.RTCIceCandidate(e.candidate),
                writable: 'false'
              });
            }

            return e;
          });
        }

        function shimMaxMessageSize(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          if (!('sctp' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
              get: function get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              }
            });
          }

          var sctpInDescription = function sctpInDescription(description) {
            if (!description || !description.sdp) {
              return false;
            }

            var sections = _sdp2["default"].splitSections(description.sdp);

            sections.shift();
            return sections.some(function (mediaSection) {
              var mLine = _sdp2["default"].parseMLine(mediaSection);

              return mLine && mLine.kind === 'application' && mLine.protocol.indexOf('SCTP') !== -1;
            });
          };

          var getRemoteFirefoxVersion = function getRemoteFirefoxVersion(description) {
            // TODO: Is there a better solution for detecting Firefox?
            var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);

            if (match === null || match.length < 2) {
              return -1;
            }

            var version = parseInt(match[1], 10); // Test for NaN (yes, this is ugly)

            return version !== version ? -1 : version;
          };

          var getCanSendMaxMessageSize = function getCanSendMaxMessageSize(remoteIsFirefox) {
            // Every implementation we know can send at least 64 KiB.
            // Note: Although Chrome is technically able to send up to 256 KiB, the
            //       data does not reach the other peer reliably.
            //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
            var canSendMaxMessageSize = 65536;

            if (browserDetails.browser === 'firefox') {
              if (browserDetails.version < 57) {
                if (remoteIsFirefox === -1) {
                  // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                } else {
                  // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
                }
              } else if (browserDetails.version < 60) {
                // Currently, all FF >= 57 will reset the remote maximum message size
                // to the default value when a data channel is created at a later
                // stage. :(
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
              } else {
                // FF >= 60 supports sending ~2 GiB
                canSendMaxMessageSize = 2147483637;
              }
            }

            return canSendMaxMessageSize;
          };

          var getMaxMessageSize = function getMaxMessageSize(description, remoteIsFirefox) {
            // Note: 65536 bytes is the default value from the SDP spec. Also,
            //       every implementation we know supports receiving 65536 bytes.
            var maxMessageSize = 65536; // FF 57 has a slightly incorrect default remote max message size, so
            // we need to adjust it here to avoid a failure when sending.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697

            if (browserDetails.browser === 'firefox' && browserDetails.version === 57) {
              maxMessageSize = 65535;
            }

            var match = _sdp2["default"].matchPrefix(description.sdp, 'a=max-message-size:');

            if (match.length > 0) {
              maxMessageSize = parseInt(match[0].substr(19), 10);
            } else if (browserDetails.browser === 'firefox' && remoteIsFirefox !== -1) {
              // If the maximum message size is not present in the remote SDP and
              // both local and remote are Firefox, the remote peer can receive
              // ~2 GiB.
              maxMessageSize = 2147483637;
            }

            return maxMessageSize;
          };

          var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
            this._sctp = null; // Chrome decided to not expose .sctp in plan-b mode.
            // As usual, adapter.js has to do an 'ugly worakaround'
            // to cover up the mess.

            if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
              var _getConfiguration = this.getConfiguration(),
                  sdpSemantics = _getConfiguration.sdpSemantics;

              if (sdpSemantics === 'plan-b') {
                Object.defineProperty(this, 'sctp', {
                  get: function get() {
                    return typeof this._sctp === 'undefined' ? null : this._sctp;
                  },
                  enumerable: true,
                  configurable: true
                });
              }
            }

            if (sctpInDescription(arguments[0])) {
              // Check if the remote is FF.
              var isFirefox = getRemoteFirefoxVersion(arguments[0]); // Get the maximum message size the local peer is capable of sending

              var canSendMMS = getCanSendMaxMessageSize(isFirefox); // Get the maximum message size of the remote peer.

              var remoteMMS = getMaxMessageSize(arguments[0], isFirefox); // Determine final maximum message size

              var maxMessageSize = void 0;

              if (canSendMMS === 0 && remoteMMS === 0) {
                maxMessageSize = Number.POSITIVE_INFINITY;
              } else if (canSendMMS === 0 || remoteMMS === 0) {
                maxMessageSize = Math.max(canSendMMS, remoteMMS);
              } else {
                maxMessageSize = Math.min(canSendMMS, remoteMMS);
              } // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
              // attribute.


              var sctp = {};
              Object.defineProperty(sctp, 'maxMessageSize', {
                get: function get() {
                  return maxMessageSize;
                }
              });
              this._sctp = sctp;
            }

            return origSetRemoteDescription.apply(this, arguments);
          };
        }

        function shimSendThrowTypeError(window) {
          if (!(window.RTCPeerConnection && 'createDataChannel' in window.RTCPeerConnection.prototype)) {
            return;
          } // Note: Although Firefox >= 57 has a native implementation, the maximum
          //       message size can be reset for all data channels at a later stage.
          //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831


          function wrapDcSend(dc, pc) {
            var origDataChannelSend = dc.send;

            dc.send = function send() {
              var data = arguments[0];
              var length = data.length || data.size || data.byteLength;

              if (dc.readyState === 'open' && pc.sctp && length > pc.sctp.maxMessageSize) {
                throw new TypeError('Message too large (can send a maximum of ' + pc.sctp.maxMessageSize + ' bytes)');
              }

              return origDataChannelSend.apply(dc, arguments);
            };
          }

          var origCreateDataChannel = window.RTCPeerConnection.prototype.createDataChannel;

          window.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
            var dataChannel = origCreateDataChannel.apply(this, arguments);
            wrapDcSend(dataChannel, this);
            return dataChannel;
          };

          utils.wrapPeerConnectionEvent(window, 'datachannel', function (e) {
            wrapDcSend(e.channel, e.target);
            return e;
          });
        }
        /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
         * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
         * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
         * since DTLS failures would be hidden. See
         * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
         * for the Firefox tracking bug.
         */


        function shimConnectionState(window) {
          if (!window.RTCPeerConnection || 'connectionState' in window.RTCPeerConnection.prototype) {
            return;
          }

          var proto = window.RTCPeerConnection.prototype;
          Object.defineProperty(proto, 'connectionState', {
            get: function get() {
              return {
                completed: 'connected',
                checking: 'connecting'
              }[this.iceConnectionState] || this.iceConnectionState;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(proto, 'onconnectionstatechange', {
            get: function get() {
              return this._onconnectionstatechange || null;
            },
            set: function set(cb) {
              if (this._onconnectionstatechange) {
                this.removeEventListener('connectionstatechange', this._onconnectionstatechange);
                delete this._onconnectionstatechange;
              }

              if (cb) {
                this.addEventListener('connectionstatechange', this._onconnectionstatechange = cb);
              }
            },
            enumerable: true,
            configurable: true
          });
          ['setLocalDescription', 'setRemoteDescription'].forEach(function (method) {
            var origMethod = proto[method];

            proto[method] = function () {
              if (!this._connectionstatechangepoly) {
                this._connectionstatechangepoly = function (e) {
                  var pc = e.target;

                  if (pc._lastConnectionState !== pc.connectionState) {
                    pc._lastConnectionState = pc.connectionState;
                    var newEvent = new Event('connectionstatechange', e);
                    pc.dispatchEvent(newEvent);
                  }

                  return e;
                };

                this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly);
              }

              return origMethod.apply(this, arguments);
            };
          });
        }

        function removeAllowExtmapMixed(window) {
          /* remove a=extmap-allow-mixed for Chrome < M71 */
          if (!window.RTCPeerConnection) {
            return;
          }

          var browserDetails = utils.detectBrowser(window);

          if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
            return;
          }

          var nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;

          window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
            if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
              desc.sdp = desc.sdp.split('\n').filter(function (line) {
                return line.trim() !== 'a=extmap-allow-mixed';
              }).join('\n');
            }

            return nativeSRD.apply(this, arguments);
          };
        }
      }, {
        "./utils": 11,
        "sdp": 13
      }],
      7: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = exports.shimGetUserMedia = undefined;

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        var _getusermedia = require('./getusermedia');

        Object.defineProperty(exports, 'shimGetUserMedia', {
          enumerable: true,
          get: function get() {
            return _getusermedia.shimGetUserMedia;
          }
        });

        var _getdisplaymedia = require('./getdisplaymedia');

        Object.defineProperty(exports, 'shimGetDisplayMedia', {
          enumerable: true,
          get: function get() {
            return _getdisplaymedia.shimGetDisplayMedia;
          }
        });
        exports.shimOnTrack = shimOnTrack;
        exports.shimPeerConnection = shimPeerConnection;
        exports.shimSenderGetStats = shimSenderGetStats;
        exports.shimReceiverGetStats = shimReceiverGetStats;
        exports.shimRemoveStream = shimRemoveStream;
        exports.shimRTCDataChannel = shimRTCDataChannel;
        exports.shimAddTransceiver = shimAddTransceiver;
        exports.shimCreateOffer = shimCreateOffer;
        exports.shimCreateAnswer = shimCreateAnswer;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        function shimOnTrack(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        }

        function shimPeerConnection(window) {
          var browserDetails = utils.detectBrowser(window);

          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
            return; // probably media.peerconnection.enabled=false in about:config
          }

          if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.mozRTCPeerConnection;
          }

          if (browserDetails.version < 53) {
            // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (method) {
              var nativeMethod = window.RTCPeerConnection.prototype[method];

              var methodObj = _defineProperty({}, method, function () {
                arguments[0] = new (method === 'addIceCandidate' ? window.RTCIceCandidate : window.RTCSessionDescription)(arguments[0]);
                return nativeMethod.apply(this, arguments);
              });

              window.RTCPeerConnection.prototype[method] = methodObj[method];
            });
          } // support for addIceCandidate(null or undefined)
          // as well as ignoring {sdpMid, candidate: ""}


          if (browserDetails.version < 68) {
            var nativeAddIceCandidate = window.RTCPeerConnection.prototype.addIceCandidate;

            window.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
              if (!arguments[0]) {
                if (arguments[1]) {
                  arguments[1].apply(null);
                }

                return Promise.resolve();
              } // Firefox 68+ emits and processes {candidate: "", ...}, ignore
              // in older versions.


              if (arguments[0] && arguments[0].candidate === '') {
                return Promise.resolve();
              }

              return nativeAddIceCandidate.apply(this, arguments);
            };
          }

          var modernStatsTypes = {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          };
          var nativeGetStats = window.RTCPeerConnection.prototype.getStats;

          window.RTCPeerConnection.prototype.getStats = function getStats() {
            var _arguments = Array.prototype.slice.call(arguments),
                selector = _arguments[0],
                onSucc = _arguments[1],
                onErr = _arguments[2];

            return nativeGetStats.apply(this, [selector || null]).then(function (stats) {
              if (browserDetails.version < 53 && !onSucc) {
                // Shim only promise getStats with spec-hyphens in type names
                // Leave callback version alone; misc old uses of forEach before Map
                try {
                  stats.forEach(function (stat) {
                    stat.type = modernStatsTypes[stat.type] || stat.type;
                  });
                } catch (e) {
                  if (e.name !== 'TypeError') {
                    throw e;
                  } // Avoid TypeError: "type" is read-only, in old versions. 34-43ish


                  stats.forEach(function (stat, i) {
                    stats.set(i, Object.assign({}, stat, {
                      type: modernStatsTypes[stat.type] || stat.type
                    }));
                  });
                }
              }

              return stats;
            }).then(onSucc, onErr);
          };
        }

        function shimSenderGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }

          if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
            return;
          }

          var origGetSenders = window.RTCPeerConnection.prototype.getSenders;

          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              var _this = this;

              var senders = origGetSenders.apply(this, []);
              senders.forEach(function (sender) {
                return sender._pc = _this;
              });
              return senders;
            };
          }

          var origAddTrack = window.RTCPeerConnection.prototype.addTrack;

          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              var sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }

          window.RTCRtpSender.prototype.getStats = function getStats() {
            return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());
          };
        }

        function shimReceiverGetStats(window) {
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection && window.RTCRtpSender)) {
            return;
          }

          if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
            return;
          }

          var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;

          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              var _this2 = this;

              var receivers = origGetReceivers.apply(this, []);
              receivers.forEach(function (receiver) {
                return receiver._pc = _this2;
              });
              return receivers;
            };
          }

          utils.wrapPeerConnectionEvent(window, 'track', function (e) {
            e.receiver._pc = e.srcElement;
            return e;
          });

          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            return this._pc.getStats(this.track);
          };
        }

        function shimRemoveStream(window) {
          if (!window.RTCPeerConnection || 'removeStream' in window.RTCPeerConnection.prototype) {
            return;
          }

          window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
            var _this3 = this;

            utils.deprecated('removeStream', 'removeTrack');
            this.getSenders().forEach(function (sender) {
              if (sender.track && stream.getTracks().includes(sender.track)) {
                _this3.removeTrack(sender);
              }
            });
          };
        }

        function shimRTCDataChannel(window) {
          // rename DataChannel to RTCDataChannel (native fix in FF60):
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
          if (window.DataChannel && !window.RTCDataChannel) {
            window.RTCDataChannel = window.DataChannel;
          }
        }

        function shimAddTransceiver(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;

          if (origAddTransceiver) {
            window.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
              this.setParametersPromises = [];
              var initParameters = arguments[1];
              var shouldPerformCheck = initParameters && 'sendEncodings' in initParameters;

              if (shouldPerformCheck) {
                // If sendEncodings params are provided, validate grammar
                initParameters.sendEncodings.forEach(function (encodingParam) {
                  if ('rid' in encodingParam) {
                    var ridRegex = /^[a-z0-9]{0,16}$/i;

                    if (!ridRegex.test(encodingParam.rid)) {
                      throw new TypeError('Invalid RID value provided.');
                    }
                  }

                  if ('scaleResolutionDownBy' in encodingParam) {
                    if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                      throw new RangeError('scale_resolution_down_by must be >= 1.0');
                    }
                  }

                  if ('maxFramerate' in encodingParam) {
                    if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                      throw new RangeError('max_framerate must be >= 0.0');
                    }
                  }
                });
              }

              var transceiver = origAddTransceiver.apply(this, arguments);

              if (shouldPerformCheck) {
                // Check if the init options were applied. If not we do this in an
                // asynchronous way and save the promise reference in a global object.
                // This is an ugly hack, but at the same time is way more robust than
                // checking the sender parameters before and after the createOffer
                // Also note that after the createoffer we are not 100% sure that
                // the params were asynchronously applied so we might miss the
                // opportunity to recreate offer.
                var sender = transceiver.sender;
                var params = sender.getParameters();

                if (!('encodings' in params)) {
                  params.encodings = initParameters.sendEncodings;
                  this.setParametersPromises.push(sender.setParameters(params)["catch"](function () {}));
                }
              }

              return transceiver;
            };
          }
        }

        function shimCreateOffer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

          window.RTCPeerConnection.prototype.createOffer = function createOffer() {
            var _this4 = this,
                _arguments2 = arguments;

            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises).then(function () {
                return origCreateOffer.apply(_this4, _arguments2);
              })["finally"](function () {
                _this4.setParametersPromises = [];
              });
            }

            return origCreateOffer.apply(this, arguments);
          };
        }

        function shimCreateAnswer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCPeerConnection)) {
            return;
          }

          var origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;

          window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
            var _this5 = this,
                _arguments3 = arguments;

            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises).then(function () {
                return origCreateAnswer.apply(_this5, _arguments3);
              })["finally"](function () {
                _this5.setParametersPromises = [];
              });
            }

            return origCreateAnswer.apply(this, arguments);
          };
        }
      }, {
        "../utils": 11,
        "./getdisplaymedia": 8,
        "./getusermedia": 9
      }],
      8: [function (require, module, exports) {
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.shimGetDisplayMedia = shimGetDisplayMedia;

        function shimGetDisplayMedia(window, preferredMediaSource) {
          if (window.navigator.mediaDevices && 'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }

          if (!window.navigator.mediaDevices) {
            return;
          }

          window.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
            if (!(constraints && constraints.video)) {
              var err = new DOMException('getDisplayMedia without video ' + 'constraints is undefined');
              err.name = 'NotFoundError'; // from https://heycam.github.io/webidl/#idl-DOMException-error-names

              err.code = 8;
              return Promise.reject(err);
            }

            if (constraints.video === true) {
              constraints.video = {
                mediaSource: preferredMediaSource
              };
            } else {
              constraints.video.mediaSource = preferredMediaSource;
            }

            return window.navigator.mediaDevices.getUserMedia(constraints);
          };
        }
      }, {}],
      9: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimGetUserMedia = shimGetUserMedia;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function shimGetUserMedia(window) {
          var browserDetails = utils.detectBrowser(window);
          var navigator = window && window.navigator;
          var MediaStreamTrack = window && window.MediaStreamTrack;

          navigator.getUserMedia = function (constraints, onSuccess, onError) {
            // Replace Firefox 44+'s deprecation warning with unprefixed version.
            utils.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia');
            navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
          };

          if (!(browserDetails.version > 55 && 'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
            var remap = function remap(obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };

            var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

            navigator.mediaDevices.getUserMedia = function (c) {
              if ((typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && _typeof(c.audio) === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
              }

              return nativeGetUserMedia(c);
            };

            if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
              var nativeGetSettings = MediaStreamTrack.prototype.getSettings;

              MediaStreamTrack.prototype.getSettings = function () {
                var obj = nativeGetSettings.apply(this, arguments);
                remap(obj, 'mozAutoGainControl', 'autoGainControl');
                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
                return obj;
              };
            }

            if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
              var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;

              MediaStreamTrack.prototype.applyConstraints = function (c) {
                if (this.kind === 'audio' && (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object') {
                  c = JSON.parse(JSON.stringify(c));
                  remap(c, 'autoGainControl', 'mozAutoGainControl');
                  remap(c, 'noiseSuppression', 'mozNoiseSuppression');
                }

                return nativeApplyConstraints.apply(this, [c]);
              };
            }
          }
        }
      }, {
        "../utils": 11
      }],
      10: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.shimLocalStreamsAPI = shimLocalStreamsAPI;
        exports.shimRemoteStreamsAPI = shimRemoteStreamsAPI;
        exports.shimCallbacksAPI = shimCallbacksAPI;
        exports.shimGetUserMedia = shimGetUserMedia;
        exports.shimConstraints = shimConstraints;
        exports.shimRTCIceServerUrls = shimRTCIceServerUrls;
        exports.shimTrackEventTransceiver = shimTrackEventTransceiver;
        exports.shimCreateOfferLegacy = shimCreateOfferLegacy;

        var _utils = require('../utils');

        var utils = _interopRequireWildcard(_utils);

        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          } else {
            var newObj = {};

            if (obj != null) {
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
              }
            }

            newObj["default"] = obj;
            return newObj;
          }
        }

        function shimLocalStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
              if (!this._localStreams) {
                this._localStreams = [];
              }

              return this._localStreams;
            };
          }

          if (!('addStream' in window.RTCPeerConnection.prototype)) {
            var _addTrack = window.RTCPeerConnection.prototype.addTrack;

            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              var _this = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }

              if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              } // Try to emulate Chrome's behaviour of adding in audio-video order.
              // Safari orders by track id.


              stream.getAudioTracks().forEach(function (track) {
                return _addTrack.call(_this, track, stream);
              });
              stream.getVideoTracks().forEach(function (track) {
                return _addTrack.call(_this, track, stream);
              });
            };

            window.RTCPeerConnection.prototype.addTrack = function addTrack(track) {
              var stream = arguments[1];

              if (stream) {
                if (!this._localStreams) {
                  this._localStreams = [stream];
                } else if (!this._localStreams.includes(stream)) {
                  this._localStreams.push(stream);
                }
              }

              return _addTrack.apply(this, arguments);
            };
          }

          if (!('removeStream' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
              var _this2 = this;

              if (!this._localStreams) {
                this._localStreams = [];
              }

              var index = this._localStreams.indexOf(stream);

              if (index === -1) {
                return;
              }

              this._localStreams.splice(index, 1);

              var tracks = stream.getTracks();
              this.getSenders().forEach(function (sender) {
                if (tracks.includes(sender.track)) {
                  _this2.removeTrack(sender);
                }
              });
            };
          }
        }

        function shimRemoteStreamsAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
              return this._remoteStreams ? this._remoteStreams : [];
            };
          }

          if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
              get: function get() {
                return this._onaddstream;
              },
              set: function set(f) {
                var _this3 = this;

                if (this._onaddstream) {
                  this.removeEventListener('addstream', this._onaddstream);
                  this.removeEventListener('track', this._onaddstreampoly);
                }

                this.addEventListener('addstream', this._onaddstream = f);
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach(function (stream) {
                    if (!_this3._remoteStreams) {
                      _this3._remoteStreams = [];
                    }

                    if (_this3._remoteStreams.includes(stream)) {
                      return;
                    }

                    _this3._remoteStreams.push(stream);

                    var event = new Event('addstream');
                    event.stream = stream;

                    _this3.dispatchEvent(event);
                  });
                });
              }
            });
            var origSetRemoteDescription = window.RTCPeerConnection.prototype.setRemoteDescription;

            window.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
              var pc = this;

              if (!this._onaddstreampoly) {
                this.addEventListener('track', this._onaddstreampoly = function (e) {
                  e.streams.forEach(function (stream) {
                    if (!pc._remoteStreams) {
                      pc._remoteStreams = [];
                    }

                    if (pc._remoteStreams.indexOf(stream) >= 0) {
                      return;
                    }

                    pc._remoteStreams.push(stream);

                    var event = new Event('addstream');
                    event.stream = stream;
                    pc.dispatchEvent(event);
                  });
                });
              }

              return origSetRemoteDescription.apply(pc, arguments);
            };
          }
        }

        function shimCallbacksAPI(window) {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !window.RTCPeerConnection) {
            return;
          }

          var prototype = window.RTCPeerConnection.prototype;
          var origCreateOffer = prototype.createOffer;
          var origCreateAnswer = prototype.createAnswer;
          var setLocalDescription = prototype.setLocalDescription;
          var setRemoteDescription = prototype.setRemoteDescription;
          var addIceCandidate = prototype.addIceCandidate;

          prototype.createOffer = function createOffer(successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = origCreateOffer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
            var options = arguments.length >= 2 ? arguments[2] : arguments[0];
            var promise = origCreateAnswer.apply(this, [options]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          var withCallback = function withCallback(description, successCallback, failureCallback) {
            var promise = setLocalDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setLocalDescription = withCallback;

          withCallback = function withCallback(description, successCallback, failureCallback) {
            var promise = setRemoteDescription.apply(this, [description]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.setRemoteDescription = withCallback;

          withCallback = function withCallback(candidate, successCallback, failureCallback) {
            var promise = addIceCandidate.apply(this, [candidate]);

            if (!failureCallback) {
              return promise;
            }

            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };

          prototype.addIceCandidate = withCallback;
        }

        function shimGetUserMedia(window) {
          var navigator = window && window.navigator;

          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // shim not needed in Safari 12.1
            var mediaDevices = navigator.mediaDevices;

            var _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);

            navigator.mediaDevices.getUserMedia = function (constraints) {
              return _getUserMedia(shimConstraints(constraints));
            };
          }

          if (!navigator.getUserMedia && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
              navigator.mediaDevices.getUserMedia(constraints).then(cb, errcb);
            }.bind(navigator);
          }
        }

        function shimConstraints(constraints) {
          if (constraints && constraints.video !== undefined) {
            return Object.assign({}, constraints, {
              video: utils.compactObject(constraints.video)
            });
          }

          return constraints;
        }

        function shimRTCIceServerUrls(window) {
          // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
          var OrigPeerConnection = window.RTCPeerConnection;

          window.RTCPeerConnection = function RTCPeerConnection(pcConfig, pcConstraints) {
            if (pcConfig && pcConfig.iceServers) {
              var newIceServers = [];

              for (var i = 0; i < pcConfig.iceServers.length; i++) {
                var server = pcConfig.iceServers[i];

                if (!server.hasOwnProperty('urls') && server.hasOwnProperty('url')) {
                  utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                  server = JSON.parse(JSON.stringify(server));
                  server.urls = server.url;
                  delete server.url;
                  newIceServers.push(server);
                } else {
                  newIceServers.push(pcConfig.iceServers[i]);
                }
              }

              pcConfig.iceServers = newIceServers;
            }

            return new OrigPeerConnection(pcConfig, pcConstraints);
          };

          window.RTCPeerConnection.prototype = OrigPeerConnection.prototype; // wrap static methods. Currently just generateCertificate.

          if ('generateCertificate' in window.RTCPeerConnection) {
            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get: function get() {
                return OrigPeerConnection.generateCertificate;
              }
            });
          }
        }

        function shimTrackEventTransceiver(window) {
          // Add event.transceiver member over deprecated event.receiver
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.RTCTrackEvent && 'receiver' in window.RTCTrackEvent.prototype && !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get: function get() {
                return {
                  receiver: this.receiver
                };
              }
            });
          }
        }

        function shimCreateOfferLegacy(window) {
          var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;

          window.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
            if (offerOptions) {
              if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
              }

              var audioTransceiver = this.getTransceivers().find(function (transceiver) {
                return transceiver.receiver.track.kind === 'audio';
              });

              if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                if (audioTransceiver.direction === 'sendrecv') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('sendonly');
                  } else {
                    audioTransceiver.direction = 'sendonly';
                  }
                } else if (audioTransceiver.direction === 'recvonly') {
                  if (audioTransceiver.setDirection) {
                    audioTransceiver.setDirection('inactive');
                  } else {
                    audioTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
                this.addTransceiver('audio');
              }

              if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
                // support bit values
                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
              }

              var videoTransceiver = this.getTransceivers().find(function (transceiver) {
                return transceiver.receiver.track.kind === 'video';
              });

              if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                if (videoTransceiver.direction === 'sendrecv') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('sendonly');
                  } else {
                    videoTransceiver.direction = 'sendonly';
                  }
                } else if (videoTransceiver.direction === 'recvonly') {
                  if (videoTransceiver.setDirection) {
                    videoTransceiver.setDirection('inactive');
                  } else {
                    videoTransceiver.direction = 'inactive';
                  }
                }
              } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
                this.addTransceiver('video');
              }
            }

            return origCreateOffer.apply(this, arguments);
          };
        }
      }, {
        "../utils": 11
      }],
      11: [function (require, module, exports) {
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */

        /* eslint-env node */
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
          return _typeof2(obj);
        } : function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
        };

        exports.extractVersion = extractVersion;
        exports.wrapPeerConnectionEvent = wrapPeerConnectionEvent;
        exports.disableLog = disableLog;
        exports.disableWarnings = disableWarnings;
        exports.log = log;
        exports.deprecated = deprecated;
        exports.detectBrowser = detectBrowser;
        exports.compactObject = compactObject;
        exports.walkStats = walkStats;
        exports.filterStats = filterStats;

        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value: value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }

          return obj;
        }

        var logDisabled_ = true;
        var deprecationWarnings_ = true;
        /**
         * Extract browser version out of the provided user agent string.
         *
         * @param {!string} uastring userAgent string.
         * @param {!string} expr Regular expression used as match criteria.
         * @param {!number} pos position in the version string to be returned.
         * @return {!number} browser version.
         */

        function extractVersion(uastring, expr, pos) {
          var match = uastring.match(expr);
          return match && match.length >= pos && parseInt(match[pos], 10);
        } // Wraps the peerconnection event eventNameToWrap in a function
        // which returns the modified event object (or false to prevent
        // the event).


        function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
          if (!window.RTCPeerConnection) {
            return;
          }

          var proto = window.RTCPeerConnection.prototype;
          var nativeAddEventListener = proto.addEventListener;

          proto.addEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap) {
              return nativeAddEventListener.apply(this, arguments);
            }

            var wrappedCallback = function wrappedCallback(e) {
              var modifiedEvent = wrapper(e);

              if (modifiedEvent) {
                cb(modifiedEvent);
              }
            };

            this._eventMap = this._eventMap || {};
            this._eventMap[cb] = wrappedCallback;
            return nativeAddEventListener.apply(this, [nativeEventName, wrappedCallback]);
          };

          var nativeRemoveEventListener = proto.removeEventListener;

          proto.removeEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[cb]) {
              return nativeRemoveEventListener.apply(this, arguments);
            }

            var unwrappedCb = this._eventMap[cb];
            delete this._eventMap[cb];
            return nativeRemoveEventListener.apply(this, [nativeEventName, unwrappedCb]);
          };

          Object.defineProperty(proto, 'on' + eventNameToWrap, {
            get: function get() {
              return this['_on' + eventNameToWrap];
            },
            set: function set(cb) {
              if (this['_on' + eventNameToWrap]) {
                this.removeEventListener(eventNameToWrap, this['_on' + eventNameToWrap]);
                delete this['_on' + eventNameToWrap];
              }

              if (cb) {
                this.addEventListener(eventNameToWrap, this['_on' + eventNameToWrap] = cb);
              }
            },
            enumerable: true,
            configurable: true
          });
        }

        function disableLog(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
          }

          logDisabled_ = bool;
          return bool ? 'adapter.js logging disabled' : 'adapter.js logging enabled';
        }
        /**
         * Disable or enable deprecation warnings
         * @param {!boolean} bool set to true to disable warnings.
         */


        function disableWarnings(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + (typeof bool === 'undefined' ? 'undefined' : _typeof(bool)) + '. Please use a boolean.');
          }

          deprecationWarnings_ = !bool;
          return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
        }

        function log() {
          if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object') {
            if (logDisabled_) {
              return;
            }

            if (typeof console !== 'undefined' && typeof console.log === 'function') {
              console.log.apply(console, arguments);
            }
          }
        }
        /**
         * Shows a deprecation warning suggesting the modern and spec-compatible API.
         */


        function deprecated(oldMethod, newMethod) {
          if (!deprecationWarnings_) {
            return;
          }

          console.warn(oldMethod + ' is deprecated, please use ' + newMethod + ' instead.');
        }
        /**
         * Browser detector.
         *
         * @return {object} result containing browser and version
         *     properties.
         */


        function detectBrowser(window) {
          var navigator = window.navigator; // Returned result object.

          var result = {
            browser: null,
            version: null
          }; // Fail early if it's not a browser

          if (typeof window === 'undefined' || !window.navigator) {
            result.browser = 'Not a browser.';
            return result;
          }

          if (navigator.mozGetUserMedia) {
            // Firefox.
            result.browser = 'firefox';
            result.version = extractVersion(navigator.userAgent, /Firefox\/(\d+)\./, 1);
          } else if (navigator.webkitGetUserMedia || window.isSecureContext === false && window.webkitRTCPeerConnection && !window.RTCIceGatherer) {
            // Chrome, Chromium, Webview, Opera.
            // Version matches Chrome/WebRTC version.
            // Chrome 74 removed webkitGetUserMedia on http as well so we need the
            // more complicated fallback to webkitRTCPeerConnection.
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
          } else if (navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
            // Edge.
            result.browser = 'edge';
            result.version = extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
          } else if (window.RTCPeerConnection && navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
            // Safari.
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
            result.supportsUnifiedPlan = window.RTCRtpTransceiver && 'currentDirection' in window.RTCRtpTransceiver.prototype;
          } else {
            // Default fallthrough: not supported.
            result.browser = 'Not a supported browser.';
            return result;
          }

          return result;
        }
        /**
         * Checks if something is an object.
         *
         * @param {*} val The something you want to check.
         * @return true if val is an object, false otherwise.
         */


        function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        }
        /**
         * Remove all empty objects and undefined values
         * from a nested object -- an enhanced and vanilla version
         * of Lodash's `compact`.
         */


        function compactObject(data) {
          if (!isObject(data)) {
            return data;
          }

          return Object.keys(data).reduce(function (accumulator, key) {
            var isObj = isObject(data[key]);
            var value = isObj ? compactObject(data[key]) : data[key];
            var isEmptyObject = isObj && !Object.keys(value).length;

            if (value === undefined || isEmptyObject) {
              return accumulator;
            }

            return Object.assign(accumulator, _defineProperty({}, key, value));
          }, {});
        }
        /* iterates the stats graph recursively. */


        function walkStats(stats, base, resultSet) {
          if (!base || resultSet.has(base.id)) {
            return;
          }

          resultSet.set(base.id, base);
          Object.keys(base).forEach(function (name) {
            if (name.endsWith('Id')) {
              walkStats(stats, stats.get(base[name]), resultSet);
            } else if (name.endsWith('Ids')) {
              base[name].forEach(function (id) {
                walkStats(stats, stats.get(id), resultSet);
              });
            }
          });
        }
        /* filter getStats for a sender/receiver track. */


        function filterStats(result, track, outbound) {
          var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
          var filteredResult = new Map();

          if (track === null) {
            return filteredResult;
          }

          var trackStats = [];
          result.forEach(function (value) {
            if (value.type === 'track' && value.trackIdentifier === track.id) {
              trackStats.push(value);
            }
          });
          trackStats.forEach(function (trackStat) {
            result.forEach(function (stats) {
              if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
                walkStats(result, stats, filteredResult);
              }
            });
          });
          return filteredResult;
        }
      }, {}],
      12: [function (require, module, exports) {}, {}],
      13: [function (require, module, exports) {
        /* eslint-env node */
        'use strict'; // SDP helpers.

        var SDPUtils = {}; // Generate an alphanumeric identifier for cname or mids.
        // TODO: use UUIDs instead? https://gist.github.com/jed/982883

        SDPUtils.generateIdentifier = function () {
          return Math.random().toString(36).substr(2, 10);
        }; // The RTCP CNAME used by all peerconnections from the same JS.


        SDPUtils.localCName = SDPUtils.generateIdentifier(); // Splits SDP into lines, dealing with both CRLF and LF.

        SDPUtils.splitLines = function (blob) {
          return blob.trim().split('\n').map(function (line) {
            return line.trim();
          });
        }; // Splits SDP into sessionpart and mediasections. Ensures CRLF.


        SDPUtils.splitSections = function (blob) {
          var parts = blob.split('\nm=');
          return parts.map(function (part, index) {
            return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
          });
        }; // returns the session description.


        SDPUtils.getDescription = function (blob) {
          var sections = SDPUtils.splitSections(blob);
          return sections && sections[0];
        }; // returns the individual media sections.


        SDPUtils.getMediaSections = function (blob) {
          var sections = SDPUtils.splitSections(blob);
          sections.shift();
          return sections;
        }; // Returns lines that start with a certain prefix.


        SDPUtils.matchPrefix = function (blob, prefix) {
          return SDPUtils.splitLines(blob).filter(function (line) {
            return line.indexOf(prefix) === 0;
          });
        }; // Parses an ICE candidate line. Sample input:
        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
        // rport 55996"


        SDPUtils.parseCandidate = function (line) {
          var parts; // Parse both variants.

          if (line.indexOf('a=candidate:') === 0) {
            parts = line.substring(12).split(' ');
          } else {
            parts = line.substring(10).split(' ');
          }

          var candidate = {
            foundation: parts[0],
            component: parseInt(parts[1], 10),
            protocol: parts[2].toLowerCase(),
            priority: parseInt(parts[3], 10),
            ip: parts[4],
            address: parts[4],
            // address is an alias for ip.
            port: parseInt(parts[5], 10),
            // skip parts[6] == 'typ'
            type: parts[7]
          };

          for (var i = 8; i < parts.length; i += 2) {
            switch (parts[i]) {
              case 'raddr':
                candidate.relatedAddress = parts[i + 1];
                break;

              case 'rport':
                candidate.relatedPort = parseInt(parts[i + 1], 10);
                break;

              case 'tcptype':
                candidate.tcpType = parts[i + 1];
                break;

              case 'ufrag':
                candidate.ufrag = parts[i + 1]; // for backward compability.

                candidate.usernameFragment = parts[i + 1];
                break;

              default:
                // extension handling, in particular ufrag
                candidate[parts[i]] = parts[i + 1];
                break;
            }
          }

          return candidate;
        }; // Translates a candidate object into SDP candidate attribute.


        SDPUtils.writeCandidate = function (candidate) {
          var sdp = [];
          sdp.push(candidate.foundation);
          sdp.push(candidate.component);
          sdp.push(candidate.protocol.toUpperCase());
          sdp.push(candidate.priority);
          sdp.push(candidate.address || candidate.ip);
          sdp.push(candidate.port);
          var type = candidate.type;
          sdp.push('typ');
          sdp.push(type);

          if (type !== 'host' && candidate.relatedAddress && candidate.relatedPort) {
            sdp.push('raddr');
            sdp.push(candidate.relatedAddress);
            sdp.push('rport');
            sdp.push(candidate.relatedPort);
          }

          if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
            sdp.push('tcptype');
            sdp.push(candidate.tcpType);
          }

          if (candidate.usernameFragment || candidate.ufrag) {
            sdp.push('ufrag');
            sdp.push(candidate.usernameFragment || candidate.ufrag);
          }

          return 'candidate:' + sdp.join(' ');
        }; // Parses an ice-options line, returns an array of option tags.
        // a=ice-options:foo bar


        SDPUtils.parseIceOptions = function (line) {
          return line.substr(14).split(' ');
        }; // Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
        // a=rtpmap:111 opus/48000/2


        SDPUtils.parseRtpMap = function (line) {
          var parts = line.substr(9).split(' ');
          var parsed = {
            payloadType: parseInt(parts.shift(), 10) // was: id

          };
          parts = parts[0].split('/');
          parsed.name = parts[0];
          parsed.clockRate = parseInt(parts[1], 10); // was: clockrate

          parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1; // legacy alias, got renamed back to channels in ORTC.

          parsed.numChannels = parsed.channels;
          return parsed;
        }; // Generate an a=rtpmap line from RTCRtpCodecCapability or
        // RTCRtpCodecParameters.


        SDPUtils.writeRtpMap = function (codec) {
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          var channels = codec.channels || codec.numChannels || 1;
          return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate + (channels !== 1 ? '/' + channels : '') + '\r\n';
        }; // Parses an a=extmap line (headerextension from RFC 5285). Sample input:
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset


        SDPUtils.parseExtmap = function (line) {
          var parts = line.substr(9).split(' ');
          return {
            id: parseInt(parts[0], 10),
            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
            uri: parts[1]
          };
        }; // Generates a=extmap line from RTCRtpHeaderExtensionParameters or
        // RTCRtpHeaderExtension.


        SDPUtils.writeExtmap = function (headerExtension) {
          return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== 'sendrecv' ? '/' + headerExtension.direction : '') + ' ' + headerExtension.uri + '\r\n';
        }; // Parses an ftmp line, returns dictionary. Sample input:
        // a=fmtp:96 vbr=on;cng=on
        // Also deals with vbr=on; cng=on


        SDPUtils.parseFmtp = function (line) {
          var parsed = {};
          var kv;
          var parts = line.substr(line.indexOf(' ') + 1).split(';');

          for (var j = 0; j < parts.length; j++) {
            kv = parts[j].trim().split('=');
            parsed[kv[0].trim()] = kv[1];
          }

          return parsed;
        }; // Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.


        SDPUtils.writeFmtp = function (codec) {
          var line = '';
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          if (codec.parameters && Object.keys(codec.parameters).length) {
            var params = [];
            Object.keys(codec.parameters).forEach(function (param) {
              if (codec.parameters[param]) {
                params.push(param + '=' + codec.parameters[param]);
              } else {
                params.push(param);
              }
            });
            line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
          }

          return line;
        }; // Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
        // a=rtcp-fb:98 nack rpsi


        SDPUtils.parseRtcpFb = function (line) {
          var parts = line.substr(line.indexOf(' ') + 1).split(' ');
          return {
            type: parts.shift(),
            parameter: parts.join(' ')
          };
        }; // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.


        SDPUtils.writeRtcpFb = function (codec) {
          var lines = '';
          var pt = codec.payloadType;

          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }

          if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
            // FIXME: special handling for trr-int?
            codec.rtcpFeedback.forEach(function (fb) {
              lines += 'a=rtcp-fb:' + pt + ' ' + fb.type + (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') + '\r\n';
            });
          }

          return lines;
        }; // Parses an RFC 5576 ssrc media attribute. Sample input:
        // a=ssrc:3735928559 cname:something


        SDPUtils.parseSsrcMedia = function (line) {
          var sp = line.indexOf(' ');
          var parts = {
            ssrc: parseInt(line.substr(7, sp - 7), 10)
          };
          var colon = line.indexOf(':', sp);

          if (colon > -1) {
            parts.attribute = line.substr(sp + 1, colon - sp - 1);
            parts.value = line.substr(colon + 1);
          } else {
            parts.attribute = line.substr(sp + 1);
          }

          return parts;
        };

        SDPUtils.parseSsrcGroup = function (line) {
          var parts = line.substr(13).split(' ');
          return {
            semantics: parts.shift(),
            ssrcs: parts.map(function (ssrc) {
              return parseInt(ssrc, 10);
            })
          };
        }; // Extracts the MID (RFC 5888) from a media section.
        // returns the MID or undefined if no mid line was found.


        SDPUtils.getMid = function (mediaSection) {
          var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];

          if (mid) {
            return mid.substr(6);
          }
        };

        SDPUtils.parseFingerprint = function (line) {
          var parts = line.substr(14).split(' ');
          return {
            algorithm: parts[0].toLowerCase(),
            // algorithm is case-sensitive in Edge.
            value: parts[1]
          };
        }; // Extracts DTLS parameters from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the fingerprint line as input. See also getIceParameters.


        SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
          var lines = SDPUtils.matchPrefix(mediaSection + sessionpart, 'a=fingerprint:'); // Note: a=setup line is ignored since we use the 'auto' role.
          // Note2: 'algorithm' is not case sensitive except in Edge.

          return {
            role: 'auto',
            fingerprints: lines.map(SDPUtils.parseFingerprint)
          };
        }; // Serializes DTLS parameters to SDP.


        SDPUtils.writeDtlsParameters = function (params, setupType) {
          var sdp = 'a=setup:' + setupType + '\r\n';
          params.fingerprints.forEach(function (fp) {
            sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
          });
          return sdp;
        }; // Parses ICE information from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the ice-ufrag and ice-pwd lines as input.


        SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
          var lines = SDPUtils.splitLines(mediaSection); // Search in session part, too.

          lines = lines.concat(SDPUtils.splitLines(sessionpart));
          var iceParameters = {
            usernameFragment: lines.filter(function (line) {
              return line.indexOf('a=ice-ufrag:') === 0;
            })[0].substr(12),
            password: lines.filter(function (line) {
              return line.indexOf('a=ice-pwd:') === 0;
            })[0].substr(10)
          };
          return iceParameters;
        }; // Serializes ICE parameters to SDP.


        SDPUtils.writeIceParameters = function (params) {
          return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' + 'a=ice-pwd:' + params.password + '\r\n';
        }; // Parses the SDP media section and returns RTCRtpParameters.


        SDPUtils.parseRtpParameters = function (mediaSection) {
          var description = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
            rtcp: []
          };
          var lines = SDPUtils.splitLines(mediaSection);
          var mline = lines[0].split(' ');

          for (var i = 3; i < mline.length; i++) {
            // find all codecs from mline[3..]
            var pt = mline[i];
            var rtpmapline = SDPUtils.matchPrefix(mediaSection, 'a=rtpmap:' + pt + ' ')[0];

            if (rtpmapline) {
              var codec = SDPUtils.parseRtpMap(rtpmapline);
              var fmtps = SDPUtils.matchPrefix(mediaSection, 'a=fmtp:' + pt + ' '); // Only the first a=fmtp:<pt> is considered.

              codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
              codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-fb:' + pt + ' ').map(SDPUtils.parseRtcpFb);
              description.codecs.push(codec); // parse FEC mechanisms from rtpmap lines.

              switch (codec.name.toUpperCase()) {
                case 'RED':
                case 'ULPFEC':
                  description.fecMechanisms.push(codec.name.toUpperCase());
                  break;

                default:
                  // only RED and ULPFEC are recognized as FEC mechanisms.
                  break;
              }
            }
          }

          SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (line) {
            description.headerExtensions.push(SDPUtils.parseExtmap(line));
          }); // FIXME: parse rtcp.

          return description;
        }; // Generates parts of the SDP media section describing the capabilities /
        // parameters.


        SDPUtils.writeRtpDescription = function (kind, caps) {
          var sdp = ''; // Build the mline.

          sdp += 'm=' + kind + ' ';
          sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.

          sdp += ' UDP/TLS/RTP/SAVPF ';
          sdp += caps.codecs.map(function (codec) {
            if (codec.preferredPayloadType !== undefined) {
              return codec.preferredPayloadType;
            }

            return codec.payloadType;
          }).join(' ') + '\r\n';
          sdp += 'c=IN IP4 0.0.0.0\r\n';
          sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n'; // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.

          caps.codecs.forEach(function (codec) {
            sdp += SDPUtils.writeRtpMap(codec);
            sdp += SDPUtils.writeFmtp(codec);
            sdp += SDPUtils.writeRtcpFb(codec);
          });
          var maxptime = 0;
          caps.codecs.forEach(function (codec) {
            if (codec.maxptime > maxptime) {
              maxptime = codec.maxptime;
            }
          });

          if (maxptime > 0) {
            sdp += 'a=maxptime:' + maxptime + '\r\n';
          }

          sdp += 'a=rtcp-mux\r\n';

          if (caps.headerExtensions) {
            caps.headerExtensions.forEach(function (extension) {
              sdp += SDPUtils.writeExtmap(extension);
            });
          } // FIXME: write fecMechanisms.


          return sdp;
        }; // Parses the SDP media section and returns an array of
        // RTCRtpEncodingParameters.


        SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
          var encodingParameters = [];
          var description = SDPUtils.parseRtpParameters(mediaSection);
          var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
          var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1; // filter a=ssrc:... cname:, ignore PlanB-msid

          var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (parts) {
            return parts.attribute === 'cname';
          });
          var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
          var secondarySsrc;
          var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID').map(function (line) {
            var parts = line.substr(17).split(' ');
            return parts.map(function (part) {
              return parseInt(part, 10);
            });
          });

          if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
            secondarySsrc = flows[0][1];
          }

          description.codecs.forEach(function (codec) {
            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
              var encParam = {
                ssrc: primarySsrc,
                codecPayloadType: parseInt(codec.parameters.apt, 10)
              };

              if (primarySsrc && secondarySsrc) {
                encParam.rtx = {
                  ssrc: secondarySsrc
                };
              }

              encodingParameters.push(encParam);

              if (hasRed) {
                encParam = JSON.parse(JSON.stringify(encParam));
                encParam.fec = {
                  ssrc: primarySsrc,
                  mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
                };
                encodingParameters.push(encParam);
              }
            }
          });

          if (encodingParameters.length === 0 && primarySsrc) {
            encodingParameters.push({
              ssrc: primarySsrc
            });
          } // we support both b=AS and b=TIAS but interpret AS as TIAS.


          var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');

          if (bandwidth.length) {
            if (bandwidth[0].indexOf('b=TIAS:') === 0) {
              bandwidth = parseInt(bandwidth[0].substr(7), 10);
            } else if (bandwidth[0].indexOf('b=AS:') === 0) {
              // use formula from JSEP to convert b=AS to TIAS value.
              bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95 - 50 * 40 * 8;
            } else {
              bandwidth = undefined;
            }

            encodingParameters.forEach(function (params) {
              params.maxBitrate = bandwidth;
            });
          }

          return encodingParameters;
        }; // parses http://draft.ortc.org/#rtcrtcpparameters*


        SDPUtils.parseRtcpParameters = function (mediaSection) {
          var rtcpParameters = {}; // Gets the first SSRC. Note tha with RTX there might be multiple
          // SSRCs.

          var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (obj) {
            return obj.attribute === 'cname';
          })[0];

          if (remoteSsrc) {
            rtcpParameters.cname = remoteSsrc.value;
            rtcpParameters.ssrc = remoteSsrc.ssrc;
          } // Edge uses the compound attribute instead of reducedSize
          // compound is !reducedSize


          var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
          rtcpParameters.reducedSize = rsize.length > 0;
          rtcpParameters.compound = rsize.length === 0; // parses the rtcp-mux attrіbute.
          // Note that Edge does not support unmuxed RTCP.

          var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
          rtcpParameters.mux = mux.length > 0;
          return rtcpParameters;
        }; // parses either a=msid: or a=ssrc:... msid lines and returns
        // the id of the MediaStream and MediaStreamTrack.


        SDPUtils.parseMsid = function (mediaSection) {
          var parts;
          var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');

          if (spec.length === 1) {
            parts = spec[0].substr(7).split(' ');
            return {
              stream: parts[0],
              track: parts[1]
            };
          }

          var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:').map(function (line) {
            return SDPUtils.parseSsrcMedia(line);
          }).filter(function (msidParts) {
            return msidParts.attribute === 'msid';
          });

          if (planB.length > 0) {
            parts = planB[0].value.split(' ');
            return {
              stream: parts[0],
              track: parts[1]
            };
          }
        }; // SCTP
        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
        // to draft-ietf-mmusic-sctp-sdp-05


        SDPUtils.parseSctpDescription = function (mediaSection) {
          var mline = SDPUtils.parseMLine(mediaSection);
          var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
          var maxMessageSize;

          if (maxSizeLine.length > 0) {
            maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
          }

          if (isNaN(maxMessageSize)) {
            maxMessageSize = 65536;
          }

          var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');

          if (sctpPort.length > 0) {
            return {
              port: parseInt(sctpPort[0].substr(12), 10),
              protocol: mline.fmt,
              maxMessageSize: maxMessageSize
            };
          }

          var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');

          if (sctpMapLines.length > 0) {
            var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0].substr(10).split(' ');
            return {
              port: parseInt(parts[0], 10),
              protocol: parts[1],
              maxMessageSize: maxMessageSize
            };
          }
        }; // SCTP
        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
        // support by now receiving in this format, unless we originally parsed
        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
        // protocol of DTLS/SCTP -- without UDP/ or TCP/)


        SDPUtils.writeSctpDescription = function (media, sctp) {
          var output = [];

          if (media.protocol !== 'DTLS/SCTP') {
            output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctp-port:' + sctp.port + '\r\n'];
          } else {
            output = ['m=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n'];
          }

          if (sctp.maxMessageSize !== undefined) {
            output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
          }

          return output.join('');
        }; // Generate a session ID for SDP.
        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
        // recommends using a cryptographically random +ve 64-bit value
        // but right now this should be acceptable and within the right range


        SDPUtils.generateSessionId = function () {
          return Math.random().toString().substr(2, 21);
        }; // Write boilder plate for start of SDP
        // sessId argument is optional - if not supplied it will
        // be generated randomly
        // sessVersion is optional and defaults to 2
        // sessUser is optional and defaults to 'thisisadapterortc'


        SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
          var sessionId;
          var version = sessVer !== undefined ? sessVer : 2;

          if (sessId) {
            sessionId = sessId;
          } else {
            sessionId = SDPUtils.generateSessionId();
          }

          var user = sessUser || 'thisisadapterortc'; // FIXME: sess-id should be an NTP timestamp.

          return 'v=0\r\n' + 'o=' + user + ' ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' + 's=-\r\n' + 't=0 0\r\n';
        };

        SDPUtils.writeMediaSection = function (transceiver, caps, type, stream) {
          var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps); // Map ICE parameters (ufrag, pwd) to SDP.

          sdp += SDPUtils.writeIceParameters(transceiver.iceGatherer.getLocalParameters()); // Map DTLS parameters to SDP.

          sdp += SDPUtils.writeDtlsParameters(transceiver.dtlsTransport.getLocalParameters(), type === 'offer' ? 'actpass' : 'active');
          sdp += 'a=mid:' + transceiver.mid + '\r\n';

          if (transceiver.direction) {
            sdp += 'a=' + transceiver.direction + '\r\n';
          } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
            sdp += 'a=sendrecv\r\n';
          } else if (transceiver.rtpSender) {
            sdp += 'a=sendonly\r\n';
          } else if (transceiver.rtpReceiver) {
            sdp += 'a=recvonly\r\n';
          } else {
            sdp += 'a=inactive\r\n';
          }

          if (transceiver.rtpSender) {
            // spec.
            var msid = 'msid:' + stream.id + ' ' + transceiver.rtpSender.track.id + '\r\n';
            sdp += 'a=' + msid; // for Chrome.

            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' ' + msid;

            if (transceiver.sendEncodingParameters[0].rtx) {
              sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' ' + msid;
              sdp += 'a=ssrc-group:FID ' + transceiver.sendEncodingParameters[0].ssrc + ' ' + transceiver.sendEncodingParameters[0].rtx.ssrc + '\r\n';
            }
          } // FIXME: this should be written by writeRtpDescription.


          sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc + ' cname:' + SDPUtils.localCName + '\r\n';

          if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
            sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc + ' cname:' + SDPUtils.localCName + '\r\n';
          }

          return sdp;
        }; // Gets the direction from the mediaSection or the sessionpart.


        SDPUtils.getDirection = function (mediaSection, sessionpart) {
          // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
          var lines = SDPUtils.splitLines(mediaSection);

          for (var i = 0; i < lines.length; i++) {
            switch (lines[i]) {
              case 'a=sendrecv':
              case 'a=sendonly':
              case 'a=recvonly':
              case 'a=inactive':
                return lines[i].substr(2);

              default: // FIXME: What should happen here?

            }
          }

          if (sessionpart) {
            return SDPUtils.getDirection(sessionpart);
          }

          return 'sendrecv';
        };

        SDPUtils.getKind = function (mediaSection) {
          var lines = SDPUtils.splitLines(mediaSection);
          var mline = lines[0].split(' ');
          return mline[0].substr(2);
        };

        SDPUtils.isRejected = function (mediaSection) {
          return mediaSection.split(' ', 2)[1] === '0';
        };

        SDPUtils.parseMLine = function (mediaSection) {
          var lines = SDPUtils.splitLines(mediaSection);
          var parts = lines[0].substr(2).split(' ');
          return {
            kind: parts[0],
            port: parseInt(parts[1], 10),
            protocol: parts[2],
            fmt: parts.slice(3).join(' ')
          };
        };

        SDPUtils.parseOLine = function (mediaSection) {
          var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
          var parts = line.substr(2).split(' ');
          return {
            username: parts[0],
            sessionId: parts[1],
            sessionVersion: parseInt(parts[2], 10),
            netType: parts[3],
            addressType: parts[4],
            address: parts[5]
          };
        }; // a very naive interpretation of a valid SDP.


        SDPUtils.isValidSDP = function (blob) {
          if (typeof blob !== 'string' || blob.length === 0) {
            return false;
          }

          var lines = SDPUtils.splitLines(blob);

          for (var i = 0; i < lines.length; i++) {
            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
              return false;
            } // TODO: check the modifier a bit more.

          }

          return true;
        }; // Expose public methods.


        if (_typeof2(module) === 'object') {
          module.exports = SDPUtils;
        }
      }, {}]
    }, {}, [1])(1);
  });
});

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9MZXRzZWUvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0xldHNlZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9MZXRzZWUvLi9Db250ZXh0LmpzIiwid2VicGFjazovL0xldHNlZS8uL0xldHNlZS5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9TY3JlZW4uanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vVXRpbC5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9jb3JlL0NhbWVyYS5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9jb3JlL0RhdGEuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vY29yZS9PYmplY3QzRC5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9jb3JlL1BlcnNwZWN0aXZlQ2FtZXJhLmpzIiwid2VicGFjazovL0xldHNlZS8uL2NvcmUvU2NlbmUuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vY29yZS9UcmFja2FibGVNYW5hZ2VyLmpzIiwid2VicGFjazovL0xldHNlZS8uL2VuZ2luZS5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9lbnRpdHkvRW50aXR5LmpzIiwid2VicGFjazovL0xldHNlZS8uL2VudGl0eS9FbnRpdHlFdmVudC5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9lbnRpdHkvRW50aXR5RXZlbnRUeXBlLmpzIiwid2VicGFjazovL0xldHNlZS8uL2V4dGVybmFsL1RIUkVFLmpzIiwid2VicGFjazovL0xldHNlZS8uL2luZGV4LmpzIiwid2VicGFjazovL0xldHNlZS8uL2xpYnMvQ1NTUGFyc2VyLmpzIiwid2VicGFjazovL0xldHNlZS8uL2xpYnMvRW50aXR5UGFyc2VyLmpzIiwid2VicGFjazovL0xldHNlZS8uL2xpYnMvTWVzc2FnZVR5cGVzLmpzIiwid2VicGFjazovL0xldHNlZS8uL2xpYnMvT2JqZWN0VHJhY2tlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9saWJzL1ZpZGVvTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9tYXRoL0V1bGVyLmpzIiwid2VicGFjazovL0xldHNlZS8uL21hdGgvTWF0aC5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9tYXRoL01hdHJpeDMuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbWF0aC9NYXRyaXg0LmpzIiwid2VicGFjazovL0xldHNlZS8uL21hdGgvUXVhdGVybmlvbi5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9tYXRoL1ZlY3RvcjIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vbWF0aC9WZWN0b3IzLmpzIiwid2VicGFjazovL0xldHNlZS8uL29ic2VydmVycy9PYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9MZXRzZWUvLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvRW50aXR5T2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vb2JzZXJ2ZXJzL29ic2VydmVyL0xldHNlZU9ic2VydmVyLmpzIiwid2VicGFjazovL0xldHNlZS8uL3JlbmRlcmVyL0RPTVJlbmRlcmFibGUuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vcmVuZGVyZXIvRE9NUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vTGV0c2VlLy4vdmVuZG9yL2FkYXB0ZXJfbm9fZWRnZS5qcyJdLCJuYW1lcyI6WyJfb3MiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX29yaWVudGF0aW9uIiwiX2lzUG9ydHJhaXQiLCJCb2R5SWQiLCJEb21SZW5kZXJlcklkIiwiVmlkZW9Db250YWluZXJJZCIsIlBsYWNlaG9sZGVySWQiLCJDb250ZXh0IiwiY29uZmlnIiwid2lkdGgiLCJoZWlnaHQiLCJvcmllbnRhdGlvbiIsInZhbHVlIiwiY29udGV4dCIsImluc3RhbmNlIiwidHJhY2tlciIsIl9zY2VhbkNhbnZhcyIsIl92aWRlb0VsZW1lbnQiLCJ2aWRlb0xvYWRGbGFnIiwiZmlyc3RMb2FkRmxhZyIsIl9sZXRzZWVFbmdpbmVDb25maWciLCJydW5UeXBlIiwiZGF0YSIsInByb2plY3Rpb25QYXJhbWV0ZXIiLCJleHRlcm5hbCIsInZhbGlkYXRlQ29uZmlnIiwiX2NvbmZpZyIsImFwcEtleSIsIkFQUF9LRVkiLCJ0cmFja2VyVHlwZSIsImNhbWVyYVBhcmFtZXRlciIsImZvdiIsIm5lYXIiLCJmYXIiLCJ6SW5kZXgiLCJ6SW5kZXhJbmNyZW1lbnQiLCJ0eXBlIiwiRXJyb3IiLCJfX0xPQ0FMX18iLCJ2aWRlb1VybCIsImRlYnVnIiwiYm9keUlkIiwiZG9tUmVuZGVyZXJJZCIsInZpZGVvSWQiLCJ2aWRlb0NvbnRhaW5lcklkIiwicmVmSW1hZ2VEYXRhIiwiX3JlbmRlck1vZHVsZSIsIk1hcCIsImFkZFJlbmRlck1vZHVsZSIsIm1vZHVsZU9iamVjdCIsIm5hbWUiLCJvblJlbmRlciIsImNvbnNvbGUiLCJsb2ciLCJoYXMiLCJzZXQiLCJyZW1vdmVSZW5kZXJNb2R1bGUiLCJyZXNldFJlbmRlck1vZHVsZXMiLCJjbGVhciIsInJlbmRlck1vZHVsZXMiLCJyZW5kZXJNb2R1bGVNYXAiLCJvYmoiLCJmb3JFYWNoIiwidiIsImsiLCJMZXRzZWVQcml2YXRlIiwiZG9jdW1lbnQiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiTWVzc2FnZSIsIkxFVFNFRV9DU1MiLCJMRVRTRUVfTE9BRElORyIsIl9pc1BhdXNlIiwic3RhdGUiLCJfdXBkYXRlRmxhZyIsImVudGl0eU1hbmFnZXIiLCJFbnRpdHlQYXJzZXIiLCJ2aWRlb01hbmFnZXIiLCJWaWRlb01hbmFnZXIiLCJzdWJzY3JpYmUiLCJMRVRTRUVfRVZFTlQiLCJPTl9TVEFUVVMiLCJlIiwiY29kZSIsInN0YXR1cyIsInF1ZXJ5U2VsZWN0b3IiLCJzZXRBdHRyaWJ1dGUiLCJBUl9NT0RFX09OIiwiZG9tUGxhY2Vob2xkZXIiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJwbGFjZWhvbGRlcklkIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImFwcGVuZENoaWxkIiwiY3NzRGF0YSIsImNzc1BhcnNlciIsInBhcnNlIiwiZW50aXR5T2JzZXJ2ZXIiLCJFbnRpdHlPYnNlcnZlciIsIkVOVElUWV9FVkVOVCIsIlRSQUNLX1NUQVJUIiwibm90aWZ5IiwidHJhY2tTdGF0dXNDc3MiLCJUUkFDS19NT1ZFIiwiVFJBQ0tfRU5EIiwiY2hlY2tFbnRpdHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImluaXRFbnRpdHkiLCJ0aGVuIiwiZW50aXR5IiwiaW1hZ2UiLCJyZXN1bHQiLCJlcnJvciIsImNoZWNrRW52IiwiaW5pdCIsImNhbnZhc0VsZW1lbnQiLCJ2aWRlb0VsZW1lbnQiLCJzY3JlZW5JbmZvIiwiYW5nbGUiLCJzY3JlZW5Bc3BlY3RSYXRpbyIsImVuZ2luZSIsIkVuZ2luZSIsIndhcm4iLCJjaGVja1NjcmlwdCIsInNjcmlwdCIsInNyYyIsIlRSQUNLRVJfVVJMIiwiSU1BR0VfVFJBQ0tFUl9GSUxFX05BTUUiLCJNQVJLRVJfVFJBQ0tFUl9GSUxFX05BTUUiLCJRUkNPREVfVFJBQ0tFUl9GSUxFX05BTUUiLCJhcHBlbmQiLCJvbmxvYWQiLCJUcmFja2VyIiwib25lcnJvciIsInByb21pc2VDaGFpbiIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdG9wVHJhY2tlciIsIm9yaWVudGF0aW9uQ2hhbmdlIiwib25Db25maWd1cmF0aW9uQ2hhbmdlZCIsIlJPVEFUSU9OX0NIQU5HRSIsImV2Iiwic2NyZWVuIiwidW5kZWZpbmVkIiwiZml0V2lkdGhBbmRIZWlnaHQiLCJhbGwiLCJpbml0VHJhY2tlciIsInNldFJlZkltYWdlIiwiaW1nIiwiY3JlYXRlTWFya2VyU3RhdGUiLCJtYXJrZXJMaXN0IiwiY29kZUxpc3QiLCJyZW5kZXJBbGxUYXNrIiwiaXNQYXVzZSIsInJlbW92ZSIsIkFSX01PREVfT0ZGIiwiY29udGFpbmVyIiwiZGlzcGxheSIsInZhbCIsInBlcmZvcm1hbmNlIiwibm93IiwicHJvY2Vzc0ZyYW1lIiwiTEVUU0VFX0xPQURFRCIsImNoZWNrTG9hZGVyIiwic2V0VGltZW91dCIsIkVWRU5UX0FQUF9PTkxPQUQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtYXRyaXgiLCJjdXJyZW50U3RhdGUiLCJuZXdTdGF0ZSIsIlNUQVRFX1JFQ09HTklaRSIsIm1hcCIsIkpTT04iLCJvYmplY3RUcmFja2VyIiwidXBkYXRlU3RhdGUiLCJtYXJrZXJJZCIsImZpbHRlciIsImluY2x1ZGVzIiwibGV0c2VlTWFya2VySWQiLCJpbmRleE9mIiwiUkVDT0dOSVpFIiwiY29kZVN0cmluZyIsInNldFZpZGVvU291cmNlIiwiX2FyUmVuZGVyZXIiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJlcnIiLCJtZXNzYWdlIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiIsIm1zUmVxdWVzdEZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsIm1vekNhbmNlbEZ1bGxTY3JlZW4iLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm1zRXhpdEZ1bGxzY3JlZW4iLCJMZXRzZWVPYnNlcnZlciIsIlNjcmVlbiIsIl92aWRlb01hbmFnZXIiLCJyZWNvbm5lY3RNZWRpYVN0cmVhbSIsImNvbG9yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJsZXRzZWVXcmFwcGVyIiwibGV0c2VlTG9hZGVyIiwibGV0c2VlU3RhdHVzIiwiZGVmYXVsdExvYWRlckNvbnRlbnQiLCJsZXRzZWVTdHlsZSIsInN0YXR1c0h0bWwiLCJfaHRtbCIsImxvY2F0aW9uIiwiaHJlZiIsInN0YXR1c0NzcyIsIl9jc3MiLCJjcmVhdGVMZXRzZWVXcmFwcGVyIiwiaGVhZCIsImluZGV4Iiwic2hlZXQiLCJpbnNlcnRSdWxlIiwiaW5zZXJ0QmVmb3JlIiwiZmlyc3RDaGlsZCIsImNyZWF0ZUxvYWRlciIsImlubmVySFRNTCIsImNyZWF0ZVN0YXR1c1NjcmVlbiIsIkxFVFNFRV9TVEFUVVMiLCJhZGRWaWV3cG9ydCIsInZpZXdQb3J0VGFnIiwiY29udGVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibG9hZEltYWdlIiwicGF0aCIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsIlVVSUQiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJyZXBsYWNlIiwiYyIsInIiLCJNYXRoIiwicmFuZG9tIiwiZmxvb3IiLCJ0b1N0cmluZyIsImlzV2ViUlRDU3VwcG9ydGVkIiwiaXRlbSIsImlzTW9iaWxlIiwiQW5kcm9pZCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIm1hdGNoIiwiQmxhY2tCZXJyeSIsImlPUyIsIk9wZXJhIiwiV2luZG93cyIsImFueSIsImdldE9zTmFtZSIsIm9zTmFtZSIsImdldEJyb3dzZXJJbmZvIiwiaXNNb2JpbGVEZXZpY2UiLCJ0ZXN0IiwiaXNFZGdlIiwibXNTYXZlT3JPcGVuQmxvYiIsIm1zU2F2ZUJsb2IiLCJpc09wZXJhIiwib3BlcmEiLCJpc0ZpcmVmb3giLCJJbnN0YWxsVHJpZ2dlciIsImlzU2FmYXJpIiwiaXNDaHJvbWUiLCJjaHJvbWUiLCJpc0lFIiwiZG9jdW1lbnRNb2RlIiwiblZlciIsImFwcFZlcnNpb24iLCJuQWd0IiwiYnJvd3Nlck5hbWUiLCJhcHBOYW1lIiwiZnVsbFZlcnNpb24iLCJwYXJzZUZsb2F0IiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJuYW1lT2Zmc2V0IiwidmVyT2Zmc2V0IiwiaXgiLCJzcGxpdCIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwidG9Mb3dlckNhc2UiLCJ0b1VwcGVyQ2FzZSIsInNlYXJjaCIsImlzTmFOIiwiaGFzV2JjYW0iLCJkZXZpY2VzIiwiaGFzV2ViY2FtIiwiZGV2aWNlTGlzdCIsImRldmljZSIsImtpbmQiLCJwdXNoIiwiZGV2aWNlSWQiLCJjaHVuayIsImFyciIsImNodW5rU2l6ZSIsImNhY2hlIiwidG1wIiwibGVuZ3RoIiwic3BsaWNlIiwicmVtb3ZlQXJyYXlJdGVtIiwiYXJyYXkiLCJlbGVtZW50IiwiaWR4IiwiaXNOdWxsIiwiaXNOaWwiLCJfdHlwZSIsIl9pc0NhbWVyYSIsIkNhbWVyYSIsInByb2plY3Rpb25NYXRyaXgiLCJNYXRyaXg0IiwicHJvamVjdGlvbk1hdHJpeEludmVyc2UiLCJtYXRyaXhXb3JsZEludmVyc2UiLCJ0YXJnZXQiLCJtIiwibG9va0F0IiwicG9zaXRpb24iLCJ1cCIsInF1YXRlcm5pb24iLCJzZXRGcm9tUm90YXRpb25NYXRyaXgiLCJWZWN0b3IzIiwiYXBwbHlRdWF0ZXJuaW9uIiwid29ybGRRdWF0ZXJuaW9uIiwiT2JqZWN0M0QiLCJFdmVudERhdGEiLCJFdmVudERhdGFPYmplY3QiLCJoYW5kbGVycyIsImdldCIsImV2ZW50TmFtZSIsImN1cnJlbnRUYXJnZXQiLCJldmVudEhhbmRsZXIiLCJFbnRpdHlEYXRhIiwiRW50aXR5RGF0YU9iamVjdCIsImVsZSIsIm9iamVjdElkIiwiX2lzT2JqZWN0M0QiLCJPQkpFQ1RfRVZFTlQiLCJPQkpFQ1RfQURERUQiLCJTZXQiLCJPQkpFQ1RfUkVNT1ZFRCIsIlF1YXRlcm5pb24iLCJzY2FsZSIsInZpc2libGUiLCJ0cmFjayIsInBhcmVudCIsImNoaWxkcmVuIiwibWF0cml4V29ybGQiLCJtYXRyaXhBdXRvVXBkYXRlIiwibWF0cml4V29ybGROZWVkc1VwZGF0ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwieCIsInkiLCJ6IiwieEF4aXMiLCJ5QXhpcyIsInpBeGlzIiwibXVsdGlwbHlTY2FsYXIiLCJheGlzIiwicSIsInNldEZyb21BeGlzQW5nbGUiLCJtdWx0aXBseSIsInJvdGF0aW9uIiwic2V0RnJvbVF1YXRlcm5pb24iLCJ2ZWN0b3IiLCJhcHBseU1hdHJpeDQiLCJnZXRJbnZlcnNlIiwib2JqZWN0IiwiYXJndW1lbnRzIiwiaSIsImlzT2JqZWN0M0QiLCJjb21wb3NlIiwiZm9yY2UiLCJ1cGRhdGVNYXRyaXgiLCJjb3B5IiwibXVsdGlwbHlNYXRyaWNlcyIsImwiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsInVwZGF0ZVBhcmVudHMiLCJ1cGRhdGVDaGlsZHJlbiIsInVwZGF0ZVdvcmxkTWF0cml4IiwidmVjdG9yMyIsInByZW11bHRpcGx5IiwiZGVjb21wb3NlIiwicmVjdXJzaXZlIiwic291cmNlIiwiY2hpbGQiLCJjbG9uZSIsImNhbGxiYWNrIiwidHJhdmVyc2UiLCJ0cmF2ZXJzZVZpc2libGUiLCJ0cmF2ZXJzZUFuY2VzdG9ycyIsInRyYXZlcnNlUmVuZGVyYWJsZSIsImFyZ3MiLCJldmVudCIsInNldEZyb21NYXRyaXhQb3NpdGlvbiIsIkV1bGVyIiwiaXNFdWxlciIsInNldEZyb21FdWxlciIsImlzUXVhdGVybmlvbiIsImlzTWF0cml4NCIsInNldEZyb21NYXRyaXgiLCJvcmRlciIsIk9ic2VydmVyIiwiaXNQZXJzcGVjdGl2ZUNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwiYXNwZWN0Iiwiem9vbSIsImZvY3VzIiwidmlldyIsImZpbG1HYXVnZSIsImZpbG1PZmZzZXQiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYXRhbiIsInRhbiIsInRvcCIsIkRFRzJSQUQiLCJsZWZ0IiwiZW5hYmxlZCIsImZ1bGxXaWR0aCIsImZ1bGxIZWlnaHQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInNrZXciLCJmaWxtV2lkdGgiLCJtYWtlUGVyc3BlY3RpdmUiLCJyb3RhdGlvbk1hdHJpeCIsIkxldHNlZUVuZ2luZSIsInJlbmRlcmVyIiwicmVuZGVyIiwiZm9jYWxMZW5ndGgiLCJ2RXh0ZW50U2xvcGUiLCJmaWxtSGVpZ2h0IiwibWluIiwibWF4IiwiX2lzU2NlbmUiLCJTY2VuZSIsIl9lbnRpdGllcyIsIlRyYWNrYWJsZU1hbmFnZXIiLCJFbnRpdHkiLCJfbmF0aXZlIiwibG9hZEVudGl0eSIsInVyaSIsInZhbHVlcyIsInBhcmFtIiwiaGFzRW50aXR5IiwicmVtb3ZlUmVuZGVyYWJsZXMiLCJzZXREYXRhIiwib2JqZWN0cyIsImN1cnJlbnRFbnRpdHkiLCJhZGRFbnRpdHkiLCJyZW5kZXJhYmxlcyIsInNlbGVjdG9yIiwidHJhbnNsYXRlIiwiZWxlbXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWxlbSIsInJlbmRlcmFibGUiLCJET01SZW5kZXJhYmxlIiwiYWRkUmVuZGVyYWJsZSIsInRyYWNrYWJsZU1hbmFnZXIiLCJfaW5zdGFuY2UiLCJjYW1lcmEiLCJzZXRDb25maWciLCJkb21SZW5kZXJlciIsImluaXRSZW5kZXJlciIsInRocmVlUmVuZGVyZXIiLCJMZXRzZWVUaHJlZSIsInNldERhdGFzIiwibWFyZ2luIiwicGFkZGluZyIsIm5ld0NvbmZpZyIsInVwZGF0ZU9yaWVudGF0aW9uIiwiZ2V0RW50aXR5IiwiZ2V0RW50aXRpZXMiLCJyZW1vdmVFbnRpdHkiLCJyZXNldEVsZW1lbnQiLCJhcHBlbmRFbGVtZW50IiwiYXBwZW5kQWxsRWxlbWVudHMiLCJzaXplIiwiZGVwdGgiLCJ1bml0IiwiX3Zpc2libGUiLCJfdHJhY2siLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInRyYW5zbGF0ZVoiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJ1dWlkIiwiY2FtZXJhUG9zZSIsImxvb3RBdFJlbmRlcmFibGVzIiwiRW50aXR5RXZlbnQiLCJzZXRTY2FsYXIiLCJwaXhlbFNpemUiLCJFdmVudFR5cGUiLCJfcmVuZGVyZXIiLCJfY2FtZXJhIiwiX3NjZW5lIiwiX2F1dG9SZW5kZXIiLCJfY2FudmFzIiwiTEVUU0VFX1RIUkVFIiwiZW50aXR5R3JvdXAiLCJyZW5kZXJTY2VuZSIsInJlc2V0IiwiZ2V0VGhyZWVHcm91cCIsImdyb3VwIiwiR3JvdXAiLCJfYWRkT2JqZWN0VG9FbnRpdHkiLCJyZW1vdmVPYmplY3RGcm9tRW50aXR5Iiwib25UcmFja1N0YXJ0Q2FsbGJhY2siLCJvblRyYWNrTW92ZUNhbGxiYWNrIiwib25UcmFja0VuZENhbGxiYWNrIiwib25UcmFja01vdmUiLCJpZGVudGl0eSIsImFwcGx5TWF0cml4Iiwib25UcmFja1N0YXJ0Iiwib25UcmFja0VuZCIsImNhbWVyYVBhcmFtIiwiVEhSRUUiLCJjbGFzc05hbWUiLCJXZWJHTFJlbmRlcmVyIiwiYWxwaGEiLCJzZXRTaXplIiwic2NyZWVuV2lkdGgiLCJzY3JlZW5IZWlnaHQiLCJfbGV0c2VlIiwiX2N1cnJlbnRQYXVzZVN0YXR1cyIsIl9oaWRlU2NyZWVuIiwibGV0c2VlRXZlbnQiLCJMZXRzZWVFdmVudCIsIlZFUlNJT04iLCJWRVJTSU9OX1NUUklORyIsIl9fREVWX18iLCJMZXRzZWUiLCJyZXNldERvbVJlbmRlcmFibGUiLCJwYXVzZSIsImFwcGVuZEFsbERvbVJlbmRlcmFibGVzIiwicmVzdW1lIiwiT05fTE9BRCIsInVuc3Vic2NyaWJlIiwiaHRtbCIsImNzcyIsImdldFNvdXJjZURldmljZUxpc3QiLCJsZXRzZWUiLCJNYXRyaXgzIiwiVmVjdG9yMiIsIkFUVFJfVFJBTlNMQVRFIiwiQVRUUl9ST1RBVEUiLCJQUk9QRVJUWV9UQVJHRVQiLCJQUk9QRVJUWV9UUkFOU0ZPUk0iLCJBTkdMRV9VTklUIiwiZGVncmVlIiwicmFkaWFuIiwidHVybiIsImdyYWRpYW4iLCJUUkFOU0xBVEVfUkVHIiwiUmVnRXhwIiwiUk9UQVRFX1JFRyIsIlVSSV9SRUciLCJDU1NQYXJzZXIiLCJkYXRhTWFwIiwic3R5bGVUYWdzIiwidGFnIiwibWVkaWEiLCJyZW1vdmVDb21tZW50IiwicGFyc2VEYXRhIiwicmVtb3ZlTWVkaWEiLCJ0ZXh0Iiwic3R5bGVzIiwicG9wIiwic2VwZXJhdGVTdHlsZSIsInRyaW0iLCJwcm9wZXJ0eVZhbHVlcyIsInByb3AiLCJrZXkiLCJwYXJzZVZhbHVlIiwicGFyc2VUYXJnZXQiLCJwYXJzZVBvc2l0aW9uIiwicm90YXRlIiwic3RyIiwicHJvcFBvc2l0aW9uIiwicHJvcFJvdGF0aW9uIiwiZ2V0VHJhbnNsYXRlIiwiZ2V0Um90YXRpb24iLCJQSSIsInNlcGFyYXRvcm0iLCJ0ZW1wQXJyYXkiLCJzZXBhcmF0b3IiLCJ1cmwiLCJwYXRoQXJyYXkiLCJsYXN0IiwiYmFzZSIsImpvaW4iLCJzdWJzdHIiLCJ0YWdFbGVtIiwibmV3U3R5bGUiLCJtb2RpZmllZFN0eWxlIiwicGxhY2VTdHlsZSIsIm5ld1NlbGVjdG9yIiwic2VsIiwidW5zaGlmdCIsImNyZWF0ZVRleHROb2RlIiwicmVwbGFjZUNoaWxkIiwidGVtcGxhdGUiLCJfZW50aXR5U3RhdGUiLCJfbWFya2VyTGlzdCIsIl9jb2RlTGlzdCIsIkZldGNoZXIiLCJmZXRjaCIsInJlc3BvbnNlIiwianNvbiIsInN0cmluZ2lmeSIsImVudGl0eUxpc3QiLCJmZXRjaEVudGl0eSIsIkVWRU5UX0FQUF9TVEFUVVMiLCJFVkVOVF9BUFBfUk9UQVRJT05DSEFOR0UiLCJTVEFURV9UUkFDS19TVEFSVCIsIlNUQVRFX1RSQUNLX01PVkUiLCJTVEFURV9UUkFDS19FTkQiLCJUQVJHRVQiLCJ0cmFuc2xhdGVNYXRyaXgiLCJPYmplY3RUcmFja2VyIiwidGFyZ2V0cyIsInVzZUNhbWVyYSIsImtleXMiLCJmcm9tQXJyYXkiLCJlbnRpdHlFdmVudCIsImFkZFRhcmdldCIsImVudGl0eU9iamVjdCIsInJvdGF0ZU0iLCJtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiIsImRlY29tcG9zZWRWYWx1ZSIsIm1ha2VUcmFuc2xhdGlvbiIsInRvQXJyYXkiLCJyZW1vdmVUYXJnZXQiLCJfY29udGFpbmVyIiwiX3NjZW5lQ2FudmFzIiwiX3NjcmVlbldpZHRoIiwiX3NjcmVlbkhlaWdodCIsIl9hbmdsZSIsIl9zY3JlZW5Bc3BlY3RSYXRpbyIsIl9icm93c2VyIiwiX3ZpZGVvQXR0YWNoZWQiLCJpc0ZpcnN0Q2FtZXJhSW5pdCIsImdldFVzZXJNZWRpYUNvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJhdWRpbyIsInZpZGVvIiwiZmFjaW5nTW9kZSIsImV4Y2VwdGlvbkRldmljZXMiLCJsYWJlbCIsImlkZWFsIiwiZ2V0TWVkaWEiLCJzdHJlYW0iLCJnZXRUcmFja3MiLCJzdG9wIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY2hlY2tDYW1lcmEiLCJnb3RTdHJlYW0iLCJtZWRpYVN0cmVhbSIsInNyY09iamVjdCIsInJlbW92ZVN0cmVhbSIsIl9pbml0Q2FtZXJhQ29udGFpbmVyIiwiYXV0b3BsYXkiLCJtdXRlZCIsImJvcmRlciIsInZpc2liaWxpdHkiLCJyaWdodCIsImJvdHRvbSIsIl9hdHRhY2hTb3VyY2VUb1ZpZGVvIiwic291cmNlTVA0IiwiX3NldEFzcGVjdFJhdGlvIiwidHJhbnNmb3JtIiwiX2luaXRDYW52YXMiLCJjb250YWluZXJJZCIsImVudW1lcmF0ZURldmljZXMiLCJnZXRBdHRhY2hlZFZpZGVvIiwiX3NjcmVlblNpemUiLCJicm93c2VySW5mbyIsIm9uQ2hhbmdlQ2FsbGJhY2siLCJfaXNFdWxlciIsIkRlZmF1bHRPcmRlciIsIlJvdGF0aW9uT3JkZXJzIiwic2V0RnJvbVF1YXRlcm5pb25RIiwicmVvcmRlclEiLCJfeCIsIl95IiwiX3oiLCJfb3JkZXIiLCJ1cGRhdGUiLCJ0ZSIsImVsZW1lbnRzIiwibTExIiwibTIxIiwibTMxIiwibTQxIiwibTEyIiwibTIyIiwibTMyIiwibTQyIiwibTEzIiwibTIzIiwibTMzIiwibTQzIiwiYXNpbiIsImFicyIsImF0YW4yIiwibmV3T3JkZXIiLCJldWxlciIsIm9mZnNldCIsIm9wdGlvbmFsUmVzdWx0IiwiUkFEMkRFRyIsImRlZ1RvUmFkIiwiZGVncmVlcyIsInJhZFRvRGVnIiwicmFkaWFucyIsIndvcmxkVG9TY3JlZW4iLCJwcm9qZWN0IiwiY2xhbXAiLCJldWNsaWRlYW5Nb2R1bG8iLCJuIiwibWFwTGluZWFyIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJsZXJwIiwidCIsInNtb290aHN0ZXAiLCJzbW9vdGhlcnN0ZXAiLCJyYW5kSW50IiwibG93IiwiaGlnaCIsInJhbmRGbG9hdCIsInJhbmRGbG9hdFNwcmVhZCIsInJhbmdlIiwiaXNQb3dlck9mVHdvIiwibmVhcmVzdFBvd2VyT2ZUd28iLCJyb3VuZCIsIkxOMiIsIm5leHRQb3dlck9mVHdvIiwiTWF0aFV0aWwiLCJfaXNNYXRyaXgzIiwiX2VsZW1lbnRzIiwiRmxvYXQzMkFycmF5IiwibjExIiwibjEyIiwibjEzIiwibjIxIiwibjIyIiwibjIzIiwibjMxIiwibjMyIiwibjMzIiwibWUiLCJhdHRyaWJ1dGUiLCJ2MSIsImNvdW50IiwiZ2V0WCIsImdldFkiLCJnZXRaIiwiYXBwbHlNYXRyaXgzIiwic2V0WFlaIiwicyIsImEiLCJiIiwiZiIsImciLCJoIiwidGhyb3dPbkRlZ2VuZXJhdGUiLCJ0MTEiLCJ0MTIiLCJ0MTMiLCJkZXQiLCJtc2ciLCJkZXRJbnYiLCJtYXRyaXg0Iiwic2V0RnJvbU1hdHJpeDQiLCJ0cmFuc3Bvc2UiLCJleHRyYWN0Um90YXRpb25WIiwibG9va0F0WCIsImxvb2tBdFkiLCJsb29rQXRaIiwiZGVjb21wb3NlViIsImRlY29tcG9zZU0iLCJfaXNNYXRyaXg0IiwibjE0IiwibjI0IiwibjM0IiwibjQxIiwibjQyIiwibjQzIiwibjQ0Iiwic2V0RnJvbU1hdHJpeENvbHVtbiIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsImN4IiwiY29zIiwic3giLCJzaW4iLCJjeSIsInN5IiwiY3oiLCJzeiIsInciLCJ4MiIsInkyIiwiejIiLCJ4eCIsInh5IiwieHoiLCJ5eSIsInl6IiwienoiLCJ3eCIsInd5Iiwid3oiLCJleWUiLCJzdWJWZWN0b3JzIiwibGVuZ3RoU3EiLCJub3JtYWxpemUiLCJjcm9zc1ZlY3RvcnMiLCJhZSIsImJlIiwiYTExIiwiYTIxIiwiYTMxIiwiYTQxIiwiYTEyIiwiYTIyIiwiYTMyIiwiYTQyIiwiYTEzIiwiYTIzIiwiYTMzIiwiYTQzIiwiYTE0IiwiYTI0IiwiYTM0IiwiYTQ0IiwiYjExIiwiYjIxIiwiYjMxIiwiYjQxIiwiYjEyIiwiYjIyIiwiYjMyIiwiYjQyIiwiYjEzIiwiYjIzIiwiYjMzIiwiYjQzIiwiYjE0IiwiYjI0IiwiYjM0IiwiYjQ0IiwidDE0Iiwic2NhbGVYU3EiLCJzY2FsZVlTcSIsInNjYWxlWlNxIiwic3FydCIsInRoZXRhIiwidHgiLCJ0eSIsInNldFBvc2l0aW9uIiwiZGV0ZXJtaW5hbnQiLCJpbnZTWCIsImludlNZIiwiaW52U1oiLCJ5bWluIiwieW1heCIsInhtaW4iLCJ4bWF4IiwibWFrZUZydXN0dW0iLCJwIiwiRVBTSUxPTiIsIk51bWJlciIsInBvdyIsInNldEZyb21Vbml0VmVjdG9yc0VQUyIsInNldEZyb21Vbml0VmVjdG9yc1YiLCJfaXNRdWF0ZXJuaW9uIiwiYzEiLCJjMiIsImMzIiwiczEiLCJzMiIsInMzIiwiaGFsZkFuZ2xlIiwidHJhY2UiLCJ2RnJvbSIsInZUbyIsImRvdCIsImNvbmp1Z2F0ZSIsIm11bHRpcGx5UXVhdGVybmlvbnMiLCJxYXgiLCJxYXkiLCJxYXoiLCJxYXciLCJxYngiLCJxYnkiLCJxYnoiLCJxYnciLCJxYiIsImNvc0hhbGZUaGV0YSIsInNpbkhhbGZUaGV0YSIsImhhbGZUaGV0YSIsInJhdGlvQSIsInJhdGlvQiIsInFTdGFydCIsInFFbmQiLCJxVGFyZ2V0Iiwic2xlcnAiLCJkc3QiLCJkc3RPZmZzZXQiLCJzcmMwIiwic3JjT2Zmc2V0MCIsInNyYzEiLCJzcmNPZmZzZXQxIiwieDAiLCJ5MCIsInowIiwidzAiLCJ4MSIsInkxIiwiejEiLCJ3MSIsImRpciIsInNxclNpbiIsImxlbiIsInREaXIiLCJfaXNWZWN0b3IyIiwic2NhbGFyIiwiaXNGaW5pdGUiLCJtaW5WYWwiLCJtYXhWYWwiLCJjZWlsIiwiZGl2aWRlU2NhbGFyIiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJkeCIsImR5IiwidjIiLCJjZW50ZXIiLCJhcHBseUV1bGVyUSIsImFwcGx5QXhpc0FuZ2xlUSIsInByb2plY3RPblBsYW5lViIsInJlZmxlY3RWIiwiX2lzVmVjdG9yMyIsInF4IiwicXkiLCJxeiIsInF3IiwiaXkiLCJpeiIsIml3IiwiYXgiLCJheSIsImF6IiwiYngiLCJieSIsImJ6IiwicGxhbmVOb3JtYWwiLCJwcm9qZWN0T25WZWN0b3IiLCJzdWIiLCJub3JtYWwiLCJhY29zIiwiZHoiLCJnZXRUYXJnZXQiLCJhZGRIYW5kbGVyIiwiaGFuZGxlciIsImdldEhhbmRsZXIiLCJFbnRpdHlUeXBlIiwiX2lzRE9NUmVuZGVyYWJsZSIsImdob3N0SWQiLCJwYXJlbnRFbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJvcmlnaW5hbEVsZW1lbnQiLCJjbG9uZU5vZGUiLCJnaG9zdEVsZW1lbnQiLCJhZGRFbGVtZW50Iiwid2lsbENoYW5nZSIsImlzQWRkZWRUb0NhbWVyYSIsImlzRE9NUmVuZGVyYWJsZSIsImFkZGVkIiwicmVtb3ZlZCIsImlzU2NlbmUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlcHNpbG9uIiwiZ2V0Q2FtZXJhQ1NTTWF0cml4IiwiY2FtZXJhTWF0cml4IiwiZ2V0T2JqZWN0Q1NTTWF0cml4Iiwib2JqZWN0TWF0cml4IiwiX2NhY2hlZFN0eWxlcyIsIl9kb21FbGVtZW50IiwiX2NhbWVyYUVsZW1lbnQiLCJET01SZW5kZXJlciIsIm92ZXJmbG93IiwiV2Via2l0VHJhbnNmb3JtU3R5bGUiLCJ0cmFuc2Zvcm1TdHlsZSIsImdldEVsZW1lbnQiLCJnaG9zdCIsIm9yaWdpbmFsIiwiZ2V0QWxsRWxlbWVudHMiLCJnZXRFZmZlY3RpdmVGT1YiLCJjYW1lcmFDU1NNYXRyaXgiLCJjYW1lcmFUcmFuc2Zvcm0iLCJXZWJraXRQZXJzcGVjdGl2ZSIsInBlcnNwZWN0aXZlIiwiV2Via2l0VHJhbnNmb3JtIiwiY2FjaGVkU3R5bGUiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwibyIsInJlcXVpcmUiLCJ1IiwiY2FsbCIsIl9hZGFwdGVyX2ZhY3RvcnkiLCJhZGFwdGVyIiwiYWRhcHRlckZhY3RvcnkiLCJfdXRpbHMiLCJ1dGlscyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX2Nocm9tZV9zaGltIiwiY2hyb21lU2hpbSIsIl9lZGdlX3NoaW0iLCJlZGdlU2hpbSIsIl9maXJlZm94X3NoaW0iLCJmaXJlZm94U2hpbSIsIl9zYWZhcmlfc2hpbSIsInNhZmFyaVNoaW0iLCJfY29tbW9uX3NoaW0iLCJjb21tb25TaGltIiwiX19lc01vZHVsZSIsIm5ld09iaiIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiX3JlZiIsIm9wdGlvbnMiLCJzaGltQ2hyb21lIiwic2hpbUZpcmVmb3giLCJzaGltRWRnZSIsInNoaW1TYWZhcmkiLCJsb2dnaW5nIiwiYnJvd3NlckRldGFpbHMiLCJkZXRlY3RCcm93c2VyIiwiZXh0cmFjdFZlcnNpb24iLCJkaXNhYmxlTG9nIiwiZGlzYWJsZVdhcm5pbmdzIiwiYnJvd3NlciIsInNoaW1QZWVyQ29ubmVjdGlvbiIsImJyb3dzZXJTaGltIiwic2hpbUdldFVzZXJNZWRpYSIsInNoaW1NZWRpYVN0cmVhbSIsInNoaW1PblRyYWNrIiwic2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2siLCJzaGltR2V0U2VuZGVyc1dpdGhEdG1mIiwic2hpbUdldFN0YXRzIiwic2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMiLCJmaXhOZWdvdGlhdGlvbk5lZWRlZCIsInNoaW1SVENJY2VDYW5kaWRhdGUiLCJzaGltQ29ubmVjdGlvblN0YXRlIiwic2hpbU1heE1lc3NhZ2VTaXplIiwic2hpbVNlbmRUaHJvd1R5cGVFcnJvciIsInJlbW92ZUFsbG93RXh0bWFwTWl4ZWQiLCJzaGltUmVtb3ZlU3RyZWFtIiwic2hpbVNlbmRlckdldFN0YXRzIiwic2hpbVJlY2VpdmVyR2V0U3RhdHMiLCJzaGltUlRDRGF0YUNoYW5uZWwiLCJzaGltQWRkVHJhbnNjZWl2ZXIiLCJzaGltQ3JlYXRlT2ZmZXIiLCJzaGltQ3JlYXRlQW5zd2VyIiwic2hpbUdldERpc3BsYXlNZWRpYSIsInNoaW1SZXBsYWNlVHJhY2siLCJzaGltUlRDSWNlU2VydmVyVXJscyIsInNoaW1DcmVhdGVPZmZlckxlZ2FjeSIsInNoaW1DYWxsYmFja3NBUEkiLCJzaGltTG9jYWxTdHJlYW1zQVBJIiwic2hpbVJlbW90ZVN0cmVhbXNBUEkiLCJzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfZ2V0dXNlcm1lZGlhIiwiZW51bWVyYWJsZSIsIl9nZXRkaXNwbGF5bWVkaWEiLCJzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUiLCJfZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk1lZGlhU3RyZWFtIiwid2Via2l0TWVkaWFTdHJlYW0iLCJSVENQZWVyQ29ubmVjdGlvbiIsIl9vbnRyYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiX3RoaXMiLCJfb250cmFja3BvbHkiLCJyZWNlaXZlciIsImdldFJlY2VpdmVycyIsImZpbmQiLCJFdmVudCIsInRyYW5zY2VpdmVyIiwic3RyZWFtcyIsImRpc3BhdGNoRXZlbnQiLCJhcHBseSIsIndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50Iiwic2hpbVNlbmRlcldpdGhEdG1mIiwicGMiLCJkdG1mIiwiX2R0bWYiLCJjcmVhdGVEVE1GU2VuZGVyIiwiX3BjIiwiZ2V0U2VuZGVycyIsIl9zZW5kZXJzIiwic2xpY2UiLCJvcmlnQWRkVHJhY2siLCJhZGRUcmFjayIsInNlbmRlciIsIm9yaWdSZW1vdmVUcmFjayIsInJlbW92ZVRyYWNrIiwib3JpZ0FkZFN0cmVhbSIsImFkZFN0cmVhbSIsIl90aGlzMiIsIm9yaWdSZW1vdmVTdHJlYW0iLCJfdGhpczMiLCJSVENSdHBTZW5kZXIiLCJvcmlnR2V0U2VuZGVycyIsIl90aGlzNCIsInNlbmRlcnMiLCJvcmlnR2V0U3RhdHMiLCJnZXRTdGF0cyIsIl90aGlzNSIsIl9hcmd1bWVudHMiLCJBcnJheSIsIm9uU3VjYyIsIm9uRXJyIiwiZml4Q2hyb21lU3RhdHNfIiwic3RhbmRhcmRSZXBvcnQiLCJyZXBvcnRzIiwicmVwb3J0Iiwic3RhbmRhcmRTdGF0cyIsInRpbWVzdGFtcCIsImxvY2FsY2FuZGlkYXRlIiwicmVtb3RlY2FuZGlkYXRlIiwibmFtZXMiLCJzdGF0IiwibWFrZU1hcFN0YXRzIiwic3RhdHMiLCJzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXyIsIlJUQ1J0cFJlY2VpdmVyIiwiX3RoaXM2IiwiZmlsdGVyU3RhdHMiLCJvcmlnR2V0UmVjZWl2ZXJzIiwiX3RoaXM3IiwicmVjZWl2ZXJzIiwic3JjRWxlbWVudCIsIk1lZGlhU3RyZWFtVHJhY2siLCJET01FeGNlcHRpb24iLCJnZXRMb2NhbFN0cmVhbXMiLCJfdGhpczgiLCJfc2hpbW1lZExvY2FsU3RyZWFtcyIsInN0cmVhbUlkIiwiX3RoaXM5IiwiYWxyZWFkeUV4aXN0cyIsImV4aXN0aW5nU2VuZGVycyIsIm5ld1NlbmRlcnMiLCJuZXdTZW5kZXIiLCJjb25jYXQiLCJfdGhpczEwIiwidmVyc2lvbiIsIm9yaWdHZXRMb2NhbFN0cmVhbXMiLCJfdGhpczExIiwibmF0aXZlU3RyZWFtcyIsIl9yZXZlcnNlU3RyZWFtcyIsIl90aGlzMTIiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsIl90aGlzMTMiLCJzaWduYWxpbmdTdGF0ZSIsIm9sZFN0cmVhbSIsInJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkIiwiZGVzY3JpcHRpb24iLCJzZHAiLCJpbnRlcm5hbElkIiwiZXh0ZXJuYWxTdHJlYW0iLCJpbnRlcm5hbFN0cmVhbSIsIlJUQ1Nlc3Npb25EZXNjcmlwdGlvbiIsInJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkIiwibWV0aG9kIiwibmF0aXZlTWV0aG9kIiwibWV0aG9kT2JqIiwiX3RoaXMxNCIsImlzTGVnYWN5Q2FsbCIsImRlc2MiLCJvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbiIsInNldExvY2FsRGVzY3JpcHRpb24iLCJvcmlnTG9jYWxEZXNjcmlwdGlvbiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl90aGlzMTUiLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwiUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQWRkSWNlQ2FuZGlkYXRlIiwiYWRkSWNlQ2FuZGlkYXRlIiwiY2FuZGlkYXRlIiwiZ2V0U291cmNlSWQiLCJnZXREaXNwbGF5TWVkaWEiLCJzb3VyY2VJZCIsIndpZHRoU3BlY2lmaWVkIiwiaGVpZ2h0U3BlY2lmaWVkIiwiZnJhbWVSYXRlU3BlY2lmaWVkIiwiZnJhbWVSYXRlIiwibWFuZGF0b3J5IiwiY2hyb21lTWVkaWFTb3VyY2UiLCJjaHJvbWVNZWRpYVNvdXJjZUlkIiwibWF4RnJhbWVSYXRlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJjb25zdHJhaW50c1RvQ2hyb21lXyIsIm9wdGlvbmFsIiwiY2MiLCJleGFjdCIsIm9sZG5hbWVfIiwicHJlZml4IiwiY2hhckF0Iiwib2MiLCJtaXgiLCJhZHZhbmNlZCIsInNoaW1Db25zdHJhaW50c18iLCJmdW5jIiwicmVtYXAiLCJmYWNlIiwiZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMiLCJnZXRTdXBwb3J0ZWRDb25zdHJhaW50cyIsIm1hdGNoZXMiLCJkZXYiLCJzb21lIiwic2hpbUVycm9yXyIsIlBlcm1pc3Npb25EZW5pZWRFcnJvciIsIlBlcm1pc3Npb25EaXNtaXNzZWRFcnJvciIsIkludmFsaWRTdGF0ZUVycm9yIiwiRGV2aWNlc05vdEZvdW5kRXJyb3IiLCJDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3IiLCJUcmFja1N0YXJ0RXJyb3IiLCJNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd24iLCJNZWRpYURldmljZUtpbGxTd2l0Y2hPbiIsIlRhYkNhcHR1cmVFcnJvciIsIlNjcmVlbkNhcHR1cmVFcnJvciIsIkRldmljZUNhcHR1cmVFcnJvciIsImNvbnN0cmFpbnQiLCJjb25zdHJhaW50TmFtZSIsImdldFVzZXJNZWRpYV8iLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwid2Via2l0R2V0VXNlck1lZGlhIiwiYmluZCIsIm9yaWdHZXRVc2VyTWVkaWEiLCJjcyIsImdldEF1ZGlvVHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJfc2RwIiwiX3NkcDIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwicGFyc2VDYW5kaWRhdGUiLCJhdWdtZW50ZWRDYW5kaWRhdGUiLCJhc3NpZ24iLCJ0b0pTT04iLCJzZHBNaWQiLCJzZHBNTGluZUluZGV4IiwidXNlcm5hbWVGcmFnbWVudCIsIl9zY3RwIiwic2N0cEluRGVzY3JpcHRpb24iLCJzZWN0aW9ucyIsInNwbGl0U2VjdGlvbnMiLCJzaGlmdCIsIm1lZGlhU2VjdGlvbiIsIm1MaW5lIiwicGFyc2VNTGluZSIsInByb3RvY29sIiwiZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24iLCJnZXRDYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJyZW1vdGVJc0ZpcmVmb3giLCJjYW5TZW5kTWF4TWVzc2FnZVNpemUiLCJnZXRNYXhNZXNzYWdlU2l6ZSIsIm1heE1lc3NhZ2VTaXplIiwibWF0Y2hQcmVmaXgiLCJfZ2V0Q29uZmlndXJhdGlvbiIsImdldENvbmZpZ3VyYXRpb24iLCJzZHBTZW1hbnRpY3MiLCJjYW5TZW5kTU1TIiwicmVtb3RlTU1TIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJzY3RwIiwid3JhcERjU2VuZCIsImRjIiwib3JpZ0RhdGFDaGFubmVsU2VuZCIsInNlbmQiLCJieXRlTGVuZ3RoIiwicmVhZHlTdGF0ZSIsIlR5cGVFcnJvciIsIm9yaWdDcmVhdGVEYXRhQ2hhbm5lbCIsImNyZWF0ZURhdGFDaGFubmVsIiwiZGF0YUNoYW5uZWwiLCJjaGFubmVsIiwicHJvdG8iLCJjb21wbGV0ZWQiLCJjaGVja2luZyIsImljZUNvbm5lY3Rpb25TdGF0ZSIsIl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsImNiIiwib3JpZ01ldGhvZCIsIl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5IiwiX2xhc3RDb25uZWN0aW9uU3RhdGUiLCJjb25uZWN0aW9uU3RhdGUiLCJuZXdFdmVudCIsIm5hdGl2ZVNSRCIsImxpbmUiLCJSVENUcmFja0V2ZW50IiwibW96UlRDUGVlckNvbm5lY3Rpb24iLCJtb2Rlcm5TdGF0c1R5cGVzIiwiaW5ib3VuZHJ0cCIsIm91dGJvdW5kcnRwIiwiY2FuZGlkYXRlcGFpciIsIm5hdGl2ZUdldFN0YXRzIiwiZGVwcmVjYXRlZCIsIkRhdGFDaGFubmVsIiwiUlRDRGF0YUNoYW5uZWwiLCJvcmlnQWRkVHJhbnNjZWl2ZXIiLCJhZGRUcmFuc2NlaXZlciIsInNldFBhcmFtZXRlcnNQcm9taXNlcyIsImluaXRQYXJhbWV0ZXJzIiwic2hvdWxkUGVyZm9ybUNoZWNrIiwic2VuZEVuY29kaW5ncyIsImVuY29kaW5nUGFyYW0iLCJyaWRSZWdleCIsInJpZCIsInNjYWxlUmVzb2x1dGlvbkRvd25CeSIsIlJhbmdlRXJyb3IiLCJtYXhGcmFtZXJhdGUiLCJwYXJhbXMiLCJnZXRQYXJhbWV0ZXJzIiwiZW5jb2RpbmdzIiwic2V0UGFyYW1ldGVycyIsIm9yaWdDcmVhdGVPZmZlciIsImNyZWF0ZU9mZmVyIiwiX2FyZ3VtZW50czIiLCJvcmlnQ3JlYXRlQW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiX2FyZ3VtZW50czMiLCJwcmVmZXJyZWRNZWRpYVNvdXJjZSIsIm1lZGlhU291cmNlIiwibmF0aXZlR2V0VXNlck1lZGlhIiwiZ2V0U2V0dGluZ3MiLCJuYXRpdmVHZXRTZXR0aW5ncyIsImFwcGx5Q29uc3RyYWludHMiLCJuYXRpdmVBcHBseUNvbnN0cmFpbnRzIiwic2hpbUNvbnN0cmFpbnRzIiwiX2xvY2FsU3RyZWFtcyIsIl9hZGRUcmFjayIsInRyYWNrcyIsImdldFJlbW90ZVN0cmVhbXMiLCJfcmVtb3RlU3RyZWFtcyIsIl9vbmFkZHN0cmVhbSIsIl9vbmFkZHN0cmVhbXBvbHkiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJwcm9taXNlIiwid2l0aENhbGxiYWNrIiwiX2dldFVzZXJNZWRpYSIsImVycmNiIiwiY29tcGFjdE9iamVjdCIsIk9yaWdQZWVyQ29ubmVjdGlvbiIsInBjQ29uZmlnIiwicGNDb25zdHJhaW50cyIsImljZVNlcnZlcnMiLCJuZXdJY2VTZXJ2ZXJzIiwic2VydmVyIiwidXJscyIsImdlbmVyYXRlQ2VydGlmaWNhdGUiLCJvZmZlck9wdGlvbnMiLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwiYXVkaW9UcmFuc2NlaXZlciIsImdldFRyYW5zY2VpdmVycyIsImRpcmVjdGlvbiIsInNldERpcmVjdGlvbiIsIm9mZmVyVG9SZWNlaXZlVmlkZW8iLCJ2aWRlb1RyYW5zY2VpdmVyIiwid2Fsa1N0YXRzIiwibG9nRGlzYWJsZWRfIiwiZGVwcmVjYXRpb25XYXJuaW5nc18iLCJ1YXN0cmluZyIsImV4cHIiLCJwb3MiLCJldmVudE5hbWVUb1dyYXAiLCJ3cmFwcGVyIiwibmF0aXZlQWRkRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUV2ZW50TmFtZSIsIndyYXBwZWRDYWxsYmFjayIsIm1vZGlmaWVkRXZlbnQiLCJfZXZlbnRNYXAiLCJuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyIiwidW53cmFwcGVkQ2IiLCJib29sIiwib2xkTWV0aG9kIiwibmV3TWV0aG9kIiwibW96R2V0VXNlck1lZGlhIiwiaXNTZWN1cmVDb250ZXh0IiwiUlRDSWNlR2F0aGVyZXIiLCJzdXBwb3J0c1VuaWZpZWRQbGFuIiwiUlRDUnRwVHJhbnNjZWl2ZXIiLCJpc09iamVjdCIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiaXNPYmoiLCJpc0VtcHR5T2JqZWN0IiwicmVzdWx0U2V0IiwiZW5kc1dpdGgiLCJvdXRib3VuZCIsInN0cmVhbVN0YXRzVHlwZSIsImZpbHRlcmVkUmVzdWx0IiwidHJhY2tTdGF0cyIsInRyYWNrSWRlbnRpZmllciIsInRyYWNrU3RhdCIsInRyYWNrSWQiLCJTRFBVdGlscyIsImdlbmVyYXRlSWRlbnRpZmllciIsImxvY2FsQ05hbWUiLCJzcGxpdExpbmVzIiwiYmxvYiIsInBhcnRzIiwicGFydCIsImdldERlc2NyaXB0aW9uIiwiZ2V0TWVkaWFTZWN0aW9ucyIsImZvdW5kYXRpb24iLCJjb21wb25lbnQiLCJwcmlvcml0eSIsImlwIiwiYWRkcmVzcyIsInBvcnQiLCJyZWxhdGVkQWRkcmVzcyIsInJlbGF0ZWRQb3J0IiwidGNwVHlwZSIsInVmcmFnIiwid3JpdGVDYW5kaWRhdGUiLCJwYXJzZUljZU9wdGlvbnMiLCJwYXJzZVJ0cE1hcCIsInBhcnNlZCIsInBheWxvYWRUeXBlIiwiY2xvY2tSYXRlIiwiY2hhbm5lbHMiLCJudW1DaGFubmVscyIsIndyaXRlUnRwTWFwIiwiY29kZWMiLCJwdCIsInByZWZlcnJlZFBheWxvYWRUeXBlIiwicGFyc2VFeHRtYXAiLCJ3cml0ZUV4dG1hcCIsImhlYWRlckV4dGVuc2lvbiIsInByZWZlcnJlZElkIiwicGFyc2VGbXRwIiwia3YiLCJqIiwid3JpdGVGbXRwIiwicGFyYW1ldGVycyIsInBhcnNlUnRjcEZiIiwicGFyYW1ldGVyIiwid3JpdGVSdGNwRmIiLCJsaW5lcyIsInJ0Y3BGZWVkYmFjayIsImZiIiwicGFyc2VTc3JjTWVkaWEiLCJzcCIsInNzcmMiLCJjb2xvbiIsInBhcnNlU3NyY0dyb3VwIiwic2VtYW50aWNzIiwic3NyY3MiLCJnZXRNaWQiLCJtaWQiLCJwYXJzZUZpbmdlcnByaW50IiwiYWxnb3JpdGhtIiwiZ2V0RHRsc1BhcmFtZXRlcnMiLCJzZXNzaW9ucGFydCIsInJvbGUiLCJmaW5nZXJwcmludHMiLCJ3cml0ZUR0bHNQYXJhbWV0ZXJzIiwic2V0dXBUeXBlIiwiZnAiLCJnZXRJY2VQYXJhbWV0ZXJzIiwiaWNlUGFyYW1ldGVycyIsInBhc3N3b3JkIiwid3JpdGVJY2VQYXJhbWV0ZXJzIiwicGFyc2VSdHBQYXJhbWV0ZXJzIiwiY29kZWNzIiwiaGVhZGVyRXh0ZW5zaW9ucyIsImZlY01lY2hhbmlzbXMiLCJydGNwIiwibWxpbmUiLCJydHBtYXBsaW5lIiwiZm10cHMiLCJ3cml0ZVJ0cERlc2NyaXB0aW9uIiwiY2FwcyIsIm1heHB0aW1lIiwiZXh0ZW5zaW9uIiwicGFyc2VSdHBFbmNvZGluZ1BhcmFtZXRlcnMiLCJlbmNvZGluZ1BhcmFtZXRlcnMiLCJoYXNSZWQiLCJoYXNVbHBmZWMiLCJwcmltYXJ5U3NyYyIsInNlY29uZGFyeVNzcmMiLCJmbG93cyIsImFwdCIsImVuY1BhcmFtIiwiY29kZWNQYXlsb2FkVHlwZSIsInJ0eCIsImZlYyIsIm1lY2hhbmlzbSIsImJhbmR3aWR0aCIsIm1heEJpdHJhdGUiLCJwYXJzZVJ0Y3BQYXJhbWV0ZXJzIiwicnRjcFBhcmFtZXRlcnMiLCJyZW1vdGVTc3JjIiwiY25hbWUiLCJyc2l6ZSIsInJlZHVjZWRTaXplIiwiY29tcG91bmQiLCJtdXgiLCJwYXJzZU1zaWQiLCJzcGVjIiwicGxhbkIiLCJtc2lkUGFydHMiLCJwYXJzZVNjdHBEZXNjcmlwdGlvbiIsIm1heFNpemVMaW5lIiwic2N0cFBvcnQiLCJmbXQiLCJzY3RwTWFwTGluZXMiLCJ3cml0ZVNjdHBEZXNjcmlwdGlvbiIsIm91dHB1dCIsImdlbmVyYXRlU2Vzc2lvbklkIiwid3JpdGVTZXNzaW9uQm9pbGVycGxhdGUiLCJzZXNzSWQiLCJzZXNzVmVyIiwic2Vzc1VzZXIiLCJzZXNzaW9uSWQiLCJ1c2VyIiwid3JpdGVNZWRpYVNlY3Rpb24iLCJpY2VHYXRoZXJlciIsImdldExvY2FsUGFyYW1ldGVycyIsImR0bHNUcmFuc3BvcnQiLCJydHBTZW5kZXIiLCJydHBSZWNlaXZlciIsIm1zaWQiLCJzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzIiwiZ2V0RGlyZWN0aW9uIiwiZ2V0S2luZCIsImlzUmVqZWN0ZWQiLCJwYXJzZU9MaW5lIiwidXNlcm5hbWUiLCJzZXNzaW9uVmVyc2lvbiIsIm5ldFR5cGUiLCJhZGRyZXNzVHlwZSIsImlzVmFsaWRTRFAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFF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QUFLLENBQUM3cEMsTUFBMUIsRUFBa0N1RSxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLGdCQUFJc2xDLEtBQUssQ0FBQ3RsQyxDQUFELENBQUwsQ0FBU3ZFLE1BQVQsR0FBa0IsQ0FBbEIsSUFBdUI2cEMsS0FBSyxDQUFDdGxDLENBQUQsQ0FBTCxDQUFTZzJCLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBbEQsRUFBdUQ7QUFDckQscUJBQU8sS0FBUDtBQUNELGFBSG9DLENBSXJDOztBQUNEOztBQUNELGlCQUFPLElBQVA7QUFDRCxTQVpELENBbHZCMEMsQ0Fnd0IxQzs7O0FBQ0EsWUFBSSxTQUFPMU4sTUFBUCxNQUFrQixRQUF0QixFQUFnQztBQUM5QkEsZ0JBQU0sQ0FBQ0QsT0FBUCxHQUFpQnNhLFFBQWpCO0FBQ0Q7QUFFQSxPQXJ3QlEsRUFxd0JQLEVBcndCTztBQTFqRmt6QixLQUE1YyxFQSt6R3hXLEVBL3pHd1csRUErekdyVyxDQUFDLENBQUQsQ0EvekdxVyxFQSt6R2hXLENBL3pHZ1csQ0FBUDtBQWcwR3ZXLEdBaDBHRCIsImZpbGUiOiJsZXRzZWUtMC45LjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJMZXRzZWVcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiTGV0c2VlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkxldHNlZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi4vXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vaW5kZXguanNcIik7XG4iLCJpbXBvcnQge1VVSUR9IGZyb20gJy4vVXRpbCc7XG5cbmxldCBfb3MgPSBudWxsO1xubGV0IF93aWR0aCA9IG51bGw7XG5sZXQgX2hlaWdodCA9IG51bGw7XG5sZXQgX29yaWVudGF0aW9uID0gbnVsbDtcbmxldCBfaXNQb3J0cmFpdCA9IG51bGw7XG5cbmxldCBCb2R5SWQgPSBgYm9keS0ke1VVSUQoKX1gO1xubGV0IERvbVJlbmRlcmVySWQgPSBgZG9tLSR7VVVJRCgpfWA7XG5sZXQgVmlkZW9Db250YWluZXJJZCA9IGB2aWRlby0ke1VVSUQoKX1gO1xubGV0IFBsYWNlaG9sZGVySWQgPSBgcGxhY2Vob2xkZXItJHtVVUlEKCl9YDtcblxuY2xhc3MgQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gIH1cbiAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgIF93aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICBfaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICBfb3JpZW50YXRpb24gPSBjb25maWcub3JpZW50YXRpb247XG4gICAgX2lzUG9ydHJhaXQgPSBfb3JpZW50YXRpb24gPT09IDAgfHwgX29yaWVudGF0aW9uID09PSAxODA7XG4gIH1cbiAgZ2V0IGJvZHlJZCgpIHtcbiAgICByZXR1cm4gQm9keUlkO1xuICB9XG4gIHNldCBib2R5SWQodmFsdWUpIHtcbiAgICBCb2R5SWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBkb21SZW5kZXJlcklkKCkge1xuICAgIHJldHVybiBEb21SZW5kZXJlcklkO1xuICB9XG5cbiAgZ2V0IHZpZGVvQ29udGFpbmVySWQoKSB7XG4gICAgcmV0dXJuIFZpZGVvQ29udGFpbmVySWQ7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXJJZCgpIHtcbiAgICByZXR1cm4gUGxhY2Vob2xkZXJJZDtcbiAgfVxuXG4gIGdldCBvcygpIHtcbiAgICByZXR1cm4gX29zO1xuICB9XG4gIHNldCBvcyh2YWx1ZSkge1xuICAgIF9vcyA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgIHJldHVybiBfb3JpZW50YXRpb247XG4gIH1cbiAgc2V0IG9yaWVudGF0aW9uKHZhbHVlKSB7XG4gICAgX29yaWVudGF0aW9uID0gdmFsdWU7XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIF93aWR0aDtcbiAgfVxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICBfd2lkdGggPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIF9oZWlnaHQ7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIF9oZWlnaHQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBpc1BvcnRyYWl0KCkge1xuICAgIHJldHVybiBfaXNQb3J0cmFpdDtcbiAgfVxuXG4gIGdldCBzY3JlZW5XaWR0aCgpIHtcbiAgICByZXR1cm4gX3dpZHRoO1xuICB9XG4gIGdldCBzY3JlZW5IZWlnaHQoKSB7XG4gICAgcmV0dXJuIF9oZWlnaHQ7XG4gIH1cbn1cblxuZXhwb3J0IGxldCBjb250ZXh0ID0gbmV3IENvbnRleHQoKTtcbiIsImltcG9ydCBWaWRlb01hbmFnZXIgZnJvbSAnLi9saWJzL1ZpZGVvTWFuYWdlcic7XG5pbXBvcnQgKiBhcyBNZXNzYWdlIGZyb20gJy4vbGlicy9NZXNzYWdlVHlwZXMnO1xuaW1wb3J0IHtMRVRTRUVfRVZFTlQsIEVOVElUWV9FVkVOVH0gZnJvbSAnLi9saWJzL01lc3NhZ2VUeXBlcyc7XG5pbXBvcnQge2Nzc1BhcnNlcn0gZnJvbSAnLi9saWJzL0NTU1BhcnNlcic7XG5pbXBvcnQge2xvYWRJbWFnZSwgY3JlYXRlTGV0c2VlV3JhcHBlciwgY3JlYXRlTG9hZGVyLCBhZGRWaWV3cG9ydCwgY3JlYXRlU3RhdHVzU2NyZWVuLCAvKiBVVUlELCovIGlzTmlsfSBmcm9tICcuL1V0aWwnO1xuaW1wb3J0IEVudGl0eVBhcnNlciBmcm9tICcuL2xpYnMvRW50aXR5UGFyc2VyJztcbmltcG9ydCB7Y29udGV4dH0gZnJvbSAnQ29udGV4dCc7XG5cbmltcG9ydCBMZXRzZWVPYnNlcnZlciBmcm9tICcuL29ic2VydmVycy9vYnNlcnZlci9MZXRzZWVPYnNlcnZlcic7XG5pbXBvcnQgRW50aXR5T2JzZXJ2ZXIgZnJvbSAnLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvRW50aXR5T2JzZXJ2ZXInO1xuaW1wb3J0IEVuZ2luZSBmcm9tICcuL2VuZ2luZSc7XG4vLyBpbXBvcnQgTWF0aFV0aWwgZnJvbSAnLi9tYXRoL01hdGgnO1xuLy8gaW1wb3J0IHtldmVudE1hbmFnZXJ9IGZyb20gJy4vZXZlbnQvRXZlbnRNYW5hZ2VyJztcblxubGV0IGluc3RhbmNlO1xubGV0IHRyYWNrZXI7XG5sZXQgX3NjZWFuQ2FudmFzO1xubGV0IF92aWRlb0VsZW1lbnQ7XG5sZXQgdmlkZW9Mb2FkRmxhZyA9IGZhbHNlO1xubGV0IGZpcnN0TG9hZEZsYWcgPSBmYWxzZTtcbmNvbnN0IF9sZXRzZWVFbmdpbmVDb25maWcgPSB7XG5cdHJ1blR5cGU6ICdCUk9XU0VSJyxcblx0d2lkdGg6IG51bGwsXG5cdGhlaWdodDogbnVsbCxcblx0b3JpZW50YXRpb246IG51bGwsXG5cdGRhdGE6IG51bGwsXG5cdHByb2plY3Rpb25QYXJhbWV0ZXI6IG51bGwsXG5cdGV4dGVybmFsOiBudWxsXG59O1xuXG5jb25zdCB2YWxpZGF0ZUNvbmZpZyA9IChfY29uZmlnKSA9PiB7XG5cdGNvbnN0IGNvbmZpZyA9IHtcblx0XHRhcHBLZXk6IGAke0FQUF9LRVl9YCxcblx0XHR0cmFja2VyVHlwZTogX2NvbmZpZy50cmFja2VyVHlwZSB8fCAnSU1BR0UnLFxuXHRcdGV4dGVybmFsOiBudWxsLFxuXHRcdGNhbWVyYVBhcmFtZXRlcjoge1xuXHRcdFx0Zm92OiA1MCxcblx0XHRcdG5lYXI6IDAuMSxcblx0XHRcdGZhcjogMjAwMFxuXHRcdH0sXG5cdFx0ekluZGV4OiAxMDAsXG5cdFx0ekluZGV4SW5jcmVtZW50OiAxMFxuXHR9O1xuXHRcblx0aWYgKF9jb25maWcudHlwZSkgY29uZmlnLnRyYWNrZXJUeXBlID0gX2NvbmZpZy50eXBlO1xuXHRpZiAoX2NvbmZpZy5leHRlcm5hbCkgY29uZmlnLmV4dGVybmFsID0gX2NvbmZpZy5leHRlcm5hbDtcblx0aWYgKF9jb25maWcuY2FtZXJhUGFyYW1ldGVyKSB7XG5cdFx0aWYgKFxuXHRcdFx0X2NvbmZpZy5jYW1lcmFQYXJhbWV0ZXIuZm92ICYmXG5cdFx0XHRfY29uZmlnLmNhbWVyYVBhcmFtZXRlci5uZWFyICYmXG5cdFx0XHRfY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mYXJcblx0XHQpIHtcblx0XHRcdGNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIgPSBfY29uZmlnLmNhbWVyYVBhcmFtZXRlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdmb3YsIG5lYXIsIGZhciBhcmUgbWFuZGF0b3J5IGZpZWxkLicpO1xuXHRcdH1cblx0fVxuXHQvLyBAYXV0aG9yIHRyZWV0b3J5IDogTE9DQUwg7ZmY6rK97J28IOuVjCwg7JWx7YKk66W8IOuwm+yVhOyYpOuKlCDqsoPsnbQg7J6I7Jy866m0IOyEpOygle2VmOqzoCwg7JeG7Jy866m0IOq4sOuzuO2CpCDsgqzsmqk/XG5cdGlmIChfX0xPQ0FMX18pIHtcblx0XHRpZiAoX2NvbmZpZy5hcHBLZXkpIGNvbmZpZy5hcHBLZXkgPSBfY29uZmlnLmFwcEtleTtcblx0XHRpZiAoX2NvbmZpZy52aWRlb1VybCkgY29uZmlnLmFwcEtleSA9IF9jb25maWcuYXBwS2V5O1xuXHRcdGlmIChfY29uZmlnLmRlYnVnKSBjb25maWcuYXBwS2V5ID0gX2NvbmZpZy5hcHBLZXk7XG5cdH1cblx0XG5cdGlmICh0eXBlb2YgX2NvbmZpZy56SW5kZXggPT09ICdudW1iZXInKSBjb25maWcuekluZGV4ID0gX2NvbmZpZy56SW5kZXg7XG5cdGlmICh0eXBlb2YgX2NvbmZpZy56SW5kZXhJbmNyZW1lbnQgPT09ICdudW1iZXInKSBjb25maWcuekluZGV4SW5jcmVtZW50ID0gX2NvbmZpZy56SW5kZXhJbmNyZW1lbnQ7XG5cdFxuXHRpZiAoX2NvbmZpZy5ib2R5SWQpIHtcblx0XHRjb25maWcuYm9keUlkID0gX2NvbmZpZy5ib2R5SWQ7XG5cdFx0Y29udGV4dC5ib2R5SWQgPSBfY29uZmlnLmJvZHlJZDtcblx0fSBlbHNlIHtcblx0XHRjb25maWcuYm9keUlkID0gY29udGV4dC5ib2R5SWQ7XG5cdH1cblx0XG5cdGNvbmZpZy5kb21SZW5kZXJlcklkID0gY29udGV4dC5kb21SZW5kZXJlcklkO1xuXHRjb25maWcudmlkZW9JZCA9IGNvbnRleHQudmlkZW9Db250YWluZXJJZDtcblx0XG5cdHJldHVybiBjb25maWc7XG59O1xuXG5sZXQgcmVmSW1hZ2VEYXRhID0gbnVsbDtcblxuLy8gcmVuZGVyIG1vZHVsZSBzdGFydFxuXG5jb25zdCBfcmVuZGVyTW9kdWxlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY29uc3QgYWRkUmVuZGVyTW9kdWxlID0gKG1vZHVsZU9iamVjdCkgPT4geyAvLyBzdWJzY3JpYmVcblx0aWYgKCEhbW9kdWxlT2JqZWN0Lm5hbWUgJiYgISFtb2R1bGVPYmplY3Qub25SZW5kZXIpIHtcblx0XHRpZiAodHlwZW9mIG1vZHVsZU9iamVjdC5vblJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29uc29sZS5sb2coJ1JlbmRlciBNb2R1bGVcXCdzIGFjdGlvbiBpcyBmdW5jdGlvbicpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoX3JlbmRlck1vZHVsZS5oYXMobW9kdWxlT2JqZWN0Lm5hbWUpKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnRHVwbGljYXRlIG1vZHVsZSBuYW1lJyk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdF9yZW5kZXJNb2R1bGUuc2V0KG1vZHVsZU9iamVjdC5uYW1lLCBtb2R1bGVPYmplY3Qub25SZW5kZXIpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUubG9nKCdZb3UgbXVzdCBzZXQgbmFtZSBhbmQgb25SZW5kZXInKTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgcmVtb3ZlUmVuZGVyTW9kdWxlID0gKG5hbWUpID0+IHtcblx0aWYgKCEhbmFtZSAmJiBfcmVuZGVyTW9kdWxlLmhhcyhuYW1lKSkge1xuXHRcdF9yZW5kZXJNb2R1bGUuZGVsZXRlKG5hbWUpO1xuXHR9XG59O1xuXG5leHBvcnQgY29uc3QgcmVzZXRSZW5kZXJNb2R1bGVzID0gKCkgPT4ge1xuXHRfcmVuZGVyTW9kdWxlLmNsZWFyKCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVuZGVyTW9kdWxlcyA9ICgpID0+IHtcblx0cmV0dXJuIChyZW5kZXJNb2R1bGVNYXAgPT4ge1xuXHRcdGNvbnN0IG9iaiA9IHt9O1xuXHRcdFxuXHRcdHJlbmRlck1vZHVsZU1hcC5mb3JFYWNoKCh2LCBrKSA9PiB7XG5cdFx0XHRvYmpba10gPSB2O1xuXHRcdH0pO1xuXHRcdHJldHVybiBvYmo7XG5cdH0pKF9yZW5kZXJNb2R1bGUpO1xufTtcblxuLy8gcmVuZGVyIG1vZHVsZSBlbmRcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGV0c2VlUHJpdmF0ZSBleHRlbmRzIExldHNlZU9ic2VydmVyIHtcblx0Y29uc3RydWN0b3IoX2NvbmZpZykge1xuXHRcdHN1cGVyKCk7XG5cdFx0aWYgKGluc3RhbmNlKSByZXR1cm4gaW5zdGFuY2U7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfTE9BRElORyk7XG5cdFx0dGhpcy5faXNQYXVzZSA9IGZhbHNlO1xuXHRcdGFkZFZpZXdwb3J0KCk7XG5cdFx0Y3JlYXRlTGV0c2VlV3JhcHBlcigpO1xuXHRcdGNyZWF0ZUxvYWRlcigpO1xuXHRcdHRoaXMuc3RhdGUgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZUZsYWcgPSBmYWxzZTtcblx0XHR0aGlzLmVudGl0eU1hbmFnZXIgPSBuZXcgRW50aXR5UGFyc2VyKCk7XG5cdFx0dGhpcy52aWRlb01hbmFnZXIgPSBuZXcgVmlkZW9NYW5hZ2VyKCk7XG5cdFx0dGhpcy52aWRlb01hbmFnZXIuc3Vic2NyaWJlKExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIGUgPT4ge1xuXHRcdFx0Ly8gdGhpcy5ub3RpZnkoTEVUU0VFX0VWRU5ULk9OX1NUQVRVUywgZSk7XG5cdFx0XHRpZiAoZS5jb2RlID09PSAyMDIpIHZpZGVvTG9hZEZsYWcgPSB0cnVlO1xuXHRcdFx0aWYgKGUuc3RhdHVzID09PSAnZXJyb3InKSBjcmVhdGVTdGF0dXNTY3JlZW4oZS5jb2RlKTtcblx0XHR9KTtcblx0XHRcblx0XHQvLyBAYXV0aG9yIHRyZWV0b3J5IDogTE9DQUwg7ZmY6rK97J28IOuVjCwgdmFsaWRhdGUg7ZWY64qUIOqyg+ydtCDsobDqsbTsnbQg64us65287KeA6rKMIO2VmOuptCDrkJjsp4Ag7JWK7J2E6rmMP1xuXHRcdHRoaXMuY29uZmlnID0gdmFsaWRhdGVDb25maWcoX2NvbmZpZyk7XG5cdFx0XG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmNvbmZpZy5ib2R5SWQpO1xuXHRcdGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChNZXNzYWdlLkxFVFNFRV9DU1MuQVJfTU9ERV9PTik7XG5cdFx0XG5cdFx0Ly8gU3RhcnQgZG9tIHBsYWNlIGhvbGRlclxuXHRcdGNvbnN0IGRvbVBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XG5cdFx0ZG9tUGxhY2Vob2xkZXIuaWQgPSBjb250ZXh0LnBsYWNlaG9sZGVySWQ7XG5cdFx0ZG9tUGxhY2Vob2xkZXIuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvbVBsYWNlaG9sZGVyKTtcblx0XHQvLyBFbmQgZG9tIHBsYWNlIGhvbGRlclxuXHRcdFxuXHRcdGNvbnN0IGNzc0RhdGEgPSBjc3NQYXJzZXIucGFyc2UodGhpcy5jb25maWcuYm9keUlkKTtcblx0XHRcblx0XHR0aGlzLmVudGl0eU9ic2VydmVyID0gbmV3IEVudGl0eU9ic2VydmVyKCk7XG5cdFx0dGhpcy5lbnRpdHlPYnNlcnZlci5zdWJzY3JpYmUoRU5USVRZX0VWRU5ULlRSQUNLX1NUQVJULCBlID0+IHtcblx0XHRcdHRoaXMubm90aWZ5KEVOVElUWV9FVkVOVC5UUkFDS19TVEFSVCwgZSk7XG5cdFx0XHR0aGlzLnRyYWNrU3RhdHVzQ3NzKEVOVElUWV9FVkVOVC5UUkFDS19TVEFSVCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5lbnRpdHlPYnNlcnZlci5zdWJzY3JpYmUoRU5USVRZX0VWRU5ULlRSQUNLX01PVkUsIGUgPT4ge1xuXHRcdFx0dGhpcy5ub3RpZnkoTEVUU0VFX0VWRU5ULlRSQUNLX01PVkUsIGUpO1xuXHRcdFx0dGhpcy50cmFja1N0YXR1c0NzcyhFTlRJVFlfRVZFTlQuVFJBQ0tfTU9WRSk7XG5cdFx0fSk7XG5cdFx0dGhpcy5lbnRpdHlPYnNlcnZlci5zdWJzY3JpYmUoRU5USVRZX0VWRU5ULlRSQUNLX0VORCwgZSA9PiB7XG5cdFx0XHR0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuVFJBQ0tfRU5ELCBlKTtcblx0XHRcdHRoaXMudHJhY2tTdGF0dXNDc3MoRU5USVRZX0VWRU5ULlRSQUNLX0VORCk7XG5cdFx0fSk7XG5cdFx0XG5cdFx0Y29uc3QgY2hlY2tFbnRpdHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR0aGlzLmVudGl0eU1hbmFnZXIuaW5pdEVudGl0eShjc3NEYXRhKVxuXHRcdFx0XHQudGhlbigob2JqKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5zdGF0ZSA9IG9iajtcblx0XHRcdFx0XHRpZiAodGhpcy5jb25maWcudHJhY2tlclR5cGUgPT09ICdJTUFHRScpIHtcblx0XHRcdFx0XHRcdGxvYWRJbWFnZSh0aGlzLnN0YXRlWzBdLmVudGl0eS5pbWFnZSlcblx0XHRcdFx0XHRcdFx0LnRoZW4ocmVzdWx0ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRyZWZJbWFnZURhdGEgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShyZWZJbWFnZURhdGEpO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHQuY2F0Y2goZXJyb3IgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcblx0XHRjb25zdCBjaGVja0VudiA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLmluaXQodGhpcy5jb25maWcuekluZGV4LCB0aGlzLmNvbmZpZy56SW5kZXhJbmNyZW1lbnQpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRfc2NlYW5DYW52YXMgPSB0aGlzLnZpZGVvTWFuYWdlci5jYW52YXNFbGVtZW50O1xuXHRcdFx0XHRcdF92aWRlb0VsZW1lbnQgPSB0aGlzLnZpZGVvTWFuYWdlci52aWRlb0VsZW1lbnQ7XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy53aWR0aCA9IHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8ud2lkdGg7XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy5oZWlnaHQgPSB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLmhlaWdodDtcblx0XHRcdFx0XHRfbGV0c2VlRW5naW5lQ29uZmlnLm9yaWVudGF0aW9uID0gdGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5hbmdsZTtcblx0XHRcdFx0XHRfbGV0c2VlRW5naW5lQ29uZmlnLmRhdGEgPSBjc3NEYXRhO1xuXHRcdFx0XHRcdF9sZXRzZWVFbmdpbmVDb25maWcuZG9tUmVuZGVyZXJJZCA9IHRoaXMuY29uZmlnLmRvbVJlbmRlcmVySWQ7XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy56SW5kZXggPSB0aGlzLmNvbmZpZy56SW5kZXg7XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy56SW5kZXhJbmNyZW1lbnQgPSB0aGlzLmNvbmZpZy56SW5kZXhJbmNyZW1lbnQ7XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy5wcm9qZWN0aW9uUGFyYW1ldGVyID1cblx0XHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWcuY2FtZXJhUGFyYW1ldGVyLmZvdixcblx0XHRcdFx0XHRcdFx0dGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5zY3JlZW5Bc3BlY3RSYXRpbyxcblx0XHRcdFx0XHRcdFx0dGhpcy5jb25maWcuY2FtZXJhUGFyYW1ldGVyLm5lYXIsXG5cdFx0XHRcdFx0XHRcdHRoaXMuY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mYXJcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy5leHRlcm5hbCA9IF9jb25maWcuZXh0ZXJuYWwgfHwgbnVsbDtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmVuZ2luZSA9IG5ldyBFbmdpbmUoX2xldHNlZUVuZ2luZUNvbmZpZyk7XG5cdFx0XHRcdFx0Ly8gdGhpcy5kaXNwYXRjaEVudGl0eUV2ZW50KCk7XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZXJyb3IgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybihlcnJvcik7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Y29uc3QgY2hlY2tTY3JpcHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdFxuXHRcdFx0c3dpdGNoICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSkge1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjYXNlICdJTUFHRSc6XG5cdFx0XHRcdFx0c2NyaXB0LnNyYyA9IGAke1RSQUNLRVJfVVJMfSR7SU1BR0VfVFJBQ0tFUl9GSUxFX05BTUV9YDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnTUFSS0VSJzpcblx0XHRcdFx0XHRzY3JpcHQuc3JjID0gYCR7VFJBQ0tFUl9VUkx9JHtNQVJLRVJfVFJBQ0tFUl9GSUxFX05BTUV9YDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnUVJDT0RFJzpcblx0XHRcdFx0XHRzY3JpcHQuc3JjID0gYCR7VFJBQ0tFUl9VUkx9JHtRUkNPREVfVFJBQ0tFUl9GSUxFX05BTUV9YDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8vIGlmICh0eXBlICE9PSAnU0xBTScpIHtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kKHNjcmlwdCk7XG5cdFx0XHQvLyBFeHBvc2VkIFRyYWNrZXIgZnJvbSB3ZWJwYWNrXG5cdFx0XHRzY3JpcHQub25sb2FkID0gKCkgPT4gcmVzb2x2ZShuZXcgVHJhY2tlcih0aGlzKSk7XG5cdFx0XHRzY3JpcHQub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYFNjcmlwdCBsb2FkIGVycm9yIGZvciAke3NyY31gKSk7XG5cdFx0XHQvLyB9IGVsc2UgaWYgKHR5cGUgPT09ICdTTEFNJykge1xuXHRcdFx0Ly8gICByZXNvbHZlKG5ldyBTbGFtKCkpO1xuXHRcdFx0Ly8gfVxuXHRcdH0pO1xuXHRcdFxuXHRcdHRoaXMucHJvbWlzZUNoYWluID0gW2NoZWNrRW50aXR5LCBjaGVja0VudiwgY2hlY2tTY3JpcHRdO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIGUgPT4ge1xuXHRcdFx0aWYgKHRyYWNrZXIpIHRyYWNrZXIuc3RvcFRyYWNrZXIgPSB0cnVlO1xuXHRcdFx0dGhpcy52aWRlb01hbmFnZXIub3JpZW50YXRpb25DaGFuZ2UoKTtcblx0XHRcdF9sZXRzZWVFbmdpbmVDb25maWcud2lkdGggPSB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLndpZHRoO1xuXHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy5oZWlnaHQgPSB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLmhlaWdodDtcblx0XHRcdF9sZXRzZWVFbmdpbmVDb25maWcub3JpZW50YXRpb24gPSB0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLmFuZ2xlO1xuXHRcdFx0X2xldHNlZUVuZ2luZUNvbmZpZy5wcm9qZWN0aW9uUGFyYW1ldGVyID1cblx0XHRcdFx0W1xuXHRcdFx0XHRcdHRoaXMuY29uZmlnLmNhbWVyYVBhcmFtZXRlci5mb3YsXG5cdFx0XHRcdFx0dGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5zY3JlZW5Bc3BlY3RSYXRpbyxcblx0XHRcdFx0XHR0aGlzLmNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIubmVhcixcblx0XHRcdFx0XHR0aGlzLmNvbmZpZy5jYW1lcmFQYXJhbWV0ZXIuZmFyXG5cdFx0XHRcdF07XG5cdFx0XHR0aGlzLmVuZ2luZS5vbkNvbmZpZ3VyYXRpb25DaGFuZ2VkKHtcblx0XHRcdFx0J3dpZHRoJzogX2xldHNlZUVuZ2luZUNvbmZpZy53aWR0aCxcblx0XHRcdFx0J2hlaWdodCc6IF9sZXRzZWVFbmdpbmVDb25maWcuaGVpZ2h0LFxuXHRcdFx0XHQnb3JpZW50YXRpb24nOiBfbGV0c2VlRW5naW5lQ29uZmlnLmFuZ2xlLFxuXHRcdFx0XHQnYXNwZWN0JzogdGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby5zY3JlZW5Bc3BlY3RSYXRpb1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAodHJhY2tlcikgdHJhY2tlci5zdG9wVHJhY2tlciA9IGZhbHNlO1xuXHRcdFx0Ly8gdGhpcy5kaXNwYXRjaChNZXNzYWdlLkVWRU5UX0FQUF9ST1RBVElPTkNIQU5HRSwgZSk7XG5cdFx0XHR0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuUk9UQVRJT05fQ0hBTkdFLCBlKTtcblx0XHR9KTtcblx0XHRcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZXYgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coJ3Jlc2l6ZScpO1xuXHRcdFx0XG5cdFx0XHQvLyB0aGlzLnZpZGVvTWFuYWdlci5jYW52YXNFbGVtZW50LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0XHQvLyB0aGlzLnZpZGVvTWFuYWdlci5jYW52YXNFbGVtZW50LmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbi5maXRXaWR0aEFuZEhlaWdodCgpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0fSk7XG5cdFx0XG5cdFx0aW5zdGFuY2UgPSB0aGlzO1xuXHR9XG5cdFxuXHRpbml0KCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRQcm9taXNlLmFsbCh0aGlzLnByb21pc2VDaGFpbilcblx0XHRcdFx0LnRoZW4odmFsdWUgPT4ge1xuXHRcdFx0XHRcdHRyYWNrZXIgPSB2YWx1ZVsyXTtcblx0XHRcdFx0XHRyZXR1cm4gdHJhY2tlci5pbml0VHJhY2tlcihfdmlkZW9FbGVtZW50LCBfc2NlYW5DYW52YXMsIHRoaXMuY29uZmlnLmFwcEtleSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHQvLyBmcmFtZUJ5dGVBZGRyZXNzID0gdHJhY2tlci51cGRhdGVTY3JlZW4odGhpcy52aWRlb01hbmFnZXIuc2NyZWVuV2lkdGgsIHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkhlaWdodCk7XG5cdFx0XHRcdFx0Ly8gaWYgKHRoaXMuY29uZmlnLnRyYWNrZXJUeXBlID09PSAnSU1BR0UnKSB0aGlzLnNldFJlZmVyZW5jZUltYWdlKHJlZkltYWdlRGF0YS5pbWcpO1xuXHRcdFx0XHRcdGlmICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSA9PT0gJ0lNQUdFJykgdHJhY2tlci5zZXRSZWZJbWFnZShyZWZJbWFnZURhdGEuaW1nKTtcblx0XHRcdFx0XHRpZiAodGhpcy5jb25maWcudHJhY2tlclR5cGUgPT09ICdNQVJLRVInKSB0cmFja2VyLmNyZWF0ZU1hcmtlclN0YXRlKHRoaXMuZW50aXR5TWFuYWdlci5tYXJrZXJMaXN0IHx8IG51bGwpO1xuXHRcdFx0XHRcdGlmICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSA9PT0gJ1FSQ09ERScpIHRyYWNrZXIuY3JlYXRlTWFya2VyU3RhdGUodGhpcy5lbnRpdHlNYW5hZ2VyLmNvZGVMaXN0IHx8IG51bGwpO1xuXHRcdFx0XHRcdC8vIGlmICh0aGlzLmNvbmZpZy50cmFja2VyVHlwZSA9PT0gJ1NMQU0nKSB0cmFja2VyLmNyZWF0ZU1hcmtlclN0YXRlKHRoaXMuZW50aXR5TWFuYWdlci5jb2RlTGlzdCB8fCBudWxsKTtcblx0XHRcdFx0XHR0aGlzLnJlbmRlckFsbFRhc2soKTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaChlcnJvciA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coZXJyb3IpO1xuXHRcdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHRnZXQgaXNQYXVzZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNQYXVzZTtcblx0fVxuXHRcblx0c2V0IGlzUGF1c2UodmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcignQWxsb3dlZCB2YWx1ZSBpcyBib29sZWFuJyk7XG5cdFx0aWYgKHRoaXMuX2lzUGF1c2UgPT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdFx0dHJhY2tlci5pc1BhdXNlID0gdmFsdWU7XG5cdFx0dGhpcy5faXNQYXVzZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRwYXVzZSh2YWx1ZSkge1xuXHRcdHRoaXMuaXNQYXVzZSA9IHRydWU7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKE1lc3NhZ2UuTEVUU0VFX0NTUy5BUl9NT0RFX09OKTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoTWVzc2FnZS5MRVRTRUVfQ1NTLkFSX01PREVfT0ZGKTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXG5cdFx0XHRFTlRJVFlfRVZFTlQuVFJBQ0tfU1RBUlQsXG5cdFx0XHRFTlRJVFlfRVZFTlQuVFJBQ0tfTU9WRSxcblx0XHRcdEVOVElUWV9FVkVOVC5UUkFDS19FTkRcblx0XHQpO1xuXHRcdGlmICh2YWx1ZSkgdGhpcy52aWRlb01hbmFnZXIuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdHJlc3VtZSh2YWx1ZSA9IGZhbHNlKSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5BUl9NT0RFX09OKTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoTWVzc2FnZS5MRVRTRUVfQ1NTLkFSX01PREVfT0ZGKTtcblx0XHR0aGlzLnZpZGVvTWFuYWdlci5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0dGhpcy5pc1BhdXNlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdHJlbmRlckFsbFRhc2soKSB7XG5cdFx0X3JlbmRlck1vZHVsZS5mb3JFYWNoKHZhbCA9PiB2YWwocGVyZm9ybWFuY2Uubm93KCkpKTtcblx0XHR0cmFja2VyLnByb2Nlc3NGcmFtZSh0aGlzLl9pc1BhdXNlKTtcblx0XHRpZiAodmlkZW9Mb2FkRmxhZyAmJiAhZmlyc3RMb2FkRmxhZykge1xuXHRcdFx0Zmlyc3RMb2FkRmxhZyA9IHRydWU7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoTWVzc2FnZS5MRVRTRUVfQ1NTLkxFVFNFRV9MT0FERUQpO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfTE9BRElORyk7XG5cdFx0XHRjb25zdCBjaGVja0xvYWRlciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoTWVzc2FnZS5MRVRTRUVfQ1NTLkxFVFNFRV9MT0FERUQpO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoTWVzc2FnZS5MRVRTRUVfQ1NTLkxFVFNFRV9MT0FESU5HKTtcblx0XHRcdFx0dGhpcy5ub3RpZnkoTWVzc2FnZS5FVkVOVF9BUFBfT05MT0FEKTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGNoZWNrTG9hZGVyKTtcblx0XHRcdH0sIDIwMDApO1xuXHRcdH1cblx0XHQ7XG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG5cdFx0XHR0aGlzLnJlbmRlckFsbFRhc2soKTtcblx0XHR9KTtcblx0fVxuXHRcblx0ZGlzcGF0Y2hUcmFja1N0YXRlKG1hdHJpeCwgY3VycmVudFN0YXRlKSB7XG5cdFx0bGV0IG5ld1N0YXRlID0gW107XG5cdFx0XG5cdFx0aWYgKFxuXHRcdFx0KHRoaXMuZW5naW5lICE9PSBudWxsIHx8IHR5cGVvZiB0aGlzLmVuZ2luZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG5cdFx0XHQobWF0cml4ICE9PSBudWxsIHx8IHR5cGVvZiBtYXRyaXggIT09ICd1bmRlZmluZWQnKSAmJlxuXHRcdFx0KGN1cnJlbnRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50U3RhdGUgIT09IE1lc3NhZ2UuU1RBVEVfUkVDT0dOSVpFICYmIHR5cGVvZiBjdXJyZW50U3RhdGUgIT09ICd1bmRlZmluZWQnKVxuXHRcdCkge1xuXHRcdFx0XG5cdFx0XHRuZXdTdGF0ZSA9IHRoaXMuc3RhdGUubWFwKG9iaiA9PiB7XG5cdFx0XHRcdG9iai50eXBlID0gY3VycmVudFN0YXRlO1xuXHRcdFx0XHRvYmoubWF0cml4ID0gSlNPTi5wYXJzZSgnWycgKyBtYXRyaXggKyAnXScpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmVuZ2luZS5vYmplY3RUcmFja2VyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcblx0XHRcdC8vIHRoaXMuZGlzcGF0Y2hFbnRpdHlFdmVudChuZXdTdGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdbZXJyb3JdIGxldHNlZSBpcyBub3QgbG9hZGVkIScpO1xuXHRcdH1cblx0fVxuXHRcblx0ZGlzcGF0Y2hUcmFja1N0YXRlTWFya2VyKG1hdHJpeCwgY3VycmVudFN0YXRlLCBtYXJrZXJJZCA9IG51bGwpIHtcblx0XHRsZXQgbmV3U3RhdGUgPSBbXTtcblx0XHRcblx0XHRpZiAoXG5cdFx0XHQodGhpcy5lbmdpbmUgIT09IG51bGwgfHwgdHlwZW9mIHRoaXMuZW5naW5lICE9PSAndW5kZWZpbmVkJykgJiZcblx0XHRcdChtYXRyaXggIT09IG51bGwgfHwgdHlwZW9mIG1hdHJpeCAhPT0gJ3VuZGVmaW5lZCcpICYmXG5cdFx0XHQoY3VycmVudFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnRTdGF0ZSAhPT0gTWVzc2FnZS5TVEFURV9SRUNPR05JWkUgJiYgdHlwZW9mIGN1cnJlbnRTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0KSB7XG5cdFx0XHRuZXdTdGF0ZSA9IHRoaXMuc3RhdGVcblx0XHRcdFx0LmZpbHRlcihvYmogPT4ge1xuXHRcdFx0XHRcdHJldHVybiBtYXJrZXJJZC5pbmNsdWRlcyhvYmouZW50aXR5LmxldHNlZU1hcmtlcklkKTtcblx0XHRcdFx0fSkubWFwKG9iaiA9PiB7XG5cdFx0XHRcdFx0b2JqLnR5cGUgPSBjdXJyZW50U3RhdGVbbWFya2VySWQuaW5kZXhPZihvYmouZW50aXR5LmxldHNlZU1hcmtlcklkKV07XG5cdFx0XHRcdFx0b2JqLm1hdHJpeCA9IEpTT04ucGFyc2UoJ1snICsgbWF0cml4W21hcmtlcklkLmluZGV4T2Yob2JqLmVudGl0eS5sZXRzZWVNYXJrZXJJZCldICsgJ10nKTtcblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0dGhpcy5lbmdpbmUub2JqZWN0VHJhY2tlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdbZXJyb3JdIGxldHNlZSBpcyBub3QgbG9hZGVkIScpO1xuXHRcdH1cblx0fVxuXHRcblx0ZGlzcGF0Y2hUcmFja1N0YXRlUXIobWF0cml4LCBjdXJyZW50U3RhdGUsIG1hcmtlcklkID0gbnVsbCkge1xuXHRcdGxldCBuZXdTdGF0ZSA9IFtdO1xuXHRcdFxuXHRcdGlmIChcblx0XHRcdCFpc05pbCh0aGlzLmVuZ2luZSkgJiZcblx0XHRcdCFpc05pbChtYXRyaXgpICYmXG5cdFx0XHQhaXNOaWwoY3VycmVudFN0YXRlKSAmJlxuXHRcdFx0Y3VycmVudFN0YXRlICE9PSBNZXNzYWdlLkVOVElUWV9FVkVOVC5SRUNPR05JWkVcblx0XHQpIHtcblx0XHRcdG5ld1N0YXRlID0gdGhpcy5zdGF0ZVxuXHRcdFx0XHQuZmlsdGVyKG9iaiA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hcmtlcklkLmluY2x1ZGVzKG9iai5lbnRpdHkuY29kZVN0cmluZyk7XG5cdFx0XHRcdH0pLm1hcChvYmogPT4ge1xuXHRcdFx0XHRcdG9iai50eXBlID0gY3VycmVudFN0YXRlW21hcmtlcklkLmluZGV4T2Yob2JqLmVudGl0eS5jb2RlU3RyaW5nKV07XG5cdFx0XHRcdFx0b2JqLm1hdHJpeCA9IEpTT04ucGFyc2UoJ1snICsgbWF0cml4W21hcmtlcklkLmluZGV4T2Yob2JqLmVudGl0eS5jb2RlU3RyaW5nKV0gKyAnXScpO1xuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH0pO1xuXHRcdFx0dGhpcy5lbmdpbmUub2JqZWN0VHJhY2tlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKCdbZXJyb3JdIGxldHNlZSBpcyBub3QgbG9hZGVkIScpO1xuXHRcdH1cblx0fVxuXHRcblx0dHJhY2tTdGF0dXNDc3Moc3RhdHVzKSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFxuXHRcdFx0RU5USVRZX0VWRU5ULlRSQUNLX1NUQVJULFxuXHRcdFx0RU5USVRZX0VWRU5ULlRSQUNLX01PVkUsXG5cdFx0XHRFTlRJVFlfRVZFTlQuVFJBQ0tfRU5EXG5cdFx0KTtcblx0XHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoc3RhdHVzKTtcblx0fTtcblx0XG5cdHN3aXRjaENhbWVyYShzcmMpIHtcblx0XHR0aGlzLnZpZGVvTWFuYWdlci5zZXRWaWRlb1NvdXJjZShzcmMpO1xuXHR9O1xuXHRcblx0cmVxdWVzdEZ1bGxzY3JlZW4oKSB7XG5cdFx0Y29uc29sZS5sb2coJ3JlcXVlc3RGdWxsc2NyZWVuIGZ1bmN0aW9uIGlzIGNhbGxlZC4nKTtcblx0XHQvL3RoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbi5maXRXaWR0aEFuZEhlaWdodCgpO1xuXHRcdFxuXHRcdGxldCBfYXJSZW5kZXJlciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FyLXJlbmRlcmVyJyk7XG5cdFx0XG5cdFx0aWYgKF9hclJlbmRlcmVyWzBdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFxuXHRcdFx0aWYgKF9hclJlbmRlcmVyWzBdLnJlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRcdF9hclJlbmRlcmVyWzBdLnJlcXVlc3RGdWxsc2NyZWVuKCkudGhlbigoZSkgPT4ge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbi5maXRXaWR0aEFuZEhlaWdodCgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHR9KS5jYXRjaChlcnIgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBFcnJvciBhdHRlbXB0aW5nIHRvIGVuYWJsZSBmdWxsLXNjcmVlbiBtb2RlOiAke2Vyci5tZXNzYWdlfSAoJHtlcnIubmFtZX0pYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuXHRcdFx0XHRfYXJSZW5kZXJlclswXS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuXHRcdFx0fSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuXHRcdFx0XHRfYXJSZW5kZXJlclswXS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuXHRcdFx0fSBlbHNlIGlmIChfYXJSZW5kZXJlclswXS5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0XHRcdF9hclJlbmRlcmVyWzBdLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRleGl0RnVsbHNjcmVlbigpIHtcblx0XHRpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcblx0XHRcdGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbi5maXRXaWR0aEFuZEhlaWdodCgpO1xuXHRcdFx0fSkuY2F0Y2goZXJyID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coZXJyKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoZG9jdW1lbnQubW96Q2FuY2VsRnVsbFNjcmVlbikgeyAvKiBGaXJlZm94ICovXG5cdFx0XHRkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG5cdFx0fSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikgeyAvKiBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmEgKi9cblx0XHRcdGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0fSBlbHNlIGlmIChkb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKSB7IC8qIElFL0VkZ2UgKi9cblx0XHRcdGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdFx0XG5cdH07XG5cdFxuXHQvLyBGaXhlZCBnZXR0ZXIvc2V0dGVyXG5cdGdldCBsZXRzZWVFbmdpbmVDb25maWcoKSB7XG5cdFx0cmV0dXJuIF9sZXRzZWVFbmdpbmVDb25maWc7XG5cdH1cbn1cbiIsIi8vaW1wb3J0IHZpZGVvTWFuYWdlciBmcm9tICcuL2xpYnMvVmlkZW9NYW5hZ2VyJztcblxuY2xhc3MgU2NyZWVuIHtcblx0Y29uc3RydWN0b3IoX3dpZHRoLCBfaGVpZ2h0LCBfdmlkZW9NYW5hZ2VyKSB7XG5cdFx0Y29uc29sZS5sb2coJ1NjcmVlbiBpcyBjb25zdHJ1Y3RlZCEnKTtcblx0XHR0aGlzLndpZHRoID0gX3dpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gX2hlaWdodDtcblx0XHR0aGlzLnZpZGVvTWFuYWdlciA9IF92aWRlb01hbmFnZXI7XG5cdH1cblx0XG5cdGZpdFdpZHRoQW5kSGVpZ2h0KCkge1xuXHRcdGNvbnNvbGUubG9nKCdmaXRXaWR0aEFuZEhlaWdodCBmdW5jdGlvbiBpcyBjYWxsZWQuJyk7XG5cdFx0XG5cdFx0dGhpcy52aWRlb01hbmFnZXIucmVjb25uZWN0TWVkaWFTdHJlYW0oKTtcblx0XHRcblx0XHRsZXQgY29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShcblx0XHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hci1yZW5kZXJlcicpLCAnOmJhY2tkcm9wJ1xuXHRcdCkuZ2V0UHJvcGVydHlWYWx1ZSgnYmFja2dyb3VuZCcpO1xuXHRcdGNvbnNvbGUubG9nKGNvbG9yKTtcblx0XHRcblx0XHR0aGlzLnZpZGVvTWFuYWdlci5jYW52YXNFbGVtZW50LndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0dGhpcy52aWRlb01hbmFnZXIuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0dGhpcy52aWRlb01hbmFnZXIuc2NyZWVuSW5mby53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdHRoaXMudmlkZW9NYW5hZ2VyLnNjcmVlbkluZm8uaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXHRcdFxuXHRcdC8vIGlmICh0aGlzLnZpZGVvTWFuYWdlci5jb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vXG5cdFx0Ly8gXHQvLyBUb2dnbGluZyBmdWxsc2NyZWVuIG1vZGVcblx0XHQvLyBcdGlmICghdGhpcy52aWRlb01hbmFnZXIuY29udGFpbmVyLmZ1bGxzY3JlZW5FbGVtZW50KSB7XG5cdFx0Ly8gXHRcdGlmICh0aGlzLnZpZGVvTWFuYWdlci5jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4pIHtcblx0XHQvLyBcdFx0XHR0aGlzLnZpZGVvTWFuYWdlci5jb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oKS50aGVuKChlKSA9PiB7XG5cdFx0Ly8gXHRcdFx0XHR0aGlzLnZpZGVvTWFuYWdlci5yZWNvbm5lY3RNZWRpYVN0cmVhbSgpO1xuXHRcdC8vIFx0XHRcdFx0dGhpcy52aWRlb01hbmFnZXIuY2FudmFzRWxlbWVudC53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdC8vIFx0XHRcdFx0dGhpcy52aWRlb01hbmFnZXIuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cdFx0Ly8gXHRcdFx0XHR0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFx0Ly8gXHRcdFx0XHR0aGlzLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHQvLyBcdFx0XHR9KS5jYXRjaChlcnIgPT4ge1xuXHRcdC8vIFx0XHRcdFx0Y29uc29sZS5sb2coYEVycm9yIGF0dGVtcHRpbmcgdG8gZW5hYmxlIGZ1bGwtc2NyZWVuIG1vZGU6ICR7ZXJyLm1lc3NhZ2V9ICgke2Vyci5uYW1lfSlgKTtcblx0XHQvLyBcdFx0XHR9KTtcblx0XHQvL1xuXHRcdC8vIFx0XHR9IGVsc2UgaWYgKHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuXHRcdC8vIFx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuXHRcdC8vIFx0XHR9IGVsc2UgaWYgKHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuXHRcdC8vIFx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuXHRcdC8vIFx0XHR9IGVsc2UgaWYgKHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG5cdFx0Ly8gXHRcdFx0dGhpcy52aWRlb01hbmFnZXIuY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHQvLyBcdFx0fVxuXHRcdC8vIFx0fSBlbHNlIHtcblx0XHQvLyBcdFx0aWYgKHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5leGl0RnVsbHNjcmVlbikge1xuXHRcdC8vIFx0XHRcdHRoaXMudmlkZW9NYW5hZ2VyLmNvbnRhaW5lci5leGl0RnVsbHNjcmVlbigpO1xuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXHR9O1xuXHRcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2NyZWVuO1xuIiwiLy8gaW1wb3J0IGFkYXB0ZXIgZnJvbSAnd2VicnRjLWFkYXB0ZXInO1xuLy8gaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0ICogYXMgTWVzc2FnZSBmcm9tICcuL2xpYnMvTWVzc2FnZVR5cGVzJztcblxuY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuY29uc3QgbGV0c2VlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuY29uc3QgbGV0c2VlTG9hZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5jb25zdCBsZXRzZWVTdGF0dXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnN0IGRlZmF1bHRMb2FkZXJDb250ZW50ID0gJzxkaXYgY2xhc3M9XCJsZXRzZWVMb2FkZXJcIj48aW1nIHNyYz1cImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU5EUWlJR2hsYVdkb2REMGlORFFpSUhacFpYZENiM2c5SWpBZ01DQTBOQ0EwTkNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWlCemRISnZhMlU5SWlObVptWWlQaUFnUEdjZ1ptbHNiRDBpYm05dVpTSWdjM1J5YjJ0bFBTSWpNREJpTVdNM0lpQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJSE4wY205clpTMTNhV1IwYUQwaU1pSStJQ0FnSUR4amFYSmpiR1VnWTNnOUlqSXlJaUJqZVQwaU1qSWlJSEk5SWpFaVBpQWdJQ0FnSUR4aGJtbHRZWFJsSUdGMGRISnBZblYwWlU1aGJXVTlJbklpSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdZbVZuYVc0OUlqQnpJaUJrZFhJOUlqRXVPSE1pSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbUZzZFdWelBTSXhPeUF5TUNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVd4alRXOWtaVDBpYzNCc2FXNWxJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHdGxlVlJwYldWelBTSXdPeUF4SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVZOd2JHbHVaWE05SWpBdU1UWTFMQ0F3TGpnMExDQXdMalEwTENBeElpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbGNHVmhkRU52ZFc1MFBTSnBibVJsWm1sdWFYUmxJaUF2UGlBZ0lDQWdJRHhoYm1sdFlYUmxJR0YwZEhKcFluVjBaVTVoYldVOUluTjBjbTlyWlMxdmNHRmphWFI1SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR0psWjJsdVBTSXdjeUlnWkhWeVBTSXhMamh6SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoYkhWbGN6MGlNVHNnTUNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JqWVd4alRXOWtaVDBpYzNCc2FXNWxJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHdGxlVlJwYldWelBTSXdPeUF4SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJR3RsZVZOd2JHbHVaWE05SWpBdU15d2dNQzQyTVN3Z01DNHpOVFVzSURFaUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnY21Wd1pXRjBRMjkxYm5ROUltbHVaR1ZtYVc1cGRHVWlJQzgrSUNBZ0lEd3ZZMmx5WTJ4bFBpQWdJQ0E4WTJseVkyeGxJR040UFNJeU1pSWdZM2s5SWpJeUlpQnlQU0l4SWo0Z0lDQWdJQ0E4WVc1cGJXRjBaU0JoZEhSeWFXSjFkR1ZPWVcxbFBTSnlJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lHSmxaMmx1UFNJdE1DNDVjeUlnWkhWeVBTSXhMamh6SWlBZ0lDQWdJQ0FnSUNBZ0lDQWdJSFpoYkhWbGN6MGlNVHNnTWpBaUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnWTJGc1kwMXZaR1U5SW5Od2JHbHVaU0lnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnJaWGxVYVcxbGN6MGlNRHNnTVNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JyWlhsVGNHeHBibVZ6UFNJd0xqRTJOU3dnTUM0NE5Dd2dNQzQwTkN3Z01TSWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCeVpYQmxZWFJEYjNWdWREMGlhVzVrWldacGJtbDBaU0lnTHo0Z0lDQWdJQ0E4WVc1cGJXRjBaU0JoZEhSeWFXSjFkR1ZPWVcxbFBTSnpkSEp2YTJVdGIzQmhZMmwwZVNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JpWldkcGJqMGlMVEF1T1hNaUlHUjFjajBpTVM0NGN5SWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCMllXeDFaWE05SWpFN0lEQWlJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ1kyRnNZMDF2WkdVOUluTndiR2x1WlNJZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0JyWlhsVWFXMWxjejBpTURzZ01TSWdJQ0FnSUNBZ0lDQWdJQ0FnSUNCclpYbFRjR3hwYm1WelBTSXdMak1zSURBdU5qRXNJREF1TXpVMUxDQXhJaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lISmxjR1ZoZEVOdmRXNTBQU0pwYm1SbFptbHVhWFJsSWlBdlBpQWdJQ0E4TDJOcGNtTnNaVDRnSUR3dlp6NDhMM04yWno0PVwiPjwvZGl2Pic7XG5jb25zdCBsZXRzZWVTdHlsZSA9IFtcbiAgYEBmb250LWZhY2V7Zm9udC1mYW1pbHk6Um9ib3RvO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtzcmM6dXJsKGh0dHBzOi8vY2RuLmxldHNlZS5pby9mb250L3JvYm90by00MDAud29mZikgZm9ybWF0KCd3b2ZmJyl9YCxcbiAgYC5sZXRzZWVTdGF0dXMsLmxldHNlZUxvYWRlcntmb250LWZhbWlseTogJ1JvYm90bycsIHNhbnMtc2VyaWY7fWAsXG4gIGAjbGV0c2VlV3JhcHBlcj5kaXZ7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmZpeGVkIWltcG9ydGFudDt3aWR0aDoxMDAlIWltcG9ydGFudDtoZWlnaHQ6MTAwJSFpbXBvcnRhbnQ7ei1pbmRleDoxMDAwMDAwMCFpbXBvcnRhbnQ7YmFja2dyb3VuZDojZmZmIWltcG9ydGFudDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDt0ZXh0LWFsaWduOmNlbnRlcn1gLFxuICBgLmxldHNlZUxvYWRlciBpbWd7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O2xlZnQ6NTAlIWltcG9ydGFudDt0b3A6NTAlIWltcG9ydGFudDt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSkhaW1wb3J0YW50O3dpZHRoOjUwcHghaW1wb3J0YW50O2hlaWdodDo1MHB4IWltcG9ydGFudH1gLFxuICBgLmxldHNlZS1sb2FkaW5nICNsZXRzZWVXcmFwcGVyIC5sZXRzZWVMb2FkZXJ7ZGlzcGxheTpibG9ja31gLFxuICBgLmxldHNlZS1zdGF0dXMgI2xldHNlZVdyYXBwZXIgLmxldHNlZVN0YXR1c3tkaXNwbGF5OmJsb2NrfWAsXG4gIGBib2R5LmFyLW1vZGUtb2ZmIC5hci1yZW5kZXJlcntkaXNwbGF5Om5vbmUhaW1wb3J0YW50O31gXG5dO1xuY29uc3Qgc3RhdHVzSHRtbCA9ICh0eXBlKSA9PiB7XG4gIGxldCBfaHRtbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIDEwMTpcbiAgICAgIF9odG1sID0gYDxkaXYgY2xhc3M9XCJ0aXRsZVwiPjxoMj5Vc2Ugc2FmYXJpIGZvciBhd2Vzb21lIEFSIGFwcCB3aXRoIGlQaG9uZTwvaDI+PC9kaXY+PGRpdiBjbGFzcz1cImJvZHlcIj48cCBpZD1cImNvcHlUZXh0XCIgY2xhc3M9XCJ1cmxcIj4ke3dpbmRvdy5sb2NhdGlvbi5ocmVmfTwvcD48cCBjbGFzcz1cInRleHRcIj5Db3B5IHVybCBhbmQgcGFzdGUgdG8gc2FmYXJpLjwvcD48L2Rpdj48c2NyaXB0PmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29weVRleHRcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oKXshZnVuY3Rpb24oZSl7Y29uc3QgdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dEFyZWFcIik7bGV0IG4sbzt0LnZhbHVlPWUsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KSxuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pcGFkfGlwaG9uZS9pKT8oKG49ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSkuc2VsZWN0Tm9kZUNvbnRlbnRzKHQpLChvPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSkucmVtb3ZlQWxsUmFuZ2VzKCksby5hZGRSYW5nZShuKSx0LnNldFNlbGVjdGlvblJhbmdlKDAsOTk5OTk5KSk6dC5zZWxlY3QoKSxkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIiksZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KX0oZS50YXJnZXQudGV4dENvbnRlbnQpfSk7PC9zY3JpcHQ+YDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMDI6XG4gICAgICBfaHRtbCA9ICc8ZGl2IGNsYXNzPVwidGl0bGVcIj48aDI+VW5zdXBwb3J0ZWQgYnJvd3NlcjwvaDI+PC9kaXY+PGRpdiBjbGFzcz1cImJvZHlcIj48cCBjbGFzcz1cInRleHRcIj5QbGVhc2UgdXNlIENocm9tZSwgRmlyZWZveCwgaU9TIDExLCBBbmRyb2lkIDUgb3IgaGlnaGVyLCBTYWZhcmkgMTEgb3IgaGlnaGVyPC9wPjwvZGl2Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTAzOlxuICAgICAgX2h0bWwgPSAnPGRpdiBjbGFzcz1cInRpdGxlXCI+PGgyPk5vIGNhbWVyYSBkZXRlY3RlZDwvaDI+PC9kaXY+PGRpdiBjbGFzcz1cImJvZHlcIj48cCBjbGFzcz1cInRleHRcIj5QbGVhc2UgaW5zdGFsbCBhbiBleHRlcm5hbCB3ZWJjYW0gZGV2aWNlLjwvcD48L2Rpdj4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwNDpcbiAgICAgIF9odG1sID0gJzxkaXYgY2xhc3M9XCJ0aXRsZVwiPjxoMj5ObyBtb2JpbGUgZGV2aWNlIGRldGVjdGVkPC9oMj48L2Rpdj48ZGl2IGNsYXNzPVwiYm9keVwiPjxwIGNsYXNzPVwidGV4dFwiPlBsZWFzZSB1c2UgbW9iaWxlIGJyb3dzZXIuPC9wPjwvZGl2Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA1OlxuICAgICAgX2h0bWwgPSAnPGRpdiBjbGFzcz1cInRpdGxlXCI+PGgyPkNhbWVyYSBkZW5pZWQ8L2gyPjwvZGl2PjxkaXYgY2xhc3M9XCJib2R5XCI+PHAgY2xhc3M9XCJ0ZXh0XCI+UGxlYXNlIGFsbG93IGNhbWVyYSBwZXJtaXNzaW9uLjwvcD48L2Rpdj4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgX2h0bWwgPSAnPGRpdiBjbGFzcz1cInRpdGxlXCI+PGgyPkdlbmVyYWwgZXJyb3I8L2gyPjwvZGl2PjxkaXYgY2xhc3M9XCJib2R5XCI+PHAgY2xhc3M9XCJ0ZXh0XCI+R2VuZXJhbCBlcnJvcjwvcD48L2Rpdj4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbiAgcmV0dXJuIF9odG1sO1xufTtcblxuY29uc3Qgc3RhdHVzQ3NzID0gKHR5cGUpID0+IHtcbiAgbGV0IF9jc3M7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAxMDE6XG4gICAgICBfY3NzID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwMjpcbiAgICAgIF9jc3MgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTAzOlxuICAgICAgX2NzcyA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMDQ6XG4gICAgICBfY3NzID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlIDEwNTpcbiAgICAgIF9jc3MgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBfY3NzID0gW107XG4gIH1cbiAgcmV0dXJuIF9jc3M7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTGV0c2VlV3JhcHBlciA9ICgpID0+IHtcbiAgc3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kKHN0eWxlKTtcbiAgbGV0c2VlU3R5bGUuZm9yRWFjaCgodmFsLCBpbmRleCkgPT4ge1xuICAgIHN0eWxlLnNoZWV0Lmluc2VydFJ1bGUodmFsLCBpbmRleCk7XG4gIH0pO1xuICBsZXRzZWVXcmFwcGVyLmlkID0gJ2xldHNlZVdyYXBwZXInO1xuXG4gIGxldHNlZUxvYWRlci5jbGFzc0xpc3QuYWRkKCdsZXRzZWVMb2FkZXInKTtcbiAgbGV0c2VlU3RhdHVzLmNsYXNzTGlzdC5hZGQoJ2xldHNlZVN0YXR1cycpO1xuICBsZXRzZWVXcmFwcGVyLmFwcGVuZENoaWxkKGxldHNlZUxvYWRlcik7XG4gIGxldHNlZVdyYXBwZXIuYXBwZW5kQ2hpbGQobGV0c2VlU3RhdHVzKTtcblxuICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShsZXRzZWVXcmFwcGVyLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUxvYWRlciA9IChfaHRtbCA9IGRlZmF1bHRMb2FkZXJDb250ZW50LCBfY3NzID0gbnVsbCkgPT4ge1xuICBpZiAoX2Nzcykge1xuICAgIF9jc3MuZm9yRWFjaCgodmFsLCBpbmRleCkgPT4ge1xuICAgICAgc3R5bGUuc2hlZXQuaW5zZXJ0UnVsZSh2YWwsIGluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBsZXRzZWVMb2FkZXIuaW5uZXJIVE1MID0gJyc7XG4gIGxldHNlZUxvYWRlci5pbm5lckhUTUwgPSBfaHRtbDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTdGF0dXNTY3JlZW4gPSAodHlwZSkgPT4ge1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoTWVzc2FnZS5MRVRTRUVfQ1NTLkxFVFNFRV9MT0FESU5HKTtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKE1lc3NhZ2UuTEVUU0VFX0NTUy5MRVRTRUVfU1RBVFVTKTtcbiAgbGV0c2VlU3RhdHVzLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0dXMtY29kZScsIHR5cGUpO1xuICBsZXRzZWVTdGF0dXMuaW5uZXJIVE1MID0gc3RhdHVzSHRtbCh0eXBlKTtcblxuICBzdGF0dXNDc3ModHlwZSkuZm9yRWFjaCgodmFsLCBpbmRleCkgPT4ge1xuICAgIHN0eWxlLnNoZWV0Lmluc2VydFJ1bGUodmFsLCBpbmRleCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZFZpZXdwb3J0ID0gKCkgPT4ge1xuICBjb25zdCB2aWV3UG9ydFRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcblxuICB2aWV3UG9ydFRhZy5pZCA9ICd2aWV3cG9ydCc7XG4gIHZpZXdQb3J0VGFnLm5hbWUgPSAndmlld3BvcnQnO1xuICB2aWV3UG9ydFRhZy5jb250ZW50ID0gJ21pbmltdW0tc2NhbGU9MS4wLCB3aWR0aD1kZXZpY2Utd2lkdGgsIG1heGltdW0tc2NhbGU9MSwgdXNlci1zY2FsYWJsZT1ubywgdmlld3BvcnQtZml0PWNvdmVyJztcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZCh2aWV3UG9ydFRhZyk7XG59O1xuZXhwb3J0IGNvbnN0IGxvYWRJbWFnZSA9IHBhdGggPT4ge1xuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICBpbWcuc3JjID0gcGF0aDtcbiAgaW1nLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICgoaW1nLm5hdHVyYWxXaWR0aCAqIGltZy5uYXR1cmFsSGVpZ2h0KSA+IDY0MDAwMCkge1xuICAgICAgICByZWplY3QoJ1RvbyBsYXJnZSByZWZmZXJlbmNlIGltYWdlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltZy5uYXR1cmFsV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcubmF0dXJhbEhlaWdodDtcblxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICAgIGxldCB7d2lkdGgsIGhlaWdodCwgZGF0YX0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgLy8gdXJpOiB1cmksXG4gICAgICAgICAgaW1nOiB7XG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IFVVSUQgPSAoKSA9PiB7XG4gIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGQgKz0gcGVyZm9ybWFuY2Uubm93KCk7IC8vIHVzZSBoaWdoLXByZWNpc2lvbiB0aW1lciBpZiBhdmFpbGFibGVcbiAgfVxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIGxldCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuXG4gICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCkpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59O1xuXG5jb25zdCBpc1dlYlJUQ1N1cHBvcnRlZCA9ICgpID0+IHtcbiAgLy8gLS0tLS0tLS0tIERldGVjdCBpZiBzeXN0ZW0gc3VwcG9ydHMgV2ViUlRDIDEuMCBvciBXZWJSVEMgMS4xLlxuICBsZXQgaXNXZWJSVENTdXBwb3J0ZWQgPSBmYWxzZTtcblxuICBbJ1JUQ1BlZXJDb25uZWN0aW9uJywgJ3dlYmtpdFJUQ1BlZXJDb25uZWN0aW9uJywgJ21velJUQ1BlZXJDb25uZWN0aW9uJywgJ1JUQ0ljZUdhdGhlcmVyJ10uZm9yRWFjaChpdGVtID0+IHtcbiAgICBpZiAoaXNXZWJSVENTdXBwb3J0ZWQpIHJldHVybjtcbiAgICBpZiAoaXRlbSBpbiB3aW5kb3cpIGlzV2ViUlRDU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBpc1dlYlJUQ1N1cHBvcnRlZDtcbn07XG5cbmNvbnN0IGlzTW9iaWxlID0ge1xuICBBbmRyb2lkOiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpLFxuICBCbGFja0JlcnJ5OiAoKSA9PiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9CbGFja0JlcnJ5fEJCMTAvaSksXG4gIGlPUzogKCkgPT4gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC9pKSxcbiAgT3BlcmE6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL09wZXJhIE1pbmkvaSksXG4gIFdpbmRvd3M6ICgpID0+IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0lFTW9iaWxlL2kpLFxuICBhbnk6ICgpID0+IChpc01vYmlsZS5BbmRyb2lkKCkgfHwgaXNNb2JpbGUuQmxhY2tCZXJyeSgpIHx8IGlzTW9iaWxlLmlPUygpIHx8IGlzTW9iaWxlLk9wZXJhKCkgfHwgaXNNb2JpbGUuV2luZG93cygpKSxcbiAgZ2V0T3NOYW1lOiAoKSA9PiB7XG4gICAgbGV0IG9zTmFtZSA9ICdVbmtub3duIE9TJztcblxuICAgIGlmIChpc01vYmlsZS5BbmRyb2lkKCkpIG9zTmFtZSA9ICdBbmRyb2lkJztcbiAgICBpZiAoaXNNb2JpbGUuQmxhY2tCZXJyeSgpKSBvc05hbWUgPSAnQmxhY2tCZXJyeSc7XG4gICAgaWYgKGlzTW9iaWxlLmlPUygpKSBvc05hbWUgPSAnaU9TJztcbiAgICBpZiAoaXNNb2JpbGUuT3BlcmEoKSkgb3NOYW1lID0gJ09wZXJhIE1pbmknO1xuICAgIGlmIChpc01vYmlsZS5XaW5kb3dzKCkpIG9zTmFtZSA9ICdXaW5kb3dzJztcbiAgICByZXR1cm4gb3NOYW1lO1xuICB9XG59O1xuXG4vLyBodHRwczovL3d3dy53ZWJzb2NrZXQub3JnL2pzL3N0dWZmLmpzIChEZXRlY3RCcm93c2VyLmpzKVxuZXhwb3J0IGNvbnN0IGdldEJyb3dzZXJJbmZvID0gKCkgPT4ge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGxldCBpc01vYmlsZURldmljZSA9ICEhKC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QkIxMHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbml8TW9iaWxlfG1vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJykpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgbGV0IGlzRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpICE9PSAtMSAmJiAoISFuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYiB8fCAhIW5hdmlnYXRvci5tc1NhdmVCbG9iKTtcblxuICBsZXQgaXNPcGVyYSA9ICEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwO1xuICBsZXQgaXNGaXJlZm94ID0gdHlwZW9mIHdpbmRvdy5JbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIGxldCBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGxldCBpc0Nocm9tZSA9ICEhd2luZG93LmNocm9tZSAmJiAhaXNPcGVyYTtcbiAgbGV0IGlzSUUgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmICFpc0VkZ2U7XG5cbiAgbGV0IG5WZXIgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBsZXQgbkFndCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGxldCBicm93c2VyTmFtZSA9IG5hdmlnYXRvci5hcHBOYW1lO1xuICBsZXQgZnVsbFZlcnNpb24gPSAnJyArIHBhcnNlRmxvYXQobmF2aWdhdG9yLmFwcFZlcnNpb24pO1xuICBsZXQgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobmF2aWdhdG9yLmFwcFZlcnNpb24sIDEwKTtcbiAgbGV0IG5hbWVPZmZzZXQsIHZlck9mZnNldCwgaXg7XG5cbiAgLy8gYm90aCBhbmQgc2FmcmkgYW5kIGNocm9tZSBoYXMgc2FtZSB1c2VyQWdlbnRcbiAgaWYgKGlzU2FmYXJpICYmICFpc0Nocm9tZSAmJiBuQWd0LmluZGV4T2YoJ0NyaU9TJykgIT09IC0xKSB7XG4gICAgaXNTYWZhcmkgPSBmYWxzZTtcbiAgICBpc0Nocm9tZSA9IHRydWU7XG4gIH1cblxuICAvLyBJbiBPcGVyYSwgdGhlIHRydWUgdmVyc2lvbiBpcyBhZnRlciAnT3BlcmEnIG9yIGFmdGVyICdWZXJzaW9uJ1xuICBpZiAoaXNPcGVyYSkge1xuICAgIGJyb3dzZXJOYW1lID0gJ09wZXJhJztcbiAgICB0cnkge1xuICAgICAgZnVsbFZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50LnNwbGl0KCdPUFIvJylbMV0uc3BsaXQoJyAnKVswXTtcbiAgICAgIG1ham9yVmVyc2lvbiA9IGZ1bGxWZXJzaW9uLnNwbGl0KCcuJylbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZnVsbFZlcnNpb24gPSAnMC4wLjAuMCc7XG4gICAgICBtYWpvclZlcnNpb24gPSAwO1xuICAgIH1cbiAgLy8gSW4gTVNJRSB2ZXJzaW9uIDw9MTAsIHRoZSB0cnVlIHZlcnNpb24gaXMgYWZ0ZXIgJ01TSUUnIGluIHVzZXJBZ2VudCAvLyBJbiBJRSAxMSwgbG9vayBmb3IgdGhlIHN0cmluZyBhZnRlciAncnY6J1xuICB9IGVsc2UgaWYgKGlzSUUpIHtcbiAgICB2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ3J2OicpO1xuICAgIGlmICh2ZXJPZmZzZXQgPiAwKSB7IC8vIElFIDExXG4gICAgICBmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDMpO1xuICAgIH0gZWxzZSB7IC8vIElFIDEwIG9yIGVhcmxpZXJcbiAgICAgIHZlck9mZnNldCA9IG5BZ3QuaW5kZXhPZignTVNJRScpO1xuICAgICAgZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyA1KTtcbiAgICB9XG4gICAgYnJvd3Nlck5hbWUgPSAnSUUnO1xuICB9IGVsc2UgaWYgKGlzQ2hyb21lKSB7IC8vIEluIENocm9tZSwgdGhlIHRydWUgdmVyc2lvbiBpcyBhZnRlciAnQ2hyb21lJ1xuICAgIHZlck9mZnNldCA9IG5BZ3QuaW5kZXhPZignQ2hyb21lJyk7XG4gICAgYnJvd3Nlck5hbWUgPSAnQ2hyb21lJztcbiAgICBmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDcpO1xuICB9IGVsc2UgaWYgKGlzU2FmYXJpKSB7IC8vIEluIFNhZmFyaSwgdGhlIHRydWUgdmVyc2lvbiBpcyBhZnRlciAnU2FmYXJpJyBvciBhZnRlciAnVmVyc2lvbidcbiAgICB2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ1NhZmFyaScpO1xuXG4gICAgYnJvd3Nlck5hbWUgPSAnU2FmYXJpJztcbiAgICBmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDcpO1xuXG4gICAgaWYgKCh2ZXJPZmZzZXQgPSBuQWd0LmluZGV4T2YoJ1ZlcnNpb24nKSkgIT09IC0xKSB7XG4gICAgICBmdWxsVmVyc2lvbiA9IG5BZ3Quc3Vic3RyaW5nKHZlck9mZnNldCArIDgpO1xuICAgIH1cblxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1ZlcnNpb24vJykgIT09IC0xKSB7XG4gICAgICBmdWxsVmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQuc3BsaXQoJ1ZlcnNpb24vJylbMV0uc3BsaXQoJyAnKVswXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGaXJlZm94KSB7IC8vIEluIEZpcmVmb3gsIHRoZSB0cnVlIHZlcnNpb24gaXMgYWZ0ZXIgJ0ZpcmVmb3gnXG4gICAgdmVyT2Zmc2V0ID0gbkFndC5pbmRleE9mKCdGaXJlZm94Jyk7XG4gICAgYnJvd3Nlck5hbWUgPSAnRmlyZWZveCc7XG4gICAgZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyA4KTtcbiAgLy8gSW4gbW9zdCBvdGhlciBicm93c2VycywgJ25hbWUvdmVyc2lvbicgaXMgYXQgdGhlIGVuZCBvZiB1c2VyQWdlbnRcbiAgfSBlbHNlIGlmICgobmFtZU9mZnNldCA9IG5BZ3QubGFzdEluZGV4T2YoJyAnKSArIDEpIDwgKHZlck9mZnNldCA9IG5BZ3QubGFzdEluZGV4T2YoJy8nKSkpIHtcbiAgICBicm93c2VyTmFtZSA9IG5BZ3Quc3Vic3RyaW5nKG5hbWVPZmZzZXQsIHZlck9mZnNldCk7XG4gICAgZnVsbFZlcnNpb24gPSBuQWd0LnN1YnN0cmluZyh2ZXJPZmZzZXQgKyAxKTtcblxuICAgIGlmIChicm93c2VyTmFtZS50b0xvd2VyQ2FzZSgpID09PSBicm93c2VyTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBicm93c2VyTmFtZSA9IG5hdmlnYXRvci5hcHBOYW1lO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0VkZ2UpIHtcbiAgICBicm93c2VyTmFtZSA9ICdFZGdlJztcbiAgICBmdWxsVmVyc2lvbiA9IG5hdmlnYXRvci51c2VyQWdlbnQuc3BsaXQoJ0VkZ2UvJylbMV07XG4gICAgLy8gZnVsbFZlcnNpb24gPSBwYXJzZUludChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLihcXGQrKSQvKVsyXSwgMTApLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyB0cmltIHRoZSBmdWxsVmVyc2lvbiBzdHJpbmcgYXQgc2VtaWNvbG9uL3NwYWNlL2JyYWNrZXQgaWYgcHJlc2VudFxuICBpZiAoKGl4ID0gZnVsbFZlcnNpb24uc2VhcmNoKC9bOyBcXCldLykpICE9PSAtMSkge1xuICAgIGZ1bGxWZXJzaW9uID0gZnVsbFZlcnNpb24uc3Vic3RyaW5nKDAsIGl4KTtcbiAgfVxuXG4gIG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KCcnICsgZnVsbFZlcnNpb24sIDEwKTtcblxuICBpZiAoaXNOYU4obWFqb3JWZXJzaW9uKSkge1xuICAgIGZ1bGxWZXJzaW9uID0gJycgKyBwYXJzZUZsb2F0KG5hdmlnYXRvci5hcHBWZXJzaW9uKTtcbiAgICBtYWpvclZlcnNpb24gPSBwYXJzZUludChuYXZpZ2F0b3IuYXBwVmVyc2lvbiwgMTApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAnZnVsbFZlcnNpb24nOiBmdWxsVmVyc2lvbixcbiAgICAndmVyc2lvbic6IG1ham9yVmVyc2lvbixcbiAgICAnbmFtZSc6IGJyb3dzZXJOYW1lLFxuICAgICdpc1ByaXZhdGVCcm93c2luZyc6IGZhbHNlLFxuICAgICdpc01vYmlsZURldmljZSc6IGlzTW9iaWxlRGV2aWNlLFxuICAgICdpc1dlYlJUQ1N1cHBvcnRlZCc6IGlzV2ViUlRDU3VwcG9ydGVkKCksXG4gICAgJ29zTmFtZSc6IGlzTW9iaWxlLmdldE9zTmFtZSgpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgaGFzV2JjYW0gPSAoZGV2aWNlcykgPT4ge1xuICBsZXQgaGFzV2ViY2FtID0gZmFsc2U7XG4gIGxldCBkZXZpY2VMaXN0ID0gW107XG5cbiAgZGV2aWNlcy5mb3JFYWNoKGRldmljZSA9PiB7XG4gICAgaWYgKGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgIGhhc1dlYmNhbSA9IHRydWU7XG4gICAgICBkZXZpY2VMaXN0LnB1c2goZGV2aWNlLmRldmljZUlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHJldHVybiB7aGFzV2ViY2FtOiBoYXNXZWJjYW0sIGRldmljZUxpc3Q6IGRldmljZUxpc3R9O1xuICByZXR1cm4gaGFzV2ViY2FtO1xuXG4gIC8vIGRldmljZXMuZm9yRWFjaCgoX2RldmljZSkgPT4ge1xuICAvLyAgIGNvbnN0IGRldmljZSA9IHt9O1xuICAvL1xuICAvLyAgIGZvciAoY29uc3QgZCBpbiBfZGV2aWNlKSB7XG4gIC8vICAgICB0cnkge1xuICAvLyAgICAgICBpZiAodHlwZW9mIF9kZXZpY2VbZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgICAgICBkZXZpY2VbZF0gPSBfZGV2aWNlW2RdO1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9IGNhdGNoIChlKSB7fVxuICAvLyAgIH1cbiAgLy9cbiAgLy9cbiAgLy8gICAvLyBpZiBpdCBpcyBNZWRpYVN0cmVhbVRyYWNrLmdldFNvdXJjZXNcbiAgLy8gICBpZiAoZGV2aWNlLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgLy8gICAgIGRldmljZS5raW5kID0gJ2F1ZGlvaW5wdXQnO1xuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoZGV2aWNlLmtpbmQgPT09ICd2aWRlbycpIHtcbiAgLy8gICAgIGRldmljZS5raW5kID0gJ3ZpZGVvaW5wdXQnO1xuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoIWRldmljZS5kZXZpY2VJZCkge1xuICAvLyAgICAgZGV2aWNlLmRldmljZUlkID0gZGV2aWNlLmlkO1xuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoIWRldmljZS5pZCkge1xuICAvLyAgICAgZGV2aWNlLmlkID0gZGV2aWNlLmRldmljZUlkO1xuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoIWRldmljZS5sYWJlbCkge1xuICAvLyAgICAgZGV2aWNlLmlzQ3VzdG9tTGFiZWwgPSB0cnVlO1xuICAvL1xuICAvLyAgICAgaWYgKGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgLy8gICAgICAgZGV2aWNlLmxhYmVsID0gJ0NhbWVyYSAnICsgKHZpZGVvSW5wdXREZXZpY2VzLmxlbmd0aCArIDEpO1xuICAvLyAgICAgfSBlbHNlIGlmIChkZXZpY2Uua2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gIC8vICAgICAgIGRldmljZS5sYWJlbCA9ICdNaWNyb3Bob25lICcgKyAoYXVkaW9JbnB1dERldmljZXMubGVuZ3RoICsgMSk7XG4gIC8vICAgICB9IGVsc2UgaWYgKGRldmljZS5raW5kID09PSAnYXVkaW9vdXRwdXQnKSB7XG4gIC8vICAgICAgIGRldmljZS5sYWJlbCA9ICdTcGVha2VyICcgKyAoYXVkaW9PdXRwdXREZXZpY2VzLmxlbmd0aCArIDEpO1xuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgZGV2aWNlLmxhYmVsID0gJ1BsZWFzZSBpbnZva2UgZ2V0VXNlck1lZGlhIG9uY2UuJztcbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gICAgIGlmICh0eXBlb2YgRGV0ZWN0UlRDICE9PSAndW5kZWZpbmVkJyAmJiBEZXRlY3RSVEMuYnJvd3Nlci5pc0Nocm9tZSAmJiBEZXRlY3RSVEMuYnJvd3Nlci52ZXJzaW9uID49IDQ2ICYmICEvXihodHRwczp8Y2hyb21lLWV4dGVuc2lvbjopJC9nLnRlc3QobG9jYXRpb24ucHJvdG9jb2wgfHwgJycpKSB7XG4gIC8vICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb21haW4gPT09ICdzdHJpbmcnICYmIGRvY3VtZW50LmRvbWFpbi5zZWFyY2ggJiYgZG9jdW1lbnQuZG9tYWluLnNlYXJjaCgvbG9jYWxob3N0fDEyNy4wLi9nKSA9PT0gLTEpIHtcbiAgLy8gICAgICAgICBkZXZpY2UubGFiZWwgPSAnSFRUUHMgaXMgcmVxdWlyZWQgdG8gZ2V0IGxhYmVsIG9mIHRoaXMgJyArIGRldmljZS5raW5kICsgJyBkZXZpY2UuJztcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH0gZWxzZSB7XG4gIC8vICAgICAvLyBGaXJlZm94IG9uIEFuZHJvaWQgc3RpbGwgcmV0dXJucyBlbXB0eSBsYWJlbFxuICAvLyAgICAgaWYgKGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcgJiYgIWlzV2Vic2l0ZUhhc1dlYmNhbVBlcm1pc3Npb25zKSB7XG4gIC8vICAgICAgIGlzV2Vic2l0ZUhhc1dlYmNhbVBlcm1pc3Npb25zID0gdHJ1ZTtcbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gICAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ2F1ZGlvaW5wdXQnICYmICFpc1dlYnNpdGVIYXNNaWNyb3Bob25lUGVybWlzc2lvbnMpIHtcbiAgLy8gICAgICAgaXNXZWJzaXRlSGFzTWljcm9waG9uZVBlcm1pc3Npb25zID0gdHJ1ZTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgaWYgKGRldmljZS5raW5kID09PSAnYXVkaW9pbnB1dCcpIHtcbiAgLy8gICAgIGhhc01pY3JvcGhvbmUgPSB0cnVlO1xuICAvL1xuICAvLyAgICAgaWYgKGF1ZGlvSW5wdXREZXZpY2VzLmluZGV4T2YoZGV2aWNlKSA9PT0gLTEpIHtcbiAgLy8gICAgICAgYXVkaW9JbnB1dERldmljZXMucHVzaChkZXZpY2UpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoZGV2aWNlLmtpbmQgPT09ICdhdWRpb291dHB1dCcpIHtcbiAgLy8gICAgIGhhc1NwZWFrZXJzID0gdHJ1ZTtcbiAgLy9cbiAgLy8gICAgIGlmIChhdWRpb091dHB1dERldmljZXMuaW5kZXhPZihkZXZpY2UpID09PSAtMSkge1xuICAvLyAgICAgICBhdWRpb091dHB1dERldmljZXMucHVzaChkZXZpY2UpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy9cbiAgLy8gICBpZiAoZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAvLyAgICAgaGFzV2ViY2FtID0gdHJ1ZTtcbiAgLy9cbiAgLy8gICAgIGlmICh2aWRlb0lucHV0RGV2aWNlcy5pbmRleE9mKGRldmljZSkgPT09IC0xKSB7XG4gIC8vICAgICAgIHZpZGVvSW5wdXREZXZpY2VzLnB1c2goZGV2aWNlKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgLy8gdGhlcmUgaXMgbm8gJ3ZpZGVvb3VwdXQnIGluIHRoZSBzcGVjLlxuICAvLyAgIE1lZGlhRGV2aWNlcy5wdXNoKGRldmljZSk7XG4gIC8vXG4gIC8vICAgYWxyZWFkeVVzZWREZXZpY2VzW2RldmljZS5kZXZpY2VJZCArIGRldmljZS5sYWJlbCArIGRldmljZS5raW5kXSA9IGRldmljZTtcbiAgLy8gfSk7XG59O1xuXG5leHBvcnQgY29uc3QgY2h1bmsgPSAoYXJyLCBjaHVua1NpemUgPSAxLCBjYWNoZSA9IFtdKSA9PiB7XG4gIGNvbnN0IHRtcCA9IFsuLi5hcnJdO1xuXG4gIGlmIChjaHVua1NpemUgPD0gMCkgcmV0dXJuIGNhY2hlO1xuICB3aGlsZSAodG1wLmxlbmd0aCkgY2FjaGUucHVzaCh0bXAuc3BsaWNlKDAsIGNodW5rU2l6ZSkpO1xuICByZXR1cm4gY2FjaGU7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGFyZSBlcXVhbCB0byBgZWxlbWVudGAuIFRoZSBgYXJyYXlgXG4gKiBwYXJhbWV0ZXIgaXMgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBleHBvcnQgZnVuY3Rpb24gY2FsbC5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQG1ldGhvZCByZW1vdmVBcnJheUl0ZW1cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcGFyYW0geyp9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGV4YW1wbGVcbiAqIGxldCBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAqIHJlbW92ZUFycmF5SXRlbShhcnJheSwgMSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXkpO1xuICogLy8gPT4gWzIsIDMsIDRdXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBcnJheUl0ZW0gPSAoYXJyYXksIGVsZW1lbnQpID0+IHtcbiAgbGV0IGlkeCA9IGFycmF5LmluZGV4T2YoZWxlbWVudCk7XG5cbiAgaWYgKGlkeCA+IC0xKSBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc051bGwgPSAodmFsdWUpID0+IHZhbHVlID09PSBudWxsO1xuZXhwb3J0IGNvbnN0IGlzTmlsID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuLy9cbi8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3B5VGV4dCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbiAoKSB7XG4vLyAgIChmdW5jdGlvbih0ZXh0KSB7XG4vLyAgICAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0QXJlYScpO1xuLy8gICAgIGxldCByYW5nZSxcbi8vICAgICAgIHNlbGVjdGlvbjtcbi8vXG4vLyAgICAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xuLy8gICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpO1xuLy8gICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9pcGFkfGlwaG9uZS9pKSkge1xuLy8gICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuLy8gICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHRBcmVhKTtcbi8vICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbi8vICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbi8vICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4vLyAgICAgICB0ZXh0QXJlYS5zZXRTZWxlY3Rpb25SYW5nZSgwLCA5OTk5OTkpO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICB0ZXh0QXJlYS5zZWxlY3QoKTtcbi8vICAgICB9XG4vL1xuLy8gICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4vLyAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XG4vLyAgIH0pKGUudGFyZ2V0LnRleHRDb250ZW50KTtcbi8vIH0pXG5cbi8qXG5mdW5jdGlvbiBjbGlwYm9hcmQodGV4dCkge1xuICBjb25zdCB0ZXh0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRBcmVhJyk7XG4gIGxldCByYW5nZSxcbiAgICBzZWxlY3Rpb247XG5cbiAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKTtcbiAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lwYWR8aXBob25lL2kpKSB7XG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyh0ZXh0QXJlYSk7XG4gICAgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIHRleHRBcmVhLnNldFNlbGVjdGlvblJhbmdlKDAsIDk5OTk5OSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dEFyZWEuc2VsZWN0KCk7XG4gIH1cblxuICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKTtcbn07Ki9cbiIsImltcG9ydCBPYmplY3QzRCBmcm9tICcuL09iamVjdDNEJztcbmltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi9tYXRoL1ZlY3RvcjMnO1xuXG5jb25zdCBfdHlwZSA9ICdDYW1lcmEnO1xuXG4vKipcbiAqIFVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGlzIG9yIGRlcml2ZWQgY2xhc3NlcyBhcmUgY2FtZXJhcy4gWW91IHNob3VsZCBub3RcbiAqIGNoYW5nZSB0aGlzLCBhcyBpdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIHJlbmRlcmVyIGZvciBvcHRpbWlzYXRpb24uXG4gKiBAbWVtYmVyIHtib29sZWFufSBpc0NhbWVyYVxuICogQG1lbWJlcm9mIENhbWVyYS5wcm90b3R5cGVcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuY29uc3QgX2lzQ2FtZXJhID0gdHJ1ZTtcblxuXG4vKipcbiAqIEBpZ25vcmVcbiAqIEBjbGFzcyBDYW1lcmFcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNhbWVyYXMuIFRoaXMgY2xhc3Mgc2hvdWxkIGFsd2F5cyBiZSBpbmhlcml0ZWQgd2hlblxuICogeW91IGJ1aWxkIGEgbmV3IGNhbWVyYS4gTm90ZSB0aGF0IHRoaXMgY2xhc3MgaXMgbm90IGludGVuZGVkIHRvIGJlIGNhbGxlZFxuICogZGlyZWN0bHk7IFlvdSBwcm9iYWJseSB3YW50IGEge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhfSBvclxuICoge0BsaW5rIE9ydGhvZ3JhcGhpY0NhbWVyYX0gaW5zdGVhZC5cbiAqIEBleHRlbmRzIE9iamVjdDNEXG4gKi9cbmNsYXNzIENhbWVyYSBleHRlbmRzIE9iamVjdDNEIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfdHlwZTtcbiAgfVxuXG4gIGdldCBpc0NhbWVyYSgpIHtcbiAgICByZXR1cm4gX2lzQ2FtZXJhO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIGludmVyc2Ugb2Yge0BsaW5rIE9iamVjdDNEI21hdHJpeFdvcmxkfS5cbiAgICoge0BsaW5rIE9iamVjdDNEI21hdHJpeFdvcmxkfSBjb250YWlucyB0aGUge0BsaW5rIE1hdHJpeDR9IHdoaWNoIGhhcyB0aGVcbiAgICogd29ybGQgdHJhbnNmb3JtIG9mIHRoZSB7QGxpbmsgQ2FtZXJhfS5cbiAgICogQG1lbWJlciB7TWF0cml4NH0gbWF0cml4V29ybGRJbnZlcnNlXG4gICAqIEBtZW1iZXJvZiBDYW1lcmEjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgLy8gZ2V0IG1hdHJpeFdvcmxkSW52ZXJzZSgpIHtcbiAgLy8gICByZXR1cm4gbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIG1hdHJpeCB3aGljaCBjb250YWlucyB0aGUgcHJvamVjdGlvbi5cbiAgICogQG1lbWJlciB7TWF0cml4NH0gcHJvamVjdGlvbk1hdHJpeFxuICAgKiBAbWVtYmVyb2YgQ2FtZXJhI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIC8vIGdldCBwcm9qZWN0aW9uTWF0cml4KCkge1xuICAvLyAgIHJldHVybiB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gIC8vIH1cbiAgLy9cbiAgLy8gc2V0IHByb2plY3Rpb25NYXRyaXgodmFsdWUpIHtcbiAgLy8gICB0aGlzLnByb2plY3Rpb25NYXRyaXggPSB2YWx1ZTtcbiAgLy8gfVxuXG4gIC8vIGdldCBwcm9qZWN0aW9uTWF0cml4SW52ZXJzZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZTtcbiAgLy8gfVxuICAvL1xuICAvLyBzZXQgcHJvamVjdGlvbk1hdHJpeEludmVyc2UodmFsdWUpIHtcbiAgLy8gICB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gdmFsdWU7XG4gIC8vIH1cblxuICBnZXQgd29ybGRaKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygwLCAwLCAtMSkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMud29ybGRRdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIHRoZSBjYW1lcmEgbG9vayBhdCB0aGUgdmVjdG9yIHBvc2l0aW9uIGluIHRoZSBnbG9iYWwgc3BhY2UgYXNcbiAgICogbG9uZyBhcyB0aGUgcGFyZW50IG9mIHRoaXMgY2FtZXJhIGlzIHRoZSBzY2VuZSBvciBhdCBwb3NpdGlvbiBgKDAsIDAsIDApYC5cbiAgICogQG1ldGhvZCBsb29rQXRcbiAgICogQG1lbWJlcm9mIENhbWVyYS5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gdGFyZ2V0IFBvc2l0aW9uIGluIDNEIHNwYWNlIGZvciB0aGUgY2FtZXJhIHRvIHBvaW50IHRvd2FyZHNcbiAgICovXG4gIGxvb2tBdCh0YXJnZXQpIHtcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIG0ubG9va0F0KHRoaXMucG9zaXRpb24sIHRhcmdldCwgdGhpcy51cCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmE7XG4iLCJpbXBvcnQge2lzTmlsfSBmcm9tICcuLi9VdGlsJztcblxuLy8gT2JzZXJ2ZXIgRGF0YSBPYmplY3RcbmNvbnN0IEV2ZW50RGF0YSA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNsYXNzIEV2ZW50RGF0YU9iamVjdCB7XG4gIHN0YXRpYyBhZGRIYW5kbGVyKHRhcmdldCwgaGFuZGxlcnMpIHtcbiAgICBFdmVudERhdGEuc2V0KHRhcmdldCwgaGFuZGxlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIEV2ZW50RGF0YS5nZXQodGFyZ2V0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRIYW5kbGVyKHRhcmdldCwgdHlwZSkge1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjdXJyZW50VGFyZ2V0ID0gRXZlbnREYXRhLmdldCh0YXJnZXQpO1xuXG4gICAgaWYgKGlzTmlsKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSBkb2VzIG5vdCBleGlzdGA7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gY3VycmVudFRhcmdldC5nZXQodHlwZSk7XG5cbiAgICByZXR1cm4gKGlzTmlsKGV2ZW50SGFuZGxlcikpID8gYCR7dGFyZ2V0fSBkb2VzIG5vdCBoYXZlICR7ZXZlbnROYW1lfWAgOiBldmVudEhhbmRsZXI7XG4gIH1cbn1cblxuLy8gRW50aXR5IERhdGEgT2JqZWN0XG5jb25zdCBFbnRpdHlEYXRhID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY2xhc3MgRW50aXR5RGF0YU9iamVjdCB7XG4gIHN0YXRpYyBhZGRFbGVtZW50KGVsZW1lbnQsIG1hcCkge1xuICAgIEVudGl0eURhdGEuc2V0KGVsZW1lbnQsIG1hcCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RWxlbWVudChlbGUpIHtcbiAgICByZXR1cm4gRW50aXR5RGF0YS5nZXQoZWxlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBbGxFbGVtZW50cygpIHtcbiAgICByZXR1cm4gRW50aXR5RGF0YTtcbiAgfVxufVxuIiwiLy8gaW1wb3J0IEV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL0V2ZW50RGlzcGF0Y2hlcic7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuLi9tYXRoL1ZlY3RvcjMnO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi4vbWF0aC9RdWF0ZXJuaW9uJztcbmltcG9ydCBFdWxlciBmcm9tICcuLi9tYXRoL0V1bGVyJztcbmltcG9ydCBNYXRyaXg0IGZyb20gJy4uL21hdGgvTWF0cml4NCc7XG5pbXBvcnQgT2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL09ic2VydmVyJztcbmltcG9ydCB7T0JKRUNUX0VWRU5UfSBmcm9tICcuLi9saWJzL01lc3NhZ2VUeXBlcyc7XG4vLyBpbXBvcnQge0VOVElUWV9FVkVOVH0gZnJvbSAnLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuLy8gaW1wb3J0IEVudGl0eUV2ZW50IGZyb20gJy4uL2V2ZW50L0VudGl0eUV2ZW50JztcblxubGV0IG9iamVjdElkID0gMDtcblxuLyoqXG4gKiBVc2VkIHRvIGNoZWNrIHdoZXRoZXIgdGhpcyBvciBkZXJpdmVkIGNsYXNzZXMgYXJlIHtAbGluayBPYmplY3QzRH1zLiBZb3VcbiAqIHNob3VsZCBub3QgY2hhbmdlIHRoaXMsIGFzIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBmb3Igb3B0aW1pc2F0aW9uLlxuICogQG1lbWJlciB7Ym9vbGVhbn0gaXNPYmplY3QzRFxuICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5jb25zdCBfaXNPYmplY3QzRCA9IHRydWU7XG5cbmNvbnN0IF90eXBlID0gJ09iamVjdDNEJztcblxuY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKFxuICBbXG4gICAgW09CSkVDVF9FVkVOVC5PQkpFQ1RfQURERUQsIG5ldyBTZXQoKV0sXG4gICAgW09CSkVDVF9FVkVOVC5PQkpFQ1RfUkVNT1ZFRCwgbmV3IFNldCgpXVxuICBdKTtcblxuLyoqXG4gKiBAY2xhc3MgT2JqZWN0M0RcbiAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuICogQGNsYXNzZGVzY1xuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbW9zdCBvYmplY3RzIGFuZCBwcm92aWRlcyBhIHNldCBvZiBwcm9wZXJ0aWVzIGFuZFxuICogbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIG9iamVjdHMgaW4gM0Qgc3BhY2UuIE5vdGUgdGhhdCB0aGlzIGNhbiBiZSB1c2VkIGZvclxuICogZ3JvdXBpbmcgb2JqZWN0cyB2aWEgdGhlIHtAbGluayBPYmplY3QzRCNhZGR9IG1ldGhvZCB3aGljaCBhZGRzIHRoZSBvYmplY3RcbiAqIGFzIGEgY2hpbGQsIGhvd2V2ZXIgaXQgaXMgYmV0dGVyIHRvIHVzZSB7QGxpbmsgR3JvdXB9IGZvciB0aGlzLlxuICovXG4vLyBjbGFzcyBPYmplY3QzRCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XG5jbGFzcyBPYmplY3QzRCBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYG9iamVjdF8ke29iamVjdElkfWAsIGhhbmRsZXJzKTtcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbnVtYmVyIGZvciB0aGlzIG9iamVjdCBpbnN0YW5jZS5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGlkXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIC8vIHRoaXMuaWQgPSBvYmplY3RJZDtcblxuICAgIC8vIFRPRE8gQGRlZmF1bHRcbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0J3MgbG9jYWwgcG9zaXRpb24uXG4gICAgICogQG1lbWJlciB7VmVjdG9yM30gcG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgKDAsIDAsIDApXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKDAsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0J3MgbG9jYWwgcm90YXRpb24gYXMgYSB7QGxpbmsgUXVhdGVybmlvbn0uXG4gICAgICogQG1lbWJlciB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICAgKi9cbiAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCdzIGxvY2FsIHNjYWxlLlxuICAgICAqIEBtZW1iZXIge1ZlY3RvcjN9IHNjYWxlXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEBkZWZhdWx0ICgxLCAxLCAxKVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUge0BsaW5rIE9iamVjdDNEI2xvb2tBdH0gbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG9cbiAgICAgKiBkZXRlcm1pbmUgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSByZXN1bHQuXG4gICAgICogQG1lbWJlciB7VmVjdG9yM30gdXBcbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgKDAsIDEsIDApXG4gICAgICovXG4gICAgdGhpcy51cCA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGdldHMgcmVuZGVyZWQgaWYgYHRydWVgLlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHZpc2libGVcbiAgICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy50cmFjayA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT2JqZWN0J3MgcGFyZW50IGluIHRoZVxuICAgICAqIFtzY2VuZSBncmFwaF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2NlbmVfZ3JhcGgpLlxuICAgICAqIEBtZW1iZXIge09iamVjdDNEfG51bGx9IHBhcmVudFxuICAgICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgd2l0aCBvYmplY3QncyBjaGlsZHJlbi4gU2VlIHtAbGluayBHcm91cH0gZm9yIGluZm8gb24gbWFudWFsbHlcbiAgICAgKiBncm91cGluZyBvYmplY3RzLlxuICAgICAqIEBtZW1iZXIge09iamVjdDNEW119IGNoaWxkcmVuXG4gICAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIC8vIHRoaXMucm90YXRpb24gPSBuZXcgRXVsZXIoKTtcblxuICAgIC8vIHRoaXMuaWQgPSBvYmplY3RJZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkJywge1xuICAgICAgdmFsdWU6IGBvYmplY3RfJHtvYmplY3RJZH1gXG4gICAgfSk7XG4gICAgb2JqZWN0SWQrKztcblxuICB9XG5cbiAgLy8gZ2V0IGlkKCkge1xuICAvLyAgIHJldHVybiBvYmplY3RJZDtcbiAgLy8gfTtcbiAgLy8gZ2V0IHBhcmVudCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIC8vIH07XG4gIC8vXG4gIC8vIHNldCBwYXJlbnQodmFsdWUpIHtcbiAgLy8gICB0aGlzLnBhcmVudCA9IHZhbHVlO1xuICAvLyB9XG4gIC8vXG4gIC8vIGdldCBjaGlsZHJlbigpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgLy8gfTtcblxuICAvLyBnZXQgcG9zaXRpb24oKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIC8vIH07XG4gIC8vIGdldCBxdWF0ZXJuaW9uKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnF1YXRlcm5pb247XG4gIC8vIH07XG4gIC8vIGdldCBzY2FsZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgLy8gfTtcbiAgLy8gZ2V0IHVwKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnVwO1xuICAvLyB9O1xuICAvLyBnZXQgdmlzaWJsZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAvLyB9O1xuICAvLyBnZXQgdHJhY2soKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gIC8vIH07XG4gIC8vXG4gIC8vIHNldCB0cmFjayh2YWx1ZSkge1xuICAvLyAgIHRoaXMudHJhY2sgPSB2YWx1ZTtcbiAgLy8gfVxuICBnZXQgaXNPYmplY3QzRCgpIHtcbiAgICByZXR1cm4gX2lzT2JqZWN0M0Q7XG4gIH07XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZCBzcGFjZS5cbiAgICogQG1lbWJlciB7VmVjdG9yM30gd29ybGRQb3NpdGlvblxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdHJhbnNsYXRlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHpcbiAgICovXG4gIHRyYW5zbGF0ZSh4LCB5LCB6KSB7XG4gICAgY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICBjb25zdCB5QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDEsIDApO1xuICAgIGNvbnN0IHpBeGlzID0gbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG4gICAgeEF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgeUF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgekF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgdGhpcy5wb3NpdGlvbi5hZGQoeEF4aXMubXVsdGlwbHlTY2FsYXIoeCkpO1xuICAgIHRoaXMucG9zaXRpb24uYWRkKHlBeGlzLm11bHRpcGx5U2NhbGFyKHkpKTtcbiAgICB0aGlzLnBvc2l0aW9uLmFkZCh6QXhpcy5tdWx0aXBseVNjYWxhcih6KSk7XG4gIH1cblxuICB0cmFuc2xhdGVYKHZhbHVlKSB7XG4gICAgY29uc3QgeEF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICB4QXhpcy5hcHBseVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICB0aGlzLnBvc2l0aW9uLmFkZCh4QXhpcy5tdWx0aXBseVNjYWxhcih2YWx1ZSkpO1xuICB9XG5cbiAgdHJhbnNsYXRlWSh2YWx1ZSkge1xuICAgIGNvbnN0IHlBeGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgeUF4aXMuYXBwbHlRdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgdGhpcy5wb3NpdGlvbi5hZGQoeUF4aXMubXVsdGlwbHlTY2FsYXIodmFsdWUpKTtcbiAgfVxuXG4gIHRyYW5zbGF0ZVoodmFsdWUpIHtcbiAgICBjb25zdCB6QXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuICAgIHpBeGlzLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHRoaXMucG9zaXRpb24uYWRkKHpBeGlzLm11bHRpcGx5U2NhbGFyKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgcm90YXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFdWxlcigpLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cblxuICBzZXQgcm90YXRpb24ocm90YXRpb24pIHtcbiAgICBpZiAocm90YXRpb24uaXNFdWxlcikge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlcihyb3RhdGlvbik7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvbi5pc1F1YXRlcm5pb24pIHtcbiAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KHJvdGF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uLmlzTWF0cml4NCkge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21NYXRyaXgocm90YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JvdGF0aW9uIG11c3QgYmUgb25lIG9mIEV1bGVyLCBRdWF0ZXJuaW9uIG9yIE1hdHJpeDQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXVsZXIgYW5nbGVzIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZFxuICAgKiBzcGFjZS5cbiAgICogQG1lbWJlciB7RXVsZXJ9IHdvcmxkUm90YXRpb25cbiAgICogQG1lbWJlcm9mIE9iamVjdDNEI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCB3b3JsZFJvdGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbih0aGlzLndvcmxkUXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiB3b3JsZFxuICAgKiBzcGFjZS5cbiAgICogQG1lbWJlciB7UXVhdGVybmlvbn0gd29ybGRRdWF0ZXJuaW9uXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgd29ybGRRdWF0ZXJuaW9uKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UobmV3IFZlY3RvcjMoKSwgcmVzdWx0LCBuZXcgVmVjdG9yMygpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0IHdvcmxkWCgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMoMSwgMCwgMCkuYXBwbHlRdWF0ZXJuaW9uKHRoaXMud29ybGRRdWF0ZXJuaW9uKTtcbiAgfVxuXG4gIGdldCB3b3JsZFkoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKDAsIDEsIDApLmFwcGx5UXVhdGVybmlvbih0aGlzLndvcmxkUXVhdGVybmlvbik7XG4gIH1cblxuICBnZXQgd29ybGRaKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMygwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24odGhpcy53b3JsZFF1YXRlcm5pb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZXMgdGhlIG9iamVjdCBhcm91bmQgeCBheGlzIGluIGxvY2FsIHNwYWNlLlxuICAgKiBAbWV0aG9kIHJvdGF0ZVhcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSBpbiByYWRpYW5zLlxuICAgKi9cbiAgcm90YXRlWChhbmdsZSkge1xuICAgIGNvbnN0IGF4aXMgPSBuZXcgVmVjdG9yMygxLCAwLCAwKTtcbiAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLm11bHRpcGx5KHEpO1xuICAgIHRoaXMucm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24odGhpcy5xdWF0ZXJuaW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVzIHRoZSBvYmplY3QgYXJvdW5kIHkgYXhpcyBpbiBsb2NhbCBzcGFjZS5cbiAgICogQG1ldGhvZCByb3RhdGVZXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgaW4gcmFkaWFucy5cbiAgICovXG4gIHJvdGF0ZVkoYW5nbGUpIHtcbiAgICBjb25zdCBheGlzID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgY29uc3QgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBxLnNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpO1xuICAgIHRoaXMucXVhdGVybmlvbi5tdWx0aXBseShxKTtcbiAgICB0aGlzLnJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlcyB0aGUgb2JqZWN0IGFyb3VuZCB6IGF4aXMgaW4gbG9jYWwgc3BhY2UuXG4gICAqIEBtZXRob2Qgcm90YXRlWlxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGluIHJhZGlhbnMuXG4gICAqL1xuICByb3RhdGVaKGFuZ2xlKSB7XG4gICAgY29uc3QgYXhpcyA9IG5ldyBWZWN0b3IzKDAsIDAsIDEpO1xuICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgcS5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKTtcbiAgICB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkocSk7XG4gICAgdGhpcy5yb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdGhlIHNjYWxpbmcgZmFjdG9ycyBhcHBsaWVkIHRvIHRoZSBvYmplY3QgZm9yIGVhY2ggYXhpc1xuICAgKiBpbiB3b3JsZCBzcGFjZS5cbiAgICogQG1lbWJlciB7VmVjdG9yM30gd29ybGRTY2FsZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHdvcmxkU2NhbGUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShuZXcgVmVjdG9yMygpLCBuZXcgUXVhdGVybmlvbigpLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvY2FsIHRyYW5zZm9ybSBtYXRyaXguXG4gICAqIEBtZW1iZXIge01hdHJpeDR9IG1hdHJpeFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgLy8gZ2V0IG1hdHJpeCgpIHtcbiAgLy8gICByZXR1cm4gbmV3IE1hdHJpeDQoKS5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG4gIC8vIH1cblxuICAvKipcbiAgICogVGhlIGdsb2JhbCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdC4gSWYgdGhlIG9iamVjdCBoYXMgbm8gcGFyZW50LCB0aGVuIGl0J3NcbiAgICogaWRlbnRpY2FsIHRvIHRoZSBsb2NhbCB0cmFuc2Zvcm0ge0BsaW5rIE9iamVjdDNEI21hdHJpeH0uXG4gICAqIEBtZW1iZXIge01hdHJpeDR9IG1hdHJpeFdvcmxkXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRCNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICAvLyBnZXQgbWF0cml4V29ybGQoKSB7XG4gIC8vICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gIC8vICAgY29uc3QgbWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gIC8vXG4gIC8vICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAvLyAgICAgcmV0dXJuIG1hdHJpeDtcbiAgLy8gICB9XG4gIC8vXG4gIC8vICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkubXVsdGlwbHlNYXRyaWNlcyhwYXJlbnQubWF0cml4V29ybGQsIG1hdHJpeCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHZlY3RvciBmcm9tIGxvY2FsIHNwYWNlIHRvIHdvcmxkIHNwYWNlLlxuICAgKiBAbWV0aG9kIGxvY2FsVG9Xb3JsZFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHZlY3RvciBBIHZlY3RvciByZXByZXNlbnRpbmcgYSBwb3NpdGlvbiBpbiBsb2NhbCAob2JqZWN0KSBzcGFjZS5cbiAgICogQHJldHVybiB7VmVjdG9yM31cbiAgICovXG4gIGxvY2FsVG9Xb3JsZCh2ZWN0b3IpIHtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB2ZWN0b3IgZnJvbSB3b3JsZCBzcGFjZSB0byBsb2NhbCBzcGFjZS5cbiAgICogQG1ldGhvZCB3b3JsZFRvTG9jYWxcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSB2ZWN0b3IgQSB3b3JsZCB2ZWN0b3IuXG4gICAqIEByZXR1cm4ge1ZlY3RvcjN9XG4gICAqL1xuICB3b3JsZFRvTG9jYWwodmVjdG9yKSB7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQobmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMubWF0cml4V29ybGQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGBvYmplY3RgIGFzIGNoaWxkIG9mIHRoaXMgb2JqZWN0LiBBbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG9iamVjdHMgbWF5XG4gICAqIGJlIGFkZGVkLiBTZWUge0BsaW5rIEdyb3VwfSBmb3IgaW5mbyBvbiBtYW51YWxseSBncm91cGluZyBvYmplY3RzLlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0M0R9IG9iamVjdFxuICAgKi9cbiAgYWRkKG9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0ID09PSB0aGlzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMZXRzZWUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuXFwndCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIGl0c2VsZi4nLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdCAmJiBvYmplY3QuaXNPYmplY3QzRCkge1xuICAgICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgb2JqZWN0Lm5vdGlmeShPQkpFQ1RfRVZFTlQuT0JKRUNUX0FEREVEKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMZXRzZWUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIExldHNlZS5PYmplY3QzRC4nLCBvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIGlmIChvYmplY3QgJiYgb2JqZWN0ICE9PSB0aGlzICYmIG9iamVjdC5pc09iamVjdDNEKSB7XG4gICAgLy8gICBpZiAob2JqZWN0LnBhcmVudCkge1xuICAgIC8vICAgICBvYmplY3QucGFyZW50LnJlbW92ZShvYmplY3QpO1xuICAgIC8vICAgfVxuICAgIC8vXG4gICAgLy8gICBpZiAoIXRoaXMuaXNTY2VuZSkge1xuICAgIC8vICAgICBvYmplY3QudHJhY2sgPSB0aGlzLnRyYWNrO1xuICAgIC8vICAgfVxuICAgIC8vXG4gICAgLy8gICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAvLyAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KHt0eXBlOiAnYWRkZWQnfSk7XG4gICAgLy9cbiAgICAvLyAgIC8vIHRoaXMuY2hpbGRyZW4gPSBbXG4gICAgLy8gICAvLyAgIC4uLnRoaXMuY2hpbGRyZW4sXG4gICAgLy8gICAvLyAgIG9iamVjdCxcbiAgICAvLyAgIC8vIF07XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAvLyAgIHRoaXMuYWRkKG9iamVjdFtpXSk7XG4gICAgLy8gfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9iamVjdGAgYXMgY2hpbGQgb2YgdGhpcyBvYmplY3QuIEFuIGFyYml0cmFyeSBudW1iZXIgb2Ygb2JqZWN0c1xuICAgKiBtYXkgYmUgZXJlbW92ZWQuXG4gICAqIEBtZXRob2QgcmVtb3ZlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG9iamVjdFxuICAgKi9cbiAgcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihvYmplY3QpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICBvYmplY3Qubm90aWZ5KE9CSkVDVF9FVkVOVC5PQkpFQ1RfUkVNT1ZFRCk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvL1xuICAgIC8vXG4gICAgLy8gY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2Yob2JqZWN0KTtcbiAgICAvL1xuICAgIC8vIGlmIChpbmRleCA+IC0xKSB7XG4gICAgLy8gICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAvLyAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KHt0eXBlOiAncmVtb3ZlZCd9KTtcbiAgICAvL1xuICAgIC8vICAgZm9yIChsZXQgY2hpbGQgb2Ygb2JqZWN0LmNoaWxkcmVuKSB7XG4gICAgLy8gICBvYmplY3QucmVtb3ZlKGNoaWxkKTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyB0aGlzLmNoaWxkcmVuID0gW1xuICAgIC8vICAgLi4udGhpcy5jaGlsZHJlbi5zbGljZSgwLCBpbmRleCksXG4gICAgLy8gICAuLi50aGlzLmNoaWxkcmVuLnNsaWNlKGluZGV4ICsgMSksXG4gICAgLy8gXTtcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgLy8gICB0aGlzLnJlbW92ZShvdGhlcltpXSk7XG4gICAgLy8gfVxuICB9XG5cbiAgdXBkYXRlTWF0cml4KCkge1xuICAgIHRoaXMubWF0cml4LmNvbXBvc2UodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlKTtcbiAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQoZm9yY2UpIHtcbiAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIGlmICh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UpIHtcbiAgICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2hpbGRyZW5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2hpbGRyZW5baV0udXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVdvcmxkTWF0cml4KHVwZGF0ZVBhcmVudHMsIHVwZGF0ZUNoaWxkcmVuKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKHVwZGF0ZVBhcmVudHMgPT09IHRydWUgJiYgcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIGlmICh0aGlzLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGNoaWxkcmVuXG5cbiAgICBpZiAodXBkYXRlQ2hpbGRyZW4gPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbG9va0F0KHZlY3RvcjMpIHtcbiAgICBjb25zdCBtID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIG0ubG9va0F0KHZlY3RvcjMsIHRoaXMucG9zaXRpb24sIHRoaXMudXApO1xuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgobSk7XG4gIH1cbiAgYXBwbHlNYXRyaXgobWF0cml4KSB7XG5cbiAgICB0aGlzLm1hdHJpeC5wcmVtdWx0aXBseShtYXRyaXgpO1xuXG4gICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7XG5cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgb2JqZWN0IGFuZCBvcHRpb25hbGx5IGFsbCBkZXNjZW5kYW50cy5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFtyZWN1cnNpdmU9dHJ1ZV0gSWYgdHJ1ZSwgZGVzY2VuZGFudHMgb2YgdGhlIG9iamVjdCBhcmUgYWxzbyBjbG9uZWQuXG4gICAqIEByZXR1cm4ge09iamVjdDNEfVxuICAgKi9cbiAgY2xvbmUocmVjdXJzaXZlID0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgT2JqZWN0M0QoKS5jb3B5KHRoaXMsIHJlY3Vyc2l2ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29weSB0aGUgZ2l2ZW4gYHNvdXJjZWAgb2JqZWN0IGludG8gdGhpcyBvYmplY3QuXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBzb3VyY2VcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT10cnVlXSBJZiB0cnVlLCBkZXNjZW5kYW50cyBvZiB0aGUgb2JqZWN0IGFyZSBhbHNvIGNvcGllZC5cbiAgICovXG4gIGNvcHkoc291cmNlLCByZWN1cnNpdmUgPSB0cnVlKSB7XG4gICAgdGhpcy5wb3NpdGlvbi5jb3B5KHNvdXJjZS5wb3NpdGlvbik7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkoc291cmNlLnF1YXRlcm5pb24pO1xuICAgIHRoaXMuc2NhbGUuY29weShzb3VyY2Uuc2NhbGUpO1xuICAgIHRoaXMudXAuY29weShzb3VyY2UuY29weSk7XG4gICAgdGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cbiAgICBpZiAocmVjdXJzaXZlID09PSB0cnVlIHx8IHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlbltpXTtcblxuICAgICAgICB0aGlzLmFkZChjaGlsZC5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYGNhbGxiYWNrYCBvbiB0aGlzIG9iamVjdCBhbmQgYWxsIGRlc2NlbmRhbnRzLlxuICAgKiBAbWV0aG9kIHRyYXZlcnNlXG4gICAqIEBtZW1iZXJvZiBPYmplY3QzRC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gd2l0aCBhcyBmaXJzdCBhcmd1bWVudCBhbiB7QGxpbmsgT2JqZWN0M0R9IG9iamVjdC5cbiAgICovXG4gIHRyYXZlcnNlKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodGhpcyk7XG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC50cmF2ZXJzZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSB7QGxpbmsgT2JqZWN0M0QjdHJhdmVyc2V9LCBidXQgdGhlIGBjYWxsYmFja2Agd2lsbCBvbmx5IGJlIGV4ZWN1dGVkXG4gICAqIGZvciB2aXNpYmxlIG9iamVjdHMuIERlc2NlbmRhbnRzIG9mIGludmlzaWJsZSBvYmplY3RzIGFyZSBub3QgdHJhdmVyc2VkLlxuICAgKiBAbWV0aG9kIHRyYXZlcnNlVmlzaWJsZVxuICAgKiBAbWVtYmVyb2YgT2JqZWN0M0QucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHdpdGggYXMgZmlyc3QgYXJndW1lbnQgYW4ge0BsaW5rIE9iamVjdDNEfSBvYmplY3QuXG4gICAqL1xuICB0cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBjaGlsZC50cmF2ZXJzZVZpc2libGUoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBgY2FsbGJhY2tgIG9uIGFsbCBhbmNlc3RvcnMuXG4gICAqIEBtZXRob2QgdHJhdmVyc2VBbmNlc3RvcnNcbiAgICogQG1lbWJlcm9mIE9iamVjdDNELnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB3aXRoIGFzIGZpcnN0IGFyZ3VtZW50IGFuIHtAbGluayBPYmplY3QzRH0gb2JqZWN0LlxuICAgKi9cbiAgdHJhdmVyc2VBbmNlc3RvcnMoY2FsbGJhY2spIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKHBhcmVudCk7XG4gICAgICBwYXJlbnQudHJhdmVyc2VBbmNlc3RvcnMoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHRyYXZlcnNlUmVuZGVyYWJsZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy50cmFjaykge1xuICAgICAgY2FsbGJhY2sodGhpcyk7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2VSZW5kZXJhYmxlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaywgLi4uYXJncykge1xuICAgIHN1cGVyLnN1YnNjcmliZSh0aGlzLmlkLCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRoaXMuaWQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIG5vdGlmeSh0eXBlLCBldmVudCkge1xuICAgIGNvbnN0IGUgPSAoZXZlbnQpID8gZXZlbnQgOiB7fTtcblxuICAgIGUudGFyZ2V0ID0gdGhpcztcbiAgICBlLnR5cGUgPSB0eXBlO1xuICAgIHN1cGVyLm5vdGlmeSh0aGlzLmlkLCB0eXBlLCBlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBPYmplY3QzRDtcbiIsImltcG9ydCBDYW1lcmEgZnJvbSAnLi9DYW1lcmEnO1xuaW1wb3J0IHsgZGVnVG9SYWQsIHJhZFRvRGVnLCBERUcyUkFELCBSQUQyREVHIH0gZnJvbSAnLi4vbWF0aC9NYXRoJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQZXJzcGVjdGl2ZUNhbWVyYVZpZXdPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmdWxsV2lkdGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmdWxsSGVpZ2h0XG4gKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0WFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodFxuICovXG4vLyB0eXBlIFBlcnNwZWN0aXZlQ2FtZXJhVmlld09mZnNldCA9IHtcbi8vICAgZnVsbFdpZHRoLFxuLy8gICBmdWxsSGVpZ2h0LFxuLy8gICBvZmZzZXRYLFxuLy8gICBvZmZzZXRZLFxuLy8gICB3aWR0aCxcbi8vICAgaGVpZ2h0LFxuLy8gfTtcbi8qXG5cblxuLyEqKlxuICogQ2FtZXJhIGZydXN0dW0gdmVydGljYWwgZmllbGQgb2YgdmlldywgZnJvbSBib3R0b20gdG8gdG9wIG9mIHZpZXcsIGluXG4gKiBkZWdyZWVzLlxuICogQG1lbWJlciB7bnVtYmVyfSBmb3ZcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IDUwXG4gKiEvXG5sZXQgdGhpcy5mb3YgPSA1MDtcbi8hKipcbiAqIEdldHMgb3Igc2V0cyB0aGUgem9vbSBmYWN0b3Igb2YgdGhlIGNhbWVyYS5cbiAqIEBtZW1iZXIge251bWJlcn0gem9vbVxuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMVxuICohL1xubGV0IHRoaXMuem9vbSA9IDE7XG5cbi8hKipcbiAqIENhbWVyYSBmcnVzdHVtIG5lYXIgcGxhbmUuIFRoZSB2YWxpZCByYW5nZSBpcyBncmVhdGVyIHRoYW4gYDBgIGFuZCBsZXNzXG4gKiB0aGFuIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjZmFyfSBwbGFuZS4gTm90ZVxuICogdGhhdCwgdW5saWtlIGZvciB0aGUge0BsaW5rIE9ydGhvZ3JhcGhpY0NhbWVyYX0sIGAwYCBpcyBfbm90XyBhIHZhbGlkIHZhbHVlXG4gKiBmb3IgYSB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmF9J3MgbmVhciBwbGFuZS5cbiAqIEBtZW1iZXIge251bWJlcn0gbmVhclxuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMC4xXG4gKiEvXG5sZXQgdGhpcy5uZWFyID0gMC4xO1xuXG4vISoqXG4gKiBDYW1lcmEgZnJ1c3R1bSBmYXIgcGxhbmUuIFRoZSB2YWxpZCByYW5nZSBpcyBiZXR3ZWVuIHRoZSBjdXJyZW50IHZhbHVlIG9mXG4gKiB0aGUge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI25lYXJ9IHBsYW5lIGFuZCBpbmZpbml0eS5cbiAqIEBtZW1iZXIge251bWJlcn0gZmFyXG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAyMDAwXG4gKiEvXG5sZXQgdGhpcy5mYXIgPSAyMDAwO1xuXG4vISoqXG4gKiBPYmplY3QgZGlzdGFuY2UgdXNlZCBmb3Igc3RlcmVvc2NvcHkgYW5kIGRlcHRoLW9mLWZpZWxkIGVmZmVjdHMuIFRoaXNcbiAqIHBhcmFtZXRlciBkb2VzIG5vdCBpbmZsdWVuY2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHVubGVzcyBhXG4gKiB7QGxpbmsgU3RlcmVvQ2FtZXJhfSBpcyBiZWluZyB1c2VkLlxuICogQG1lbWJlciB7bnVtYmVyfSBmb2N1c1xuICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICogQGRlZmF1bHQgMTBcbiAqIS9cbmxldCB0aGlzLmZvY3VzID0gMTA7XG5cbi8hKipcbiAqIENhbWVyYSBmcnVzdHVtIGFzcGVjdCByYXRpbywgdXN1YWxseSB0aGUgY2FudmFzIHdpZHRoIC8gY2FudmFzIGhlaWdodC5cbiAqIEBtZW1iZXIge251bWJlcn0gYXNwZWN0XG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAxIChzcXVhcmUgY2FudmFzKVxuICohL1xubGV0IHRoaXMuYXNwZWN0ID0gMTtcblxuLyEqKlxuICogRnJ1c3R1bSB3aW5kb3cgc3BlY2lmaWNhdGlvbiBvciBgbnVsbGAuIFRoaXMgaXMgc2V0IHVzaW5nIHRoZVxuICoge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI3NldFZpZXdPZmZzZXR9IG1ldGhvZCBhbmQgY2xlYXJlZCB1c2luZ1xuICoge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2NsZWFyVmlld09mZnNldH0uXG4gKiBAbWVtYmVyIHtQZXJzcGVjdGl2ZUNhbWVyYVZpZXdPZmZzZXR9IHZpZXdcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IG51bGxcbiAqIS9cbmxldCB0aGlzLnZpZXcgPSBudWxsO1xuXG4vISoqXG4gKiBGaWxtIHNpemUgdXNlZCBmb3IgdGhlIGxhcmdlciBheGlzLiBUaGlzIHBhcmFtZXRlciBkb2VzIG5vdCBpbmZsdWVuY2UgdGhlXG4gKiBwcm9qZWN0aW9uIG1hdHJpeCB1bmxlc3Mge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2ZpbG1PZmZzZXR9IGlzIHNldCB0byBhXG4gKiBub256ZXJvIHZhbHVlLlxuICogQG1lbWJlciB7bnVtYmVyfSBmaWxtR2F1Z2VcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAqIEBkZWZhdWx0IDM1IChtaWxsaW1ldGVycylcbiAqIS9cbmxldCB0aGlzLmZpbG1HYXVnZSA9IDM1O1xuXG4vISoqXG4gKiBIb3Jpem9udGFsIG9mZi1jZW50ZXIgb2Zmc2V0IGluIHRoZSBzYW1lIHVuaXQgYXNcbiAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICogQG1lbWJlciB7bnVtYmVyfSBmaWxtT2Zmc2V0XG4gKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gKiBAZGVmYXVsdCAwXG4gKiEvXG5sZXQgdGhpcy5maWxtT2Zmc2V0ID0gMDtcblxuLyEqKlxuICogQ2FtZXJhIHByb2plY3Rpb24gbWF0cml4XG4gKiBAbWVtYmVyIHtNYXRyaXg0fSBwcm9qZWN0aW9uTWF0cml4XG4gKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLmNhbWVyYVxuICohL1xuLy8gbGV0IF9wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuLyEqKlxuICogVXNlZCB0byB0ZXN0IHdoZXRoZXIgdGhpcyBvciBkZXJpdmVkIGNsYXNzZXMgYXJlXG4gKiB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmF9cy4gVGhpcyBzaG91bGQgbm90IGJlIGNoYW5nZWQgYXMgaXQgaXMgdXNlZFxuICogaW50ZXJuYWxseSBieSB0aGUgcmVuZGVyZXIgZm9yIG9wdGltaXNhdGlvbi5cbiAqIEBtZW1iZXIge2Jvb2xlYW59IGlzUGVyc3BlY3RpdmVDYW1lcmFcbiAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGVcbiAqIEBkZWZhdWx0IHRydWVcbiAqIS8qL1xuY29uc3QgaXNQZXJzcGVjdGl2ZUNhbWVyYSA9IHRydWU7XG5jb25zdCBfdHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBjYW1lcmFcbiAqIEBtZW1iZXJvZiBsZXRzZWVcbiAqIEBjbGFzcyBQZXJzcGVjdGl2ZUNhbWVyYVxuICogQGNsYXNzZGVzY1xuICogQ2FtZXJhIHRoYXQgdXNlc1xuICogW3BlcnNwZWN0aXZlIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BlcnNwZWN0aXZlXyhncmFwaGljYWwpKS5cbiAqIFRoaXMgcHJvamVjdGlvbiBtb2RlIGlzIGRlc2lnbmVkIHRvIG1pbWljIHRoZSB3YXkgdGhlIGh1bWFuIGV5ZSBzZWVzLiBJdCBpc1xuICogdGhlIG1vc3QgY29tbW9uIHByb2plY3Rpb24gbW9kZSB1c2VkIGZvciByZW5kZXJpbmcgYSAzRCBzY2VuZS5cbiAqIEBleHRlbmRzIENhbWVyYVxuICogQGV4YW1wbGVcbiAqIHZhciBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoNDUsIHdpZHRoL2hlaWdodCwgMSwgMTAwMCk7XG4gKiBzY2VuZS5hZGQoY2FtZXJhKTtcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtICB7bnVtYmVyfSBbZm92XSAgICBDYW1lcmEgZnJ1c3R1bSB2ZXJ0aWNhbCBmaWVsZCBvZiB2aWV3LlxuICogQHBhcmFtICB7bnVtYmVyfSBbYXNwZWN0XSBDYW1lcmEgZnJ1c3R1bSBhc3BlY3QgcmF0aW8uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtuZWFyXSAgIENhbWVyYSBmcnVzdHVtIG5lYXIgcGxhbmUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmYXJdICAgIENhbWVyYSBmcnVzdHVtIGZhciBwbGFuZS5cbiAqL1xuY2xhc3MgUGVyc3BlY3RpdmVDYW1lcmEgZXh0ZW5kcyBDYW1lcmEge1xuICBjb25zdHJ1Y3Rvcihmb3YsIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcbiAgICB0aGlzLnpvb20gPSAxO1xuICAgIHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XG4gICAgdGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XG4gICAgdGhpcy5mb2N1cyA9IDEwO1xuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuICAgIHRoaXMudmlldyA9IG51bGw7XG4gICAgdGhpcy5maWxtR2F1Z2UgPSAzNTtcbiAgICB0aGlzLmZpbG1PZmZzZXQgPSAwO1xuICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICB9XG4gIC8vXG4gIC8vIGdldCBmb3YoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZm92O1xuICAvLyB9XG4gIC8vXG4gIC8vIGdldCB6b29tKCkge1xuICAvLyAgIHJldHVybiB0aGlzLnpvb207XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IG5lYXIoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMubmVhcjtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmFyKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmZhcjtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZm9jdXMoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZm9jdXM7XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IGFzcGVjdCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5hc3BlY3Q7XG4gIC8vIH1cbiAgLy9cbiAgLy8gZ2V0IHZpZXcoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudmlldztcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmlsbUdhdWdlKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmZpbG1HYXVnZTtcbiAgLy8gfVxuICAvL1xuICAvLyBnZXQgZmlsbU9mZnNldCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5maWxtT2Zmc2V0O1xuICAvLyB9XG5cbiAgY29weShzb3VyY2UpIHtcbiAgICBzdXBlci5jb3B5KHNvdXJjZSk7XG5cbiAgICB0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XG4gICAgdGhpcy56b29tID0gc291cmNlLnpvb207XG4gICAgdGhpcy5uZWFyID0gc291cmNlLm5lYXI7XG4gICAgdGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuICAgIHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XG4gICAgdGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xuICAgIHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IHsuLi5zb3VyY2Uudmlld307XG4gICAgdGhpcy5maWxtR2F1Z2UgPSBzb3VyY2UuZmlsbUdhdWdlO1xuICAgIHRoaXMuZmlsbU9mZnNldCA9IHNvdXJjZS5maWxtT2Zmc2V0O1xuICAgIC8vIF9wcm9qZWN0aW9uTWF0cml4ID0gc291cmNlLnByb2plY3Rpb25NYXRyaXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXQgZm9jYWxMZW5ndGgoZm9jYWxMZW5ndGgpIHtcbiAgICBjb25zdCB2RXh0ZW50U2xvcGUgPSAwLjUgKiB0aGlzLmZpbG1IZWlnaHQgLyBmb2NhbExlbmd0aDtcbiAgICB0aGlzLmZvdiA9IDIgKiByYWRUb0RlZyhNYXRoLmF0YW4odkV4dGVudFNsb3BlKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGZvY2FsIGxlbmd0aCBvZiB0aGUgY3VycmVudCB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjZm92fSBpbiByZXNwZWN0IHRvXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvY2FsTGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAgICovXG4gIGdldCBmb2NhbExlbmd0aCgpIHtcbiAgICBjb25zdCB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbigwLjUgKiBkZWdUb1JhZCh0aGlzLmZvdikpO1xuICAgIHJldHVybiAwLjUgKiB0aGlzLmZpbG1IZWlnaHQgLyB2RXh0ZW50U2xvcGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBpbWFnZSBvbiB0aGUgZmlsbS4gSWYge0BsaW5rIFBlcnNwZWN0aXZlQ2FtZXJhI2FzcGVjdH0gaXNcbiAgICogZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAxYCAobGFuZHNjYXBlIGZvcm1hdCksIHRoZSByZXN1bHQgZXF1YWxzXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbG1XaWR0aFxuICAgKiBAbWVtYmVyb2YgUGVyc3BlY3RpdmVDYW1lcmEjXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGZpbG1XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxtR2F1Z2UgKiBNYXRoLm1pbih0aGlzLmFzcGVjdCwgMSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvZiB0aGUgaW1hZ2Ugb24gdGhlIGZpbG0uIElmIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNhc3BlY3R9IGlzXG4gICAqIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgMWAgKHBvcnRyYWl0IGZvcm1hdCksIHRoZSByZXN1bHQgZXF1YWxzXG4gICAqIHtAbGluayBQZXJzcGVjdGl2ZUNhbWVyYSNmaWxtR2F1Z2V9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbG1IZWlnaHRcbiAgICogQG1lbWJlcm9mIFBlcnNwZWN0aXZlQ2FtZXJhI1xuICAgKiBAcmVhZG9ubHlcbiAgICovXG4gIGdldCBmaWxtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KHRoaXMuYXNwZWN0LCAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgYW5nbGUgaW4gZGVncmVlcyBjb25zaWRlcmluZ1xuICAgKiB7QGxpbmsgUGVyc3BlY3RpdmVDYW1lcmEjem9vbX0uXG4gICAqIEBtZW1iZXIge251bWJlcn0gZWZmZWN0aXZlRk9WXG4gICAqIEBtZW1iZXJvZiBQZXJzcGVjdGl2ZUNhbWVyYSNcbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXRFZmZlY3RpdmVGT1YoKSB7XG4gICAgcmV0dXJuIDIgKiByYWRUb0RlZyhNYXRoLmF0YW4oTWF0aC50YW4oMC41ICogZGVnVG9SYWQodGhpcy5mb3YpKSAvIHRoaXMuem9vbSkpO1xuICB9XG5cbiAgc2V0IHZpZXdPZmZzZXQodmlldykge1xuICAgIHRoaXMudmlldyA9IHZpZXc7XG5cbiAgICBpZiAodGhpcy52aWV3ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmFzcGVjdCA9IHRoaXMudmlldy5mdWxsV2lkdGggLyB0aGlzLnZpZXcuZnVsbEhlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgcHJvamVjdGlvbk1hdHJpeCgpIHtcbiAgLy8gICByZXR1cm4gX3Byb2plY3Rpb25NYXRyaXg7XG4gIC8vIH1cblxuICB1cGRhdGVQcm9qZWN0aW9uTWF0cml4KCkge1xuICAgIGxldCBuZWFyID0gdGhpcy5uZWFyLFxuICAgICAgdG9wID0gbmVhciAqIE1hdGgudGFuKERFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdikgLyB0aGlzLnpvb20sXG4gICAgICBoZWlnaHQgPSAyICogdG9wLFxuICAgICAgd2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodCxcbiAgICAgIGxlZnQgPSAtMC41ICogd2lkdGgsXG4gICAgICB2aWV3ID0gdGhpcy52aWV3O1xuXG4gICAgaWYgKHRoaXMudmlldyAhPT0gbnVsbCAmJiB0aGlzLnZpZXcuZW5hYmxlZCkge1xuICAgICAgbGV0IGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxuICAgICAgICBmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xuXG4gICAgICBsZWZ0ICs9IHZpZXcub2Zmc2V0WCAqIHdpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgdG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XG4gICAgICB3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xuICAgICAgaGVpZ2h0ICo9IHZpZXcuaGVpZ2h0IC8gZnVsbEhlaWdodDtcblxuICAgIH1cblxuICAgIGxldCBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xuXG4gICAgaWYgKHNrZXcgIT09IDApIGxlZnQgKz0gbmVhciAqIHNrZXcgLyB0aGlzLmZpbG1XaWR0aCgpO1xuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoXG4gICAgICBsZWZ0LFxuICAgICAgbGVmdCArIHdpZHRoLFxuICAgICAgdG9wLFxuICAgICAgdG9wIC0gaGVpZ2h0LFxuICAgICAgbmVhcixcbiAgICAgIHRoaXMuZmFyKTtcbiAgICB0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgfVxuXG4gIHNldFZpZXdQb3J0KHJvdGF0aW9uTWF0cml4KSB7XG4gICAgaWYgKHJvdGF0aW9uTWF0cml4LmlzTWF0cml4NCkge1xuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChyb3RhdGlvbk1hdHJpeCk7XG4gICAgICBMZXRzZWVFbmdpbmUucmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBlcnNwZWN0aXZlQ2FtZXJhO1xuIiwiaW1wb3J0IE9iamVjdDNEIGZyb20gJy4vT2JqZWN0M0QnO1xuXG4vKipcbiAqIEBjbGFzcyBTY2VuZVxuICogQGNsYXNzZGVzY1xuICogU2NlbmVzIGFsbG93IHlvdSB0byBzZXQgdXAgd2hhdCBhbmQgd2hlcmUgaXMgdG8gYmUgcmVuZGVyZWQuIFRoaXMgaXMgd2hlcmVcbiAqIHlvdSBwbGFjZSBvYmplY3RzLCBsaWdodHMsIGFuZCBjYW1lcmFzLlxuICogQGV4dGVuZHMgT2JqZWN0M0RcbiAqL1xuXG5jb25zdCBfdHlwZSA9ICdTY2VuZSc7XG5jb25zdCBfaXNTY2VuZSA9IHRydWU7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjZW5lIGV4dGVuZHMgT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHN1cGVyLnRyYWNrID0gdHJ1ZTtcbiAgfVxuICBnZXQgaXNTY2VuZSgpIHtcbiAgICByZXR1cm4gX2lzU2NlbmU7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gX3R5cGU7XG4gIH1cbn1cblxuIiwiaW1wb3J0IEVudGl0eSBmcm9tICcuLi9lbnRpdHkvRW50aXR5JztcbmltcG9ydCBET01SZW5kZXJhYmxlIGZyb20gJy4uL3JlbmRlcmVyL0RPTVJlbmRlcmFibGUnO1xuaW1wb3J0IEV1bGVyIGZyb20gJy4uL21hdGgvRXVsZXInO1xuXG5sZXQgX2VudGl0aWVzO1xuXG5jbGFzcyBUcmFja2FibGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX2VudGl0aWVzID0ge307XG4gIH1cblxuICBsb2FkKGVudGl0eSkge1xuICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHJldHVybiB3aW5kb3cuX25hdGl2ZS5sb2FkRW50aXR5KGVudGl0eS51cmkpO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlamVjdCgncGFyYW1ldGVyIGlzIG5vdCBlbnRpdHknKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldEVudGl0eSh1cmkpIHtcbiAgICBpZiAoX2VudGl0aWVzW3VyaV0pIHJldHVybiBfZW50aXRpZXNbdXJpXTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldEVudGl0aWVzKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKF9lbnRpdGllcyk7XG4gIH1cblxuICBoYXNFbnRpdHkodXJpKSB7XG4gICAgaWYgKF9lbnRpdGllc1t1cmldKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhZGRFbnRpdHkoZW50aXR5KSB7XG4gICAgX2VudGl0aWVzW2VudGl0eS51cmldID0gZW50aXR5O1xuXG4gICAgLy8gaWYgKGVudGl0eS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy8gICAgIFBsYWNlQ29udHJvbGxlci5hZGRFbnRpdHkoZW50aXR5KTtcbiAgICAvLyB9XG4gIH1cblxuICByZW1vdmVFbnRpdHkocGFyYW0pIHtcbiAgICBsZXQgdXJpID0gcGFyYW07XG5cbiAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBFbnRpdHkpIHtcbiAgICAgIHVyaSA9IHBhcmFtLnVyaTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNFbnRpdHkodXJpKSkge1xuICAgICAgY29uc3QgZW50aXR5ID0gX2VudGl0aWVzW3VyaV07XG5cbiAgICAgIGlmIChlbnRpdHkudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gUGxhY2VDb250cm9sbGVyLnJlbW92ZUVudGl0eShlbnRpdHkpO1xuICAgICAgfVxuXG4gICAgICBfZW50aXRpZXNbdXJpXS5yZW1vdmVSZW5kZXJhYmxlcygpO1xuICAgICAgZGVsZXRlIF9lbnRpdGllc1t1cmldO1xuICAgIH1cbiAgfVxuXG4gIHNldEVudGl0eShlbnRpdHkpIHtcbiAgICBjb25zdCB1cmkgPSBlbnRpdHkudXJpO1xuXG4gICAgaWYgKF9lbnRpdGllc1t1cmldKSB7XG4gICAgICBfZW50aXRpZXNbdXJpXS5zZXREYXRhKGVudGl0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9lbnRpdGllc1t1cmldID0gZW50aXR5O1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyYXZlcnNlRW50aXR5KGNhbGxiYWNrOiAoZW50aXR5OiBFbnRpdHkpID0+IHZvaWQpIHtcbiAgLy8gICBmb3IgKGxldCBlbnRpdHkgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmVudGl0aWVzKSkge1xuICAvLyAgICAgY2FsbGJhY2soZW50aXR5KTtcbiAgLy8gICB9XG4gIC8vIH1cblxuICBzZXREYXRhcyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICBjb25zdCBvYmplY3RzID0gZGF0YTtcbiAgICAvLyBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGlmIChvYmplY3RzICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgIGNvbnN0IGUgPSBvYmplY3QuZW50aXR5O1xuICAgICAgICBjb25zdCBjdXJyZW50RW50aXR5ID0gbmV3IEVudGl0eShlLnVyaSwgZSk7XG5cbiAgICAgICAgdGhpcy5hZGRFbnRpdHkoY3VycmVudEVudGl0eSk7XG4gICAgICAgIGNvbnN0IHJlbmRlcmFibGVzID0gb2JqZWN0LnJlbmRlcmFibGVzO1xuXG4gICAgICAgIHJlbmRlcmFibGVzLmZvckVhY2gociA9PiB7XG4gICAgICAgICAgY29uc3Qge3NlbGVjdG9yLCB0cmFuc2xhdGUsIHJvdGF0aW9ufSA9IHI7XG4gICAgICAgICAgY29uc3QgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICAgIGVsZW1zLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJhYmxlID0gbmV3IERPTVJlbmRlcmFibGUoZWxlbSk7XG5cbiAgICAgICAgICAgIHJlbmRlcmFibGUucG9zaXRpb24uc2V0KC4uLnRyYW5zbGF0ZSk7XG4gICAgICAgICAgICByZW5kZXJhYmxlLnJvdGF0aW9uID0gbmV3IEV1bGVyKC4uLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRFbnRpdHkuYWRkUmVuZGVyYWJsZShyZW5kZXJhYmxlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb25zdCBwbGFjZXMgPSBkYXRhLnBsYWNlO1xuICAgIC8vXG4gICAgLy8gaWYgKHBsYWNlcyAmJiBwbGFjZXMubGVuZ3RoID4gMCkge1xuICAgIC8vICAgcGxhY2VzLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlKSB7XG4gICAgLy8gICAgIGNvbnN0IGUgPSBwbGFjZS5lbnRpdHk7XG4gICAgLy8gICAgIGNvbnN0IGVudGl0eSA9IG5ldyBFbnRpdHkoZS51cmksIGUpO1xuICAgIC8vICAgICBjb25zdCByZW5kZXJhYmxlcyA9IHBsYWNlLnJlbmRlcmFibGVzO1xuICAgIC8vXG4gICAgLy8gICAgIGlmIChlbnRpdHkudXJpID09PSAnZ2VvbG9jYXRpb24nKSB7XG4gICAgLy8gICAgICAgZW50aXR5LnRyYWNrID0gdHJ1ZTtcbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVuZGVyYWJsZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAvLyAgICAgICBjb25zdCByID0gcmVuZGVyYWJsZXNbal07XG4gICAgLy8gICAgICAgY29uc3Qgc2VsZWN0b3IgPSByLnNlbGVjdG9yO1xuICAgIC8vICAgICAgIGNvbnN0IHBvc2UgPSByLnBvc2U7XG4gICAgLy8gICAgICAgY29uc3QgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAvL1xuICAgIC8vICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZWxlbXMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAvLyAgICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtc1trXTtcbiAgICAvLyAgICAgICAgIGxldCByZW5kZXJhYmxlID0gbmV3IEdlb1JlbmRlcmFibGUoZWxlbSk7XG4gICAgLy9cbiAgICAvLyAgICAgICAgIHJlbmRlcmFibGUuc2V0TG9jYXRpb24ocG9zZVswXSwgcG9zZVsxXSwgcG9zZVsyXSk7XG4gICAgLy9cbiAgICAvLyAgICAgICAgIGVudGl0eS5hZGRSZW5kZXJhYmxlKHJlbmRlcmFibGUpO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuICB9XG59XG5cbi8vIGV4cG9ydCBkZWZhdWx0IG5ldyBUcmFja2FibGVNYW5hZ2VyKCk7XG4vLyBleHBvcnQgZGVmYXVsdCBUcmFja2FibGVNYW5hZ2VyO1xuZXhwb3J0IGxldCB0cmFja2FibGVNYW5hZ2VyID0gbmV3IFRyYWNrYWJsZU1hbmFnZXIoKTtcbiIsImltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCB7ZG9tUmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXIvRE9NUmVuZGVyZXInO1xuaW1wb3J0IHtvYmplY3RUcmFja2VyfSBmcm9tICcuL2xpYnMvT2JqZWN0VHJhY2tlcic7XG5pbXBvcnQge3RyYWNrYWJsZU1hbmFnZXJ9IGZyb20gJy4vY29yZS9UcmFja2FibGVNYW5hZ2VyJztcbi8vIGltcG9ydCB7ZXZlbnRNYW5hZ2VyfSBmcm9tICcuL2V2ZW50L0V2ZW50TWFuYWdlcic7XG5pbXBvcnQgUGVyc3BlY3RpdmVDYW1lcmEgZnJvbSAnLi9jb3JlL1BlcnNwZWN0aXZlQ2FtZXJhJztcbmltcG9ydCBMZXRzZWVUaHJlZSBmcm9tICcuL2V4dGVybmFsL1RIUkVFJztcblxubGV0IF9pbnN0YW5jZTtcbmxldCBfY29uZmlnID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIGlmIChfaW5zdGFuY2UpIHJldHVybiBfaW5zdGFuY2U7XG5cbiAgICBfY29uZmlnID0gey4uLmNvbmZpZ307XG5cbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSguLi5fY29uZmlnLnByb2plY3Rpb25QYXJhbWV0ZXIpO1xuXG4gICAgY29udGV4dC5zZXRDb25maWcoX2NvbmZpZyk7XG4gICAgZG9tUmVuZGVyZXIuaW5pdFJlbmRlcmVyKHRoaXMuY2FtZXJhLCBfY29uZmlnLmRvbVJlbmRlcmVySWQsIF9jb25maWcuekluZGV4LCBfY29uZmlnLnpJbmRleEluY3JlbWVudCk7XG5cbiAgICBvYmplY3RUcmFja2VyLmNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgIGlmIChjb25maWcuZXh0ZXJuYWwgPT09ICdUSFJFRScpIHtcbiAgICAgIHRoaXMudGhyZWVSZW5kZXJlciA9IG5ldyBMZXRzZWVUaHJlZShfY29uZmlnLnByb2plY3Rpb25QYXJhbWV0ZXIsIF9jb25maWcuekluZGV4LCBfY29uZmlnLnpJbmRleEluY3JlbWVudCk7XG4gICAgfVxuXG4gICAgdHJhY2thYmxlTWFuYWdlci5zZXREYXRhcyhfY29uZmlnLmRhdGEpO1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgIHN0eWxlLm1hcmdpbiA9IDA7XG4gICAgc3R5bGUucGFkZGluZyA9IDA7XG5cbiAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICBfaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbiAgb25Db25maWd1cmF0aW9uQ2hhbmdlZChuZXdDb25maWcpIHtcbiAgICBjb250ZXh0LnNldENvbmZpZyhuZXdDb25maWcpO1xuICAgIGRvbVJlbmRlcmVyLnVwZGF0ZU9yaWVudGF0aW9uKG5ld0NvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5leHRlcm5hbCA9PT0gJ1RIUkVFJyAmJiB0aGlzLnRocmVlUmVuZGVyZXIpIHRoaXMudGhyZWVSZW5kZXJlci51cGRhdGVPcmllbnRhdGlvbihuZXdDb25maWcpO1xuICB9XG5cbiAgZ2V0IG9iamVjdFRyYWNrZXIoKSB7XG4gICAgcmV0dXJuIG9iamVjdFRyYWNrZXI7XG4gIH1cblxuICBnZXQgZG9tUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIGRvbVJlbmRlcmVyO1xuICB9XG4gIGdldEVudGl0eSh1cmkpIHtcbiAgICByZXR1cm4gdHJhY2thYmxlTWFuYWdlci5nZXRFbnRpdHkodXJpKTtcbiAgfVxuICBnZXRFbnRpdGllcygpIHtcbiAgICByZXR1cm4gdHJhY2thYmxlTWFuYWdlci5nZXRFbnRpdGllcygpO1xuICB9XG4gIHJlbW92ZUVudGl0eSh1cmkpIHtcbiAgICB0cmFja2FibGVNYW5hZ2VyLnJlbW92ZUVudGl0eSh1cmkpO1xuICB9XG5cbiAgaGFzRW50aXR5KHVyaSkge1xuICAgIHJldHVybiB0cmFja2FibGVNYW5hZ2VyLmhhc0VudGl0eSh1cmkpO1xuICB9XG5cbiAgcmVzZXREb21SZW5kZXJhYmxlKCkge1xuICAgIHRoaXMuZG9tUmVuZGVyZXIucmVzZXRFbGVtZW50KCk7XG4gIH1cbiAgYXBwZW5kRG9tUmVuZGVyYWJsZShlbGVtZW50KSB7XG4gICAgdGhpcy5kb21SZW5kZXJlci5hcHBlbmRFbGVtZW50KGVsZW1lbnQpO1xuICB9XG4gIGFwcGVuZEFsbERvbVJlbmRlcmFibGVzKCkge1xuICAgIHRoaXMuZG9tUmVuZGVyZXIuYXBwZW5kQWxsRWxlbWVudHMoKTtcbiAgfVxufVxuIiwiLy8gaW1wb3J0IHtldmVudE1hbmFnZXJ9IGZyb20gJy4uL2V2ZW50L0V2ZW50TWFuYWdlcic7XG4vLyBpbXBvcnQgTWF0cml4NCBmcm9tICcuLi9tYXRoL01hdHJpeDQnO1xuLy8gaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi4vbWF0aC9WZWN0b3IzJztcbi8vIGltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4uL21hdGgvUXVhdGVybmlvbic7XG5pbXBvcnQge3JlbW92ZUFycmF5SXRlbX0gZnJvbSAnLi4vVXRpbCc7XG5pbXBvcnQgT2JqZWN0M0QgZnJvbSAnLi4vY29yZS9PYmplY3QzRCc7XG5pbXBvcnQge2RvbVJlbmRlcmVyfSBmcm9tICcuLi9yZW5kZXJlci9ET01SZW5kZXJlcic7XG5pbXBvcnQge0VOVElUWV9FVkVOVH0gZnJvbSAnLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuaW1wb3J0IE9ic2VydmVyIGZyb20gJy4uL29ic2VydmVycy9PYnNlcnZlcic7XG5pbXBvcnQgRW50aXR5RXZlbnQgZnJvbSAnLi9FbnRpdHlFdmVudCc7XG5cbmNvbnN0IGhhbmRsZXJzID0gbmV3IE1hcChcbiAgW1xuICAgIFtFTlRJVFlfRVZFTlQuVFJBQ0tfU1RBUlQsIG5ldyBTZXQoKV0sXG4gICAgW0VOVElUWV9FVkVOVC5UUkFDS19NT1ZFLCBuZXcgU2V0KCldLFxuICAgIFtFTlRJVFlfRVZFTlQuVFJBQ0tfRU5ELCBuZXcgU2V0KCldXG4gIF0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHJlYWwgd29ybGQgb2JqZWN0IHRoYXQgY2FuIGJlIGRldGVjdGVkIGFuZCBiZSBhc3NvY2lhdGVkIHdpdGggSFRNTCBlbGVtZW50cy5cbiAqIEBjbGFzc1xuICogQG5hbWUgRW50aXR5XG4gKiBAaGlkZWNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eSBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IodXJpLCBkYXRhKSB7XG4gICAgaWYgKCF1cmkpIHRocm93IG5ldyBFcnJvcignRW50aXR5IHJlcXVpcmVzIGFuIGVudGl0eSB1cmknKTtcbiAgICBzdXBlcih1cmksIGhhbmRsZXJzKTtcblxuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMudHlwZSA9IChkYXRhICYmIGRhdGEudHlwZSkgPyBkYXRhLnR5cGUgOiAnb2JqZWN0JztcbiAgICB0aGlzLm5hbWUgPSAoZGF0YSAmJiBkYXRhLm5hbWUpID8gZGF0YS5uYW1lIDogJyc7XG4gICAgdGhpcy5pbWFnZSA9IChkYXRhICYmIGRhdGEuaW1hZ2UpID8gZGF0YS5pbWFnZSA6ICcnO1xuICAgIHRoaXMuc2l6ZSA9IChkYXRhICYmIGRhdGEuc2l6ZSkgPyBkYXRhLnNpemUgOiB7d2lkdGg6IDAsIGhlaWdodDogMCwgZGVwdGg6IDAsIHVuaXQ6ICdtbSd9O1xuICAgIHRoaXMucmVuZGVyYWJsZXMgPSBbXTtcbiAgICB0aGlzLm9iamVjdCA9IG5ldyBPYmplY3QzRCgpO1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuX3RyYWNrID0gZmFsc2U7XG4gIH1cblxuICBzZXREYXRhKGRhdGEpIHtcbiAgICB0aGlzLnR5cGUgPSAoZGF0YSAmJiBkYXRhLnR5cGUpID8gZGF0YS50eXBlIDogJ29iamVjdCc7XG4gICAgdGhpcy5uYW1lID0gKGRhdGEgJiYgZGF0YS5uYW1lKSA/IGRhdGEubmFtZSA6ICcnO1xuICAgIHRoaXMuaW1hZ2UgPSAoZGF0YSAmJiBkYXRhLmltYWdlKSA/IGRhdGEuaW1hZ2UgOiAnJztcbiAgICB0aGlzLnNpemUgPSAoZGF0YSAmJiBkYXRhLnNpemUpID8gZGF0YS5zaXplIDoge3dpZHRoOiAwLCBoZWlnaHQ6IDAsIGRlcHRoOiAwLCB1bml0OiAnbW0nfTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMub2JqZWN0LnRyYXZlcnNlKChvYmopID0+IHtcbiAgICAgIG9iai52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgaWYgKG9iai5lbGVtZW50KSB7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgb2JqLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iai5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCB0cmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gIH1cblxuICBzZXQgdHJhY2sodHJhY2spIHtcbiAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuXG4gICAgdGhpcy5vYmplY3QudHJhdmVyc2UoKG9iaikgPT4ge1xuICAgICAgb2JqLnRyYWNrID0gdHJhY2s7XG5cbiAgICAgIGlmIChvYmouZWxlbWVudCkge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICBvYmouZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdC5wb3NpdGlvbjtcbiAgfVxuXG4gIGdldCBtYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0Lm1hdHJpeDtcbiAgfVxuXG4gIGdldCBtYXRyaXhXb3JsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG4gIH1cblxuICBnZXQgcXVhdGVybmlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3QucXVhdGVybmlvbjtcbiAgfVxuXG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Qucm90YXRpb247XG4gIH1cblxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0LnNjYWxlO1xuICB9XG5cbiAgc2V0IHNjYWxlKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlKSB0aGlzLm9iamVjdC5zY2FsZS5zZXRTY2FsYXIoc2NhbGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJhbnNsYXRlWCh2YWx1ZSkge1xuICAgIHRoaXMub2JqZWN0LnRyYW5zbGF0ZVgodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zbGF0ZVkodmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdC50cmFuc2xhdGVZKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2xhdGVaKHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3QudHJhbnNsYXRlWih2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVYKHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Qucm90YXRlWCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVZKHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Qucm90YXRlWSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVaKHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Qucm90YXRlWih2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGRhdGVNYXRyaXgoKSB7XG4gICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICog7KCE64us65CcIGBSZW5kZXJhYmxlYOydhCDsl5TthLDti7Dsl5Ag65Ox66Gd7ZWp64uI64ukLiBgUmVuZGVyYWJsZWDsnYAg7JeU7YSw7Yuw6rCAIOymneqwleuQmOuptCDtmZTrqbTsl5Ag67O07Jes7KeR64uI64ukLlxuICAgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIGBSZW5kZXJhYmxlYCB0byB0aGlzIGVudGl0eS4gVGhlIGBSZW5kZXJhYmxlYCB3aWxsIGJlXG4gICAqIHJlbmRlcmVkIHdoZW4gdGhpcyBlbnRpdHkgaXMgdHJhY2tlZC5cbiAgICogQG1ldGhvZCBFbnRpdHkjYWRkUmVuZGVyYWJsZVxuICAgKiBAcGFyYW0ge1JlbmRlcmFibGV9IHJlbmRlcmFibGVcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIGEgcmVuZGVyYWJsZSBIVE1MIGVsZW1lbnRcbiAgICogLy8gaHRtbOuhnCDrp4zrk6TslrTsp4QgcmVuZGVyYWJsZeydhCDsg53shLHtlanri4jri6QuXG4gICAqIHZhciBoZWxsb1dvcmxkRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gICAqIGhlbGxvV29ybGRFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdIZWxsbyBXb3JsZCEnKSk7XG4gICAqIHZhciBoZWxsb1dvcmxkID0gbmV3IERPTVJlbmRlcmFibGUoaGVsbG9Xb3JsZEVsZW0pO1xuICAgKlxuICAgKiAvLyBSZWdpc3RlciB0aGUgcmVuZGVyYWJsZSB0byB0aGUgZW50aXR5XG4gICAqIC8vIHJlbmRlcmFibGXsnYQg7JeU7YSw7Yuw7JeQIOuTseuhne2VqeuLiOuLpC5cbiAgICogZW50aXR5LmFkZFJlbmRlcmFibGUoaGVsbG9Xb3JsZCk7XG4gICAqL1xuICBhZGRSZW5kZXJhYmxlKHJlbmRlcmFibGUpIHtcbiAgICBpZiAocmVuZGVyYWJsZSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvbVJlbmRlcmVyLmFkZCh0aGlzLm9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyYWJsZXMucHVzaChyZW5kZXJhYmxlKTtcbiAgICAgIHRoaXMub2JqZWN0LmFkZChyZW5kZXJhYmxlKTtcblxuICAgICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrO1xuXG4gICAgICAgIHJlbmRlcmFibGUudHJhdmVyc2UoKG9iaikgPT4ge1xuICAgICAgICAgIG9iai50cmFjayA9IHRyYWNrO1xuXG4gICAgICAgICAgaWYgKG9iai5lbGVtZW50KSB7XG4gICAgICAgICAgICBvYmouZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICog7KCE64us65CcIGBSZW5kZXJhYmxlYOydhCDsl5TthLDti7Dsl5DshJwg7IKt7KCc7ZWp64uI64ukLiDsgq3soJzrkJwgYFJlbmRlcmFibGVg7J2AIOuNlOydtOyDgSDtmZTrqbTsl5Ag7ZGc7Iuc65CY7KeAIOyViuyKteuLiOuLpC5cbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYFJlbmRlcmFibGVgIGZyb20gdGhpcyBlbnRpdHkncyByZW5kZXJhYmxlcy5cbiAgICogVGhlIGBSZW5kZXJhYmxlYCB3aWxsIG5vIGxvbmdlciBiZSByZW5kZXJlZFxuICAgKiB3aGVuIHRoaXMgZW50aXR5IGlzIHRyYWNrZWQuXG4gICAqIEBtZXRob2QgcmVtb3ZlUmVuZGVyYWJsZVxuICAgKiBAbWVtYmVyb2YgRW50aXR5LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1JlbmRlcmFibGV9IHJlbmRlcmFibGVcbiAgICovXG4gIHJlbW92ZVJlbmRlcmFibGUocmVuZGVyYWJsZSkge1xuICAgIGlmIChyZW5kZXJhYmxlKSB7XG4gICAgICByZW1vdmVBcnJheUl0ZW0odGhpcy5yZW5kZXJhYmxlcywgcmVuZGVyYWJsZSk7XG4gICAgICB0aGlzLm9iamVjdC5yZW1vdmUocmVuZGVyYWJsZSk7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb21SZW5kZXJlci5yZW1vdmUodGhpcy5vYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBhbGwgYFJlbmRlcmFibGVzYCByZWdpc3RlcmVkIHRvIHRoaXMgZW50aXR5LlxuICAgKiDrk7HroZ3rkJwg66qo65OgIGBSZW5kZXJhYmxlc2DsnYQg7IKt7KCc7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIEVudGl0eSNyZXNldFJlbmRlcmFibGVzXG4gICAqL1xuICByZXNldFJlbmRlcmFibGVzKCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGZvciAobGV0IHJlbmRlcmFibGUgb2YgdGhpcy5yZW5kZXJhYmxlcykge1xuICAgICAgLy8gICB0aGlzLm9iamVjdC5yZW1vdmUocmVuZGVyYWJsZSk7XG4gICAgICAvLyB9XG5cbiAgICAgIHRoaXMucmVuZGVyYWJsZXMgPSBbXTtcbiAgICAgIGRvbVJlbmRlcmVyLnJlbW92ZSh0aGlzLm9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHRoZSBSZW5kZXJhYmxlcyBvZiB0aGlzIGVudGl0eS5cbiAgICog65Ox66Gd65CcIOuqqOuToCBgUmVuZGVyYWJsZXNg7J2EIOuwmO2ZmO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBFbnRpdHkjZ2V0QWxsUmVuZGVyYWJsZXNcbiAgICogQHJldHVybiB7UmVuZGVyYWJsZVtdfVxuICAgKi9cbiAgZ2V0QWxsUmVuZGVyYWJsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyYWJsZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgUmVuZGVyYWJsZSB3aXRoIHRoZSBnaXZlbiBgdXVpZGAsIG9yIGBudWxsYCBpZiBubyBzdWNoXG4gICAqIFJlbmRlcmFibGUgZXhpc3RzLlxuICAgKiDsp4DsoJXrkJwgVVVJROulvCDqsIDsp4QgYFJlbmRlcmFibGVzYOydhCDrsJjtmZjtlanri4jri6QuIOyXhuycvOuptCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIGdldFJlbmRlcmFibGVcbiAgICogQG1lbWJlcm9mIEVudGl0eS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHV1aWRcbiAgICogQHJldHVybiB7UmVuZGVyYWJsZXxudWxsfVxuICAgKi9cbiAgZ2V0UmVuZGVyYWJsZSh1dWlkKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucmVuZGVyYWJsZXMubGVuZ3RoOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZXNbaV0udXVpZCA9PT0gdXVpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJhYmxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGdldFNjcmVlbigpIHtcbiAgLy8gICBjb25zdCBjYW1lcmEgPSBMZXRzZWVFbmdpbmUuY2FtZXJhO1xuICAvL1xuICAvLyAgIGlmIChjYW1lcmEpIHtcbiAgLy8gICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gIC8vICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS50b0NTUzNEKCkpO1xuICAvL1xuICAvLyAgICAgY29uc3QgdiA9IHRoaXMub2JqZWN0LnBvc2l0aW9uLmNsb25lKCk7XG4gIC8vICAgICB2LmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAvL1xuICAvLyAgICAgY29uc3QgaGFsZldpZHRoID0gQ29udGV4dC53aWR0aCAqIDAuNTtcbiAgLy8gICAgIGNvbnN0IGhhbGZIZWlnaHQgPSBDb250ZXh0LmhlaWdodCAqIDAuNTtcbiAgLy9cbiAgLy8gICAgIHJldHVybiBuZXcgVmVjdG9yMigpLnNldChcbiAgLy8gICAgICAgKHYueCArIDEpICogaGFsZldpZHRoLFxuICAvLyAgICAgICAoLXYueSArIDEpICogaGFsZkhlaWdodFxuICAvLyAgICAgKTtcbiAgLy9cbiAgLy8gICB9IGVsc2Uge1xuICAvLyAgICAgY29uc29sZS5lcnJvcignQ2FtZXJhIGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAvLyAgIH1cbiAgLy8gfVxuXG4gIGxvb2tBdChwb3NpdGlvbikge1xuICAgIHRoaXMub2JqZWN0Lmxvb2tBdChwb3NpdGlvbik7XG4gIH1cblxuICBsb290QXRSZW5kZXJhYmxlcyhwb3NpdGlvbikge1xuICAgIHRoaXMub2JqZWN0LnRyYXZlcnNlKChvYmopID0+IHtcbiAgICAgIGlmICh0aGlzLm9iamVjdCAhPT0gb2JqKSB7XG4gICAgICAgIG9iai5sb29rQXQocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbG9va0F0Q2FtZXJhKCkge1xuICAgIGNvbnN0IGNhbWVyYVBvc2UgPSBMZXRzZWVFbmdpbmUuY2FtZXJhLnBvc2l0aW9uO1xuXG4gICAgdGhpcy5sb290QXRSZW5kZXJhYmxlcyhjYW1lcmFQb3NlKTtcbiAgfVxuXG4gIC8vIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgLy8gICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLnVyaSwgbGlzdGVuZXIpO1xuICAvLyB9XG4gIC8vXG4gIC8vIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgLy8gICBldmVudE1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLnVyaSwgY2FsbGJhY2spO1xuICAvLyB9XG5cbiAgc3Vic2NyaWJlKHR5cGUsIGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgc3VwZXIuc3Vic2NyaWJlKHRoaXMudXJpLCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRoaXMudXJpLCB0eXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBub3RpZnkodHlwZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFbnRpdHlFdmVudCkge1xuICAgICAgc3VwZXIubm90aWZ5KHRoaXMudXJpLCB0eXBlLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi4vbWF0aC9NYXRyaXg0JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7J3RyYWNrc3RhcnQnfCd0cmFja21vdmUnfCd0cmFja2VuZCd9IEVudGl0eUV2ZW50VHlwZVxuICovXG4vLyBleHBvcnQgdHlwZSBFbnRpdHlFdmVudFR5cGUgPSAndHJhY2tzdGFydCcgfCAndHJhY2ttb3ZlJyB8ICd0cmFja2VuZCc7XG5cbi8qKlxuICogQGNhbGxiYWNrIEVudGl0eUV2ZW50TGlzdGVuZXJcbiAqIEBwYXJhbSB7RW50aXR5RXZlbnR9IGV2ZW50XG4gKi9cblxuLy8gZXhwb3J0IHR5cGUgRW50aXR5RXZlbnRMaXN0ZW5lciA9IChldmVudDogRW50aXR5RXZlbnQpID0+IHZvaWQ7XG5cbi8qKlxuICogQGNsYXNzIEVudGl0eUV2ZW50XG4gKiBAY2xhc3NkZXNjIENsYXNzIHJlcHJlc2VudGluZyBmZWF0dXJlIHRyYWNraW5nIGV2ZW50cy5cbiAqIEBhdXRob3IgSm9vSHl1biBMZWUgKGxqaEBsZXRzZWUuaW8pXG4gKiBAc2luY2UgMjAxNi4gMDMuIDIzLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RW50aXR5fSBlbnRpdHlcbiAqIEBwYXJhbSB7VHJhY2thYmxlfSB0cmFja2FibGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFttYXRyaXhdXG4gKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlPTFdXG4gKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIGB0eXBlYCBvciBgZW50aXR5YCBpcyBub3Qgc3BlY2lmaWVkLlxuICovXG5cbi8qLyEqKlxuICogVGhlIHR5cGUgb2YgdGhpcyB0cmFjayBldmVudC5cbiAqIEBtZW1iZXIge3N0cmluZ30gdHlwZVxuICogQG1lbWJlcm9mIEVudGl0eUV2ZW50I1xuICohL1xubGV0IF90eXBlO1xuXG4vISoqXG4gKiBUaGUgdGFyZ2V0IG9mIHRoaXMgdHJhY2sgZXZlbnQuXG4gKiBAbWVtYmVyIHtFbnRpdHl9IHRhcmdldFxuICogQG1lbWJlcm9mIEVudGl0eUV2ZW50I1xuICohL1xubGV0IF90YXJnZXQ7XG5cbi8hKipcbiAqIEEgNHg0IFttYXRyaXhde0BsaW5rIFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWF0cml4XyhtYXRoZW1hdGljcylcIn1cbiAqIGluIGFcbiAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gKiBmb3JtYXQgdGhhdCByZXByZXNlbnRzIHRoZSB0cmFuc2xhdGlvbiBhbmQgdGhlIHJvdGF0aW9uIG9mIHRoZSBlbnRpdHlcbiAqIHJlbGF0aXZlIHRvIHRoZSBkZXZpY2UgY2FtZXJhLlxuICogQHRvZG8gY29sdW1uIHZzIHJvdywgcm90YXRpb24vdHJhbnNsYXRpb24gb2Ygd2hhdCByZWxhdGl2ZSB0byB3aGF0XG4gKiBAbWVtYmVyIHtNYXRyaXg0fSBtYXRyaXhcbiAqIEBtZW1iZXJvZiBFbnRpdHlFdmVudCNcbiAqIEBkZWZhdWx0IFtcbiAqIDEsIDAsIDAsIDAsXG4gKiAwLCAxLCAwLCAwLFxuICogMCwgMCwgMSwgMCxcbiAqIDAsIDAsIDAsIDFcbiAqIF1cbiAqIS9cbmxldCBfbWF0cml4O1xuXG4vISoqXG4gKlxuICogQG1lbWJlciB7T2JqZWN0fSBwaXhlbFNpemVcbiAqIEBtZW1iZXJvZiBFbnRpdHlFdmVudCNcbiAqIEBkZWZhdWx0IHtcbiAqIHdpZHRoOiAwLjAsXG4gKiBoZWlnaHQ6IDAuMCxcbiAqIGRlcHRoOiAwLDBcbiAqIH1cbiAqIS9cbmxldCBfcGl4ZWxTaXplID0ge1xuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICBkZXB0aDogbnVsbFxufTtcblxubGV0IF9zY2FsZTsqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHlFdmVudCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHR5cGUsXG4gICAgdGFyZ2V0LFxuICAgIG1hdHJpeCxcbiAgICBwaXhlbFNpemUsXG4gICAgc2NhbGVcbiAgKSB7XG4gICAgaWYgKCF0eXBlIHx8ICF0YXJnZXQpIHRocm93IG5ldyBFcnJvcignRW50aXR5RXZlbnQgcmVxdWlyZXMgYW4gZXZlbnQgdHlwZSBhbmQgZW50aXR5Jyk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4IHx8IG5ldyBNYXRyaXg0KCk7XG4gICAgdGhpcy5waXhlbFNpemUgPSBwaXhlbFNpemUgfHwge3dpZHRoOiAwLjAsIGhlaWdodDogMC4wLCBkZXB0aDogMC4wfTtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB9XG59XG5cbiIsImNvbnN0IEV2ZW50VHlwZSA9IHtcbiAgVFJBQ0tfU1RBUlQ6ICd0cmFja3N0YXJ0JyxcbiAgVFJBQ0tfTU9WRTogJ3RyYWNrbW92ZScsXG4gIFRSQUNLX0VORDogJ3RyYWNrZW5kJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRUeXBlO1xuIiwiaW1wb3J0IHtjb250ZXh0fSBmcm9tICcuLi9Db250ZXh0Jztcbi8vIGltcG9ydCB7ZXZlbnRNYW5hZ2VyfSBmcm9tICcuLi9ldmVudC9FdmVudE1hbmFnZXInO1xuLy8gaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi4vLi4vLi4vbWF0aC9WZWN0b3IzJztcbi8vIGltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4uLy4uLy4uL21hdGgvUXVhdGVybmlvbic7XG4vLyBpbXBvcnQgRXVsZXIgZnJvbSAnLi4vLi4vLi4vbWF0aC9FdWxlcic7XG5pbXBvcnQgTWF0cml4NCBmcm9tICcuLi9tYXRoL01hdHJpeDQnO1xuaW1wb3J0IEVudGl0eU9ic2VydmVyIGZyb20gJy4uL29ic2VydmVycy9vYnNlcnZlci9FbnRpdHlPYnNlcnZlcic7XG5cbmNvbnN0IF90eXBlID0gJ0xldHNlZVRocmVlJztcbmxldCBfaW5zdGFuY2UgPSBudWxsO1xubGV0IF9yZW5kZXJlciA9IG51bGw7XG5sZXQgX2NhbWVyYSA9IG51bGw7XG5sZXQgX3NjZW5lID0gbnVsbDtcbmxldCBfYXV0b1JlbmRlciA9IHRydWU7XG5jb25zdCBfY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5sZXQgTEVUU0VFX1RIUkVFID0gbnVsbDtcblxuY29uc3QgZW50aXR5R3JvdXAgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IHJlbmRlclNjZW5lID0gKGV2ZW50KSA9PiB7XG4gIGlmIChfYXV0b1JlbmRlcikge1xuICAgIC8vIHRoaXMuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgX3JlbmRlcmVyLnN0YXRlLnJlc2V0KCk7XG4gICAgX3JlbmRlcmVyLnJlbmRlcihfc2NlbmUsIF9jYW1lcmEpO1xuICAgIC8vIHRoaXMub25SZW5kZXJDYWxsYmFjayhldmVudCk7XG4gIH1cbn1cblxuY29uc3QgZ2V0VGhyZWVHcm91cCA9ICh1cmkpID0+IHtcbiAgaWYgKGVudGl0eUdyb3VwLmdldCh1cmkpID09IG51bGwpIHtcbiAgICBjb25zdCBncm91cCA9IG5ldyBMRVRTRUVfVEhSRUUuR3JvdXAoKTtcblxuICAgIGdyb3VwLm5hbWUgPSB1cmk7XG4gICAgZW50aXR5R3JvdXAuc2V0KHVyaSwgZ3JvdXApO1xuICAgIF9zY2VuZS5hZGQoZ3JvdXApO1xuICAgIHJldHVybiBncm91cDtcbiAgfVxuICByZXR1cm4gZW50aXR5R3JvdXAuZ2V0KHVyaSk7XG59O1xuXG5jb25zdCBfYWRkT2JqZWN0VG9FbnRpdHkgPSAodXJpLCBvYmplY3QpID0+IHtcbiAgY29uc3QgZ3JvdXAgPSBnZXRUaHJlZUdyb3VwKHVyaSk7XG5cbiAgZ3JvdXAuYWRkKG9iamVjdCk7XG59O1xuY29uc3QgcmVtb3ZlT2JqZWN0RnJvbUVudGl0eSA9ICh1cmksIG9iamVjdCkgPT4ge1xuICBpZiAodGhpcy5vYmplY3RzW3VyaV0pIHtcbiAgICB0aGlzLm9iamVjdHNbdXJpXS5yZW1vdmUob2JqZWN0KTtcblxuICAgIGlmICh0aGlzLm9iamVjdHNbdXJpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9iamVjdHNbdXJpXTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgb25UcmFja1N0YXJ0Q2FsbGJhY2sgPSAoZSkgPT4ge31cbmNvbnN0IG9uVHJhY2tNb3ZlQ2FsbGJhY2sgPSAoZSkgPT4ge31cbmNvbnN0IG9uVHJhY2tFbmRDYWxsYmFjayA9IChlKSA9PiB7fVxuXG5jb25zdCBvblRyYWNrTW92ZSA9IChlKSA9PiB7XG4gIGlmIChlbnRpdHlHcm91cC5nZXQoZS50YXJnZXQudXJpKSAhPSBudWxsKSB7XG5cbiAgICAvLyBjb25zdCBvYmplY3QgPSB0aGlzLm9iamVjdHNbZS50YXJnZXQudXJpXTtcbiAgICAvLyBjb25zdCBncm91cCA9IHRoaXMuZ2V0VGhyZWVHcm91cChlLnRhcmdldC51cmkpO1xuICAgIGNvbnN0IGdyb3VwID0gZW50aXR5R3JvdXAuZ2V0KGUudGFyZ2V0LnVyaSk7XG5cbiAgICBncm91cC5tYXRyaXguY29tcG9zZShncm91cC5wb3NpdGlvbiwgZ3JvdXAucXVhdGVybmlvbiwgZ3JvdXAuc2NhbGUpO1xuICAgIGdyb3VwLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIC8vIGUuZXZlbnQgd2FzIGRpc3BhdGNoZWQgZnJvbSBPYmplY3RUcmFja2VyLlxuICAgIC8vIEludmVydCBYIGF4aXMgd2FzIGFscmVhZHkgYXBwbGllZCBhdCBPYmplY3RUcmFja2VyXG4gICAgY29uc3QgbWF0cml4ID0gZS5tYXRyaXg7XG5cbiAgICBtYXRyaXguZGVjb21wb3NlKFxuICAgICAgX2NhbWVyYS5wb3NpdGlvbixcbiAgICAgIF9jYW1lcmEucXVhdGVybmlvbixcbiAgICAgIF9jYW1lcmEuc2NhbGVcbiAgICApO1xuICAgIF9jYW1lcmEudXBkYXRlTWF0cml4KCk7XG4gICAgY29uc3QgdG1wID0gbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKF9jYW1lcmEubWF0cml4KTtcblxuICAgIF9jYW1lcmEubWF0cml4LmlkZW50aXR5KCk7XG4gICAgX2NhbWVyYS5hcHBseU1hdHJpeCh0bXApO1xuICAgIF9jYW1lcmEudXBkYXRlTWF0cml4KCk7XG5cbiAgICBfY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgX2NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZShfY2FtZXJhLm1hdHJpeFdvcmxkKTtcblxuICAgIGdyb3VwLnZpc2libGUgPSB0cnVlO1xuICAgIHJlbmRlclNjZW5lKGUpO1xuICAgIG9uVHJhY2tNb3ZlQ2FsbGJhY2soZSk7XG4gIH1cbn07XG5jb25zdCBvblRyYWNrU3RhcnQgPSAoZSkgPT4ge1xuICBpZiAoZW50aXR5R3JvdXAuZ2V0KGUudGFyZ2V0LnVyaSkgIT0gbnVsbCkgZW50aXR5R3JvdXAuZ2V0KGUudGFyZ2V0LnVyaSkudmlzaWJsZSA9IHRydWU7XG4gIHJlbmRlclNjZW5lKGUpO1xuICBvblRyYWNrU3RhcnRDYWxsYmFjayhlKTtcbn07XG5jb25zdCBvblRyYWNrRW5kID0gKGUpID0+IHtcbiAgaWYgKGVudGl0eUdyb3VwLmdldChlLnRhcmdldC51cmkpICE9IG51bGwpIGVudGl0eUdyb3VwLmdldChlLnRhcmdldC51cmkpLnZpc2libGUgPSBmYWxzZTtcbiAgcmVuZGVyU2NlbmUoZSk7XG4gIG9uVHJhY2tFbmRDYWxsYmFjayhlKTtcbn07XG5cbmNvbnN0IGluaXQgPSAoY2FtZXJhUGFyYW0sIHpJbmRleCwgekluZGV4SW5jcmVtZW50KSA9PiB7XG4gIExFVFNFRV9USFJFRSA9IHdpbmRvdy5USFJFRTtcbiAgX2NhbnZhcy5jbGFzc05hbWUgPSAnYXItcmVuZGVyZXInO1xuICBfY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgX2NhbnZhcy5zdHlsZS50b3AgPSAwO1xuICBfY2FudmFzLnN0eWxlLmxlZnQgPSAwO1xuICBfY2FudmFzLnN0eWxlLm1hcmdpbiA9IDA7XG4gIF9jYW52YXMuc3R5bGUucGFkZGluZyA9IDA7XG4gIF9jYW52YXMuc3R5bGUuekluZGV4ID0gekluZGV4ICsgekluZGV4SW5jcmVtZW50O1xuICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShfY2FudmFzLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICBfY2FtZXJhID0gbmV3IExFVFNFRV9USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSguLi5jYW1lcmFQYXJhbSk7XG4gIF9zY2VuZSA9IG5ldyBMRVRTRUVfVEhSRUUuU2NlbmUoKTtcbiAgX3JlbmRlcmVyID0gbmV3IExFVFNFRV9USFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICBjYW52YXM6IF9jYW52YXNcbiAgfSk7XG4gIF9jYW1lcmEubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICBfY2FtZXJhLmxvb2tBdChfc2NlbmUucG9zaXRpb24pO1xuICBfcmVuZGVyZXIuc2V0U2l6ZShjb250ZXh0LnNjcmVlbldpZHRoLCBjb250ZXh0LnNjcmVlbkhlaWdodCk7XG4gIF9zY2VuZS5hZGQoX2NhbWVyYSk7XG5cbiAgLy8gZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrbW92ZScsIChlKSA9PiBvblRyYWNrTW92ZShlKSk7XG4gIC8vIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFja3N0YXJ0JywgKGUpID0+IG9uVHJhY2tTdGFydChlKSk7XG4gIC8vIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFja2VuZCcsIChlKSA9PiBvblRyYWNrRW5kKGUpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExldHNlZVRocmVlIGV4dGVuZHMgRW50aXR5T2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihwYXJhbSwgekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghd2luZG93LlRIUkVFKSB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFIGlzIG5vdCBkZWZpbmRlZC4gcGxlYXNlIGltcG9ydCB0aHJlZS5qcyBsaWJyYXJ5LicpO1xuICAgIGlmIChfaW5zdGFuY2UpIHJldHVybiBfaW5zdGFuY2U7XG4gICAgaW5pdChwYXJhbSwgekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpO1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoJ3RyYWNrbW92ZScsIChlKSA9PiBvblRyYWNrTW92ZShlKSk7XG4gICAgdGhpcy5zdWJzY3JpYmUoJ3RyYWNrc3RhcnQnLCAoZSkgPT4gb25UcmFja1N0YXJ0KGUpKTtcbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2tlbmQnLCAoZSkgPT4gb25UcmFja0VuZChlKSk7XG5cbiAgICBfaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIF90eXBlO1xuICB9XG5cbiAgZ2V0IGNhbWVyYSgpIHtcbiAgICByZXR1cm4gX2NhbWVyYTtcbiAgfVxuXG4gIGdldCBzY2VuZSgpIHtcbiAgICByZXR1cm4gX3NjZW5lO1xuICB9XG5cbiAgYWRkT2JqZWN0VG9FbnRpdHkodXJpLCBvYmplY3QpIHtcbiAgICBfYWRkT2JqZWN0VG9FbnRpdHkodXJpLCBvYmplY3QpO1xuICB9XG5cbiAgZW50aXR5R3JvdXAodXJpKSB7XG4gICAgaWYgKGVudGl0eUdyb3VwLmdldCh1cmkpID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZW50aXR5IGdyb3VwIGZvdW5kZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eUdyb3VwLmdldCh1cmkpO1xuICB9XG5cbiAgcmVtb3ZlT2JqZWN0RnJvbUVudGl0eSh1cmksIG9iamVjdCkge1xuICAgIHJlbW92ZU9iamVjdEZyb21FbnRpdHkodXJpLCBvYmplY3QpO1xuICB9XG5cbiAgdXBkYXRlT3JpZW50YXRpb24obmV3Q29uZmlnKSB7XG4gICAgX3JlbmRlcmVyLnNldFNpemUobmV3Q29uZmlnLndpZHRoLCBuZXdDb25maWcuaGVpZ2h0KTtcbiAgICBfY2FtZXJhLmFzcGVjdCA9IG5ld0NvbmZpZy5hc3BlY3Q7XG4gICAgX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHtMRVRTRUVfRVZFTlR9IGZyb20gJy4vbGlicy9NZXNzYWdlVHlwZXMnO1xuaW1wb3J0IHtjcmVhdGVMb2FkZXIsIGlzTmlsfSBmcm9tICcuL1V0aWwnO1xuaW1wb3J0IExldHNlZVByaXZhdGUsIHtcbiAgYWRkUmVuZGVyTW9kdWxlIGFzIF9hZGRSZW5kZXJNb2R1bGUsXG4gIHJlbW92ZVJlbmRlck1vZHVsZSBhcyBfcmVtb3ZlUmVuZGVyTW9kdWxlLFxuICByZW5kZXJNb2R1bGVzIGFzIF9yZW5kZXJNb2R1bGVzLFxuICByZXNldFJlbmRlck1vZHVsZXMgYXMgX3Jlc2V0UmVuZGVyTW9kdWxlc1xufSBmcm9tICcuL0xldHNlZSc7XG5pbXBvcnQgTGV0c2VlRXZlbnQgZnJvbSAnLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvTGV0c2VlT2JzZXJ2ZXInO1xuXG5sZXQgX2xldHNlZSA9IG51bGw7XG5sZXQgX2N1cnJlbnRQYXVzZVN0YXR1cyA9IGZhbHNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5sZXQgX2hpZGVTY3JlZW4gPSBmYWxzZTtcbmNvbnN0IGxldHNlZUV2ZW50ID0gbmV3IExldHNlZUV2ZW50KCk7XG5jb25zdCBWRVJTSU9OID0gJzAuOS4yMC4wMDI4JztcbmNvbnN0IFZFUlNJT05fU1RSSU5HID0gKF9fREVWX18pID8gKF9fTE9DQUxfXykgPyBgVkVSU0lPTjogJHtWRVJTSU9OfV9sb2NhbGAgOiBgVkVSU0lPTjogJHtWRVJTSU9OfV9kZXZgIDogYFZFUlNJT046ICR7VkVSU0lPTn1gOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHR5cGVkZWYgeyhcIklNQUdFXCJ8XCJNQVJLRVJcInxcIlFSQ09ERVwiKX0gVHJhY2tlclR5cGUgLSDsgqzsmqkg6rCA64ql7ZWcIO2KuOuemey7pCDtg4DsnoVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEVudGl0eUV2ZW50XG4gKiBAcHJvcGVydHkge1widHJhY2tzdGFydFwifFwidHJhY2ttb3ZlXCJ8XCJ0cmFja2VuZFwifSB0eXBlIC0g7ZiE7J6sIO2KuOueme2CuSDsg4Htg5xcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtYXRyaXhcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdHJpeC5lbGVtZW50c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlXG4gKiBAcHJvcGVydHkge29iamVjdH0gcGl4ZWxTaXplXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxTaXplLndpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGl4ZWxTaXplLmhlaWdodFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsU2l6ZS5kZXB0aFxuICogQHByb3BlcnR5IHsoXCJtbVwiKX0gcGl4ZWxTaXplLnVuaXRcbiAqIEBwcm9wZXJ0eSB7RW50aXR5fSB0YXJnZXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IExldHNlZVN0YXR1c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgLSDsg4Htg5wg7L2U65OcXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSAtIOyDge2DnCDrqZTshLjsp4BcbiAqIEBkZXNjcmlwdGlvblxuICogTGV0c2VlU3RhdHVz64qUIExldHNlZSBFbmdpbmUg7J6R64+Z7KSRIOuwnOyDne2VmOuKlCDqsIHsooUg7IOB7YOcIOuzgOqyveydtOuCmCDsmIjsmbgg7IOB7Zmp7J2EIOygleydmO2VnCDsvZTrk5zrpbwg64KY7YOA64OF64uI64ukLlxuICog7IOB7YOcIOy9lOuTnOyZgCDshKTrqoUg66mU7Iuc7KeA64qUIOyVhOuemOydmCDtkZzsmYAg6rCZ7Iq164uI64ukLlxuICpcbiAqIHxDT0RFIHxNRVNTQUdFICB8XG4gKiB8LS0tXHR8LS0tXHR8XG4gKiB8MTAxICB8IFVzZSBjaHJvbWUgd2l0aCBpb3N8XG4gKiB8MTAyICB8IFVuc3VwcG9ydGVkIGJyb3dzZXJ8XG4gKiB8MTAzICB8IE5vIGNhbWVyYSBkZXRlY3RlZHxcbiAqIHwxMDQgIHwgTm8gbW9iaWxlIGRldmljZSBkZXRlY3RlZHxcbiAqIHwyMDAgIHwgQ2FtZXJhIGluaXRpYWxpemUgc3RhcnR8XG4gKiB8MjAxICB8IENhbWVyYSBpbml0aWFsaXplIGRvbmV8XG4gKiB8MjAyICB8IFZpZGVvIHN0YXJ0fFxuICovXG5cbi8qKlxuICogTGV0c2VlIOqwneyytOulvCDsg53shLHtlanri4jri6QuXG4gKiBAY2xhc3NcbiAqIEBuYW1lIExldHNlZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIOugm+yLnCDsvZjtlLzqt7hcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb25maWcuYXBwS2V5IC0gTGV0c2VlIFdlYiBBUiBTREsg7J247KadIO2CpFxuICogQHBhcmFtIHtUcmFja2VyVHlwZX0gY29uZmlnLnRyYWNrZXJUeXBlIC0g7Yq4656Z7LukIO2DgOyehVxuICogQHJldHVybnMge0xldHNlZX1cbiAqL1xuXG5jbGFzcyBMZXRzZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoX19ERVZfXyB8fCBfX0xPQ0FMX18pIHtcblxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnXFxuJyArXG4gICAgICAgICcgICAg4paT4paI4paI4paI4paI4paI4paEICDiloTiloTiloQgICAgICAg4paI4paI4paI4paEICAgIOKWiCAgIOKWhOKWiOKWiOKWiOKWiCDilpPilojilojilojilojiloggIOKWiOKWiOKWgOKWiOKWiOKWiCAgIOKWkOKWiOKWiOKWjCBcXG4nICtcbiAgICAgICAgJyAgICDilpLilojilojiloAg4paI4paI4paM4paS4paI4paI4paI4paI4paEICAgICDilojilogg4paA4paIICAg4paIICDilojilojilpIg4paA4paI4paS4paT4paIICAg4paAIOKWk+KWiOKWiCDilpIg4paI4paI4paSIOKWkOKWiOKWiOKWjCBcXG4nICtcbiAgICAgICAgJyAgICDilpHilojiloggICDilojilozilpLilojiloggIOKWgOKWiOKWhCAg4paT4paI4paIICDiloDilogg4paI4paI4paS4paS4paI4paI4paR4paE4paE4paE4paR4paS4paI4paI4paIICAg4paT4paI4paIIOKWkeKWhOKWiCDilpIg4paQ4paI4paI4paMIFxcbicgK1xuICAgICAgICAnICAgIOKWkeKWk+KWiOKWhCAgIOKWjOKWkeKWiOKWiOKWhOKWhOKWhOKWhOKWiOKWiCDilpPilojilojilpIgIOKWkOKWjOKWiOKWiOKWkuKWkeKWk+KWiCAg4paI4paI4paT4paS4paT4paIICDiloQg4paS4paI4paI4paA4paA4paI4paEICAg4paT4paI4paI4paSIFxcbicgK1xuICAgICAgICAnICAgIOKWkeKWkuKWiOKWiOKWiOKWiOKWkyAg4paT4paIICAg4paT4paI4paI4paS4paS4paI4paI4paRICAg4paT4paI4paI4paR4paR4paS4paT4paI4paI4paI4paA4paS4paR4paS4paI4paI4paI4paI4paS4paR4paI4paI4paTIOKWkuKWiOKWiOKWkiDilpLiloTiloQgIFxcbicgK1xuICAgICAgICAnICAgIOKWkuKWkuKWkyAg4paSICDilpLilpIgICDilpPilpLilojilpHilpEg4paS4paRICAg4paSIOKWkiAg4paR4paSICAg4paSIOKWkeKWkSDilpLilpEg4paR4paRIOKWkuKWkyDilpHilpLilpPilpEg4paR4paA4paA4paSICBcXG4nICtcbiAgICAgICAgJyAgICDilpEg4paSICDilpIgICDilpIgICDilpLilpIg4paR4paRIOKWkeKWkSAgIOKWkSDilpLilpEgIOKWkSAgIOKWkSAg4paRIOKWkSAg4paRICDilpHilpIg4paRIOKWkuKWkSDilpEgIOKWkSAgXFxuJyArXG4gICAgICAgICcgICAg4paRIOKWkSAg4paRICAg4paRICAg4paSICAgICAg4paRICAg4paRIOKWkSDilpEg4paRICAg4paRICAgIOKWkSAgICAg4paR4paRICAg4paRICAgICDilpEgIFxcbicgK1xuICAgICAgICAnICAgIOKWkSAgICAgICAgICDilpEgIOKWkSAgICAgICAgIOKWkSAgICAgICDilpEgICAg4paRICDilpEgICDilpEgICAgICDilpEgICAgICAgXFxuJyArXG4gICAgICAgICcgICAg4paRICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcbicgK1xuICAgICAgICAnXFxuJyArXG4gICAgICAgICdcXG4nXG4gICAgICApO1xuICAgICAgY29uc29sZS53YXJuKGBbU0VDVVJJVFkgTk9USUNFXSBUaGlzIGlzICckeyhfX0xPQ0FMX18pID8gJ0xvY2FsJyA6ICdEZXZlbG9wbWVudCd9JyB2ZXJzaW9uLiBVU0UgU0FGRUxZLiBTREsgVmVyc2lvbjogJHtWRVJTSU9OfWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdMZXRzZWUhJyk7XG4gIH1cblxuICBpbml0KGNvbmZpZywgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKF9sZXRzZWUpIHRocm93IG5ldyBFcnJvcignTGV0c2VlIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XG4gICAgX2xldHNlZSA9IG5ldyBMZXRzZWVQcml2YXRlKGNvbmZpZyk7XG4gICAgX2xldHNlZS5pbml0KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayBtdXN0IGJlIGZ1bmN0aW9uJyk7XG4gICAgICAgIGVsc2UgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0xldHNlZSBsb2FkZWQhJyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHBhdXNlKHZhbCA9IGZhbHNlKSB7XG4gICAgaWYgKF9jdXJyZW50UGF1c2VTdGF0dXMpIHJldHVybiBmYWxzZTtcbiAgICBfaGlkZVNjcmVlbiA9IHZhbDtcbiAgICBfY3VycmVudFBhdXNlU3RhdHVzID0gdHJ1ZTtcbiAgICBpZiAodmFsKSBfbGV0c2VlLmVuZ2luZS5yZXNldERvbVJlbmRlcmFibGUoKTtcbiAgICByZXR1cm4gX2xldHNlZS5wYXVzZSh2YWwpO1xuICB9XG5cbiAgcmVzdW1lKCkge1xuICAgIGlmICghX2N1cnJlbnRQYXVzZVN0YXR1cykgcmV0dXJuIGZhbHNlO1xuICAgIF9jdXJyZW50UGF1c2VTdGF0dXMgPSBmYWxzZTtcbiAgICBpZiAoX2hpZGVTY3JlZW4pIF9sZXRzZWUuZW5naW5lLmFwcGVuZEFsbERvbVJlbmRlcmFibGVzKCk7XG4gICAgcmV0dXJuIChfaGlkZVNjcmVlbikgPyBfbGV0c2VlLnJlc3VtZSh0cnVlKSA6IF9sZXRzZWUucmVzdW1lKCk7XG4gIH1cblxuICBnZXQgaXNQYXVzZSgpIHtcbiAgICByZXR1cm4gX2xldHNlZS5pc1BhdXNlO1xuICB9XG5cbiAgLy8gRGlzcGF0Y2ggYXQgcmVuZGVyXG4gIC8vIG9uUmVuZGVyKGNhbGxiYWNrKSB7fVxuXG4gIC8vIERpc3BhdGNoIGF0IGFwcCByZXN1bWVkXG4gIC8vIG9uUmVzdW1lKGNhbGxiYWNrKSB7fVxuXG4gIC8vIERpc3BhdGNoIGF0IGFwcCBzdGFydGVkXG4gIC8vIG9uU3RhcnQoY2FsbGJhY2spIHt9XG5cbiAgLy8gRGlzcGF0Y2ggYXQgYXBwXG4gIC8vIG9uUGF1c2VkKGNhbGxiYWNrKSB7fVxuXG4gIC8vIERpc3BhdGNoIGJlZm9yZSByZW5kZXJcbiAgLy8gb25VcGRhdGUoY2FsbGJhY2spIHt9XG4gIC8qKlxuICAgKiDroJvsi5wg7JeU7KeE7J20IOyLnOyekeuQnCDtm4Tsl5Ag7KCE64us65Cp64uI64ukLiBgb25sb2FkYOydtOuypO2KuOydmCDsiI/su7cg7J6F64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNvbkxvYWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uTG9hZChjYWxsYmFjaykge1xuICAgIGxldHNlZUV2ZW50LnN1YnNjcmliZShMRVRTRUVfRVZFTlQuT05fTE9BRCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIOymneqwlSDrjIDsg4HsnZgg7Yq4656Z7YK5IOyLnOyekeqzvCDtlajqu5gg7KCE64us65CY64qUIOydtOuypO2KuCDsnoXri4jri6QuIGB0cmFja3N0YXJ0YCDsnbTrsqTtirjsnZgg7IiP7Lu3IOyeheuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25UcmFja1N0YXJ0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RW50aXR5RXZlbnR9IGNhbGxiYWNrLmV2ZW50XG4gICAqL1xuICBvblRyYWNrU3RhcnQoY2FsbGJhY2spIHtcbiAgICBsZXRzZWVFdmVudC5zdWJzY3JpYmUoTEVUU0VFX0VWRU5ULlRSQUNLX1NUQVJULCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICog7Kad6rCVIOuMgOyDgeydmCDtirjrnpntgrnspJEg7KCE64us65CY64qUIOydtOuypO2KuCDsnoXri4jri6QuIGB0cmFja21vdmVgIOydtOuypO2KuOydmCDsiI/su7cg7J6F64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNvblRyYWNrTW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0VudGl0eUV2ZW50fSBjYWxsYmFjay5ldmVudFxuICAgKi9cbiAgb25UcmFja01vdmUoY2FsbGJhY2spIHtcbiAgICBsZXRzZWVFdmVudC5zdWJzY3JpYmUoTEVUU0VFX0VWRU5ULlRSQUNLX01PVkUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDspp3qsJUg64yA7IOB7J2YIO2KuOueme2CueydtCDrqYjstpTrqbQg7KCE64us65CY64qUIOydtOuypO2KuCDsnoXri4jri6QuIGB0cmFja2VuZGAg7J2067Kk7Yq47J2YIOyIj+y7tyDsnoXri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI29uVHJhY2tFbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtFbnRpdHlFdmVudH0gY2FsbGJhY2suZXZlbnRcbiAgICovXG4gIG9uVHJhY2tFbmQoY2FsbGJhY2spIHtcbiAgICBsZXRzZWVFdmVudC5zdWJzY3JpYmUoTEVUU0VFX0VWRU5ULlRSQUNLX0VORCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIOugm+yLnCDqsJ3ssrTsnZgg7IOB7YOc66W8IOyghOuLrO2VmOuKlCDsnbTrsqTtirgg7J6F64uI64ukLiAuIGBhcHBfc3RhdHVzYCDsnbTrsqTtirjsnZgg7IiP7Lu3IOyeheuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25TdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtMZXRzZWVTdGF0dXN9IGNhbGxiYWNrLmV2ZW50XG4gICAqL1xuICBvblN0YXR1cyhjYWxsYmFjaykge1xuICAgIGxldHNlZUV2ZW50LnN1YnNjcmliZShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICog6riw6riw7J2YIOqwgOuhnC/shLjroZwg67OA7ZmYIO2bhCDsoITri6zrkJjripQg7J2067Kk7Yq4IOyeheuLiOuLpC4gd2luZG937J2YIGBvcmllbnRhdGlvbmNoYW5nZWAg7J2067Kk7Yq47JmA64qUIOuLrOumrCDtmZTrqbQg67Cp7ZalIOyghO2ZmOyXkOuUsOuluCBMZXRzZWUg64K067aA7J2YIOyXsOyCsOydtCDsmYTro4zrkJwg7ZuEIOyghOuLrOuQqeuLiOuLpC5cbiAgICog7L2c67Cx7J2AIHdpbmRvd+ydmCBgb3JpZW50YXRpb25jaGFuZ2Vg7JmAIOuPmeydvO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjb25PcmllbnRhdGlvbkNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2V2ZW50fSBjYWxsYmFjay5ldmVudFxuICAgKi9cbiAgb25PcmllbnRhdGlvbkNoYW5nZShjYWxsYmFjaykge1xuICAgIGxldHNlZUV2ZW50LnN1YnNjcmliZShMRVRTRUVfRVZFTlQuUk9UQVRJT05fQ0hBTkdFLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTGV0c2VlIOqwneyytOyXkCDsnbTrsqTtirjrpbwg65Ox66Gd7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNhZGRFdmVudExpc3RlbmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBFdmVudFR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtldmVudH0gY2FsbGJhY2suZXZlbnRcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICBsZXRzZWVFdmVudC5zdWJzY3JpYmUodHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIExldHNlZSDqsJ3ssrTsl5DshJwg7J2067Kk7Yq466W8IOyCreygnO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgKiBAcGFyYW0ge3N0cmluZ30gRXZlbnRUeXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICBsZXRzZWVFdmVudC51bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICog7Luk7Iqk7YWAIOuhnOuUqSDtmZTrqbTsnYQg65Ox66Gd7ZWp64uI64ukLiDsoITri6zrkJwgaHRtbCDshozsiqTripQgYGlkPWxldHNlZUxvYWRlcldyYXBwZXJg7J24IGBkaXZg7YOc6re47JeQIOy2lOqwgOuQqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjc2V0TG9hZGluZ1NjcmVlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCAtIOyCrOyaqe2VoCDroZzrlKkg7ZmU66m07J2YIGh0bWwg7L2U65OcXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNzcyAtIOyeheugpe2VnCBodG1s7L2U65Oc66W8IOychO2VnCBjc3NcbiAgICogQGV4YW1wbGVcbiAgICogLy8gc3RyaW5n7ZiV7YOc66GcIGh0bWzsvZTrk5zrpbwg7IOd7ISx7ZWp64uI64ukLlxuICAgKiBjb25zdCBjdXN0b21Mb2FkZXIgPSBcIjxwPjxzcGFuPkxvYWRpbmcuLi48L3NwYW4+PC9wPlwiO1xuICAgKiAvLyBjc3Prpbwgc3RyaW5n7Jy866GcIOyDneyEse2VmOqzoCBBcnJheeyXkCDri7TsirXri4jri6QuXG4gICAqIGNvbnN0IGN1c3RvbUxvYWRlckNzcyA9IFtcbiAgICogYCNsZXRzZWVMb2FkZXJXcmFwcGVyIHAge1xuICAgKiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAqICAgIGxlZnQ6IDUwJTtcbiAgICogICAgdG9wOiA1MCU7XG4gICAqICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgKiAgfWAsXG4gICAqIGAjbGV0c2VlTG9hZGVyV3JhcHBlciBwIHNwYW4ge1xuICAgKiAgICBjb2xvcjogIzY2NjY2NjtcbiAgICogfWBdO1xuICAgKiAvLyBodG1s6rO8IGNzc+ulvCDrk7HroZ3tlanri4jri6QuXG4gICAqIG15QXBwLnNldExvYWRpbmdTY3JlZW4oY3VzdG9tTG9hZGVyLCBjdXN0b21Mb2FkZXJDc3MpO1xuICAgKi9cbiAgc2V0TG9hZGluZ1NjcmVlbihodG1sLCBjc3MpIHtcbiAgICBpZiAoISFodG1sICYmICEhY3NzKSBjcmVhdGVMb2FkZXIoaHRtbCwgY3NzKTtcbiAgICBlbHNlIGNvbnNvbGUubG9nKCdZb3UgbmVlZCBzZXR1cCBib3RoIGh0bWwgYW5kIGNzcycpO1xuICB9XG5cbiAgLyoqXG4gICAqIOugjOuNlOungeyLnOyXkCDsnpHrj5ntlaAg7Luk7Iqk7YWAIOuqqOuTiOydhCDrk7HroZ3tlanri4jri6QuIOuTseuhneuQnCDrqqjrk4jsnYAgTGV0c2Vl7J2YIOugjOuNlOungSDro6jtlITsl5Ag66ee7LaU7Ja0IOyLpO2WieuQqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjYWRkUmVuZGVyTW9kdWxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtb2R1bGVPYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU9iamVjdC5uYW1lIC0g7Luk7Iqk7YWAIOuqqOuTiOydmCDsnbTrpoTsnoXri4jri6QuIOycoOuLiO2BrO2VmOyXrOyVvCDtlanri4jri6QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZHVsZU9iamVjdC5vblJlbmRlciAtIOyLpO2WieuQoCDroIzrjZQg66qo65OIIOyeheuLiOuLpC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vZHVsZU9iamVjdC5vblJlbmRlci50aWNrIC0gbXPri6jsnITroZwg67CY7ZmY65CY64qUIOyLnOqwhOyeheuLiOuLpC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGN1c3RvbU1vZHVsZSA9ICh0aWNrKSA9PiBjb25zb2xlLmxvZyh0aWNrKTtcbiAgICogbXlBcHAuYWRkUmVuZGVyTW9kdWxlKHtcbiAgICogICAgIG5hbWU6ICdteUN1c3RvbU1vZHVsZScsXG4gICAqICAgICBvblJlbmRlcjogY3VzdG9tTW9kdWxlXG4gICAqIH0pO1xuICAgKi9cbiAgYWRkUmVuZGVyTW9kdWxlKG1vZHVsZU9iamVjdCkgeyAvLyBzdWJzY3JpYmVcbiAgICByZXR1cm4gX2FkZFJlbmRlck1vZHVsZShtb2R1bGVPYmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIO2VtOuLuSDsnbTrpoTsnYQg6rCA7KeEIOugjOuNlCDrqqjrk4jsnYQg7IKt7KCc7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNyZW1vdmVSZW5kZXJNb2R1bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSDsgq3soJztlZjqs6DsnpAg7ZWY64qUIOuqqOuTiCDsnbTrpoRcbiAgICovXG4gIHJlbW92ZVJlbmRlck1vZHVsZShuYW1lKSB7XG4gICAgcmV0dXJuIF9yZW1vdmVSZW5kZXJNb2R1bGUobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICog65Ox66Gd65CcIOuqqOuToCDroIzrjZQg66qo65OI7J2EIOyCreygnO2VqeuLiOuLpC5cbiAgICogQG1ldGhvZCBMZXRzZWUjcmVzZXRSZW5kZXJNb2R1bGVzXG4gICAqL1xuICByZXNldFJlbmRlck1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIF9yZXNldFJlbmRlck1vZHVsZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiDrk7HroZ3rkJwg66CM642UIOuqqOuTiOydhCDrsJjtmZjtlanri4jri6QuXG4gICAqIEBtZW1iZXIge0FycmF5fSBMZXRzZWUjcmVuZGVyTW9kdWxlXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlbmRlck1vZHVsZXMoKSB7XG4gICAgcmV0dXJuIF9yZW5kZXJNb2R1bGVzKCk7XG4gIH1cblxuICAvKipcbiAgICog65Ox66Gd65CcIOuqqOuToCDsl5TthLDti7Drpbwg67CY7ZmY7ZWp64uI64ukLlxuICAgKiBAbWV0aG9kIExldHNlZSNnZXRFbnRpdGllc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBnZXRBbGxFbnRpdGllcygpIHtcbiAgICByZXR1cm4gKGlzTmlsKF9sZXRzZWUpKSA/IG5ldyBFcnJvcignUnVuIGxldHNlZS5pbml0IGZpcnN0JykgOiBfbGV0c2VlLmVuZ2luZS5nZXRFbnRpdGllcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIOyjvOyWtOynhCB1cmnrpbwg6rCA7KeEIOyXlO2EsO2LsOulvCDrsJjtmZjtlanri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI2dldEVudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqIEByZXR1cm5zIHtFbnRpdHl9IEVudGl0eVxuICAgKi9cbiAgZ2V0RW50aXR5KHVyaSkge1xuICAgIHJldHVybiAoaXNOaWwoX2xldHNlZSkpID8gbmV3IEVycm9yKCdSdW4gbGV0c2VlLmluaXQgZmlyc3QnKSA6IF9sZXRzZWUuZW5naW5lLmdldEVudGl0eSh1cmkpO1xuICB9XG5cbiAgLyoqXG4gICAqIOyngOygleuQnCB1cmnrpbwg6rCA7KeEIOyXlO2EsO2LsOulvCDsgq3soJztlanri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI3JlbW92ZUVudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqL1xuICByZW1vdmVFbnRpdHkodXJpKSB7XG4gICAgcmV0dXJuIChpc05pbChfbGV0c2VlKSkgPyBuZXcgRXJyb3IoJ1J1biBsZXRzZWUuaW5pdCBmaXJzdCcpIDogX2xldHNlZS5lbmdpbmUucmVtb3ZlRW50aXR5KHVyaSk7XG4gIH1cblxuICAvKipcbiAgICog7KeA7KCV65CcIHVyaeulvCDqsIDsp4Qg7JeU7YSw7Yuw6rCAIOyeiOuKlOyngCDtmZXsnbjtlanri4jri6QuXG4gICAqIEBtZXRob2QgTGV0c2VlI2hhc0VudGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzRW50aXR5KHVyaSkge1xuICAgIHJldHVybiAoaXNOaWwoX2xldHNlZSkpID8gbmV3IEVycm9yKCdSdW4gbGV0c2VlLmluaXQgZmlyc3QnKSA6IF9sZXRzZWUuZW5naW5lLmhhc0VudGl0eSh1cmkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRocmVlLmpz7J2YIGBXZWJnbFJlbmRlcmVyYOulvCDst6jrk53tlanri4jri6QuXG4gICAqIEBtZW1iZXIge1RIUkVFLldlYmdsUmVuZGVyZXJ9IExldHNlZSN0aHJlZVJlbmRlcmVyXG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHRocmVlUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIChpc05pbChfbGV0c2VlKSkgPyBuZXcgRXJyb3IoJ1J1biBsZXRzZWUuaW5pdCBmaXJzdCcpIDogX2xldHNlZS5lbmdpbmUudGhyZWVSZW5kZXJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiDrlJTrsJTsnbTsiqQg7KCV67O066W8IOuwmO2ZmO2VqeuLiOuLpC5cbiAgICogQG1lbWJlciB7b2JqZWN0fSBMZXRzZWUjZGV2aWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGRldmljZSgpIHtcbiAgICByZXR1cm4gKGlzTmlsKF9sZXRzZWUpKSA/IG5ldyBFcnJvcignUnVuIGxldHNlZS5pbml0IGZpcnN0JykgOiBfbGV0c2VlLnZpZGVvTWFuYWdlci5zY3JlZW5JbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIExldHNlZSBXZWIgQVIgU0RL7J2YIOuyhOyghOydhCDrsJjtmZjtlanri4jri6QuXG4gICAqIEBtZW1iZXIge3N0cmluZ30gTGV0c2VlI3ZlcnNpb25cbiAgICogQHJlYWRvbmx5XG4gICAqL1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gVkVSU0lPTl9TVFJJTkc7XG4gIH1cblxuICBnZXQgY3NzU2VsZWN0b3IoKSB7XG4gICAgaWYgKGlzTmlsKF9sZXRzZWUpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdSdW4gbGV0c2VlLmluaXQgZmlyc3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHlJZDogX2xldHNlZS5jb25maWcuYm9keUlkLFxuICAgICAgZG9tUmVuZGVyZXJJZDogX2xldHNlZS5jb25maWcuZG9tUmVuZGVyZXJJZCxcbiAgICAgIHZpZGVvSWQ6IF9sZXRzZWUuY29uZmlnLnZpZGVvSWRcbiAgICB9O1xuICB9XG5cbiAgc2V0VmlkZW9Tb3VyY2Uoc3JjKSB7XG4gICAgcmV0dXJuIF9sZXRzZWUudmlkZW9NYW5hZ2VyLnNldFZpZGVvU291cmNlKHNyYyk7XG4gIH1cblxuICByZXF1ZXN0RnVsbHNjcmVlbigpIHtcbiAgICBfbGV0c2VlLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH07XG5cbiAgZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgX2xldHNlZS5leGl0RnVsbHNjcmVlbigpO1xuICB9XG4gIFxuICBnZXRTb3VyY2VEZXZpY2VMaXN0KCkge1xuICAgIHJldHVybiBfbGV0c2VlLnZpZGVvTWFuYWdlci5nZXRTb3VyY2VEZXZpY2VMaXN0KCk7XG4gIH1cbn1cblxuLy8gZXhwb3J0IGRlZmF1bHQgTGV0c2VlO1xuZXhwb3J0IGNvbnN0IGxldHNlZSA9IG5ldyBMZXRzZWUoKTtcbndpbmRvdy5sZXRzZWUgPSBsZXRzZWU7XG5cbi8vIGV4cG9ydCBoZWxwZXIgY2xhc3Nlc1xuaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi9tYXRoL01hdHJpeDQnO1xuaW1wb3J0IE1hdHJpeDMgZnJvbSAnLi9tYXRoL01hdHJpeDMnO1xuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi9tYXRoL1ZlY3RvcjInO1xuaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi9tYXRoL1ZlY3RvcjMnO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi9tYXRoL1F1YXRlcm5pb24nO1xuaW1wb3J0IEV1bGVyIGZyb20gJy4vbWF0aC9FdWxlcic7XG5cbmltcG9ydCBPYmplY3QzRCBmcm9tICcuL2NvcmUvT2JqZWN0M0QnO1xuaW1wb3J0IEVudGl0eSBmcm9tICcuL2VudGl0eS9FbnRpdHknO1xuaW1wb3J0IEVudGl0eUV2ZW50IGZyb20gJy4vZW50aXR5L0VudGl0eUV2ZW50JztcbmltcG9ydCBET01SZW5kZXJhYmxlIGZyb20gJy4vcmVuZGVyZXIvRE9NUmVuZGVyYWJsZSc7XG5cbmxldHNlZS5NYXRyaXg0ID0gTWF0cml4NDtcbmxldHNlZS5NYXRyaXgzID0gTWF0cml4MztcbmxldHNlZS5WZWN0b3IyID0gVmVjdG9yMjtcbmxldHNlZS5WZWN0b3IzID0gVmVjdG9yMztcbmxldHNlZS5RdWF0ZXJuaW9uID0gUXVhdGVybmlvbjtcbmxldHNlZS5FdWxlciA9IEV1bGVyO1xuXG5sZXRzZWUuT2JqZWN0M0QgPSBPYmplY3QzRDtcbmxldHNlZS5FbnRpdHkgPSBFbnRpdHk7XG5sZXRzZWUuRW50aXR5T2JzZXJ2ZXIgPSBFbnRpdHlFdmVudDtcbmxldHNlZS5ET01SZW5kZXJhYmxlID0gRE9NUmVuZGVyYWJsZTtcbiIsImltcG9ydCB7aXNOdWxsfSBmcm9tICcuLi9VdGlsJztcbi8vIGNvbnN0IEhUVFAgPSAnJkBodHRwQDsnO1xuLy8gY29uc3QgSFRUUFMgPSAnJkBodHRwc0A7JztcbmNvbnN0IEFUVFJfVFJBTlNMQVRFID0gJ3RyYW5zbGF0ZSc7XG5jb25zdCBBVFRSX1JPVEFURSA9ICdyb3RhdGUnO1xuXG5jb25zdCBQUk9QRVJUWV9UQVJHRVQgPSAnLWxldHNlZS10YXJnZXQnO1xuY29uc3QgUFJPUEVSVFlfVFJBTlNGT1JNID0gJy1sZXRzZWUtdHJhbnNmb3JtJztcbmNvbnN0IEFOR0xFX1VOSVQgPSB7XG4gIGRlZ3JlZTogJ2RlZycsXG4gIHJhZGlhbjogJ3JhZCcsXG4gIHR1cm46ICd0dXJuJyxcbiAgZ3JhZGlhbjogJ2dyYWQnXG59XG5cbmNvbnN0IFRSQU5TTEFURV9SRUcgPSBuZXcgUmVnRXhwKGAke0FUVFJfVFJBTlNMQVRFfVxcKC5bMC05LC5cXC1dK1xcKWAsICdnJyk7XG5jb25zdCBST1RBVEVfUkVHID0gbmV3IFJlZ0V4cChgJHtBVFRSX1JPVEFURX1cXCguKFswLTksLlxcLV18JHtBTkdMRV9VTklULmRlZ3JlZX18JHtBTkdMRV9VTklULnJhZGlhbn18JHtBTkdMRV9VTklULnR1cm59fCR7QU5HTEVfVU5JVC5ncmFkaWFufSkrXFwpYCwgJ2cnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuY29uc3QgVVJJX1JFRyA9IC91cmlcXChbJ1wiXS5bXid8XCJdK1snXCJdXFwpL2c7XG4vLyBjb25zdCBVUklfUkVHID0gL3VyaVxcKCgnfFwiKSg/Omh0dHAocyk/OlxcL1xcLyk/W1xcdy4tXSsoPzpcXC5bXFx3XFwuLV0rKStbXFx3XFwtXFwuX346Lz8jW1xcXUAhXFwkJidcXChcXClcXCpcXCssOz0uXSsoJ3xcIilcXCkvZztcblxuLyoqXG4gKiBAY2xhc3MgQ1NTUGFyc2VyXG4gKiBAYXV0aG9yIEpvb0h5dW4gTGVlIChsamhAbGV0c2VlLmlvKVxuICogQHNpbmNlIDIwMTcuIDAzLiAxMC5cbiAqL1xuY2xhc3MgQ1NTUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5kYXRhTWFwID0ge307XG4gICAgdGhpcy5kb21SZW5kZXJlcklkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBhcnNlXG4gICAqIEBtZW1iZXJvZiBDU1NQYXJzZXIucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcGFyc2UoaWQpIHtcbiAgICB0aGlzLmRhdGFNYXAgPSB7fTtcbiAgICB0aGlzLmRvbVJlbmRlcmVySWQgPSBpZDtcbiAgICBjb25zdCBzdHlsZVRhZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVUYWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB0YWcgPSBzdHlsZVRhZ3NbaV07XG5cbiAgICAgIGlmICh0YWcubWVkaWEgPT09ICdwbGFjZScpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnJlbW92ZUNvbW1lbnQodGFnLmlubmVySFRNTCk7XG5cbiAgICAgICAgdGhpcy5wYXJzZURhdGEoc3R5bGUpO1xuICAgICAgICB0aGlzLnJlbW92ZU1lZGlhKHRhZywgc3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuZGF0YU1hcCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVDb21tZW50XG4gICAqIEBtZW1iZXJvZiBDU1NQYXJzZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlbW92ZUNvbW1lbnQodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcL1xcKigufFtcXHJcXG5dKSo/XFwqXFwvL2csICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHBhcnNlRGF0YVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIHBhcnNlRGF0YSh0ZXh0KSB7XG4gICAgY29uc3Qgc3R5bGVzID0gdGV4dC5zcGxpdCgnfScpO1xuXG4gICAgc3R5bGVzLnBvcCgpO1xuICAgIHN0eWxlcy5mb3JFYWNoKChzdHlsZSkgPT4ge1xuICAgICAgY29uc3Qgc2VwZXJhdGVTdHlsZSA9IHN0eWxlLnNwbGl0KCd7Jyk7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IHNlcGVyYXRlU3R5bGVbMF0udHJpbSgpO1xuICAgICAgY29uc3QgcHJvcGVydHlWYWx1ZXMgPSBzZXBlcmF0ZVN0eWxlWzFdLnNwbGl0KCc7Jyk7XG4gICAgICBjb25zdCByZW5kZXJhYmxlID0ge3NlbGVjdG9yLCB0cmFuc2xhdGU6IFswLjAsIDAuMCwgMC4wXSwgcm90YXRpb246IFswLCAwLCAwXX07XG4gICAgICBsZXQgZW50aXR5ID0gbnVsbDtcblxuICAgICAgcHJvcGVydHlWYWx1ZXMucG9wKCk7XG5cbiAgICAgIHByb3BlcnR5VmFsdWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgcHJvcCA9IHByb3AudHJpbSgpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3Auc3Vic3RyaW5nKDAsIHByb3AuaW5kZXhPZignOicpKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wLnN1YnN0cmluZyhwcm9wLmluZGV4T2YoJzonKSArIDEpO1xuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSBQUk9QRVJUWV9UQVJHRVQ6XG4gICAgICAgICAgICBjb25zdCBwYXJzZVZhbHVlID0gdGhpcy5wYXJzZVRhcmdldCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGVudGl0eSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogcGFyc2VWYWx1ZVswXSxcbiAgICAgICAgICAgICAgdXJpOiBwYXJzZVZhbHVlWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQUk9QRVJUWV9UUkFOU0ZPUk06XG4gICAgICAgICAgICBjb25zdCB7dHJhbnNsYXRlLCByb3RhdGV9ID0gdGhpcy5wYXJzZVBvc2l0aW9uKHZhbHVlKTtcblxuICAgICAgICAgICAgcmVuZGVyYWJsZS50cmFuc2xhdGVbMF0gPSB0cmFuc2xhdGVbMF07XG4gICAgICAgICAgICByZW5kZXJhYmxlLnRyYW5zbGF0ZVsxXSA9IHRyYW5zbGF0ZVsxXTtcbiAgICAgICAgICAgIHJlbmRlcmFibGUudHJhbnNsYXRlWzJdID0gdHJhbnNsYXRlWzJdO1xuXG4gICAgICAgICAgICByZW5kZXJhYmxlLnJvdGF0aW9uWzBdID0gcm90YXRlWzBdO1xuICAgICAgICAgICAgcmVuZGVyYWJsZS5yb3RhdGlvblsxXSA9IHJvdGF0ZVsxXTtcbiAgICAgICAgICAgIHJlbmRlcmFibGUucm90YXRpb25bMl0gPSByb3RhdGVbMl07XG5cbiAgICAgICAgICAgIC8vIGlmIChjb250YWluZXIgPT09ICdnZW8nKSB7XG4gICAgICAgICAgICAvLyAgIGVudGl0eSA9IHtcbiAgICAgICAgICAgIC8vICAgICB0eXBlOiAnZ2VvJyxcbiAgICAgICAgICAgIC8vICAgICB1cmk6ICdnZW9sb2NhdGlvbidcbiAgICAgICAgICAgIC8vICAgfTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFNYXBbZW50aXR5LnVyaV0pIHtcbiAgICAgICAgICB0aGlzLmRhdGFNYXBbZW50aXR5LnVyaV0gPSB7ZW50aXR5LCByZW5kZXJhYmxlczogW119O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YU1hcFtlbnRpdHkudXJpXTtcblxuICAgICAgICAvLyBUT0RPOiBnZXQgZW50aXR5IGRlc2NyaXB0aW9uXG4gICAgICAgIGRhdGEuZW50aXR5ID0gZW50aXR5O1xuICAgICAgICBkYXRhLnJlbmRlcmFibGVzLnB1c2gocmVuZGVyYWJsZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVRhcmdldCh2YWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgdXJpID0gKHN0ci5tYXRjaChVUklfUkVHKSkgPyBzdHIubWF0Y2goVVJJX1JFRylbMF0ucmVwbGFjZSgvdXJpXFwoWydcIl18WydcIl1cXCkvZywgJycpIDogJyc7XG5cbiAgICByZXR1cm4gWydvYmplY3QnLCB1cmldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcGFyc2VWYWx1ZVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7e3JvdGF0ZTogQXJyYXksIHRyYW5zbGF0ZTogQXJyYXl9fVxuICAgKi9cbiAgcGFyc2VQb3NpdGlvbih2YWx1ZSkge1xuICAgIGNvbnN0IHN0ciA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgcHJvcFBvc2l0aW9uID0gKHN0ci5tYXRjaChUUkFOU0xBVEVfUkVHKSkgPyBzdHIubWF0Y2goVFJBTlNMQVRFX1JFRylbMF0ucmVwbGFjZShuZXcgUmVnRXhwKGAke0FUVFJfVFJBTlNMQVRFfVxcXFwofFxcXFwpYCwgJ2cnKSwgJycpIDogJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBjb25zdCBwcm9wUm90YXRpb24gPSAoc3RyLm1hdGNoKFJPVEFURV9SRUcpKSA/IHN0ci5tYXRjaChST1RBVEVfUkVHKVswXS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7QVRUUl9ST1RBVEV9XFxcXCh8XFxcXClgLCAnZycpLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zbGF0ZTogKCEhcHJvcFBvc2l0aW9uKSA/IFsuLi50aGlzLmdldFRyYW5zbGF0ZShwcm9wUG9zaXRpb24pXSA6IFswLCAwLCAwXSwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgcm90YXRlOiAoISFwcm9wUm90YXRpb24pID8gWy4uLnRoaXMuZ2V0Um90YXRpb24ocHJvcFJvdGF0aW9uKV0gOiBbMCwgMCwgMF0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH07XG4gIH1cblxuICBnZXRUcmFuc2xhdGUodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoaXNOdWxsKHZhbHVlLm1hdGNoKC9bMC05XS8pKSkgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIHZhbHVlIG5vdCBwcm92aWRlZCcpO1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Um90YXRpb24odmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5zcGxpdCgnLCcpXG4gICAgICAubWFwKHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoQU5HTEVfVU5JVC5kZWdyZWUpKSkgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZShBTkdMRV9VTklULmRlZ3JlZSwgJycpKSAqIChNYXRoLlBJIC8gMTgwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAodmFsdWUubWF0Y2gobmV3IFJlZ0V4cChBTkdMRV9VTklULnJhZGlhbikpKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKEFOR0xFX1VOSVQucmFkaWFuLCAnJykpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKEFOR0xFX1VOSVQuZ3JhZGlhbikpKSByZXR1cm4gKHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZShBTkdMRV9VTklULmdyYWRpYW4sICcnKSkgKiAzNjAgLyA0MDApICogKE1hdGguUEkgLyAxODApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmICh2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKEFOR0xFX1VOSVQudHVybikpKSByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZS5yZXBsYWNlKEFOR0xFX1VOSVQudHVybiwgJycpKSAqIDM2MCAqIChNYXRoLlBJIC8gMTgwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBpZiAoaXNOdWxsKHZhbHVlLm1hdGNoKC9bMC05XS8pKSkgdGhyb3cgbmV3IEVycm9yKCdOdW1lcmljIHZhbHVlIG5vdCBwcm92aWRlZCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbG93ZWQgdW5pdCBhcmUgXCIke0FOR0xFX1VOSVQuZGVncmVlfVwiLCBcIiR7QU5HTEVfVU5JVC5yYWRpYW59XCIsIFwiJHtBTkdMRV9VTklULmdyYWRpYW59XCIsIFwiJHtBTkdMRV9VTklULnR1cm59XCIuYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIH0pO1xuICB9XG5cbiAgc3BsaXRBbmRSZW1vdmVUYWlsKHZhbHVlLCBzZXBhcmF0b3JtLCByZW1vdmUpIHtcbiAgICBjb25zdCB0ZW1wQXJyYXkgPSB2YWx1ZS5yZXBsYWNlKHJlbW92ZSwgJycpO1xuXG4gICAgdGVtcEFycmF5LnNwbGl0KHNlcGFyYXRvcik7XG4gICAgcmV0dXJuIHRlbXBBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEJhc2VcbiAgICogQG1lbWJlcm9mIENTU1BhcnNlclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRCYXNlKCkge1xuICAgIGNvbnN0IHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgIGNvbnN0IHBhdGhBcnJheSA9IHVybC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGxhc3QgPSBwYXRoQXJyYXlbcGF0aEFycmF5Lmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QuaW5kZXhPZignLmh0bWwnKSA+IC0xKSB7XG4gICAgICBwYXRoQXJyYXkucG9wKCk7XG4gICAgfVxuXG4gICAgbGV0IGJhc2UgPSBwYXRoQXJyYXkuam9pbignLycpO1xuXG4gICAgaWYgKGJhc2Uuc3Vic3RyKGJhc2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgYmFzZSArPSAnLyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVNZWRpYVxuICAgKiBAbWVtYmVyb2YgQ1NTUGFyc2VyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IHRhZ0VsZW1cbiAgICogQHBhcmFtIHN0eWxlXG4gICAqL1xuXG4gIHJlbW92ZU1lZGlhKHRhZ0VsZW0sIHN0eWxlKSB7XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQ7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNvbnN0IG1vZGlmaWVkU3R5bGUgPSBzdHlsZVxuICAgICAgLy8gLnJlcGxhY2UoLygtbGV0c2VlLXRhcmdldCkuKzsvZywgJycpXG4gICAgICAvLyAucmVwbGFjZSgvKC1sZXRzZWUtdHJhbnNmb3JtKS4rOy9nLCAnJylcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke1BST1BFUlRZX1RBUkdFVH0pLis7YCwgJ2cnKSwgJycpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtQUk9QRVJUWV9UUkFOU0ZPUk19KS4rO2AsICdnJyksICcnKVxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnJylcbiAgICAgIC5yZXBsYWNlKC8oe1xccyspL2csICd7JylcbiAgICAgIC5yZXBsYWNlKC8oO1xccyspL2csICc7JylcbiAgICAgIC5zcGxpdCgnfScpO1xuXG4gICAgbW9kaWZpZWRTdHlsZS5wb3AoKTtcbiAgICBjb25zdCBwbGFjZVN0eWxlID0gbW9kaWZpZWRTdHlsZS5tYXAodmFsID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gdmFsLnNwbGl0KCd7JylbMF0uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsLnNwbGl0KCd7JylbMV07XG4gICAgICBjb25zdCBuZXdTZWxlY3RvciA9IHNlbGVjdG9yLm1hcChzZWwgPT4gYCMke3RoaXMuZG9tUmVuZGVyZXJJZCB9LmFyLW1vZGUtb24gJHtzZWwudHJpbSgpfWApO1xuXG4gICAgICByZXR1cm4gYCR7bmV3U2VsZWN0b3Iuam9pbignLCcpfXske3ZhbHVlfX1gO1xuICAgIH0pO1xuXG4gICAgbmV3U3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG4gICAgcGxhY2VTdHlsZS51bnNoaWZ0KGBib2R5IyR7dGhpcy5kb21SZW5kZXJlcklkIH0uYXItbW9kZS1vbntvdmVyZmxvdzpoaWRkZW47fWApO1xuICAgIG5ld1N0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHBsYWNlU3R5bGUuam9pbignJykpKTtcbiAgICBoZWFkLnJlcGxhY2VDaGlsZChuZXdTdHlsZSwgdGFnRWxlbSk7XG4gIH1cbn1cbmV4cG9ydCBjb25zdCBjc3NQYXJzZXIgPSBuZXcgQ1NTUGFyc2VyKCk7XG4iLCJsZXQgaW5zdGFuY2UgPSBudWxsO1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHtcbiAgZW50aXR5OlxuICAgIHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgdXJpOiBudWxsLFxuICAgICAgbGV0c2VlTWFya2VySWQ6IG51bGwsXG4gICAgICBjb2RlU3RyaW5nOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGltYWdlOiBudWxsLFxuICAgICAgc2l6ZToge3dpZHRoOiBudWxsLCBoZWlnaHQ6IG51bGwsIGRlcHRoOiAwLjAsIHVuaXQ6ICdtbSd9XG4gICAgfSxcbiAgcGl4ZWxTaXplOiB7d2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCwgZGVwdGg6IG51bGwsIHVuaXQ6ICdweCd9LFxuICBzY2FsZTogbnVsbFxufTtcblxubGV0IF9lbnRpdHlTdGF0ZSA9IFtdLFxuICBfbWFya2VyTGlzdCA9IFtdLFxuICBfY29kZUxpc3QgPSBbXTtcblxuY2xhc3MgRmV0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMuZW50aXR5ID0ge307XG4gICAgdGhpcy5lbnRpdHkudXJpID0gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBnZXQgZmV0Y2hFbnRpdHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZldGNoKHRoaXMuZW50aXR5LnVyaSlcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAvLyB0ZW1wLmVudGl0eS51cmkgPSBkYXRhO1xuICAgICAgICAgIHRoaXMuZW50aXR5LmxldHNlZU1hcmtlcklkID0gZGF0YS5sZXRzZWVNYXJrZXJJZCB8fCBudWxsO1xuICAgICAgICAgIHRoaXMuZW50aXR5LmNvZGVTdHJpbmcgPSBkYXRhLmNvZGVTdHJpbmcgfHwgbnVsbDtcbiAgICAgICAgICB0aGlzLmVudGl0eS5uYW1lID0gZGF0YS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5lbnRpdHkuaW1hZ2UgPSBkYXRhLmltYWdlIHx8IG51bGw7XG4gICAgICAgICAgdGhpcy5lbnRpdHkuc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBkYXRhLnNpemUud2lkdGggfHwgMCxcbiAgICAgICAgICAgIGhlaWdodDogZGF0YS5zaXplLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgZGVwdGg6IGRhdGEuc2l6ZS5oZWlnaHQgfHwgMCxcbiAgICAgICAgICAgIHVuaXQ6IGRhdGEuc2l6ZS51bml0IHx8ICdtbSdcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucGl4ZWxTaXplID0ge1xuICAgICAgICAgICAgd2lkdGg6IGRhdGEuc2l6ZS53aWR0aCB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBkYXRhLnNpemUuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgICBkZXB0aDogZGF0YS5zaXplLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgdW5pdDogZGF0YS5zaXplLnVuaXQgfHwgJ21tJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5zY2FsZSA9IGRhdGEuc2NhbGUgfHwgMTtcbiAgICAgICAgICBpZiAodGhpcy5lbnRpdHkubGV0c2VlTWFya2VySWQgIT09IG51bGwpIF9tYXJrZXJMaXN0LnB1c2godGhpcy5lbnRpdHkubGV0c2VlTWFya2VySWQpO1xuICAgICAgICAgIGlmICh0aGlzLmVudGl0eS5jb2RlU3RyaW5nICE9PSBudWxsKSBfY29kZUxpc3QucHVzaCh0aGlzLmVudGl0eS5jb2RlU3RyaW5nKTtcblxuICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgICBjb25zdCBlbnRpdHkgPSB7Li4udGVtcGxhdGUsIC4uLkpTT04ucGFyc2UoanNvbil9O1xuXG4gICAgICAgICAgX2VudGl0eVN0YXRlLnB1c2goZW50aXR5KTtcbiAgICAgICAgICByZXNvbHZlKGVudGl0eSk7XG5cbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHlQYXJzZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoIWluc3RhbmNlKSBpbnN0YW5jZSA9IHRoaXM7XG4gICAgdGhpcy5lbnRpdHlMaXN0ID0gW107XG4gIH1cblxuICBnZXQgZW50aXR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIF9lbnRpdHlTdGF0ZTtcbiAgfVxuXG4gIGdldCBtYXJrZXJMaXN0KCkge1xuICAgIHJldHVybiBfbWFya2VyTGlzdDtcbiAgfVxuXG4gIGdldCBjb2RlTGlzdCgpIHtcbiAgICByZXR1cm4gX2NvZGVMaXN0O1xuICB9XG5cbiAgaW5pdEVudGl0eShlbnRpdHkpIHtcbiAgICB0aGlzLmVudGl0eUxpc3QgPSBlbnRpdHlcbiAgICAgIC5tYXAob2JqZWN0ID0+IG9iamVjdC5lbnRpdHkudXJpKVxuICAgICAgLm1hcChvYmplY3QgPT4gbmV3IEZldGNoZXIob2JqZWN0KSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5lbnRpdHlMaXN0Lm1hcChvYmplY3QgPT4gb2JqZWN0LmZldGNoRW50aXR5KVxuICAgIClcbiAgICAgIC50aGVuKGRhdGEgPT4gZGF0YSk7XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBFVkVOVF9BUFBfU1RBVFVTID0gJ2FwcF9zdGF0dXMnO1xuZXhwb3J0IGNvbnN0IEVWRU5UX0FQUF9PTkxPQUQgPSAnb25sb2FkJztcbmV4cG9ydCBjb25zdCBFVkVOVF9BUFBfUk9UQVRJT05DSEFOR0UgPSAncm90YXRpb25jaGFuZ2UnO1xuXG5leHBvcnQgY29uc3QgU1RBVEVfVFJBQ0tfU1RBUlQgPSAndHJhY2tzdGFydCc7XG5leHBvcnQgY29uc3QgU1RBVEVfVFJBQ0tfTU9WRSA9ICd0cmFja21vdmUnO1xuZXhwb3J0IGNvbnN0IFNUQVRFX1RSQUNLX0VORCA9ICd0cmFja2VuZCc7XG5leHBvcnQgY29uc3QgU1RBVEVfUkVDT0dOSVpFID0gJ3JlY29nbml6ZSc7XG5cbmV4cG9ydCBjb25zdCBPQkpFQ1RfRVZFTlQgPSB7XG4gIE9CSkVDVF9BRERFRDogJ2FkZGVkJyxcbiAgT0JKRUNUX1JFTU9WRUQ6ICdyZW1vdmVkJ1xufVxuXG5leHBvcnQgY29uc3QgRU5USVRZX0VWRU5UID0ge1xuICBUQVJHRVQ6ICdFbnRpdHlFdmVudCcsXG4gIFRSQUNLX1NUQVJUOiAndHJhY2tzdGFydCcsXG4gIFRSQUNLX01PVkU6ICd0cmFja21vdmUnLFxuICBUUkFDS19FTkQ6ICd0cmFja2VuZCcsXG4gIFJFQ09HTklaRTogJ3JlY29nbml6ZSdcbn07XG5cbmV4cG9ydCBjb25zdCBMRVRTRUVfRVZFTlQgPSB7XG4gIFRBUkdFVDogJ0xldHNlZUV2ZW50JyxcbiAgT05fTE9BRDogJ29ubG9hZCcsXG4gIE9OX1NUQVRVUzogJ2FwcF9zdGF0dXMnLFxuICBST1RBVElPTl9DSEFOR0U6ICdyb3RhdGlvbmNoYW5nZScsXG4gIFRSQUNLX1NUQVJUOiAndHJhY2tzdGFydCcsXG4gIFRSQUNLX01PVkU6ICd0cmFja21vdmUnLFxuICBUUkFDS19FTkQ6ICd0cmFja2VuZCdcbn07XG5cbmV4cG9ydCBjb25zdCBMRVRTRUVfQ1NTID0ge1xuICBBUl9NT0RFX09OOiAnYXItbW9kZS1vbicsXG4gIEFSX01PREVfT0ZGOiAnYXItbW9kZS1vZmYnLFxuICBMRVRTRUVfTE9BRElORzogJ2xldHNlZS1sb2FkaW5nJyxcbiAgTEVUU0VFX0xPQURFRDogJ2xldHNlZS1sb2FkZWQnLFxuICBMRVRTRUVfU1RBVFVTOiAnbGV0c2VlLXN0YXR1cydcbn07XG4iLCJpbXBvcnQgRW50aXR5IGZyb20gJy4uL2VudGl0eS9FbnRpdHknO1xuXG5pbXBvcnQgTWF0cml4NCBmcm9tICcuLi9tYXRoL01hdHJpeDQnO1xuaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi4vbWF0aC9WZWN0b3IzJztcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4uL21hdGgvUXVhdGVybmlvbic7XG5pbXBvcnQgRXVsZXIgZnJvbSAnLi4vbWF0aC9FdWxlcic7XG5cbmltcG9ydCB7dHJhY2thYmxlTWFuYWdlcn0gZnJvbSAnLi4vY29yZS9UcmFja2FibGVNYW5hZ2VyJztcbmltcG9ydCBFbnRpdHlFdmVudCBmcm9tICcuLi9lbnRpdHkvRW50aXR5RXZlbnQnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9lbnRpdHkvRW50aXR5RXZlbnRUeXBlJztcblxuaW1wb3J0IEVudGl0eU9ic2VydmVyIGZyb20gJy4uL29ic2VydmVycy9vYnNlcnZlci9FbnRpdHlPYnNlcnZlcic7XG5cbmNvbnN0IHRyYW5zbGF0ZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jb25zdCByb3RhdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbmNsYXNzIE9iamVjdFRyYWNrZXIgZXh0ZW5kcyBFbnRpdHlPYnNlcnZlciB7XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQG1lbWJlciB7T2JqZWN0PHN0cmluZywgRW50aXR5Pn0gdGFyZ2V0c1xuICAgKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLnJlbmRlcmVyXG4gICAqL1xuICAvLyB0YXJnZXRzOiB7W3VyaTogc3RyaW5nXTogRW50aXR5fTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFyZ2V0cyA9IHt9O1xuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnVzZUNhbWVyYSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIGN1cnJlbnRseSB0cmFja2luZyBhbiBlbnRpdHkgd2l0aCBgdXJpYC5cbiAgICogQG1ldGhvZCBpc1RyYWNraW5nXG4gICAqIEBtZW1iZXJvZiBMZXRzZWVFbmdpbmUucmVuZGVyZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmldXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRyYWNraW5nIOyXrOu2gFxuICAgKi9cbiAgaXNUcmFja2luZyh1cmkpIHtcbiAgICBpZiAodXJpKSB7XG4gICAgICBpZiAodGhpcy50YXJnZXRzW3VyaV0pIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy50YXJnZXRzKS5sZW5ndGggPiAwKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgdHJhY2tlZCBvYmplY3RzLlxuICAgKiBAbWV0aG9kIGdldFRyYWNraW5nQ291bnRcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS50cmFja2VyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBjb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50YXJnZXRzKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHVyaVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFRhcmdldCh1cmkpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXRzW3VyaV07XG4gIH1cblxuICBhZGRUYXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YXJnZXRzW3RhcmdldC51cmldID0gdGFyZ2V0O1xuICB9XG5cbiAgcmVtb3ZlVGFyZ2V0KHRhcmdldCkge1xuICAgIGRlbGV0ZSB0aGlzLnRhcmdldHNbdGFyZ2V0LnVyaV07XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSByZW5kZXJlciBieSBkaXNwYXRjaGluZyBhIGAndHJhY2tlbmQnYCBldmVudCBmb3IgYWxsIGVudGl0aWVzXG4gICAqIHRoYXQgYXJlIGN1cnJlbnRseSB0cmFja2VkLlxuICAgKiDrqqjrk6AgVHJhY2tFdmVudOulvCBjbGVhclxuICAgKiBUcmFja2luZyDspJHsnbgg64yA7IOB7JeQIOuMgO2VtOyEnOuKlCBUcmFja0VuZCDsnbTrsqTtirgg67Cc7IOdXG4gICAqIEBtZXRob2QgY2xlYXJcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS5yZW5kZXJlclxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChsZXQgZW50aXR5IG9mIE9iamVjdC52YWx1ZXModGhpcy50YXJnZXRzKSkge1xuICAgICAgdGhpcy5vblRyYWNrRW5kKG5ldyBFbnRpdHlFdmVudCgndHJhY2tlbmQnLCBlbnRpdHkpLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnRhcmdldHMgPSB7fTtcbiAgICAvLyBMZXRzZWVFbmdpbmUucmVuZGVyZXIucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKiBAbWV0aG9kIG9uVXBkYXRlU3RhdGVcbiAgICogQG1lbWJlcm9mIExldHNlZUVuZ2luZS50cmFja2VyXG4gICAqIEBwYXJhbSAge0FycmF5fSBzdGF0ZVxuICAgKi9cbiAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHVuZGVmaW5lZCB8fCBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGUgPSBldmVudC5lbnRpdHk7XG4gICAgICBsZXQgZW50aXR5ID0gdHJhY2thYmxlTWFuYWdlci5nZXRFbnRpdHkoZS51cmkpIHx8IG5ldyBFbnRpdHkoZS51cmksIGUpO1xuXG4gICAgICBlbnRpdHkuc2V0RGF0YShlKTtcbiAgICAgIGVudGl0eS5vYmplY3QudXBkYXRlTWF0cml4KCk7XG4gICAgICBlbnRpdHkub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KGV2ZW50Lm1hdHJpeCk7XG4gICAgICBjb25zdCBlbnRpdHlFdmVudCA9IG5ldyBFbnRpdHlFdmVudChldmVudC50eXBlLCBlbnRpdHksIG1hdHJpeCwgZXZlbnQucGl4ZWxTaXplLCBldmVudC5zY2FsZSk7XG5cbiAgICAgIGlmIChlbnRpdHlFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gRXZlbnRUeXBlLlRSQUNLX1NUQVJUKSB7XG4gICAgICAgICAgdGhpcy5vblRyYWNrU3RhcnQoZW50aXR5RXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEV2ZW50VHlwZS5UUkFDS19NT1ZFKSB7XG4gICAgICAgICAgdGhpcy5vblRyYWNrTW92ZShlbnRpdHlFdmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gRXZlbnRUeXBlLlRSQUNLX0VORCkge1xuICAgICAgICAgIHRoaXMub25UcmFja0VuZChlbnRpdHlFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBtZXRob2Qgb25UcmFja1N0YXJ0XG4gICAqIEBtZW1iZXJvZiBMZXRzZWVFbmdpbmUucmVuZGVyZXJcbiAgICogQHBhcmFtICB7RW50aXR5RXZlbnR9IGV2ZW50XG4gICAqL1xuICBvblRyYWNrU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICB0YXJnZXQudHJhY2sgPSB0cnVlO1xuICAgIHRoaXMuYWRkVGFyZ2V0KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC51cmkgIT09ICd1bmtub3duJykge1xuICAgICAgdGFyZ2V0LnNjYWxlID0gZXZlbnQuc2NhbGU7XG4gICAgICB0aGlzLm5vdGlmeSgndHJhY2tzdGFydCcsIGV2ZW50KTtcbiAgICAgIHRhcmdldC5ub3RpZnkoJ3RyYWNrc3RhcnQnLCBldmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICogQG1ldGhvZCBvblRyYWNrTW92ZVxuICAgKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLnJlbmRlcmVyXG4gICAqIEBwYXJhbSAge0VudGl0eUV2ZW50fSBldmVudFxuICAgKi9cbiAgb25UcmFja01vdmUoZXZlbnQpIHtcblxuICAgIGNvbnN0IGVudGl0eSA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBlbnRpdHlPYmplY3QgPSBlbnRpdHkub2JqZWN0O1xuXG4gICAgLy8gU3RhcnQgaW52ZXJ0IFggQXhpc1xuICAgIGNvbnN0IHJvdGF0ZU0gPSBuZXcgTWF0cml4NCgpO1xuICAgIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21FdWxlcihuZXcgRXVsZXIoTWF0aC5QSSwgMCwgMCkpO1xuXG4gICAgcm90YXRlTS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxKTtcbiAgICBldmVudC5tYXRyaXgubXVsdGlwbHkocm90YXRlTSk7XG4gICAgLy8gRW5kIGludmVydCBYIGF4aXNcblxuICAgIC8vIEFwcGx5IHBvc2UgdG8gY2FtZXJhIG9yIG9iamVjdC5cbiAgICBpZiAodGhpcy51c2VDYW1lcmEpIHtcbiAgICAgIGV2ZW50Lm1hdHJpeC5kZWNvbXBvc2UoXG4gICAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLFxuICAgICAgICB0aGlzLmNhbWVyYS5xdWF0ZXJuaW9uLFxuICAgICAgICB0aGlzLmNhbWVyYS5zY2FsZVxuICAgICAgKTtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgY29uc3QgdG1wID0gbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKHRoaXMuY2FtZXJhLm1hdHJpeCk7XG5cbiAgICAgIHRoaXMuY2FtZXJhLm1hdHJpeC5pZGVudGl0eSgpO1xuICAgICAgdGhpcy5jYW1lcmEuYXBwbHlNYXRyaXgodG1wKTtcbiAgICAgIHRoaXMuY2FtZXJhLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgICB0aGlzLmNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgdGhpcy5jYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UodGhpcy5jYW1lcmEubWF0cml4V29ybGQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGV9ID0gZXZlbnQubWF0cml4LmRlY29tcG9zZWRWYWx1ZTtcblxuICAgICAgdHJhbnNsYXRlTWF0cml4Lm1ha2VUcmFuc2xhdGlvbiguLi5wb3NpdGlvbi50b0FycmF5KCkpO1xuICAgICAgcm90YXRpb25NYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gICAgICBlbnRpdHlPYmplY3QubWF0cml4Lm11bHRpcGx5KHRyYW5zbGF0ZU1hdHJpeCk7XG4gICAgICBlbnRpdHlPYmplY3QubWF0cml4Lm11bHRpcGx5KHJvdGF0aW9uTWF0cml4KTtcblxuICAgICAgZW50aXR5T2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICAgIGVudGl0eU9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoZW50aXR5LnVyaSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICB0aGlzLm5vdGlmeSgndHJhY2ttb3ZlJywgZXZlbnQpO1xuICAgICAgZW50aXR5Lm5vdGlmeSgndHJhY2ttb3ZlJywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqIEBtZXRob2Qgb25UcmFja0VuZFxuICAgKiBAbWVtYmVyb2YgTGV0c2VlRW5naW5lLnJlbmRlcmVyXG4gICAqIEBwYXJhbSAge0VudGl0eUV2ZW50fSBldmVudFxuICAgKi9cbiAgb25UcmFja0VuZChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgIHRhcmdldC50cmFjayA9IGZhbHNlO1xuICAgIHRoaXMucmVtb3ZlVGFyZ2V0KHRhcmdldCk7XG4gICAgaWYgKHRhcmdldC51cmkgIT09ICd1bmtub3duJykge1xuICAgICAgdGhpcy5ub3RpZnkoJ3RyYWNrZW5kJywgZXZlbnQpO1xuICAgICAgdGFyZ2V0Lm5vdGlmeSgndHJhY2tlbmQnLCBldmVudCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvYmplY3RUcmFja2VyID0gbmV3IE9iamVjdFRyYWNrZXIoKTtcblxuIiwiaW1wb3J0IGFkYXB0ZXIgZnJvbSAnLi4vdmVuZG9yL2FkYXB0ZXJfbm9fZWRnZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCBTY3JlZW4gZnJvbSAnLi4vU2NyZWVuJztcbmltcG9ydCB7LyogVVVJRCwgKi9nZXRCcm93c2VySW5mb30gZnJvbSAnLi4vVXRpbCc7XG5pbXBvcnQgTGV0c2VlT2JzZXJ2ZXIgZnJvbSAnLi4vb2JzZXJ2ZXJzL29ic2VydmVyL0xldHNlZU9ic2VydmVyJztcbmltcG9ydCB7TEVUU0VFX0VWRU5UfSBmcm9tICcuL01lc3NhZ2VUeXBlcyc7XG5pbXBvcnQge2NvbnRleHR9IGZyb20gJy4uL0NvbnRleHQnO1xuXG4vLyBpbXBvcnQgKiBhcyBNZXNzYWdlIGZyb20gJy4vTWVzc2FnZVR5cGVzJztcbi8vIGltcG9ydCB7VklERU9fRVZFTlR9IGZyb20gJy4vTWVzc2FnZVR5cGVzJztcbi8vIGltcG9ydCBMZXRzZWVFdmVudCBmcm9tICcuL0xldHNlZUV2ZW50Jztcbi8vIGltcG9ydCBWaWRlb09ic2VydmVyIGZyb20gJy4uL29ic2VydmVycy9vYnNlcnZlci9WaWRlb09ic2VydmVyJztcblxubGV0IGluc3RhbmNlO1xuY29uc3QgX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuY29uc3QgX3ZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG5jb25zdCBfc2NlbmVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmxldCBfc2NyZWVuV2lkdGg7XG5sZXQgX3NjcmVlbkhlaWdodDtcbmxldCBfYW5nbGUgPSAwO1xubGV0IF9zY3JlZW5Bc3BlY3RSYXRpbztcbmxldCBfdHlwZSA9IG51bGw7XG5sZXQgX2Jyb3dzZXIgPSAndW5rbm93bic7XG5sZXQgX29zID0gJ3Vua25vd24nO1xuXG5sZXQgX3ZpZGVvQXR0YWNoZWQgPSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxubGV0IF9pc1BvcnRyYWl0ID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5sZXQgZGV2aWNlTGlzdCA9IFtdO1xubGV0IGlzRmlyc3RDYW1lcmFJbml0ID0gdHJ1ZTsgLy8g7LSI6riwIOy5tOuplOudvCBJbml0IOyLnOyXkFxuLypcbmNvbnN0IF9jb25zdHJhaW50cyA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB2aWRlbzoge1xuICAgICAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIG1pbjogMTAyNCxcbiAgICAgICAgaWRlYWw6IDEyODAsXG4gICAgICAgIG1heDogMTkyMFxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBtaW46IDU3NixcbiAgICAgICAgaWRlYWw6IDcyMCxcbiAgICAgICAgbWF4OiAxMDgwXG4gICAgICB9XG4gICAgfSxcbiAgICBhdWRpbzogZmFsc2VcbiAgfTtcbn07XG4qL1xuY29uc3QgZ2V0VXNlck1lZGlhQ29uc3RyYWludHMgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IGNvbnN0cmFpbnRzID0ge307XG4gIGNvbnN0cmFpbnRzLmF1ZGlvID0gZmFsc2U7XG4gIGNvbnN0cmFpbnRzLnZpZGVvID0ge307XG5cbiAgaWYgKHNyYyA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgIGNvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGUgPSAnZW52aXJvbm1lbnQnO1xuICAgIC8qKlxuICAgICAqIO2bhOuptCDsubTrqZTrnbzsnZgg65SU67CU7J207IqkIOyepey5mOyXkCDrjIDtlZwg7JiI7Jm4IOy2nOugpS4gKEV4Y2VwdGlvbiBhYm91dCBmcm9udC1iYWNrIGNhbWVyYSBkZXZpY2UpXG4gICAgICogfHwg6rWs66y4IOydtO2bhOuhnCDstpTqsIDtlZjsl6wg7LaU6rCA7KCB7J24IExhYmVsIOuTseuhneydtCDqsIDriqUuIChBZGQgTGFiZWwgdXNpbmcgfHwgc3ludGF4IGZvciBhZGQgZXhjZXB0aW9uIGRldmljZSlcbiAgICAgKiBzMTAgOiBjYW1lcmEyIDAsIGZhY2luZyBiYWNrXG4gICAgICovXG4gICAgbGV0IGV4Y2VwdGlvbkRldmljZXMgPSBkZXZpY2VMaXN0LmZpbHRlcigoZGV2aWNlKSA9PiB7XG4gICAgICByZXR1cm4gKGRldmljZS5sYWJlbCA9PT0gJ2NhbWVyYTIgMCwgZmFjaW5nIGJhY2snIHx8IGRldmljZS5sYWJlbCA9PT0nYWRkaXRpb25hbCAuLi4uJyk7XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ1tbZXhjZXB0aW9uIGRldmljZV1dJyk7XG4gICAgY29uc29sZS53YXJuKGV4Y2VwdGlvbkRldmljZXMpO1xuICAgIGlmIChleGNlcHRpb25EZXZpY2VzLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGV4Y2VwdGlvbkRldmljZXNbMF0uZGV2aWNlSWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNyYyA9PT0gJ3VzZXInKSB7XG4gICAgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZSA9ICd1c2VyJztcbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IHNyYztcbiAgfVxuXG4gIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoID0ge307XG4gIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoLm1pbiA9IDEwMjQ7XG4gIGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoLmlkZWFsID0gMTI4MDtcbiAgY29uc3RyYWludHMudmlkZW8ud2lkdGgubWF4ID0gMTkyMDtcblxuICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQgPSB7fTtcbiAgY29uc3RyYWludHMudmlkZW8uaGVpZ2h0Lm1pbiA9IDU3NjtcbiAgY29uc3RyYWludHMudmlkZW8uaGVpZ2h0LmlkZWFsID0gNzIwO1xuICBjb25zdHJhaW50cy52aWRlby5oZWlnaHQubWF4ID0gMTA4MDtcblxuICBjb25zb2xlLmxvZygnW1tjb25zdHJhaW50c11dJyk7XG4gIGNvbnNvbGUud2Fybihjb25zdHJhaW50cyk7XG4gIHJldHVybiBjb25zdHJhaW50cztcbn07XG5cbi8vIFRFU1Rcbi8vIGxldCBhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4vLyBhLnRoZW4oKGRldmljZXMpID0+IHtcbi8vIFx0Y29uc29sZS5sb2coZGV2aWNlcy5sZW5ndGgpO1xuLy8gXHRkZXZpY2VzLmZvckVhY2goX2QgPT4ge1xuLy8gXHRcdGNvbnNvbGUubG9nKF9kLmRldmljZUlkLCBfZC5raW5kLCBfZC5sYWJlbCk7XG4vLyBcdH0pXG4vLyB9KTtcbi8vIFRFU1RcblxuY29uc3QgZ2V0TWVkaWEgPSAoY29uc3RyYWludHMpID0+IHtcblx0aWYgKHdpbmRvdy5zdHJlYW0pIHtcblx0XHR3aW5kb3cuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuXHRcdFx0dHJhY2suc3RvcCgpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0bmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG5cdFx0XHQudGhlbigoc3RyZWFtKSA9PiB7XG5cdFx0XHRcdHJlc29sdmUoc3RyZWFtKTtcblx0XHRcdH0pXG5cdFx0XHQuY2F0Y2goZSA9PiB7XG5cdFx0XHRcdHJlamVjdChlKTtcblx0XHRcdH0pO1xuXHR9KTtcbn07XG5cbmNvbnN0IGNoZWNrQ2FtZXJhID0gZGV2aWNlcyA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGhhc1dlYmNhbSA9IGZhbHNlO1xuICAgIGRldmljZUxpc3QgPSBbXTtcbiAgICBkZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHtcbiAgICAgIGlmIChkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSB7XG4gICAgICAgIGhhc1dlYmNhbSA9IHRydWU7XG4gICAgICAgIGRldmljZUxpc3QucHVzaCh7ZGV2aWNlSWQ6IGRldmljZS5kZXZpY2VJZCwgbGFiZWw6IGRldmljZS5sYWJlbH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNXZWJjYW0pIHtcbiAgICAgIHJlamVjdCgnTm8gdmlkZW9JbnB1dCBTdHJlYW0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRmlyc3RDYW1lcmFJbml0KSB7XG4gICAgICAgIHJlc29sdmUoZ2V0VXNlck1lZGlhQ29uc3RyYWludHMoJ2Vudmlyb25tZW50JykpO1xuICAgICAgICBpc0ZpcnN0Q2FtZXJhSW5pdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBnb3RTdHJlYW0gPSAobWVkaWFTdHJlYW0pID0+IHtcblx0X3ZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcblx0X3ZpZGVvQXR0YWNoZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiByZW1vdmUgY3VycmVudCB2aWRlbyBzdHJlYW0sIGFuZCBjb25uZWN0IG5ldyBzdHJlYW0uXG4gKi9cbmNvbnN0IHJlbW92ZVN0cmVhbSA9IChtZWRpYVN0cmVhbSkgPT4ge1xuICBpZih3aW5kb3cuc3RyZWFtKSB7XG4gICAgd2luZG93LnN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuICB3aW5kb3cuc3RyZWFtID0gbWVkaWFTdHJlYW07XG4gIF92aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgX3ZpZGVvQXR0YWNoZWQgPSBmYWxzZTtcbn07XG5cbmNvbnN0IF9pbml0Q2FtZXJhQ29udGFpbmVyID0gKHpJbmRleCwgekluZGV4SW5jcmVtZW50KSA9PiB7XG5cdF92aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsIHRydWUpO1xuXHRfdmlkZW9FbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcblx0X3ZpZGVvRWxlbWVudC5tdXRlZCA9IHRydWU7XG5cdF92aWRlb0VsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXHRfdmlkZW9FbGVtZW50LnN0eWxlLnRvcCA9ICcwcHgnO1xuXHRfdmlkZW9FbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4Jztcblx0X3ZpZGVvRWxlbWVudC5zdHlsZS56SW5kZXggPSAnLTEwMCc7XG5cdF92aWRlb0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdF92aWRlb0VsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBwaW5rJztcblx0X3ZpZGVvRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdC8vIF92aWRlb0VsZW1lbnQuc3R5bGUub2JqZWN0Rml0ID0gJ2NvdmVyJztcblx0Ly8gLy8gX3ZpZGVvRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG5cdC8vIF92aWRlb0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcblxuXHRfc2NlbmVDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXHRfc2NlbmVDYW52YXMuc3R5bGUudG9wID0gJzBweCc7XG5cdF9zY2VuZUNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG5cdF9zY2VuZUNhbnZhcy5zdHlsZS56SW5kZXggPSAnMCc7XG5cdF9zY2VuZUNhbnZhcy5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsdWUnO1xuXG5cdF9jb250YWluZXIuYXBwZW5kQ2hpbGQoX3ZpZGVvRWxlbWVudCk7XG5cdF9jb250YWluZXIuYXBwZW5kQ2hpbGQoX3NjZW5lQ2FudmFzKTtcblx0X2NvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG5cdF9jb250YWluZXIuc3R5bGUudG9wID0gJzBweCc7XG5cdF9jb250YWluZXIuc3R5bGUucmlnaHQgPSAnMHB4Jztcblx0X2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSAnMHB4Jztcblx0X2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gJzBweCc7XG5cdF9jb250YWluZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdF9jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRfY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcblx0X2NvbnRhaW5lci5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJlZCc7XG5cblx0ZG9jdW1lbnQuYm9keS5zdHlsZS5tYXJnaW4gPSAnMHB4Jztcblx0ZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nID0gJzBweCc7XG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2NvbnRhaW5lcik7XG5cbn07XG5cbmNvbnN0IF9hdHRhY2hTb3VyY2VUb1ZpZGVvID0gKHZpZGVvVXJsKSA9PiB7XG5cdGNvbnN0IHNvdXJjZU1QNCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuXG5cdHNvdXJjZU1QNC5zcmMgPSB2aWRlb1VybDtcblx0c291cmNlTVA0LnR5cGUgPSAndmlkZW8vbXA0Jztcblx0X3ZpZGVvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VNUDQpO1xuXHRfdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCAoKSA9PiB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pO1xufTtcblxuLy8gY29uc3QgX3VwZGF0ZUN1cnJlbnRTY3JlZW5TaXplID0gKCkgPT4ge1xuLy8gICBfc2NyZWVuV2lkdGggPSBNYXRoLmZsb29yKCh0aGlzLmlzUG9ydHJhaXQpID8gdGhpcy5zY3JlZW5XaWR0aCA6IHRoaXMuc2NyZWVuSGVpZ2h0KTtcbi8vICAgX3NjcmVlbkhlaWdodCA9IE1hdGguZmxvb3IoKHRoaXMuaXNQb3J0cmFpdCkgPyB0aGlzLnNjcmVlbkhlaWdodCA6IHRoaXMuc2NyZWVuV2lkdGgpO1xuLy8gfTtcblxuY29uc3QgX3NldEFzcGVjdFJhdGlvID0gKCkgPT4ge1xuXG5cdGNvbnN0IGFuZ2xlID0gKHR5cGVvZiBzY3JlZW4ub3JpZW50YXRpb24gPT09ICd1bmRlZmluZWQnIHx8ICFzY3JlZW4ub3JpZW50YXRpb24pID8gd2luZG93Lm9yaWVudGF0aW9uIDogc2NyZWVuLm9yaWVudGF0aW9uLmFuZ2xlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdGNvbnN0IHR5cGUgPSAodHlwZW9mIHNjcmVlbi5vcmllbnRhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIXNjcmVlbi5vcmllbnRhdGlvbikgPyAnc2FmYXJpJyA6ICdjaHJvbWUnO1xuXG5cdF9hbmdsZSA9IGFuZ2xlO1xuXHRfdHlwZSA9IHR5cGU7XG5cblx0aWYgKChfYW5nbGUgPT09IDkwIHx8IF9hbmdsZSA9PT0gLTkwIHx8IF9hbmdsZSA9PT0gMjcwIHx8IF9hbmdsZSA9PT0gLTI3MCkgJiYgX3R5cGUgIT09ICdjaHJvbWUnKSB7XG5cdFx0X3NjcmVlbldpZHRoID0gc2NyZWVuLmhlaWdodDtcblx0XHRfc2NyZWVuSGVpZ2h0ID0gc2NyZWVuLndpZHRoO1xuXHR9IGVsc2Uge1xuXHRcdF9zY3JlZW5XaWR0aCA9IHNjcmVlbi53aWR0aDtcblx0XHRfc2NyZWVuSGVpZ2h0ID0gc2NyZWVuLmhlaWdodDtcblx0fVxuXHRfc2NyZWVuQXNwZWN0UmF0aW8gPSBfc2NyZWVuV2lkdGggLyBfc2NyZWVuSGVpZ2h0O1xuXHRfaXNQb3J0cmFpdCA9IF9zY3JlZW5Bc3BlY3RSYXRpbyA8PSAxO1xuXG5cdF9zY2VuZUNhbnZhcy53aWR0aCA9IF9zY3JlZW5XaWR0aDtcblx0X3NjZW5lQ2FudmFzLmhlaWdodCA9IF9zY3JlZW5IZWlnaHQ7XG5cdF9zY2VuZUNhbnZhcy5zdHlsZS53aWR0aCA9IGAke19zY3JlZW5XaWR0aH1weGA7XG5cdF9zY2VuZUNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtfc2NyZWVuSGVpZ2h0fXB4YDtcblx0X3NjZW5lQ2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcblxuXHRyZXR1cm4geyB3aWR0aCA6IF9zY3JlZW5XaWR0aCwgaGVpZ2h0IDogX3NjcmVlbkhlaWdodCB9O1xufTtcblxuY29uc3QgX2luaXRDYW52YXMgPSAoKSA9PiB7XG5cdHJldHVybiBfc2V0QXNwZWN0UmF0aW8oKTtcbn07XG5cbmNsYXNzIHZpZGVvTWFuYWdlciBleHRlbmRzIExldHNlZU9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoaW5zdGFuY2UpIHJldHVybiBpbnN0YW5jZTtcbiAgICBfdmlkZW9FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZGRhdGEnLCAoKSA9PiB7XG4gICAgICAvLyB0aGlzLmRpc3BhdGNoKE1lc3NhZ2UuRVZFTlRfQVBQX1NUQVRVUywge1xuICAgICAgdGhpcy5ub3RpZnkoTEVUU0VFX0VWRU5ULk9OX1NUQVRVUywge1xuICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJyxcbiAgICAgICAgY29kZTogMjAyLFxuICAgICAgICBtZXNzYWdlOiAnVmlkZW8gc3RhcnQnXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IF9jb250YWluZXI7XG4gICAgdGhpcy5jb250YWluZXJJZCA9IGNvbnRleHQudmlkZW9Db250YWluZXJJZDtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5jb250YWluZXJJZCk7XG5cbiAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgLy8gdXBkYXRlIGRldmljZUxpc3Qgd2hlbiBkZXZpY2UgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkLlxuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXG4gICAgICAudGhlbihkZXZpY2VzID0+IHtcbiAgICAgICAgZGV2aWNlTGlzdCA9IFtdO1xuICAgICAgICBkZXZpY2VzLmZvckVhY2goZGV2aWNlID0+IHtcbiAgICAgICAgICBpZiAoZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgICAgZGV2aWNlTGlzdC5wdXNoKHtkZXZpY2VJZDogZGV2aWNlLmRldmljZUlkLCBsYWJlbDogZGV2aWNlLmxhYmVsfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaW5pdCh6SW5kZXgsIHpJbmRleEluY3JlbWVudCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBfaW5pdENhbWVyYUNvbnRhaW5lcih6SW5kZXgsIHpJbmRleEluY3JlbWVudCk7XG4gICAgICBpZiAodGhpcy52aWRlb1VybCkge1xuICAgICAgICBfYXR0YWNoU291cmNlVG9WaWRlbyh0aGlzLnZpZGVvVXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0YWNoZWRWaWRlbygpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gdGhpcy5kaXNwYXRjaChNZXNzYWdlLkVWRU5UX0FQUF9TVEFUVVMsIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2FtZXJhIGluaXRpYWxpemUgc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKGNoZWNrQ2FtZXJhKVxuICAgICAgICAgIC50aGVuKChjb25zdHJhaW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKHN0cmVhbSA9PiB7XG4gICAgICAgICAgICByZW1vdmVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgIGdvdFN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgICAgLy8gdGhpcy5kaXNwYXRjaChNZXNzYWdlLkVWRU5UX0FQUF9TVEFUVVMsIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICAgICAgY29kZTogMjAxLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQ2FtZXJhIGluaXRpYWxpemUgZG9uZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IF9zY3JlZW5TaXplID0gX2luaXRDYW52YXMoKTtcblxuICAgICAgICAgICAgdGhpcy5zY3JlZW4gPSBuZXcgU2NyZWVuKF9zY3JlZW5TaXplLndpZHRoLCBfc2NyZWVuU2l6ZS5oZWlnaHQsIHRoaXMpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRBdHRhY2hlZFZpZGVvKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gICAgICBjb25zdCBicm93c2VyTmFtZSA9IGJyb3dzZXJJbmZvLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IG9zTmFtZSA9IGJyb3dzZXJJbmZvLm9zTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoYnJvd3Nlck5hbWUubWF0Y2goL2Nocm9tZS9pKSkge1xuICAgICAgICBfYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgICAgfSBlbHNlIGlmIChicm93c2VyTmFtZS5tYXRjaCgvc2FmYXJpL2kpKSB7XG4gICAgICAgIF9icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYnJvd3NlciA9ICd1bmtub3duJztcbiAgICAgIH1cbiAgICAgIGlmIChvc05hbWUubWF0Y2goL2lvcy9pKSkge1xuICAgICAgICBfb3MgPSAnaW9zJztcbiAgICAgIH0gZWxzZSBpZiAob3NOYW1lLm1hdGNoKC9hbmRyb2lkL2kpKSB7XG4gICAgICAgIF9vcyA9ICdhbmRyb2lkJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9vcyA9ICd1bmtub3duJztcbiAgICAgIH1cbiAgICAgIGlmIChfb3MgPT09ICdpb3MnICYmIF9icm93c2VyICE9PSAnc2FmYXJpJykge1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoKE1lc3NhZ2UuRVZFTlRfQVBQX1NUQVRVUywge1xuICAgICAgICB0aGlzLm5vdGlmeShMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCB7XG4gICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgIGNvZGU6IDEwMSxcbiAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHVzZSBzYWZhcmkgd2l0aCBpb3MnXG4gICAgICAgIH0pO1xuICAgICAgICByZWplY3QoJ1BsZWFzZSB1c2Ugc2FmYXJpIHdpdGggaW9zJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckluZm8uaXNXZWJSVENTdXBwb3J0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgY29kZTogMTAyLFxuICAgICAgICAgIG1lc3NhZ2U6ICdVbnN1cHBvcnRlZCBicm93c2VyJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVqZWN0KCdQbGVhc2UgdXNlIENocm9tZSwgRmlyZWZveCwgaU9TIDExLCBBbmRyb2lkIDUgb3IgaGlnaGVyLCBTYWZhcmkgMTEgb3IgaGlnaGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJyb3dzZXJJbmZvLmlzTW9iaWxlRGV2aWNlKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgY29kZTogMTA0LFxuICAgICAgICAgIG1lc3NhZ2U6ICdObyBtb2JpbGUgZGV2aWNlIGRldGVjdGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVqZWN0KCdObyBtb2JpbGUgZGV2aWNlJyk7XG4gICAgICB9XG4gICAgICBpZiAoKHNjcmVlbi5oZWlnaHQgKiBzY3JlZW4ud2lkdGgpID4gOTIxNjAwKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2goTWVzc2FnZS5FVkVOVF9BUFBfU1RBVFVTLCB7XG4gICAgICAgIHRoaXMubm90aWZ5KExFVFNFRV9FVkVOVC5PTl9TVEFUVVMsIHtcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgY29kZTogMTA2LFxuICAgICAgICAgIG1lc3NhZ2U6ICdTY3JlZW4gc2l6ZSBpcyB0b28gbGFyZ2UuJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVqZWN0KCdTY3JlZW4gc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfTtcblxuICBvcmllbnRhdGlvbkNoYW5nZSgpIHtcbiAgICBfc2V0QXNwZWN0UmF0aW8oKTtcbiAgfTtcblxuICBzZXRWaWRlb1NvdXJjZShzcmMpIHtcbiAgICBpZiAoL1teXFxzXStcXC5tcDRcXGIvLnRlc3Qoc3JjKSkge1xuICAgICAgX2F0dGFjaFNvdXJjZVRvVmlkZW8oc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzID0gZ2V0VXNlck1lZGlhQ29uc3RyYWludHMoc3JjKTtcbiAgICAgIHRoaXMucmVjb25uZWN0TWVkaWFTdHJlYW0oY29uc3RyYWludHMpO1xuICAgIH1cbiAgfVxuXG4gIGdldFNvdXJjZURldmljZUxpc3QoKSB7XG4gICAgcmV0dXJuIGRldmljZUxpc3Q7XG4gIH1cblxuICAvLyBGaXhlZCBnZXR0ZXIvc2V0dGVyXG4gIGdldCBzY3JlZW5JbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogX3NjcmVlbldpZHRoLFxuICAgICAgaGVpZ2h0OiBfc2NyZWVuSGVpZ2h0LFxuICAgICAgYW5nbGU6IF9hbmdsZSxcbiAgICAgIHNjcmVlbkFzcGVjdFJhdGlvOiBfc2NyZWVuQXNwZWN0UmF0aW9cbiAgICB9O1xuICB9XG5cbiAgZ2V0IHZpZGVvRWxlbWVudCgpIHtcbiAgICByZXR1cm4gX3ZpZGVvRWxlbWVudDtcbiAgfVxuXG4gIGdldCBjYW52YXNFbGVtZW50KCkge1xuICAgIHJldHVybiBfc2NlbmVDYW52YXM7XG4gIH1cbiAgLypcbiAgc2V0RnVsbHNjcmVlbigpIHtcbiAgICBjb25zb2xlLmxvZygnc2V0RnVsbHNjcmVlbiBmdW5jdGlvbiBpcyBjYWxsZWQuJyk7XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5jb250YWluZXIpO1xuXG4gICAgaWYgKHRoaXMuY29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbigpLnRoZW4oKGUpID0+IHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnZpZGVvRWxlbWVudCk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jYW52YXNFbGVtZW50KTtcblxuICAgICAgICAgIHRoaXMucmVjb25uZWN0TWVkaWFTdHJlYW0oKTtcblxuICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgIHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgYXR0ZW1wdGluZyB0byBlbmFibGUgZnVsbC1zY3JlZW4gbW9kZTogJHtlcnIubWVzc2FnZX0gKCR7ZXJyLm5hbWV9KWApO1xuICAgICAgICB9KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5lci5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gICovXG5cbiAgLy8gY29uc3RyYWludOulvCDsnbTsmqntlZjsl6wg66+465SU7Ja0IFN0cmVhbeydhCDslrvslrTsmKTripQg66mU7ISc65OcLlxuICAvLyBnZXQgbWVkaWFTdHJlYW0gdXNpbmcgY29uc3RyYWludHMuXG4gIHJlY29ubmVjdE1lZGlhU3RyZWFtKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGdldE1lZGlhKGNvbnN0cmFpbnRzKVxuICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgIHJlbW92ZVN0cmVhbSgpO1xuICAgICAgICAgIHdpbmRvdy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgZ290U3RyZWFtKHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5ub3RpZnkoTEVUU0VFX0VWRU5ULk9OX1NUQVRVUywge1xuICAgICAgICAgICAgY29kZTogMjAxLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0NhbWVyYSBpbml0aWFsaXplIGRvbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX2luaXRDYW52YXMoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZpZGVvTWFuYWdlcjtcbiIsImltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4vUXVhdGVybmlvbic7XG5pbXBvcnQgVmVjdG9yMyBmcm9tICcuL1ZlY3RvcjMnO1xuaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi9NYXRyaXg0JztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vTWF0aCc7XG5cbi8qKlxuICogQHR5cGVkZWYgeydYWVonfCdZWlgnfCdaWFknfCdYWlknfCdZWFonfCdaWVgnfSBFdWxlclJvdGF0aW9uT3JkZXJcbiAqL1xuLy8gdHlwZSBFdWxlclJvdGF0aW9uT3JkZXIgPSAnWFlaJyB8ICdZWlgnIHwgJ1pYWScgfCAnWFpZJyB8ICdZWFonIHwgJ1pZWCc7XG5cbi8qKlxuICogQnkgZGVmYXVsdCB0aGlzIGlzIGFuIGVtcHR5IGZ1bmN0aW9uLCBob3dldmVyIGl0IGNhbiBiZSBzZXQgdmlhXG4gKiB7QGxpbmsgRXVsZXIjb25DaGFuZ2V9LiBJdCBnZXRzZSBjYWxsZWQgYWZ0ZXIgY2hhbmdpbmcgdGhlIHtAbGluayBFdWxlciN4fSxcbiAqIHtAbGluayBFdWxlciN5fSwge0BsaW5rIEV1bGVyI3p9LCBvciB7QGxpbmsgRXVsZXIjb3JkZXJ9IHByb3BlcnRpZXMsIGFuZFxuICogYWxzbyBhZnRlciBjYWxsaW5nIG1vc3Qgc2V0dGVyIGZ1bmN0aW9ucy5cbiAqIEBtZW1iZXIge0Z1bmN0aW9ufSBvbkNoYW5nZUNhbGxiYWNrXG4gKiBAbWVtYmVyb2YgRXVsZXIjXG4gKiBAZGVmYXVsdCBmdW5jdGlvbigpIHsgfVxuICovXG5sZXQgb25DaGFuZ2VDYWxsYmFjayA9ICgpID0+IHt9O1xuXG5jb25zdCBfaXNFdWxlciA9IHRydWU7XG5jb25zdCBEZWZhdWx0T3JkZXIgPSAnWFlaJztcbmNvbnN0IFJvdGF0aW9uT3JkZXJzID0gW1xuICAnWFlaJyxcbiAgJ1laWCcsXG4gICdaWFknLFxuICAnWFpZJyxcbiAgJ1lYWicsXG4gICdaWVgnXG5dO1xuXG4vKipcbiAqIEBjbGFzcyBFdWxlclxuICogQGNsYXNzZGVzY1xuICogQSBjbGFzcyByZXByZXNlbnRpbmdcbiAqIFtFdWxlciBBbmdsZXNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVsZXJfYW5nbGVzKS4gRXVsZXIgYW5nbGVzXG4gKiBkZXNjcmliZSBhIHJvdGF0aW9uYWwgdHJhbnNmb3JtYXRpb24gYnkgcm90YXRpbmcgYW4gb2JqZWN0IG9uIGl0cyB2YXJpb3VzXG4gKiBheGVzIGluIHNwZWNpZmllZCBhbW91bnRzIHBlciBheGlzLCBhbmQgYSBzcGVjaWZpZWQgYXhpcyBvcmRlci5cbiAqIEBleGFtcGxlXG4gKiB2YXIgYSA9IG5ldyBFdWxlcigwLCAxLCAxLjU3LCAnWFlaJyk7XG4gKiB2YXIgYiA9IG5ldyBWZWN0b3IzKDEsIDAsIDEpO1xuICogYi5hcHBseUV1bGVyKGEpO1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIFRoZSBhbmdsZSBvZiB0aGUgeCBheGlzIGluIHJhZGlhbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gVGhlIGFuZ2xlIG9mIHRoZSB5IGF4aXMgaW4gcmFkaWFucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbej0wXSBUaGUgYW5nbGUgb2YgdGhlIHogYXhpcyBpbiByYWRpYW5zLlxuICogQHBhcmFtIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtvcmRlcj0nWFlaJ10gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuIChNdXN0IGJlIHVwcGVyIGNhc2UpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdWxlciB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gRGVmYXVsdE9yZGVyKSB7XG5cbiAgICAvLyBjb25zdGFudHMgZm9yIG9wdGltaXNhdGlvblxuICAgIHRoaXMuc2V0RnJvbVF1YXRlcm5pb25RO1xuICAgIHRoaXMucmVvcmRlclE7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgeCBjb21wb25lbnQuIElmIHRoaXMgaXMgY2hhbmdlZCxcbiAgICoge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IHdpbGwgYmUgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHhcbiAgICogQG1lbWJlcm9mIEV1bGVyI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeCgpIHtcbiAgICByZXR1cm4gdGhpcy5feDtcbiAgfVxuXG4gIHNldCB4KHZhbHVlKSB7XG4gICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgeSBjb21wb25lbnQuIElmIHRoaXMgaXMgY2hhbmdlZCxcbiAgICoge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IHdpbGwgYmUgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHlcbiAgICogQG1lbWJlcm9mIEV1bGVyI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy5feTtcbiAgfVxuXG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy5feSA9IHZhbHVlO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgeiBjb21wb25lbnQuIElmIHRoaXMgaXMgY2hhbmdlZCxcbiAgICoge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IHdpbGwgYmUgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHpcbiAgICogQG1lbWJlcm9mIEV1bGVyI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpcy5fejtcbiAgfVxuXG4gIHNldCB6KHZhbHVlKSB7XG4gICAgdGhpcy5feiA9IHZhbHVlO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIGdldCBpc0V1bGVyKCkge1xuICAgIHJldHVybiBfaXNFdWxlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3JkZXIgaW4gd2hpY2ggdG8gYXBwbHkgcm90YXRpb25zLiBEZWZhdWx0IGlzIGAnWFlaJ2AsIHdoaWNoIG1lYW5zXG4gICAqIHRoYXQgdGhlIG9iamVjdCB3aWxsIGZpcnN0IGJlIHJvdGF0ZWQgYXJvdW5kIGl0cyBYIGF4aXMsIHRoZW4gaXRzIFkgYXhpcyxcbiAgICogYW5kIGZpbmFsbHkgaXRzIFogYXhpcy4gT3RoZXIgcG9zc2liaWxpdGllcyBhcmU6IGAnWVpYJ2AsIGAnWlhZJ2AsXG4gICAqIGAnWFpZJ2AsIGAnWVhaJ2AsIGFuZCBgJ1pZWCdgLiBUaGVzZSBtdXN0IGJlIGluIHVwcGVyIGNhc2UuXG4gICAqXG4gICAqIExldHNlZSB1c2VzIF9pbnRyaW5zaWNfIChUYWl0LUJyeWFuKSBvcmRlcmluZywgYWxzbyBrbm93biBhcyB0aGlzLl95YXdfLFxuICAgKiBfcGl0Y2hfLCBhbmQgX3JvbGxfLiBUaGlzIG1lYW5zIHRoYXQgcm90YXRpb25zIGFyZSBwZXJmb3JtZWQgd2l0aCByZXNwZWN0XG4gICAqIHRvIHRoZSBfbG9jYWxfIGNvb3JkaW5hdGUgc3lzdGVtLiBUaGF0IGlzLCBmb3Igb3JkZXIgYCdYWVonYCwgdGhlIHJvdGF0aW9uXG4gICAqIGlzIGZpcnN0IGFyb3VuZCB3b3JsZC1YLCB0aGVuIGFyb3VuZCBsb2NhbC1ZICh3aGljaCBtYXkgbm93IGJlIGRpZmZlcmVudFxuICAgKiBmcm9tIHRoZSB3b3JsZCBZLWF4aXMpLCB0aGVuIGxvY2FsLVogKHdoaWNoIG1heSBiZSBkaWZmZXJlbnQgZnJvbSB0aGVcbiAgICogd29ybGQgWi1heGlzKS5cbiAgICpcbiAgICogU29tZSBpbXBsZW1lbnRhdGlvbnMgbWF5IHVzZSBfZXh0cmluc2ljXyAocHJvcGVyKSBvcmRlcmluZywgaW4gd2hpY2ggY2FzZVxuICAgKiByb3RhdGlvbnMgYXJlIHBlcmZvcm1lZCB3aXRoIHJlc3BlY3QgdG8gdGhlIF93b3JsZF8gY29vcmRpbmF0ZSBzeXN0ZW0sIHNvXG4gICAqIHRoYXQgZm9yIG9yZGVyIGAnWFlaJ2AsIHRoZSByb3RhdGlvbnMgYXJlIGFyb3VuZCB3b3JsZC1YLCB3b3JsZC1ZLCBhbmRcbiAgICogd29ybGQtWi5cbiAgICpcbiAgICogQ29udmVydGluZyBiZXR3ZWVuIHRoZSB0d28gdHlwZXMgaXMgcmVsYXRpdmVseSBzdHJhaWdodGZvcndhcmQsIHlvdSBqdXN0XG4gICAqIG5lZWQgdG8gcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIHRoZSByb3RhdGlvbiwgc28gdGhhdCBhbiBpbnRyaW5zaWNcbiAgICogKExldHNlZSkgRXVsZXIgcm90YXRpb24gb2YgYW5nbGVzIGBhYCwgYGJgLCBgY2AgYWJvdXQgYCdYWVonYCB3aWxsIGJlXG4gICAqIGVxdWl2YWxlbnQgdG8gYW4gZXh0cmluc2ljIEV1bGVyIHJvdGF0aW9uIG9mIGFuZ2xlcyBgY2AsIGBiYCwgYGFgIGFiYm91dFxuICAgKiBgJ1pZWCdgLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGNoYW5nZWQsIHtAbGluayBFdWxlciNvbkNoYW5nZUNhbGxiYWNrfSB3aWxsIGJlIGNhbGxlZC5cbiAgICogQG1lbWJlciB7RXVsZXJSb3RhdGlvbk9yZGVyfSBvcmRlclxuICAgKiBAbWVtYmVyb2YgRXVsZXIjXG4gICAqIEBkZWZhdWx0ICdYWVonXG4gICAqL1xuICBnZXQgb3JkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGVyO1xuICB9XG5cbiAgc2V0IG9yZGVyKHZhbHVlKSB7XG4gICAgdGhpcy5fb3JkZXIgPSB2YWx1ZTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYW5nbGVzIG9mIHRoaXMgZXVsZXIgdHJhbnNmb3JtIGFuZCBvcHRpb25hbGx5IHRoZVxuICAgKiB7QGxpbmsgRXVsZXIjb3JkZXJ9IGFuZCB0aGVuIGNhbGwge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9LlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBhbmdsZSBvZiB0aGUgeCBheGlzIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBhbmdsZSBvZiB0aGUgeSBheGlzIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzIGluIHJhZGlhbnMuXG4gICAqIEBwYXJhbSB7RXVsZXJSb3RhdGlvbk9yZGVyfSBbb3JkZXJdIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgb3JkZXIgdGhhdCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLlxuICAgKi9cbiAgc2V0KHgsIHksIHosIG9yZGVyKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcbiAgICBvbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB7QGxpbmsgRXVsZXJ9IHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB0aGlzIG9uZS5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge0V1bGVyfVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBFdWxlcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHZhbHVlIG9mIGBldWxlcmAgdG8gdGhpcyBldWxlci5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RXVsZXJ9IGVcbiAgICovXG4gIGNvcHkoZSkge1xuICAgIHRoaXMuX3ggPSBlLng7XG4gICAgdGhpcy5feSA9IGUueTtcbiAgICB0aGlzLl96ID0gZS56O1xuICAgIHRoaXMuX29yZGVyID0gZS5vcmRlcjtcbiAgICBvbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYW5nbGVzIG9mIHRoaXMgZXVsZXIgdHJhbnNmb3JtIGZyb20gYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCBiYXNlZFxuICAgKiBvbiB0aGUgb3JpZW50YXRpb24gc3BlY2lmaWVkIGJ5IGBvcmRlcmAuXG4gICAqIEBtZXRob2Qgc2V0RnJvbVJvdGF0aW9uTWF0cml4XG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtIEEge0BsaW5rIE1hdHJpeDR9IG9mIHdoaWNoIHRoZSB1cHBlciAzeDMgb2YgbWF0cml4IGlzIGEgcHVyZSBbcm90YXRpb24gbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3RhdGlvbl9tYXRyaXgpIChpLmUuIHVuc2NhbGVkKS5cbiAgICogQHBhcmFtIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtvcmRlcl0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT10cnVlXSBXaGV0aGVyIHRvIGNhbGwge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IGFmdGVyIGFwcGx5aW5nIHRoZSBtYXRyaXguXG4gICAqL1xuICBzZXRGcm9tUm90YXRpb25NYXRyaXgobSwgb3JkZXIsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuICAgIGNvbnN0IHRlID0gbS5lbGVtZW50cztcblxuICAgIGNvbnN0IFtcbiAgICAgIG0xMSwgbTIxLCBtMzEsIG00MSxcbiAgICAgIG0xMiwgbTIyLCBtMzIsIG00MixcbiAgICAgIG0xMywgbTIzLCBtMzMsIG00MyxcbiAgICBdID0gdGU7XG5cbiAgICBvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgaWYgKG9yZGVyID09PSAnWFlaJykge1xuICAgICAgdGhpcy5feSA9IE1hdGguYXNpbihjbGFtcChtMTMsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMTMpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVhaJykge1xuICAgICAgdGhpcy5feCA9IE1hdGguYXNpbigtY2xhbXAobTIzLCAtMSwgMSkpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobTIzKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIobTEzLCBtMzMpO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMihtMjEsIG0yMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWlhZJykge1xuICAgICAgdGhpcy5feCA9IE1hdGguYXNpbihjbGFtcChtMzIsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMzIpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMzMpO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMigtbTEyLCBtMjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG0yMSwgbTExKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuICAgICAgdGhpcy5feSA9IE1hdGguYXNpbigtY2xhbXAobTMxLCAtMSwgMSkpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobTMxKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMzMpO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMihtMjEsIG0xMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoLW0xMiwgbTIyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWVpYJykge1xuICAgICAgdGhpcy5feiA9IE1hdGguYXNpbihjbGFtcChtMjEsIC0xLCAxKSk7XG5cbiAgICAgIGlmIChNYXRoLmFicyhtMjEpIDwgMC45OTk5OSkge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMjIpO1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMigtbTMxLCBtMTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKG0xMywgbTMzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWFpZJykge1xuICAgICAgdGhpcy5feiA9IE1hdGguYXNpbigtY2xhbXAobTEyLCAtMSwgMSkpO1xuXG4gICAgICBpZiAoTWF0aC5hYnMobTEyKSA8IDAuOTk5OTkpIHtcbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIobTMyLCBtMjIpO1xuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMihtMTMsIG0xMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMigtbTIzLCBtMzMpO1xuICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBFdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAke29yZGVyfWApO1xuICAgIH1cblxuICAgIHRoaXMuX29yZGVyID0gb3JkZXI7XG5cbiAgICBpZiAodXBkYXRlICE9PSBmYWxzZSkge1xuICAgICAgb25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFuZ2xlcyBvZiB0aGlzIGV1bGVyIHRyYW5zZm9ybSBmcm9tIGEgbm9ybWFsaXplZCBxdWF0ZXJuaW9uIGJhc2VkXG4gICAqIG9uIHRoZSBvcmllbnRhdGlvbiBzcGVjaWZpZWQgYnkgYG9yZGVyYC5cbiAgICogQG1ldGhvZCBzZXRGcm9tUXVhdGVybmlvblxuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcSBBIG5vcm1hbGl6ZWQgcXVhdGVybmlvbi5cbiAgICogQHBhcmFtIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtvcmRlcl0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZT10cnVlXSBXaGV0aGVyIHRvIGNhbGwge0BsaW5rIEV1bGVyI29uQ2hhbmdlQ2FsbGJhY2t9IGFmdGVyIGFwcGx5aW5nIHRoZSBtYXRyaXguXG4gICAqL1xuICBzZXRGcm9tUXVhdGVybmlvbihxLCBvcmRlciwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zZXRGcm9tUXVhdGVybmlvblEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNldEZyb21RdWF0ZXJuaW9uUSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRGcm9tUXVhdGVybmlvblEubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocSk7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KHRoaXMuc2V0RnJvbVF1YXRlcm5pb25RLCBvcmRlciwgdXBkYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgRXVsZXIjeH0sIHtAbGluayBFdWxlciN5fSwgYW5kIHtAbGluayBFdWxlciN6fSwgYW5kXG4gICAqIG9wdGlvbmFsbHkgdXBkYXRlIHRoZSB7QGxpbmsgRXVsZXIjb3JkZXJ9LiB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja31cbiAgICogaXMgY2FsbGVkIGFmdGVyIHRoZXNlIGNoYW5nZXMgYXJlIG1hZGUuXG4gICAqIEBtZXRob2Qgc2V0RnJvbVZlY3RvcjNcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICogQHBhcmFtIHtFdWxlclJvdGF0aW9uT3JkZXJ9IFtvcmRlcl0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAqL1xuICBzZXRGcm9tVmVjdG9yMyh2LCBvcmRlciA9IHRoaXMuX29yZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KHYueCwgdi55LCB2LnosIG9yZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGV1bGVyIGFuZ2xlIHdpdGggYSBgbmV3T3JkZXJgIGJ5IGNyZWF0aW5nIGEgcXVhdGVybmlvbiBmcm9tIHRoaXNcbiAgICogZXVsZXIgYW5nbGUgYW5kIHRoZW4gc2V0dGluZyB0aGlzIGV1bGVyIGFuZ2xlIHdpdGggdGhlIHF1YXRlcm5pb24gYW5kIHRoZVxuICAgKiBgbmV3T3JkZXJgLlxuICAgKlxuICAgKiBfV0FSTklOR186IHRoaXMgZGlzY2FyZHMgcmV2b2x1dGlvbiBpbmZvcm1hdGlvbi5cbiAgICogQG1ldGhvZCByZW9yZGVyXG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RXVsZXJSb3RhdGlvbk9yZGVyfSBbbmV3T3JkZXJdXG4gICAqL1xuICByZW9yZGVyKG5ld09yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJlb3JkZXJRID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZW9yZGVyUSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW9yZGVyUS5zZXRGcm9tRXVsZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24odGhpcy5yZW9yZGVyUSwgbmV3T3JkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3Igc3RyaWN0IGVxdWFsaXR5IG9mIHRoaXMgZXVsZXIgYW5kIGBldWxlcmAuXG4gICAqIEBtZXRob2QgZXF1YWxzXG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RXVsZXJ9IGV1bGVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMoZXVsZXIpIHtcbiAgICByZXR1cm4gKGV1bGVyLnggPT09IHRoaXMuX3gpICYmXG4gICAgICAoZXVsZXIueSA9PT0gdGhpcy5feSkgJiZcbiAgICAgIChldWxlci56ID09PSB0aGlzLl96KSAmJlxuICAgICAgKGV1bGVyLm9yZGVyID09PSB0aGlzLl9vcmRlcik7XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyB0aGlzIGV1bGVyJ3Mge0BsaW5rIEV1bGVyI3h9IGFuZ2xlIHRvIGBhcnJheVswXWAuIEFzc2lnbnMgdGhpc1xuICAgKiBldWxlcidzIHtAbGluayBFdWxlciN5fSBhbmdsZSB0byBgYXJyYXlbMV1gLiBBc3NpZ25zIHRoaXMgZXVsZXInc1xuICAgKiB7QGxpbmsgRXVsZXIjen0gYW5nbGUgdG8gYGFycmF5WzJdYC4gT3B0aW9uYWxseSBhc3NpZ25zIHRoaXMgZXVsZXInc1xuICAgKiB7QGxpbmsgRXVsZXIjb3JkZXJ9IHRvIGBhcnJheVszXWAuXG4gICAqIEBtZXRob2QgZnJvbUFycmF5XG4gICAqIEBtZW1iZXJvZiBFdWxlci5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7QXJyYXl9IGFycmF5IEFycmF5IG9mIGxlbmd0aCAzIG9yIDQuIFRoZSBvcHRpb25hbCA0dGggYXJndW1lbnQgY29ycmVzcG9uZHMgdG8ge0BsaW5rIEV1bGVyI29yZGVyfS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSkge1xuICAgIHRoaXMuX3ggPSBhcnJheVswXTtcbiAgICB0aGlzLl95ID0gYXJyYXlbMV07XG4gICAgdGhpcy5feiA9IGFycmF5WzJdO1xuXG4gICAgaWYgKGFycmF5WzNdICE9PSB1bmRlZmluZWQgJiYgYXJyYXlbM10gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX29yZGVyID0gYXJyYXlbM107XG4gICAgfVxuXG4gICAgb25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gYFt4LCB5LCB6LCBvcmRlcl1gLlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gW2FycmF5PVtdXSBBcnJheSB0byBzdG9yZSB0aGUgZXVsZXIgaW4uXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBPZmZzZXQgaW4gdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpcy5feTtcbiAgICBhcnJheVtvZmZzZXQgKyAyXSA9IHRoaXMuX3o7XG4gICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLl9vcmRlcjtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXVsZXIncyB7QGxpbmsgRXVsZXIjeH0sIHtAbGluayBFdWxlciN5fSwgYW5kIHtAbGluayBFdWxlciN6fVxuICAgKiBwcm9wZXJ0aWVzIGFzIGEge0BsaW5rIFZlY3RvcjN9LlxuICAgKiBAbWV0aG9kIHRvVmVjdG9yM1xuICAgKiBAbWVtYmVyb2YgRXVsZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IFtvcHRpb25hbFJlc3VsdF1cbiAgICogQHJldHVybiB7VmVjdG9yM31cbiAgICovXG4gIHRvVmVjdG9yMyhvcHRpb25hbFJlc3VsdCkge1xuICAgIGlmIChvcHRpb25hbFJlc3VsdCkge1xuICAgICAgcmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3opO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRXVsZXIjb25DaGFuZ2VDYWxsYmFja30gZnVuY3Rpb24uXG4gICAqIEBtZXRob2Qgb25DaGFuZ2VcbiAgICogQG1lbWJlcm9mIEV1bGVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICBvbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbkNoYW5nZUNhbGxiYWNrKCkge31cbn1cblxuIiwiaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi9WZWN0b3IzJztcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4vVmVjdG9yMic7XG5leHBvcnQgY29uc3QgREVHMlJBRCA9IE1hdGguUEkgLyAxODA7XG5leHBvcnQgY29uc3QgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7XG5cbi8qKlxuICogQ29udmVydHMgZGVncmVzcyB0byByYWRpYW5zLlxuICogQG1ldGhvZCBkZWdUb1JhZFxuICogQG1lbWJlcm9mIG1vZHVsZTpNYXRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRlZ3JlZXNcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZ1RvUmFkID0gKGRlZ3JlZXMpID0+IGRlZ3JlZXMgKiBERUcyUkFEO1xuXG4vKipcbiAqIENvbnZlcnRzIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAqIEBtZXRob2QgcmFkVG9EZWdcbiAqIEBtZW1iZXJvZiBtb2R1bGU6TWF0aFxuICogQHBhcmFtICB7bnVtYmVyfSByYWRpYW5zXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByYWRUb0RlZyA9IChyYWRpYW5zKSA9PiByYWRpYW5zICogUkFEMkRFRztcblxuLyoqXG4gKiBWZWN0b3IzIOqwkuydhCDtmITsnqwgU2NyZWVuIOuCtOyXkCBWZWN0b3IyIOqwkuycvOuhnCDrs4DtmZhcbiAqIEBtZW1iZXJvZiBtb2R1bGU6TWF0aFxuICogQG1ldGhvZCB3b3JsZFRvU2NyZWVuXG4gKiBAcGFyYW0ge1ZlY3RvcjN9IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtWZWN0b3IyfVxuICovXG5leHBvcnQgY29uc3Qgd29ybGRUb1NjcmVlbiA9IChwb3NpdGlvbikgPT4ge1xuICBjb25zdCBjYW1lcmEgPSBMZXRzZWVFbmdpbmUuY2FtZXJhO1xuXG4gIGlmIChjYW1lcmEpIHtcbiAgICBjb25zdCB2ID0gcG9zaXRpb24uY2xvbmUoKTtcblxuICAgIHYucHJvamVjdChjYW1lcmEpO1xuICAgIHJldHVybiBuZXcgVmVjdG9yMigpLnNldChcbiAgICAgICh2LnggKyAxKSAqIChzY3JlZW4ud2lkdGggLyAyKSxcbiAgICAgICgtdi55ICsgMSkgKiAoc2NyZWVuLmhlaWdodCAvIDIpXG4gICAgKTtcbiAgfVxuICBjb25zb2xlLmVycm9yKCdDYW1lcmEgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGFtcHMgdGhlIGB2YWx1ZWAgdG8gYmUgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gKiBAbWV0aG9kIGNsYW1wXG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gYmUgY2xhbXBlZC5cbiAqIEBwYXJhbSAge251bWJlcn0gbWluICAgTWluaW11bSB2YWx1ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gbWF4ICAgTWF4aW11bSB2YWx1ZS5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNsYW1wID0gKHZhbHVlLCBtaW4sIG1heCkgPT4ge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIEV1Y2xpZGVhbiBtb2R1bGUgb2YgYG0gJSBuYCwgdGhhdCBpczpcbiAqIGBgYFxuICogKChuICUgbSkgKyBtKSAlIG1cbiAqIGBgYFxuICogQG1ldGhvZCBldWNsaWRlYW5Nb2R1bG9cbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSBuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxuZXhwb3J0IGNvbnN0IGV1Y2xpZGVhbk1vZHVsbyA9IChuLCBtKSA9PiB7XG4gIHJldHVybiAoKG4gJSBtKSArIG0pICUgbTtcbn07XG5cbi8qKlxuICogTGluZWFyIG1hcHBpbmcgb2YgYHhgIGZyb20gcmFuZ2UgYFthMSwgYTJdYCB0byByYW5nZSBgW2IxLCBiMl1gLlxuICogQG1ldGhvZCBtYXBMaW5lYXJcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB4ICBWYWx1ZSB0byBiZSBtYXBwZWQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGExIE1pbmltdW0gdmFsdWUgZm9yIHJhbmdlIEEuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGEyIE1heGltdW0gdmFsdWUgZm9yIHJhbmdlIEEuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGIxIE1pbmltdW0gdmFsdWUgZm9yIHJhbmdlIEIuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGIyIE1heGltdW0gdmFsdWUgZm9yIHJhbmdlIEIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBMaW5lYXIgPSAoeCwgYTEsIGEyLCBiMSwgYjIpID0+IHtcbiAgcmV0dXJuIGIxICsgKCh4IC0gYTEpICogKGIyIC0gYjEpIC8gKGEyIC0gYTEpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlXG4gKiBbbGluZWFybHkgaW50ZXJwb2xhdGVkXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvbilcbiAqIGZyb20gdHdvIGtub3duIHBvaW50cyBiYXNlZCBvbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgLSBgdCA9IDBgIHdpbGwgcmV0dXJuIGB4YFxuICogYW5kIGB0ID0gMWAgd2lsbCByZXR1cm4gYHlgLlxuICogQG1ldGhvZCBsZXJwXG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0geCBTdGFydCBwb2ludC5cbiAqIEBwYXJhbSAge251bWJlcn0geSBFbmQgcG9pbnQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnZlcnZhbCBgWzAsIDFdYC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxlcnAgPSAoeCwgeSwgdCkgPT4ge1xuICByZXR1cm4gKCgxIC0gdCkgKiB4KSArICh0ICogeSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIGAwYCBhbmQgYDFgIHRoYXQgcmVwcmVzZW50cyB0aGUgcGVyY2VudGFnZSB0aGF0IGB4YFxuICogaGFzIG1vdmVkIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLCBidXQgc21vb3RoZWQgb3Igc2xvd2VkIGRvd24gdGhlIGNsb3NlciBgeGBcbiAqIGlzIHRvIHRoZSBgbWluYCBhbmQgYG1heGAuIFNlZVxuICogW1Ntb290aHN0ZXBdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcCkgZm9yIGRldGFpbHMuXG4gKiBAbWV0aG9kIHNtb290aHN0ZXBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB4ICAgVGhlIHZhbHVlIHRvIGV2YWx1YXRlIGJhc2VkIG9uIGl0cyBwb3NpdGlvbiBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqIEBwYXJhbSAge251bWJlcn0gbWluIEFueSBgeGAgdmFsdWUgYmVsb3cgYG1pbmAgd2lsbCBiZSBgMGAuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1heCBBbnkgYHhgIHZhbHVlIGFib3ZlIGBtYXhgIHdpbGwgYmUgYDFgLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qgc21vb3Roc3RlcCA9ICh4LCBtaW4sIG1heCkgPT4ge1xuICBpZiAoeCA8PSBtaW4pIHJldHVybiAwO1xuICBpZiAoeCA+PSBtYXgpIHJldHVybiAxO1xuXG4gIHggPSAoeCAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgcmV0dXJuIHggKiB4ICogKDMgLSAoMiAqIHgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgMWAuIEFcbiAqIFt2YXJpYXRpb24gb24gc21vb3Roc3RlcF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcCNWYXJpYXRpb25zKVxuICogdGhhdCBoYXMgemVybyAxc3QgYW5kIDJuZCBvcmRlciBkZXJpdmF0aXZlcyBhdCBgeCA9IDBgIGFuZCBgeCA9IDFgLlxuICogQG1ldGhvZCBzbW9vdGhlcnN0ZXBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB4ICAgVGhlIHZhbHVlIHRvIGV2YWx1YXRlIGJhc2VkIG9uIGl0cyBwb3NpdGlvbiBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqIEBwYXJhbSAge251bWJlcn0gbWluIEFueSBgeGAgdmFsdWUgYmVsb3cgYG1pbmAgd2lsbCBiZSBgMGAuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IG1heCBBbnkgYHhgIHZhbHVlIGFib3ZlIGBtYXhgIHdpbGwgYmUgYDFgLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qgc21vb3RoZXJzdGVwID0gKHgsIG1pbiwgbWF4KSA9PiB7XG4gIGlmICh4IDw9IG1pbikgcmV0dXJuIDA7XG4gIGlmICh4ID49IG1heCkgcmV0dXJuIDE7XG5cbiAgeCA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xuICByZXR1cm4geCAqIHggKiB4ICogKCh4ICogKCh4ICogNikgLSAxNSkpICsgMTApO1xufTtcblxuLyoqXG4gKiBSYW5kb20gaW50ZWdlciBpbiB0aGUgaW50ZXJ2YWwgYGxvd2AgdG8gYGhpZ2hgLlxuICogQG1ldGhvZCByYW5kSW50XG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0gbG93XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJhbmRJbnQgPSAobG93LCBoaWdoKSA9PiBsb3cgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdyArIDEpKTtcblxuLyoqXG4gKiBSYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIGBsb3dgIHRvIGBoaWdoYC5cbiAqIEBtZXRob2QgcmFuZEZsb2F0XG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0gbG93XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJhbmRGbG9hdCA9IChsb3csIGhpZ2gpID0+IGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKTtcblxuLyoqXG4gKiBSYW5kb20gZmxvYXQgaW4gdGhlIGludGVydmFsIGAtcmFuZ2UvMmAgdG8gYHJhbmdlLzJgLlxuICogQG1ldGhvZCByYW5kRmxvYXRTcHJlYWRcbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSByYW5nZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcmFuZEZsb2F0U3ByZWFkID0gKHJhbmdlKSA9PiByYW5nZSAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcG93ZXIgb2YgMi5cbiAqIEBtZXRob2QgaXNQb3dlck9mVHdvXG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0gIHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNQb3dlck9mVHdvID0gKHZhbHVlKSA9PiAodmFsdWUgJiAodmFsdWUgLSAxKSkgPT09IDAgJiYgdmFsdWUgIT09IDA7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBuZWFyZXN0IHBvd2VyIG9mIDIgdG8gYSBnaXZlbiBudW1iZXIgYHZhbHVlYC5cbiAqIEBtZXRob2QgbmVhcmVzdFBvd2VyT2ZUd29cbiAqIEBtZW1iZXJvZiBtb2R1bGU6VXRpbFxuICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbmVhcmVzdFBvd2VyT2ZUd28gPSAodmFsdWUpID0+IDIgKiogKE1hdGgucm91bmQoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMiB0aGF0IGlzIGJpZ2dlciB0aGFuIGB2YWx1ZWAuXG4gKiBAbWV0aG9kIG5leHRQb3dlck9mVHdvXG4gKiBAbWVtYmVyb2YgbW9kdWxlOlV0aWxcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IG5leHRQb3dlck9mVHdvID0gKHZhbHVlKSA9PiB7XG4gIGxldCByZXN1bHQgPSB2YWx1ZTtcblxuICByZXN1bHQgLT0gMTtcbiAgcmVzdWx0IHw9IHJlc3VsdCA+PiAxO1xuICByZXN1bHQgfD0gcmVzdWx0ID4+IDI7XG4gIHJlc3VsdCB8PSByZXN1bHQgPj4gNDtcbiAgcmVzdWx0IHw9IHJlc3VsdCA+PiA4O1xuICByZXN1bHQgfD0gcmVzdWx0ID4+IDE2O1xuICByZXN1bHQgKz0gMTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHdpdGggc2V2ZXJhbCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBtb2R1bGUgVXRpbFxuICogQGF1dGhvciBKb29IeXVuIExlZSAobGpoQGxldHNlZS5pbylcbiAqIEBzaW5jZSAyMDE2LiAwMy4gMTcuXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IE1hdGhVdGlsID0ge1xuICBkZWdUb1JhZCxcbiAgcmFkVG9EZWcsXG4gIHdvcmxkVG9TY3JlZW4sXG4gIGNsYW1wLFxuICBldWNsaWRlYW5Nb2R1bG8sXG4gIG1hcExpbmVhcixcbiAgbGVycCxcbiAgc21vb3Roc3RlcCxcbiAgc21vb3RoZXJzdGVwLFxuICByYW5kSW50LFxuICByYW5kRmxvYXQsXG4gIHJhbmRGbG9hdFNwcmVhZCxcbiAgaXNQb3dlck9mVHdvLFxuICBuZWFyZXN0UG93ZXJPZlR3byxcbiAgbmV4dFBvd2VyT2ZUd29cbn07XG5cbndpbmRvdy5NYXRoLmRlZ1RvUmFkID0gZGVnVG9SYWQ7XG53aW5kb3cuTWF0aC5yYWRUb0RlZyA9IHJhZFRvRGVnO1xud2luZG93Lk1hdGgud29ybGRUb1NjcmVlbiA9IHdvcmxkVG9TY3JlZW47XG5cbmV4cG9ydCBkZWZhdWx0IE1hdGhVdGlsO1xuIiwiaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi9WZWN0b3IzJztcbi8vIGltcG9ydCBNYXRyaXg0IGZyb20gJy4vTWF0cml4NCc7XG5cbi8qKlxuICogQVxuICogW2NvbHVtbi1tYWpvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm93LV9hbmRfY29sdW1uLW1ham9yX29yZGVyKVxuICogbGlzdCBvZiBtYXRyaXggdmFsdWVzLlxuICogQG1lbWJlciB7RmxvYXQzMkFycmF5fSBlbGVtZW50c1xuICogQG1lbWJlcm9mIE1hdHJpeDMjXG4gKiBAZGVmYXVsdCBbXG4gKiAxLCAwLCAwLFxuICogMCwgMSwgMCxcbiAqIDAsIDAsIDFcbiAqIF1cbiAqL1xuLy8gbGV0IHRoaXMuX2VsZW1lbnRzO1xuXG4vKipcbiAqIFVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGlzIG9yIGRlcml2ZWQgY2xhc3NlcyBhcmUge0BsaW5rIE1hdHJpeDN9cy4gWW91XG4gKiBzaG91bGQgbm90IGNoYW5nZSB0aGlzLCBhcyBpdCBpcyB1c2VkIGludGVybmFsbHkgZm9yIG9wdGltaXNhdGlvbi5cbiAqIEBwcm9wZXJ0eSBpc01hdHJpeDNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5jb25zdCBfaXNNYXRyaXgzID0gdHJ1ZTtcblxuLyoqXG4gKiBAY2xhc3MgTWF0cml4M1xuICogQGNsYXNzZGVzY1xuICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSAzeDNcbiAqIFttYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hdHJpeF8obWF0aGVtYXRpY3MpKS5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbSA9IG5ldyBNYXRyaXgzKCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeDMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICAwLCAwLCAxLFxuICAgIF0pO1xuICB9XG5cbiAgZ2V0IGVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgfVxuXG4gIGdldCBpc01hdHJpeDMoKSB7XG4gICAgcmV0dXJuIF9pc01hdHJpeDM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgM3gzIG1hdHJpeCB2YWx1ZXMgdG8gdGhlIGdpdmVuXG4gICAqIFtyb3ctbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlcilcbiAgICogc2VxdWVuY2Ugb2YgdmFsdWVzLlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4xMSBWYWx1ZSB0byBwdXQgaW4gcm93IDEsIGNvbCAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjEyIFZhbHVlIHRvIHB1dCBpbiByb3cgMSwgY29sIDIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMTMgVmFsdWUgdG8gcHV0IGluIHJvdyAxLCBjb2wgMy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4yMSBWYWx1ZSB0byBwdXQgaW4gcm93IDIsIGNvbCAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjIyIFZhbHVlIHRvIHB1dCBpbiByb3cgMiwgY29sIDIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMjMgVmFsdWUgdG8gcHV0IGluIHJvdyAyLCBjb2wgMy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG4zMSBWYWx1ZSB0byBwdXQgaW4gcm93IDMsIGNvbCAxLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjMyIFZhbHVlIHRvIHB1dCBpbiByb3cgMywgY29sIDIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMzMgVmFsdWUgdG8gcHV0IGluIHJvdyAzLCBjb2wgMy5cbiAgICovXG4gIHNldChcbiAgICBuMTEsIG4xMiwgbjEzLFxuICAgIG4yMSwgbjIyLCBuMjMsXG4gICAgbjMxLCBuMzIsIG4zMyxcbiAgKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLl9lbGVtZW50cztcblxuICAgIHRlWzBdID0gbjExO1xuICAgIHRlWzFdID0gbjIxO1xuICAgIHRlWzJdID0gbjMxO1xuICAgIHRlWzNdID0gbjEyO1xuICAgIHRlWzRdID0gbjIyO1xuICAgIHRlWzVdID0gbjMyO1xuICAgIHRlWzZdID0gbjEzO1xuICAgIHRlWzddID0gbjIzO1xuICAgIHRlWzhdID0gbjMzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIG1hdHJpeCB0byB0aGUgM3gzIGlkZW50aXR5IG1hdHJpeDpcbiAgICogYGBgXG4gICAqIDEgMCAwXG4gICAqIDAgMSAwXG4gICAqIDAgMCAxXG4gICAqIGBgYFxuICAgKiBAbWV0aG9kIGlkZW50aXR5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKi9cbiAgaWRlbnRpdHkoKSB7XG4gICAgdGhpcy5zZXQoXG4gICAgICAxLCAwLCAwLFxuICAgICAgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDEsXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbWF0cml4IHdpdGggaWRlbnRpY2FsIGVsZW1lbnRzIHRvIHRoaXMgb25lLlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtNYXRyaXgzfVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXgzKCkuZnJvbUFycmF5KHRoaXMuX2VsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGVsZW1lbnRzIG9mIG1hdHJpeCBgbWAgaW50byB0aGlzIG1hdHJpeC5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtNYXRyaXgzfSBtXG4gICAqL1xuICBjb3B5KG0pIHtcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnNldChcbiAgICAgIG1lWzBdLCBtZVszXSwgbWVbNl0sXG4gICAgICBtZVsxXSwgbWVbNF0sIG1lWzddLFxuICAgICAgbWVbMl0sIG1lWzVdLCBtZVs4XSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIG1hdHJpeCB0byB0aGUgdXBwZXIgM3gzIG1hdHJpeCBvZiB0aGUge0BsaW5rIE1hdHJpeDR9IGBtYC5cbiAgICogQG1ldGhvZCBzZXRGcm9tTWF0cml4NFxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBzZXRGcm9tTWF0cml4NChtKSB7XG4gICAgY29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy5zZXQoXG4gICAgICBtZVswXSwgbWVbNF0sIG1lWzhdLFxuICAgICAgbWVbMV0sIG1lWzVdLCBtZVs5XSxcbiAgICAgIG1lWzJdLCBtZVs2XSwgbWVbMTBdLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyAoYXBwbGllcykgdGhpcyBtYXRyaXggdG8gZXZlcnkgM0QgdmVjdG9yIGluIHRoZSBgYXR0cmlidXRlYC5cbiAgICogQG1ldGhvZCBhcHBseVRvQnVmZmVyQXR0cmlidXRlXG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtCdWZmZXJBdHRyaWJ1dGV9IGF0dHJpYnV0ZSBBbiBhdHRyaWJ1dGUgb2YgZmxvYXRzIHRoYXQgcmVwcmVzZXQgM0QgdmVjdG9ycy5cbiAgICogQHJldHVybiB7QnVmZmVyQXR0cmlidXRlfVxuICAgKi9cbiAgYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgdjEueCA9IGF0dHJpYnV0ZS5nZXRYKGkpO1xuICAgICAgdjEueSA9IGF0dHJpYnV0ZS5nZXRZKGkpO1xuICAgICAgdjEueiA9IGF0dHJpYnV0ZS5nZXRaKGkpO1xuICAgICAgdjEuYXBwbHlNYXRyaXgzKHRoaXMpO1xuICAgICAgYXR0cmlidXRlLnNldFhZWihpLCB2MS54LCB2MS55LCB2MS56KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgZXZlcnkgY29tcG9uZW50IG9mIHRoZSBtYXRyaXggYnkgdGhlIHNjYWxhciB2YWx1ZSBgc2AuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlTY2FsYXJcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAqL1xuICBtdWx0aXBseVNjYWxhcihzKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLl9lbGVtZW50cztcblxuICAgIHRlWzBdICo9IHM7XG4gICAgdGVbM10gKj0gcztcbiAgICB0ZVs2XSAqPSBzO1xuICAgIHRlWzFdICo9IHM7XG4gICAgdGVbNF0gKj0gcztcbiAgICB0ZVs3XSAqPSBzO1xuICAgIHRlWzJdICo9IHM7XG4gICAgdGVbNV0gKj0gcztcbiAgICB0ZVs4XSAqPSBzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIGFuZCByZXR1cm5zIHRoZVxuICAgKiBbZGV0ZXJtaW5hbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RldGVybWluYW50KSBvZiB0aGlzIG1hdHJpeC5cbiAgICogQG1ldGhvZCBkZXRlcm1pbmFudFxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZGV0ZXJtaW5hbnQoKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLl9lbGVtZW50cztcbiAgICBjb25zdCBhID0gdGVbMF07XG4gICAgY29uc3QgYiA9IHRlWzFdO1xuICAgIGNvbnN0IGMgPSB0ZVsyXTtcbiAgICBjb25zdCBkID0gdGVbM107XG4gICAgY29uc3QgZSA9IHRlWzRdO1xuICAgIGNvbnN0IGYgPSB0ZVs1XTtcbiAgICBjb25zdCBnID0gdGVbNl07XG4gICAgY29uc3QgaCA9IHRlWzddO1xuICAgIGNvbnN0IGkgPSB0ZVs4XTtcblxuICAgIHJldHVybiAoYSAqIGUgKiBpKSAtIChhICogZiAqIGgpIC0gKGIgKiBkICogaSkgKyAoYiAqIGYgKiBnKSArIChjICogZCAqIGgpIC0gKGMgKiBlICogZyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoaXMgbWF0cml4IHRvIHRoZVxuICAgKiBbaW52ZXJzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW52ZXJ0aWJsZV9tYXRyaXgpIG9mIHRoZSBwYXNzZWRcbiAgICogbWF0cml4IGBtYXRyaXhgLCB1c2luZyB0aGVcbiAgICogW2FuYWx5dGljIG1ldGhvZF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW52ZXJ0aWJsZV9tYXRyaXgjQW5hbHl0aWNfc29sdXRpb24pLlxuICAgKiBJZiBgdGhyb3dPbkRlZ2VuZXJhdGVgIGlzIG5vdCBzZXQgYW5kIHRoZSBtYXRyaXggaXMgbm90IGludmVydGlibGUsIHNldFxuICAgKiB0aGlzIHRvIHRoZSAzeDMgaWRlbnRpdHkgbWF0cml4LlxuICAgKiBAbWV0aG9kIGdldEludmVyc2VcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge01hdHJpeDN9IG1hdHJpeCBUaGUgbWF0cml4IHRvIHRha2UgdGhlIGludmVyc2Ugb2YuXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IFt0aHJvd09uRGVnZW5lcmF0ZT1mYWxzZV0gSWYgdHJ1ZSwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1hdHJpeCBpcyBkZWdlbmVyYXRlIChub3QgaW52ZXJ0aWJsZSkuXG4gICAqL1xuICBnZXRJbnZlcnNlKG1hdHJpeCwgdGhyb3dPbkRlZ2VuZXJhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IG1lID0gbWF0cml4LmVsZW1lbnRzO1xuICAgIGNvbnN0IHRlID0gdGhpcy5fZWxlbWVudHM7XG4gICAgY29uc3QgbjExID0gbWVbMF07XG4gICAgY29uc3QgbjIxID0gbWVbMV07XG4gICAgY29uc3QgbjMxID0gbWVbMl07XG4gICAgY29uc3QgbjEyID0gbWVbM107XG4gICAgY29uc3QgbjIyID0gbWVbNF07XG4gICAgY29uc3QgbjMyID0gbWVbNV07XG4gICAgY29uc3QgbjEzID0gbWVbNl07XG4gICAgY29uc3QgbjIzID0gbWVbN107XG4gICAgY29uc3QgbjMzID0gbWVbOF07XG4gICAgY29uc3QgdDExID0gKG4zMyAqIG4yMikgLSAobjMyICogbjIzKTtcbiAgICBjb25zdCB0MTIgPSAobjMyICogbjEzKSAtIChuMzMgKiBuMTIpO1xuICAgIGNvbnN0IHQxMyA9IChuMjMgKiBuMTIpIC0gKG4yMiAqIG4xMyk7XG4gICAgY29uc3QgZGV0ID0gKG4xMSAqIHQxMSkgKyAobjIxICogdDEyKSArIChuMzEgKiB0MTMpO1xuXG4gICAgaWYgKGRldCA9PT0gMCkge1xuICAgICAgY29uc3QgbXNnID0gJ01hdHJpeDMuZ2V0SW52ZXJzZSgpOiBjYW5cXCd0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDAnO1xuXG4gICAgICBpZiAodGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG4gICAgdGVbMF0gPSB0MTEgKiBkZXRJbnY7XG4gICAgdGVbMV0gPSAoKG4zMSAqIG4yMykgLSAobjMzICogbjIxKSkgKiBkZXRJbnY7XG4gICAgdGVbMl0gPSAoKG4zMiAqIG4yMSkgLSAobjMxICogbjIyKSkgKiBkZXRJbnY7XG4gICAgdGVbM10gPSB0MTIgKiBkZXRJbnY7XG4gICAgdGVbNF0gPSAoKG4zMyAqIG4xMSkgLSAobjMxICogbjEzKSkgKiBkZXRJbnY7XG4gICAgdGVbNV0gPSAoKG4zMSAqIG4xMikgLSAobjMyICogbjExKSkgKiBkZXRJbnY7XG4gICAgdGVbNl0gPSB0MTMgKiBkZXRJbnY7XG4gICAgdGVbN10gPSAoKG4yMSAqIG4xMykgLSAobjIzICogbjExKSkgKiBkZXRJbnY7XG4gICAgdGVbOF0gPSAoKG4yMiAqIG4xMSkgLSAobjIxICogbjEyKSkgKiBkZXRJbnY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogW1RyYW5zcG9zZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyYW5zcG9zZSkgdGhpcyBtYXRyaXggaW4gcGxhY2UuXG4gICAqIEBtZXRob2QgdHJhbnNwb3NlXG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKi9cbiAgdHJhbnNwb3NlKCkge1xuICAgIGxldCB0bXA7XG4gICAgY29uc3QgbSA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gICAgdG1wID0gbVsxXTtcbiAgICBtWzFdID0gbVszXTtcbiAgICBtWzNdID0gdG1wO1xuICAgIHRtcCA9IG1bMl07XG4gICAgbVsyXSA9IG1bNl07XG4gICAgbVs2XSA9IHRtcDtcbiAgICB0bXAgPSBtWzVdO1xuICAgIG1bNV0gPSBtWzddO1xuICAgIG1bN10gPSB0bXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyB0aGUgdXBwZXIgbGVmdCAzeDMgb2YgdGhlXG4gICAqIFtub3JtYWwgbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ob3JtYWxfbWF0cml4KSBvZiB0aGUgcGFzc2VkXG4gICAqIGBtYXRyaXg0YC4gVGhlIG5vcm1hbCBtYXRyaXggaXMgdGhlXG4gICAqIFtpbnZlcnNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnZlcnRpYmxlX21hdHJpeClcbiAgICogW3RyYW5zcG9zZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNwb3NlKSBvZiB0aGUgbWF0cml4XG4gICAqIGBtYXRyaXg0YC5cbiAgICogQG1ldGhvZCBnZXROb3JtYWxNYXRyaXhcbiAgICogQG1lbWJlcm9mIE1hdHJpeDMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbWF0cml4NFxuICAgKi9cbiAgZ2V0Tm9ybWFsTWF0cml4KG1hdHJpeDQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NChtYXRyaXg0KS5nZXRJbnZlcnNlKHRoaXMpLnRyYW5zcG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtUcmFuc3Bvc2VzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc3Bvc2UpIHRoaXMgbWF0cml4IGludG8gdGhlXG4gICAqIHN1cHBsaWVkIGFycmF5LCBhbmQgcmV0dXJucyBpdHNlbGYgdW5jaGFuZ2VkLlxuICAgKiBAbWV0aG9kIHRyYW5zcG9zZUludG9BcnJheVxuICAgKiBAbWVtYmVyb2YgTWF0cml4My5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gciBBcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIHZlY3RvciBpbi5cbiAgICovXG4gIHRyYW5zcG9zZUludG9BcnJheShyKSB7XG4gICAgY29uc3QgbSA9IHRoaXMuX2VsZW1lbnRzO1xuXG4gICAgclswXSA9IG1bMF07XG4gICAgclsxXSA9IG1bM107XG4gICAgclsyXSA9IG1bNl07XG4gICAgclszXSA9IG1bMV07XG4gICAgcls0XSA9IG1bNF07XG4gICAgcls1XSA9IG1bN107XG4gICAgcls2XSA9IG1bMl07XG4gICAgcls3XSA9IG1bNV07XG4gICAgcls4XSA9IG1bOF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZWxlbWVudHMgb2YgdGhpcyBtYXRyaXggYmFzZWQgb24gYW4gYGFycmF5YCBpblxuICAgKiBbY29sdW1uLW1ham9yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Sb3ctX2FuZF9jb2x1bW4tbWFqb3Jfb3JkZXIjQ29sdW1uLW1ham9yX29yZGVyKVxuICAgKiBmb3JtYXQuXG4gICAqIEBtZXRob2QgZnJvbUFycmF5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlYWQgdGhlIGVsZW1lbnRzIGZyb20uXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBJbmRleCBvZiBmaXJzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSwgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGluZGV4ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkgKz0gMSkge1xuICAgICAgdGhpcy5fZWxlbWVudHNbaV0gPSBhcnJheVtpICsgaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgbWF0cml4IHRvIGFuIGFycmF5IGluXG4gICAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gICAqIGZvcm1hdC5cbiAgICogQG1ldGhvZCB0b0FycmF5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXgzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gW2FycmF5PVtdXSAgQXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyB2ZWN0b3IgaW4uIElmIG5vdCBnaXZlbiBhIG5ldyBhcnJheSB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRvIHB1dCB0aGUgcmVzdWx0LlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGlmIChhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gb2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgdGUgPSB0aGlzLl9lbGVtZW50cztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGFycmF5W2luZGV4ICsgaV0gPSB0ZVtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn1cblxuIiwiaW1wb3J0IFZlY3RvcjMgZnJvbSAnLi9WZWN0b3IzJztcbmltcG9ydCBRdWF0ZXJuaW9uIGZyb20gJy4vUXVhdGVybmlvbic7XG5pbXBvcnQge2RlZ1RvUmFkfSBmcm9tICcuL01hdGgnO1xuXG4vLyBjb25zdGFudHMgZm9yIG9wdGltaXNhdGlvblxubGV0IGV4dHJhY3RSb3RhdGlvblY7XG5sZXQgbG9va0F0WDtcbmxldCBsb29rQXRZO1xubGV0IGxvb2tBdFo7XG5sZXQgZGVjb21wb3NlVjtcbmxldCBkZWNvbXBvc2VNO1xuXG4vKipcbiAqIEFcbiAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gKiBsaXN0IG9mIG1hdHJpeCB2YWx1ZXMuXG4gKiBAbWVtYmVyIHtudW1iZXJbXX0gZWxlbWVudHNcbiAqIEBtZW1iZXJvZiBNYXRyaXg0I1xuICogQGRlZmF1bHQgW1xuICogMSwgMCwgMCwgMCxcbiAqIDAsIDEsIDAsIDAsXG4gKiAwLCAwLCAxLCAwLFxuICogMCwgMCwgMCwgMVxuICogXVxuICovXG4vLyBsZXQgdGhpcy5lbGVtZW50cyA9IFtcbi8vICAgMSwgMCwgMCwgMCxcbi8vICAgMCwgMSwgMCwgMCxcbi8vICAgMCwgMCwgMSwgMCxcbi8vICAgMCwgMCwgMCwgMVxuLy8gXTtcblxubGV0IG9uQ2hhbmdlQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuY29uc3QgX2lzTWF0cml4NCA9IHRydWU7XG5cbi8qKlxuICogQGNsYXNzIE1hdHJpeDRcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgNHg0XG4gKiBbbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXRyaXhfKG1hdGhlbWF0aWNzKSkuIFRoZSBtb3N0XG4gKiBjb21tb24gdXNlIG9mIGEgNHg0IG1hdHJpeCBpbiAzRCBjb21wdXRlciBncmFwaGljcyBpcyBhcyBhXG4gKiBbdHJhbnNmb3JtYXRpb24gbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc2Zvcm1hdGlvbl9tYXRyaXgpLlxuICogRm9yIGFuIGludHJvZHVjdGlvbiB0byB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBhcyB1c2VkIGluIFdlYkdMLCBjaGVjayBvdXRcbiAqIHRoaXNcbiAqIFt0dXRvcmlhbF0oaHR0cDovL3d3dy5vcGVuZ2wtdHV0b3JpYWwub3JnL2JlZ2lubmVycy10dXRvcmlhbHMvdHV0b3JpYWwtMy1tYXRyaWNlcykuXG4gKiBUaGlzIGFsbG93cyBhIHtAbGluayBWZWN0b3IzfSByZXByZXNlbnRpbmcgYSBwb2ludCBpbiAzRCBzcGFjZSB0byB1bmRlcmdvXG4gKiB0cmFuc2Zvcm1hdGlvbnMgc3VjaCBhcyB0cmFuc2xhdGlvbiwgcm90YXRpb24sIHNoZWFyLCBzY2FsZSwgcmVmbGVjdGlvbixcbiAqIG9ydGhvZ29uYWwgb3IgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBhbmQgc28gb24sIGJ5IGJlaW5nIG11bHRpcGxpZWQgYnkgdGhlXG4gKiBtYXRyaXguIFRoaXMgaXMga25vd24gYXMgX2FwcGx5aW5nXyB0aGUgbWF0cml4IHRvIHRoZSB2ZWN0b3IuXG4gKlxuICogRXZlcnkge0BsaW5rIE9iamVjdDNEfSBoYXMgdGhyZWUgYXNzb2NpYXRlZCB7QGxpbmsgTWF0cml4NH1zOlxuICogKiB7QGxpbmsgT2JqZWN0M0QjbWF0cml4fTogdGhpcyBzdG9yZXMgdGhlIGxvY2FsIHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0LlxuICogKiB7QGxpbmsgT2JqZWN0M0QjbWF0cml4V29ybGR9OiB0aGUgZ2xvYmFsIG9yIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0LiBUaGlzIGlzIHRoZSBvYmplY3RzIHRyYW5zZm9ybWF0aW9uIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuIElmIHRoZSBvYmplY3QgaGFzIG5vIHBhcmVudCwgdGhlbiB0aGlzIGlzIGlkZW50aWNhbCB0byB0aGUgbG9jYWwgdHJhbnNmb3JtLlxuICogKiB7QGxpbmsgT2JqZWN0M0QjbW9kZWxWaWV3TWF0cml4fTogVE9ETy5cbiAqXG4gKiB7QGxpbmsgQ2FtZXJhfXMgaGF2ZSB0d28gYWRkaXRpb25hbCB7QGxpbmsgTWF0cml4NH1zOlxuICogKiB7QGxpbmsgQ2FtZXJhI21hdHJpeFdvcmxkSW52ZXJzZX06IFRoZSBpbnZlcnNlIG9mIHRoZSB7QGxpbmsgT2JqZWN0M0QjbWF0cml4V29ybGR9IGRlc2NyaWJlZCBhYm92ZS5cbiAqICoge0BsaW5rIENhbWVyYSNwcm9qZWN0aW9uTWF0cml4fTogVE9ETy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0cml4NCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXG4gICAgICAxLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgIF07XG4gIH1cbiAgLy9cbiAgLy8gZ2V0IGVsZW1lbnRzKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xuICAvLyB9XG5cbiAgZ2V0IGlzTWF0cml4NCgpIHtcbiAgICByZXR1cm4gX2lzTWF0cml4NDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHtAbGluayBNYXRyaXg0I2VsZW1lbnRzfSBvZiB0aGlzIG1hdHJpeCB0byB0aGUgc3VwcGxpZWQgcm93LW1ham9yXG4gICAqIHZhbHVlcyBgbjExYCwgYG4xMmAsIC4uLiwgYG40NGAuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbjExXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMTJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4xM1xuICAgKiBAcGFyYW0ge251bWJlcn0gbjE0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMjFcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4yMlxuICAgKiBAcGFyYW0ge251bWJlcn0gbjIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMjRcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4zMVxuICAgKiBAcGFyYW0ge251bWJlcn0gbjMyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuMzNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4zNFxuICAgKiBAcGFyYW0ge251bWJlcn0gbjQxXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuNDJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG40M1xuICAgKiBAcGFyYW0ge251bWJlcn0gbjQ0XG4gICAqL1xuICBzZXQoXG4gICAgbjExLCBuMTIsIG4xMywgbjE0LFxuICAgIG4yMSwgbjIyLCBuMjMsIG4yNCxcbiAgICBuMzEsIG4zMiwgbjMzLCBuMzQsXG4gICAgbjQxLCBuNDIsIG40MywgbjQ0LFxuICApIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVswXSA9IG4xMTtcbiAgICB0ZVs0XSA9IG4xMjtcbiAgICB0ZVs4XSA9IG4xMztcbiAgICB0ZVsxMl0gPSBuMTQ7XG4gICAgdGVbMV0gPSBuMjE7XG4gICAgdGVbNV0gPSBuMjI7XG4gICAgdGVbOV0gPSBuMjM7XG4gICAgdGVbMTNdID0gbjI0O1xuICAgIHRlWzJdID0gbjMxO1xuICAgIHRlWzZdID0gbjMyO1xuICAgIHRlWzEwXSA9IG4zMztcbiAgICB0ZVsxNF0gPSBuMzQ7XG4gICAgdGVbM10gPSBuNDE7XG4gICAgdGVbN10gPSBuNDI7XG4gICAgdGVbMTFdID0gbjQzO1xuICAgIHRlWzE1XSA9IG40NDtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBtYXRyaXggdG8gdGhlXG4gICAqIFtpZGVudGl0eSBtYXRyaXhdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lkZW50aXR5X21hdHJpeCkuXG4gICAqIEBtZXRob2QgaWRlbnRpdHlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqL1xuICBpZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtYXRyaXggd2l0aCBpZGVudGljYWwge0BsaW5rIE1hdHJpeDQjZWxlbWVudHN9IHRvIHRoaXMgb25lLlxuICAgKiBAbWV0aG9kIGNsb25lXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtNYXRyaXg0fVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUge0BsaW5rIE1hdHJpeDQjZWxlbWVudHN9IG9mIG1hdHJpeCBgbWAgaW50byB0aGlzIG1hdHJpeC5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIGNvcHkobSkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0ZVswXSA9IG1lWzBdO1xuICAgIHRlWzFdID0gbWVbMV07XG4gICAgdGVbMl0gPSBtZVsyXTtcbiAgICB0ZVszXSA9IG1lWzNdO1xuICAgIHRlWzRdID0gbWVbNF07XG4gICAgdGVbNV0gPSBtZVs1XTtcbiAgICB0ZVs2XSA9IG1lWzZdO1xuICAgIHRlWzddID0gbWVbN107XG4gICAgdGVbOF0gPSBtZVs4XTtcbiAgICB0ZVs5XSA9IG1lWzldO1xuICAgIHRlWzEwXSA9IG1lWzEwXTtcbiAgICB0ZVsxMV0gPSBtZVsxMV07XG4gICAgdGVbMTJdID0gbWVbMTJdO1xuICAgIHRlWzEzXSA9IG1lWzEzXTtcbiAgICB0ZVsxNF0gPSBtZVsxNF07XG4gICAgdGVbMTVdID0gbWVbMTVdO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnQgb2YgdGhlIHN1cHBsaWVkIG1hdHJpeCBgbWAgaW50byB0aGlzXG4gICAqIG1hdHJpeCdzIHRyYW5zbGF0aW9uIGNvbXBvbmVudC5cbiAgICogQG1ldGhvZCBjb3B5UG9zaXRpb25cbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgY29weVBvc2l0aW9uKG0pIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuICAgIHRlWzEyXSA9IG1lWzEyXTtcbiAgICB0ZVsxM10gPSBtZVsxM107XG4gICAgdGVbMTRdID0gbWVbMTRdO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBbYmFzaXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2lzXyhsaW5lYXJfYWxnZWJyYSkpXG4gICAqIG9mIHRoaXMgbWF0cml4IGludG8gdGhlIHRocmVlIGF4aXMgdmVjdG9ycyBwcm92aWRlZC4gSWYgdGhpcyBtYXRyaXggaXM6XG4gICAqIGBgYFxuICAgKiBhIGIgYyBkXG4gICAqIGUgZiBnIGhcbiAgICogaSBqIGsgbFxuICAgKiBtIG4gbyBwXG4gICAqIGBgYFxuICAgKiB0aGVuIHRoZSBgeEF4aXNgLCBgeUF4aXNgLCBgekF4aXNgIHdpbGwgYmUgc2V0IHRvOlxuICAgKiBgYGBcbiAgICogeEF4aXMgPSAoYSwgZSwgaSlcbiAgICogeUF4aXMgPSAoZCwgZiwgailcbiAgICogekF4aXMgPSAoYywgZywgaylcbiAgICogYGBgXG4gICAqIEBtZXRob2QgZXh0cmFjdEJhc2lzXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHhBeGlzXG4gICAqIEBwYXJhbSB7VmVjdG9yM30geUF4aXNcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB6QXhpc1xuICAgKi9cbiAgZXh0cmFjdEJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcbiAgICB4QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDApO1xuICAgIHlBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMSk7XG4gICAgekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0aGVcbiAgICogW2Jhc2lzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNpc18obGluZWFyX2FsZ2VicmEpKSBtYXRyaXhcbiAgICogY29uc2lzdGluZyBvZiB0aGUgdGhyZWUgcHJvdmlkZWQgYmFzaXMgdmVjdG9yczpcbiAgICogYGBgXG4gICAqIHhBeGlzLnggIHlBeGlzLnggIHpBeGlzLnggIDBcbiAgICogeEF4aXMueSAgeUF4aXMueSAgekF4aXMueSAgMFxuICAgKiB4QXhpcy56ICB5QXhpcy56ICB6QXhpcy56ICAwXG4gICAqICAgIDAgICAgICAgIDAgICAgICAgIDAgICAgIDBcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZUJhc2lzXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHhBeGlzXG4gICAqIEBwYXJhbSB7VmVjdG9yM30geUF4aXNcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB6QXhpc1xuICAgKi9cbiAgbWFrZUJhc2lzKHhBeGlzLCB5QXhpcywgekF4aXMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICB4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLFxuICAgICAgeEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcbiAgICAgIHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIHJvdGF0aW9uIGNvbXBvbmVudCBvZiB0aGUgc3VwcGxpZWQgbWF0cml4IGBtYCBpbnRvIHRoaXNcbiAgICogbWF0cml4J3Mgcm90YXRpb24gY29tcG9uZW50LlxuICAgKiBAbWV0aG9kIGV4dHJhY3RSb3RhdGlvblxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBleHRyYWN0Um90YXRpb24obSkge1xuICAgIGlmICh0eXBlb2YgZXh0cmFjdFJvdGF0aW9uViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGV4dHJhY3RSb3RhdGlvblYgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBtZSA9IG0uZWxlbWVudHM7XG4gICAgY29uc3Qgc2NhbGVYID0gMSAvIGV4dHJhY3RSb3RhdGlvblYuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzY2FsZVkgPSAxIC8gZXh0cmFjdFJvdGF0aW9uVi5zZXRGcm9tTWF0cml4Q29sdW1uKG0sIDEpLmxlbmd0aCgpO1xuICAgIGNvbnN0IHNjYWxlWiA9IDEgLyBleHRyYWN0Um90YXRpb25WLnNldEZyb21NYXRyaXhDb2x1bW4obSwgMikubGVuZ3RoKCk7XG5cbiAgICB0ZVswXSA9IG1lWzBdICogc2NhbGVYO1xuICAgIHRlWzFdID0gbWVbMV0gKiBzY2FsZVg7XG4gICAgdGVbMl0gPSBtZVsyXSAqIHNjYWxlWDtcblxuICAgIHRlWzRdID0gbWVbNF0gKiBzY2FsZVk7XG4gICAgdGVbNV0gPSBtZVs1XSAqIHNjYWxlWTtcbiAgICB0ZVs2XSA9IG1lWzZdICogc2NhbGVZO1xuXG4gICAgdGVbOF0gPSBtZVs4XSAqIHNjYWxlWjtcbiAgICB0ZVs5XSA9IG1lWzldICogc2NhbGVaO1xuICAgIHRlWzEwXSA9IG1lWzEwXSAqIHNjYWxlWjtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJvdGF0aW9uIGNvbXBvbmVudCAodGhlIHVwcGVyIGxlZnQgM3gzIG1hdHJpeCkgb2YgdGhpcyBtYXRyaXggdG9cbiAgICogdGhlIG9yaWVudGF0aW9uIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4ge0BsaW5rIEV1bGVyfSBhbmdsZS4gVGhlIHJlc3Qgb2YgdGhlXG4gICAqIG1hdHJpeCBpcyBzZXQgdG8gdGhlIGlkZW50aXR5LiBEZXBlbmRpbmcgb24gdGhlIHtAbGluayBFdWxlciNvcmRlcn0gb2YgdGhlXG4gICAqIGBldWxlcmAsIHRoZXJlIGFyZSBzaXggcG9zc2libGUgb3V0Y29tZXMuIFNlZVxuICAgKiBbdGhpcyBwYWdlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWxlcl9hbmdsZXMjUm90YXRpb25fbWF0cml4KVxuICAgKiBmb3IgYSBjb21wbGV0ZSBsaXN0LlxuICAgKiBAbWV0aG9kIG1ha2VSb3RhdGlvbkZyb21FdWxlclxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7RXVsZXJ9IGV1bGVyXG4gICAqL1xuICBtYWtlUm90YXRpb25Gcm9tRXVsZXIoZXVsZXIpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgeyB4LCB5LCB6LCBvcmRlciB9ID0gZXVsZXI7XG4gICAgY29uc3QgY3ggPSBNYXRoLmNvcyh4KTtcbiAgICBjb25zdCBzeCA9IE1hdGguc2luKHgpO1xuICAgIGNvbnN0IGN5ID0gTWF0aC5jb3MoeSk7XG4gICAgY29uc3Qgc3kgPSBNYXRoLnNpbih5KTtcbiAgICBjb25zdCBjeiA9IE1hdGguY29zKHopO1xuICAgIGNvbnN0IHN6ID0gTWF0aC5zaW4oeik7XG5cbiAgICBpZiAob3JkZXIgPT09ICdYWVonKSB7XG4gICAgICB0ZVswXSA9IGN5ICogY3o7XG4gICAgICB0ZVs0XSA9IC1jeSAqIHN6O1xuICAgICAgdGVbOF0gPSBzeTtcblxuICAgICAgdGVbMV0gPSAoY3ggKiBzeikgKyAoc3ggKiBjeiAqIHN5KTtcbiAgICAgIHRlWzVdID0gKGN4ICogY3opIC0gKHN4ICogc3ogKiBzeSk7XG4gICAgICB0ZVs5XSA9IC1zeCAqIGN5O1xuXG4gICAgICB0ZVsyXSA9IChzeCAqIHN6KSAtIChjeCAqIGN6ICogc3kpO1xuICAgICAgdGVbNl0gPSAoc3ggKiBjeikgKyAoY3ggKiBzeiAqIHN5KTtcbiAgICAgIHRlWzEwXSA9IGN4ICogY3k7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1lYWicpIHtcbiAgICAgIHRlWzBdID0gKGN5ICogY3opICsgKHN5ICogc3ogKiBzeCk7XG4gICAgICB0ZVs0XSA9IChzeSAqIGN6ICogc3gpIC0gKGN5ICogc3opO1xuICAgICAgdGVbOF0gPSBjeCAqIHN5O1xuXG4gICAgICB0ZVsxXSA9IGN4ICogc3o7XG4gICAgICB0ZVs1XSA9IGN4ICogY3o7XG4gICAgICB0ZVs5XSA9IC1zeDtcblxuICAgICAgdGVbMl0gPSAoY3kgKiBzeiAqIHN4KSAtIChzeSAqIGN6KTtcbiAgICAgIHRlWzZdID0gKHN5ICogc3opICsgKGN5ICogY3ogKiBzeCk7XG4gICAgICB0ZVsxMF0gPSBjeCAqIGN5O1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdaWFknKSB7XG4gICAgICB0ZVswXSA9IChjeSAqIGN6KSAtIChzeSAqIHN6ICogc3gpO1xuICAgICAgdGVbNF0gPSAtY3ggKiBzejtcbiAgICAgIHRlWzhdID0gKHN5ICogY3opICsgKGN5ICogc3ogKiBzeCk7XG5cbiAgICAgIHRlWzFdID0gKGN5ICogc3opICsgKHN5ICogY3ogKiBzeCk7XG4gICAgICB0ZVs1XSA9IGN4ICogY3o7XG4gICAgICB0ZVs5XSA9IChzeSAqIHN6KSAtIChjeSAqIGN6ICogc3gpO1xuXG4gICAgICB0ZVsyXSA9IC1jeCAqIHN5O1xuICAgICAgdGVbNl0gPSBzeDtcbiAgICAgIHRlWzEwXSA9IGN4ICogY3k7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcbiAgICAgIHRlWzBdID0gY3kgKiBjejtcbiAgICAgIHRlWzRdID0gKHN4ICogY3ogKiBzeSkgLSAoY3ggKiBzeik7XG4gICAgICB0ZVs4XSA9IChjeCAqIGN6ICogc3kpICsgKHN4ICogc3opO1xuXG4gICAgICB0ZVsxXSA9IGN5ICogc3o7XG4gICAgICB0ZVs1XSA9IChzeCAqIHN6ICogc3kpICsgKGN4ICogY3opO1xuICAgICAgdGVbOV0gPSAoY3ggKiBzeiAqIHN5KSAtIChzeCAqIGN6KTtcblxuICAgICAgdGVbMl0gPSAtc3k7XG4gICAgICB0ZVs2XSA9IHN4ICogY3k7XG4gICAgICB0ZVsxMF0gPSBjeCAqIGN5O1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7XG4gICAgICB0ZVswXSA9IGN5ICogY3o7XG4gICAgICB0ZVs0XSA9IChzeCAqIHN5KSAtIChjeCAqIGN5ICogc3opO1xuICAgICAgdGVbOF0gPSAoc3ggKiBjeSAqIHN6KSArIChjeCAqIHN5KTtcblxuICAgICAgdGVbMV0gPSBzejtcbiAgICAgIHRlWzVdID0gY3ggKiBjejtcbiAgICAgIHRlWzldID0gLXN4ICogY3o7XG5cbiAgICAgIHRlWzJdID0gLXN5ICogY3o7XG4gICAgICB0ZVs2XSA9IChjeCAqIHN5ICogc3opICsgKHN4ICogY3kpO1xuICAgICAgdGVbMTBdID0gKGN4ICogY3kpIC0gKHN4ICogc3kgKiBzeik7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1haWScpIHtcbiAgICAgIHRlWzBdID0gY3kgKiBjejtcbiAgICAgIHRlWzRdID0gLXN6O1xuICAgICAgdGVbOF0gPSBzeSAqIGN6O1xuXG4gICAgICB0ZVsxXSA9IChjeCAqIGN5ICogc3opICsgKHN4ICogc3kpO1xuICAgICAgdGVbNV0gPSBjeCAqIGN6O1xuICAgICAgdGVbOV0gPSAoY3ggKiBzeSAqIHN6KSAtIChzeCAqIGN5KTtcblxuICAgICAgdGVbMl0gPSAoc3ggKiBjeSAqIHN6KSAtIChjeCAqIHN5KTtcbiAgICAgIHRlWzZdID0gc3ggKiBjejtcbiAgICAgIHRlWzEwXSA9IChzeCAqIHN5ICogc3opICsgKGN4ICogY3kpO1xuICAgIH1cblxuICAgIC8vIGxhc3QgY29sdW1uXG4gICAgdGVbM10gPSAwO1xuICAgIHRlWzddID0gMDtcbiAgICB0ZVsxMV0gPSAwO1xuXG4gICAgLy8gYm90dG9tIHJvd1xuICAgIHRlWzEyXSA9IDA7XG4gICAgdGVbMTNdID0gMDtcbiAgICB0ZVsxNF0gPSAwO1xuICAgIHRlWzE1XSA9IDE7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcm90YXRpb24gY29tcG9uZW50IG9mIHRoaXMgbWF0cml4IHRvIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgYnlcbiAgICogYHFgLCBhcyBvdXRsaW5lZFxuICAgKiBbaGVyZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm90YXRpb25fbWF0cml4I1F1YXRlcm5pb24pLiBUaGUgcmVzdFxuICAgKiBvZiB0aGUgbWF0cml4IGlzIHNldCB0byB0aGUgaWRlbnRpdHkuIFNvLCBnaXZlbiBgcSA9IHcgKyB4aSArIHlqICsgemtgLFxuICAgKiB0aGUgcmVzdWx0aW5nIG1hdHJpeCB3aWxsIGJlOlxuICAgKiA8cHJlIGNsYXNzPVwiY29kZSBwcmV0dHlwcmludCBwcmV0dHlwcmludGVkXCIgc3R5bGU9XCJcIj48Y29kZT48c3BhbiBjbGFzcz1cImxpdFwiPjE8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeTxzdXA+Mjwvc3VwPjwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ6PHN1cD4yPC9zdXA+PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeHk8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yenc8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnh6PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnl3PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPlxuICAgKiA8c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeHk8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+Kzwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yenc8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4xPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mng8c3VwPjI8L3N1cD48L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yejxzdXA+Mjwvc3VwPjwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnl6PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnh3PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPlxuICAgKiA8c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeHo8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwicHVuXCI+LTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4yeXc8L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICAgICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ5ejwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4rPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ4dzwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+MTwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiA8L3NwYW4+PHNwYW4gY2xhc3M9XCJwdW5cIj4tPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjJ4PHN1cD4yPC9zdXA+PC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+IDwvc3Bhbj48c3BhbiBjbGFzcz1cInB1blwiPi08L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+Mnk8c3VwPjI8L3N1cD48L3NwYW4+PHNwYW4gY2xhc3M9XCJwbG5cIj4gICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPlxuICAgKiA8c3BhbiBjbGFzcz1cInBsblwiPiAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+MDwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgICAgICAgICAgICA8L3NwYW4+PHNwYW4gY2xhc3M9XCJsaXRcIj4wPC9zcGFuPjxzcGFuIGNsYXNzPVwicGxuXCI+ICAgICAgICAgICAgICAgPC9zcGFuPjxzcGFuIGNsYXNzPVwibGl0XCI+MDwvc3Bhbj48c3BhbiBjbGFzcz1cInBsblwiPiAgICAgICAgIDwvc3Bhbj48c3BhbiBjbGFzcz1cImxpdFwiPjE8L3NwYW4+PC9jb2RlPjwvcHJlPlxuICAgKiBAbWV0aG9kIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAgICovXG4gIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHEpIHtcbiAgICBjb25zdCB7IHgsIHksIHosIHcgfSA9IHE7XG4gICAgY29uc3QgeDIgPSB4ICsgeDtcbiAgICBjb25zdCB5MiA9IHkgKyB5O1xuICAgIGNvbnN0IHoyID0geiArIHo7XG4gICAgY29uc3QgeHggPSB4ICogeDI7XG4gICAgY29uc3QgeHkgPSB4ICogeTI7XG4gICAgY29uc3QgeHogPSB4ICogejI7XG4gICAgY29uc3QgeXkgPSB5ICogeTI7XG4gICAgY29uc3QgeXogPSB5ICogejI7XG4gICAgY29uc3QgenogPSB6ICogejI7XG4gICAgY29uc3Qgd3ggPSB3ICogeDI7XG4gICAgY29uc3Qgd3kgPSB3ICogeTI7XG4gICAgY29uc3Qgd3ogPSB3ICogejI7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxIC0gKHl5ICsgenopLCB4eSAtIHd6LCB4eiArIHd5LCAwLFxuICAgICAgeHkgKyB3eiwgMSAtICh4eCArIHp6KSwgeXogLSB3eCwgMCxcbiAgICAgIHh6IC0gd3ksIHl6ICsgd3gsIDEgLSAoeHggKyB5eSksIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIHJvdGF0aW9uIG1hdHJpeCwgbG9va2luZyBmcm9tIGBleWVgIHRvd2FyZHMgYHRhcmdldGAgb3JpZW50ZWRcbiAgICogYnkgdGhlIGB1cGAgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGxvb2tBdFxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gZXllXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHRhcmdldFxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSB1cFxuICAgKi9cbiAgbG9va0F0KGV5ZSwgdGFyZ2V0LCB1cCkge1xuICAgIGlmICh0eXBlb2YgbG9va0F0WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvb2tBdFggPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbG9va0F0WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvb2tBdFkgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbG9va0F0WiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvb2tBdFogPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBsb29rQXRaLnN1YlZlY3RvcnMoZXllLCB0YXJnZXQpO1xuXG4gICAgaWYgKGxvb2tBdFoubGVuZ3RoU3EoKSA9PT0gMCkge1xuICAgICAgbG9va0F0Wi5feiA9IDE7XG4gICAgfVxuXG4gICAgbG9va0F0Wi5ub3JtYWxpemUoKTtcbiAgICBsb29rQXRYLmNyb3NzVmVjdG9ycyh1cCwgbG9va0F0Wik7XG5cbiAgICBpZiAobG9va0F0WC5sZW5ndGhTcSgpID09PSAwKSB7XG4gICAgICBsb29rQXRaLl96ICs9IDAuMDAwMTtcbiAgICAgIGxvb2tBdFguY3Jvc3NWZWN0b3JzKHVwLCBsb29rQXRaKTtcbiAgICB9XG5cbiAgICBsb29rQXRYLm5vcm1hbGl6ZSgpO1xuICAgIGxvb2tBdFkuY3Jvc3NWZWN0b3JzKGxvb2tBdFosIGxvb2tBdFgpO1xuXG4gICAgdGVbMF0gPSBsb29rQXRYLl94O1xuICAgIHRlWzRdID0gbG9va0F0WS5feDtcbiAgICB0ZVs4XSA9IGxvb2tBdFouX3g7XG4gICAgdGVbMV0gPSBsb29rQXRYLl95O1xuICAgIHRlWzVdID0gbG9va0F0WS5feTtcbiAgICB0ZVs5XSA9IGxvb2tBdFouX3k7XG4gICAgdGVbMl0gPSBsb29rQXRYLl96O1xuICAgIHRlWzZdID0gbG9va0F0WS5fejtcbiAgICB0ZVsxMF0gPSBsb29rQXRaLl96O1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUG9zdC1tdWx0aXBsaWVzIHRoaXMgbWF0cml4IGJ5IGBtYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBtXG4gICAqL1xuICBtdWx0aXBseShtKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyh0aGlzLCBtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmUtbXVsdGlwbGllcyB0aGlzIG1hdHJpeCBieSBgbWAuXG4gICAqIEBtZXRob2QgcHJlbXVsdGlwbHlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgcHJlbXVsdGlwbHkobSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMobSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCB0byBgYSDDlyBiYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseU1hdHJpY2VzXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IGFcbiAgICogQHBhcmFtIHtNYXRyaXg0fSBiXG4gICAqL1xuICBtdWx0aXBseU1hdHJpY2VzKGEsIGIpIHtcbiAgICBjb25zdCBhZSA9IGEuZWxlbWVudHM7XG4gICAgY29uc3QgYmUgPSBiLmVsZW1lbnRzO1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGNvbnN0IFtcbiAgICAgIGExMSwgYTIxLCBhMzEsIGE0MSxcbiAgICAgIGExMiwgYTIyLCBhMzIsIGE0MixcbiAgICAgIGExMywgYTIzLCBhMzMsIGE0MyxcbiAgICAgIGExNCwgYTI0LCBhMzQsIGE0NCxcbiAgICBdID0gYWU7XG5cbiAgICBjb25zdCBbXG4gICAgICBiMTEsIGIyMSwgYjMxLCBiNDEsXG4gICAgICBiMTIsIGIyMiwgYjMyLCBiNDIsXG4gICAgICBiMTMsIGIyMywgYjMzLCBiNDMsXG4gICAgICBiMTQsIGIyNCwgYjM0LCBiNDQsXG4gICAgXSA9IGJlO1xuXG4gICAgdGVbMF0gPSAoYTExICogYjExKSArIChhMTIgKiBiMjEpICsgKGExMyAqIGIzMSkgKyAoYTE0ICogYjQxKTtcbiAgICB0ZVs0XSA9IChhMTEgKiBiMTIpICsgKGExMiAqIGIyMikgKyAoYTEzICogYjMyKSArIChhMTQgKiBiNDIpO1xuICAgIHRlWzhdID0gKGExMSAqIGIxMykgKyAoYTEyICogYjIzKSArIChhMTMgKiBiMzMpICsgKGExNCAqIGI0Myk7XG4gICAgdGVbMTJdID0gKGExMSAqIGIxNCkgKyAoYTEyICogYjI0KSArIChhMTMgKiBiMzQpICsgKGExNCAqIGI0NCk7XG4gICAgdGVbMV0gPSAoYTIxICogYjExKSArIChhMjIgKiBiMjEpICsgKGEyMyAqIGIzMSkgKyAoYTI0ICogYjQxKTtcbiAgICB0ZVs1XSA9IChhMjEgKiBiMTIpICsgKGEyMiAqIGIyMikgKyAoYTIzICogYjMyKSArIChhMjQgKiBiNDIpO1xuICAgIHRlWzldID0gKGEyMSAqIGIxMykgKyAoYTIyICogYjIzKSArIChhMjMgKiBiMzMpICsgKGEyNCAqIGI0Myk7XG4gICAgdGVbMTNdID0gKGEyMSAqIGIxNCkgKyAoYTIyICogYjI0KSArIChhMjMgKiBiMzQpICsgKGEyNCAqIGI0NCk7XG4gICAgdGVbMl0gPSAoYTMxICogYjExKSArIChhMzIgKiBiMjEpICsgKGEzMyAqIGIzMSkgKyAoYTM0ICogYjQxKTtcbiAgICB0ZVs2XSA9IChhMzEgKiBiMTIpICsgKGEzMiAqIGIyMikgKyAoYTMzICogYjMyKSArIChhMzQgKiBiNDIpO1xuICAgIHRlWzEwXSA9IChhMzEgKiBiMTMpICsgKGEzMiAqIGIyMykgKyAoYTMzICogYjMzKSArIChhMzQgKiBiNDMpO1xuICAgIHRlWzE0XSA9IChhMzEgKiBiMTQpICsgKGEzMiAqIGIyNCkgKyAoYTMzICogYjM0KSArIChhMzQgKiBiNDQpO1xuICAgIHRlWzNdID0gKGE0MSAqIGIxMSkgKyAoYTQyICogYjIxKSArIChhNDMgKiBiMzEpICsgKGE0NCAqIGI0MSk7XG4gICAgdGVbN10gPSAoYTQxICogYjEyKSArIChhNDIgKiBiMjIpICsgKGE0MyAqIGIzMikgKyAoYTQ0ICogYjQyKTtcbiAgICB0ZVsxMV0gPSAoYTQxICogYjEzKSArIChhNDIgKiBiMjMpICsgKGE0MyAqIGIzMykgKyAoYTQ0ICogYjQzKTtcbiAgICB0ZVsxNV0gPSAoYTQxICogYjE0KSArIChhNDIgKiBiMjQpICsgKGE0MyAqIGIzNCkgKyAoYTQ0ICogYjQ0KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIGV2ZXJ5IGNvbXBvbmVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyIHZhbHVlIGBzYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVNjYWxhclxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzXG4gICAqL1xuICBtdWx0aXBseVNjYWxhcihzKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGVbaV0gKj0gcztcbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhbmQgcmV0dXJucyB0aGVcbiAgICogW2RldGVybWluYW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZXRlcm1pbmFudCkgb2YgdGhpcyBtYXRyaXguXG4gICAqIEJhc2VkIG9uIHRoZSBtZXRob2Qgb3V0bGluZWRcbiAgICogW2hlcmVdKGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSkuXG4gICAqIEBtZXRob2QgZGV0ZXJtaW5hbnRcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRldGVybWluYW50KCkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGNvbnN0IFtcbiAgICAgIG4xMSwgbjIxLCBuMzEsIG40MSxcbiAgICAgIG4xMiwgbjIyLCBuMzIsIG40MixcbiAgICAgIG4xMywgbjIzLCBuMzMsIG40MyxcbiAgICAgIG4xNCwgbjI0LCBuMzQsIG40NCxcbiAgICBdID0gdGU7XG5cbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcbiAgICAvLyAoIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXG4gICAgY29uc3QgYSA9IChuMTQgKiBuMjMgKiBuMzIpIC0gKG4xMyAqIG4yNCAqIG4zMikgLSAobjE0ICogbjIyICogbjMzKVxuICAgICAgKyAobjEyICogbjI0ICogbjMzKSArIChuMTMgKiBuMjIgKiBuMzQpIC0gKG4xMiAqIG4yMyAqIG4zNCk7XG4gICAgY29uc3QgYiA9IChuMTEgKiBuMjMgKiBuMzQpIC0gKG4xMSAqIG4yNCAqIG4zMykgKyAobjE0ICogbjIxICogbjMzKVxuICAgICAgLSAobjEzICogbjIxICogbjM0KSArIChuMTMgKiBuMjQgKiBuMzEpIC0gKG4xNCAqIG4yMyAqIG4zMSk7XG4gICAgY29uc3QgYyA9IChuMTEgKiBuMjQgKiBuMzIpIC0gKG4xMSAqIG4yMiAqIG4zNCkgLSAobjE0ICogbjIxICogbjMyKVxuICAgICAgKyAobjEyICogbjIxICogbjM0KSArIChuMTQgKiBuMjIgKiBuMzEpIC0gKG4xMiAqIG4yNCAqIG4zMSk7XG4gICAgY29uc3QgZCA9ICgtbjEzICogbjIyICogbjMxKSAtIChuMTEgKiBuMjMgKiBuMzIpICsgKG4xMSAqIG4yMiAqIG4zMylcbiAgICAgICsgKG4xMyAqIG4yMSAqIG4zMikgLSAobjEyICogbjIxICogbjMzKSArIChuMTIgKiBuMjMgKiBuMzEpO1xuXG4gICAgcmV0dXJuIChuNDEgKiBhKSArIChuNDIgKiBiKSArIChuNDMgKiBjKSArIChuNDQgKiBkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbVHJhbnNwb3Nlc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNwb3NlKSB0aGlzIG1hdHJpeC5cbiAgICogQG1ldGhvZCB0cmFuc3Bvc2VcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqL1xuICB0cmFuc3Bvc2UoKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCB0bXA7XG5cbiAgICB0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcbiAgICB0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuICAgIHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gY29tcG9uZW50IGZvciB0aGlzIG1hdHJpeCBmcm9tIHZlY3RvciBgdmAsIHdpdGhvdXRcbiAgICogYWZmZWN0aW5nIHRoZSByZXN0IG9mIHRoZSBtYXRyaXggLSBpLmUuIGlmIHRoZSBtYXRyaXggaXMgY3VycmVudGx5OlxuICAgKiBgYGBcbiAgICogYSAgYiAgYyAgZFxuICAgKiBlICBmICBnICBoXG4gICAqIGkgIGogIGsgIGxcbiAgICogbSAgbiAgbyAgcFxuICAgKiBgYGBcbiAgICogdGhpcyBiZWNvbWVzOlxuICAgKiBgYGBcbiAgICogYSAgYiAgYyB2LnhcbiAgICogZSAgZiAgZyB2LnlcbiAgICogaSAgaiAgayB2LnpcbiAgICogbSAgbiAgbyAgcFxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBzZXRQb3NpdGlvblxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBzZXRQb3NpdGlvbih2KSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHRlWzEyXSA9IHYueDtcbiAgICB0ZVsxM10gPSB2Lnk7XG4gICAgdGVbMTRdID0gdi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggdG8gdGhlXG4gICAqIFtpbnZlcnNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnZlcnRpYmxlX21hdHJpeCkgb2YgdGhlIHBhc3NlZFxuICAgKiBtYXRyaXggYG1gLCB1c2luZyB0aGUgbWV0aG9kIG91dGxpbmVkXG4gICAqIFtoZXJlXShodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0pLlxuICAgKiBJZiBgdGhyb3dPbkRlZ2VuZXJhdGVgIGlzIG5vdCBzZXQgYW5kIHRoZSBtYXRyaXggaXMgbm90IGludmVydGlibGUsIHNldHNcbiAgICogdGhpcyB0byB0aGUgNHg0IGlkZW50aXR5IG1hdHJpeC5cbiAgICogQG1ldGhvZCBnZXRJbnZlcnNlXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG0gVGhlIG1hdHJpeCB0byB0YWtlIHRoZSBpbnZlcnNlIG9mLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd09uRGVnZW5lcmF0ZT1mYWxzZV0gSWYgdHJ1ZSwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1hdHJpeCBpcyBkZWdlbmVyYXRlIChub3QgaW52ZXJ0aWJsZSkuXG4gICAqL1xuICBnZXRJbnZlcnNlKG0sIHRocm93T25EZWdlbmVyYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgY29uc3QgW1xuICAgICAgbjExLCBuMjEsIG4zMSwgbjQxLFxuICAgICAgbjEyLCBuMjIsIG4zMiwgbjQyLFxuICAgICAgbjEzLCBuMjMsIG4zMywgbjQzLFxuICAgICAgbjE0LCBuMjQsIG4zNCwgbjQ0LFxuICAgIF0gPSBtZTtcblxuICAgIGNvbnN0IHQxMSA9IChuMjMgKiBuMzQgKiBuNDIpIC0gKG4yNCAqIG4zMyAqIG40MikgKyAobjI0ICogbjMyICogbjQzKVxuICAgICAgLSAobjIyICogbjM0ICogbjQzKSAtIChuMjMgKiBuMzIgKiBuNDQpICsgKG4yMiAqIG4zMyAqIG40NCk7XG4gICAgY29uc3QgdDEyID0gKG4xNCAqIG4zMyAqIG40MikgLSAobjEzICogbjM0ICogbjQyKSAtIChuMTQgKiBuMzIgKiBuNDMpXG4gICAgICArIChuMTIgKiBuMzQgKiBuNDMpICsgKG4xMyAqIG4zMiAqIG40NCkgLSAobjEyICogbjMzICogbjQ0KTtcbiAgICBjb25zdCB0MTMgPSAobjEzICogbjI0ICogbjQyKSAtIChuMTQgKiBuMjMgKiBuNDIpICsgKG4xNCAqIG4yMiAqIG40MylcbiAgICAgIC0gKG4xMiAqIG4yNCAqIG40MykgLSAobjEzICogbjIyICogbjQ0KSArIChuMTIgKiBuMjMgKiBuNDQpO1xuICAgIGNvbnN0IHQxNCA9IChuMTQgKiBuMjMgKiBuMzIpIC0gKG4xMyAqIG4yNCAqIG4zMikgLSAobjE0ICogbjIyICogbjMzKVxuICAgICAgKyAobjEyICogbjI0ICogbjMzKSArIChuMTMgKiBuMjIgKiBuMzQpIC0gKG4xMiAqIG4yMyAqIG4zNCk7XG5cbiAgICBjb25zdCBkZXQgPSAobjExICogdDExKSArIChuMjEgKiB0MTIpICsgKG4zMSAqIHQxMykgKyAobjQxICogdDE0KTtcblxuICAgIGlmIChkZXQgPT09IDApIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdNYXRyaXg0LmdldEludmVyc2UoKTogY2FuXFwndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwJztcblxuICAgICAgaWYgKHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXRJbnYgPSAxIC8gZGV0O1xuXG4gICAgdGVbMF0gPSB0MTEgKiBkZXRJbnY7XG4gICAgdGVbMV0gPSAoKG4yNCAqIG4zMyAqIG40MSkgLSAobjIzICogbjM0ICogbjQxKSAtIChuMjQgKiBuMzEgKiBuNDMpXG4gICAgICArIChuMjEgKiBuMzQgKiBuNDMpICsgKG4yMyAqIG4zMSAqIG40NCkgLSAobjIxICogbjMzICogbjQ0KSkgKiBkZXRJbnY7XG4gICAgdGVbMl0gPSAoKG4yMiAqIG4zNCAqIG40MSkgLSAobjI0ICogbjMyICogbjQxKSArIChuMjQgKiBuMzEgKiBuNDIpXG4gICAgICAtIChuMjEgKiBuMzQgKiBuNDIpIC0gKG4yMiAqIG4zMSAqIG40NCkgKyAobjIxICogbjMyICogbjQ0KSkgKiBkZXRJbnY7XG4gICAgdGVbM10gPSAoKG4yMyAqIG4zMiAqIG40MSkgLSAobjIyICogbjMzICogbjQxKSAtIChuMjMgKiBuMzEgKiBuNDIpXG4gICAgICArIChuMjEgKiBuMzMgKiBuNDIpICsgKG4yMiAqIG4zMSAqIG40MykgLSAobjIxICogbjMyICogbjQzKSkgKiBkZXRJbnY7XG5cbiAgICB0ZVs0XSA9IHQxMiAqIGRldEludjtcbiAgICB0ZVs1XSA9ICgobjEzICogbjM0ICogbjQxKSAtIChuMTQgKiBuMzMgKiBuNDEpICsgKG4xNCAqIG4zMSAqIG40MylcbiAgICAgIC0gKG4xMSAqIG4zNCAqIG40MykgLSAobjEzICogbjMxICogbjQ0KSArIChuMTEgKiBuMzMgKiBuNDQpKSAqIGRldEludjtcbiAgICB0ZVs2XSA9ICgobjE0ICogbjMyICogbjQxKSAtIChuMTIgKiBuMzQgKiBuNDEpIC0gKG4xNCAqIG4zMSAqIG40MilcbiAgICAgICsgKG4xMSAqIG4zNCAqIG40MikgKyAobjEyICogbjMxICogbjQ0KSAtIChuMTEgKiBuMzIgKiBuNDQpKSAqIGRldEludjtcbiAgICB0ZVs3XSA9ICgobjEyICogbjMzICogbjQxKSAtIChuMTMgKiBuMzIgKiBuNDEpICsgKG4xMyAqIG4zMSAqIG40MilcbiAgICAgIC0gKG4xMSAqIG4zMyAqIG40MikgLSAobjEyICogbjMxICogbjQzKSArIChuMTEgKiBuMzIgKiBuNDMpKSAqIGRldEludjtcblxuICAgIHRlWzhdID0gdDEzICogZGV0SW52O1xuICAgIHRlWzldID0gKChuMTQgKiBuMjMgKiBuNDEpIC0gKG4xMyAqIG4yNCAqIG40MSkgLSAobjE0ICogbjIxICogbjQzKVxuICAgICAgKyAobjExICogbjI0ICogbjQzKSArIChuMTMgKiBuMjEgKiBuNDQpIC0gKG4xMSAqIG4yMyAqIG40NCkpICogZGV0SW52O1xuICAgIHRlWzEwXSA9ICgobjEyICogbjI0ICogbjQxKSAtIChuMTQgKiBuMjIgKiBuNDEpICsgKG4xNCAqIG4yMSAqIG40MilcbiAgICAgIC0gKG4xMSAqIG4yNCAqIG40MikgLSAobjEyICogbjIxICogbjQ0KSArIChuMTEgKiBuMjIgKiBuNDQpKSAqIGRldEludjtcbiAgICB0ZVsxMV0gPSAoKG4xMyAqIG4yMiAqIG40MSkgLSAobjEyICogbjIzICogbjQxKSAtIChuMTMgKiBuMjEgKiBuNDIpXG4gICAgICArIChuMTEgKiBuMjMgKiBuNDIpICsgKG4xMiAqIG4yMSAqIG40MykgLSAobjExICogbjIyICogbjQzKSkgKiBkZXRJbnY7XG5cbiAgICB0ZVsxMl0gPSB0MTQgKiBkZXRJbnY7XG4gICAgdGVbMTNdID0gKChuMTMgKiBuMjQgKiBuMzEpIC0gKG4xNCAqIG4yMyAqIG4zMSkgKyAobjE0ICogbjIxICogbjMzKVxuICAgICAgLSAobjExICogbjI0ICogbjMzKSAtIChuMTMgKiBuMjEgKiBuMzQpICsgKG4xMSAqIG4yMyAqIG4zNCkpICogZGV0SW52O1xuICAgIHRlWzE0XSA9ICgobjE0ICogbjIyICogbjMxKSAtIChuMTIgKiBuMjQgKiBuMzEpIC0gKG4xNCAqIG4yMSAqIG4zMilcbiAgICAgICsgKG4xMSAqIG4yNCAqIG4zMikgKyAobjEyICogbjIxICogbjM0KSAtIChuMTEgKiBuMjIgKiBuMzQpKSAqIGRldEludjtcbiAgICB0ZVsxNV0gPSAoKG4xMiAqIG4yMyAqIG4zMSkgLSAobjEzICogbjIyICogbjMxKSArIChuMTMgKiBuMjEgKiBuMzIpXG4gICAgICAtIChuMTEgKiBuMjMgKiBuMzIpIC0gKG4xMiAqIG4yMSAqIG4zMykgKyAobjExICogbjIyICogbjMzKSkgKiBkZXRJbnY7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSBjb2x1bW5zIG9mIHRoaXMgbWF0cml4IGJ5IHZlY3RvciBgdmAuXG4gICAqIEBtZXRob2Qgc2NhbGVcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgc2NhbGUodikge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCB7IHgsIHksIHogfSA9IHY7XG4gICAgdGVbMF0gKj0geDtcbiAgICB0ZVs0XSAqPSB5O1xuICAgIHRlWzhdICo9IHo7XG4gICAgdGVbMV0gKj0geDtcbiAgICB0ZVs1XSAqPSB5O1xuICAgIHRlWzldICo9IHo7XG4gICAgdGVbMl0gKj0geDtcbiAgICB0ZVs2XSAqPSB5O1xuICAgIHRlWzEwXSAqPSB6O1xuICAgIHRlWzNdICo9IHg7XG4gICAgdGVbN10gKj0geTtcbiAgICB0ZVsxMV0gKj0gejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXhpbXVtIHNjYWxlIHZhbHVlIG9mIHRoZSAzIGF4ZXMuXG4gICAqIEBtZXRob2QgZ2V0TWF4U2NhbGVPbkF4aXNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldE1heFNjYWxlT25BeGlzKCkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBjb25zdCBzY2FsZVhTcSA9ICh0ZVswXSAqIHRlWzBdKSArICh0ZVsxXSAqIHRlWzFdKSArICh0ZVsyXSAqIHRlWzJdKTtcbiAgICBjb25zdCBzY2FsZVlTcSA9ICh0ZVs0XSAqIHRlWzRdKSArICh0ZVs1XSAqIHRlWzVdKSArICh0ZVs2XSAqIHRlWzZdKTtcbiAgICBjb25zdCBzY2FsZVpTcSA9ICh0ZVs4XSAqIHRlWzhdKSArICh0ZVs5XSAqIHRlWzldKSArICh0ZVsxMF0gKiB0ZVsxMF0pO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoc2NhbGVYU3EsIHNjYWxlWVNxLCBzY2FsZVpTcSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSB0cmFuc2xhdGlvbiB0cmFuc2Zvcm06XG4gICAqIGBgYFxuICAgKiAxICAwICAwICB4XG4gICAqIDAgIDEgIDAgIHlcbiAgICogMCAgMCAgMSAgelxuICAgKiAwICAwICAwICAxXG4gICAqIGBgYFxuICAgKiBAbWV0aG9kIG1ha2VUcmFuc2xhdGlvblxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHggYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHkgYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIGFtb3VudCB0byB0cmFuc2xhdGUgaW4gdGhlIHogYXhpcy5cbiAgICovXG4gIG1ha2VUcmFuc2xhdGlvbih4LCB5LCB6KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgMSwgMCwgMCwgeCxcbiAgICAgIDAsIDEsIDAsIHksXG4gICAgICAwLCAwLCAxLCB6LFxuICAgICAgMCwgMCwgMCwgMSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgeCBheGlzIGJ5XG4gICAqIGB0aGV0YWAuIFRoZSByZXN1bHRpbmcgbWF0cml4IHdpbGwgYmU6XG4gICAqIGBgYFxuICAgKiAxICAgIDAgICAgICAwICAgICAgMFxuICAgKiAwICBjb3MozrgpIC1zaW4ozrgpICAwXG4gICAqIDAgIHNpbijOuCkgIGNvcyjOuCkgIDBcbiAgICogMCAgICAwICAgICAgMCAgICAgIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZVJvdGF0aW9uWFxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBtYWtlUm90YXRpb25YKHRoZXRhKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIGMsIC1zLCAwLFxuICAgICAgMCwgcywgYywgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIGEgcm90YXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBhcm91bmQgdGhlIHkgYXhpcyBieVxuICAgKiBgdGhldGFgLiBUaGUgcmVzdWx0aW5nIG1hdHJpeCB3aWxsIGJlOlxuICAgKiBgYGBcbiAgICogIGNvcyjOuCkgIDAgIHNpbijOuCkgIDBcbiAgICogICAgMCAgICAgMSAgICAwICAgICAwXG4gICAqIC1zaW4ozrgpICAwICBjb3MozrgpICAwXG4gICAqICAgIDAgICAgIDAgICAgMCAgICAgMVxuICAgKiBgYGBcbiAgICogQG1ldGhvZCBtYWtlUm90YXRpb25ZXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdGhldGEgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIG1ha2VSb3RhdGlvblkodGhldGEpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3ModGhldGEpO1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICBjLCAwLCBzLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIC1zLCAwLCBjLCAwLFxuICAgICAgMCwgMCwgMCwgMSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBtYXRyaXggYXMgYSByb3RhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGFyb3VuZCB0aGUgeiBheGlzIGJ5XG4gICAqIGB0aGV0YWAuIFRoZSByZXN1bHRpbmcgbWF0cml4IHdpbGwgYmU6XG4gICAqIGBgYFxuICAgKiBjb3MozrgpIC1zaW4ozrgpICAwICAwXG4gICAqIHNpbijOuCkgIGNvcyjOuCkgIDAgIDBcbiAgICogICAwICAgICAgIDAgICAgIDEgIDBcbiAgICogICAwICAgICAgIDAgICAgIDAgIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZVJvdGF0aW9uWlxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIFJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAqL1xuICBtYWtlUm90YXRpb25aKHRoZXRhKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY29zKHRoZXRhKTtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgICAgYywgLXMsIDAsIDAsXG4gICAgICBzLCBjLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDEsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIHJvdGF0aW9uIHRyYW5zZm9ybSBhcm91bmQgYGF4aXNgIGJ5IGB0aGV0YWAuIFRoaXMgaXMgYVxuICAgKiBzb21ld2hhdCBjb250cm92ZXJzaWFsIGJ1dCBtYXRoZW1hdGljYWxseSBzb3VuZCBhbHRlcm5hdGl2ZSB0byByb3RhdGluZ1xuICAgKiB2aWEge0BsaW5rIFF1YXRlcm5pb259cy4gU2VlIHRoZSBkaXNjdXNzaW9uXG4gICAqIFtoZXJlXShodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3ApLlxuICAgKiBAbWV0aG9kIG1ha2VSb3RhdGlvbkF4aXNcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYXhpc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICovXG4gIG1ha2VSb3RhdGlvbkF4aXMoYXhpcywgYW5nbGUpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHMgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdCA9IDEgLSBjO1xuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gYXhpcztcbiAgICBjb25zdCB0eCA9IHQgKiB4O1xuICAgIGNvbnN0IHR5ID0gdCAqIHk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAodHggKiB4KSArIGMsICh0eCAqIHkpIC0gKHMgKiB6KSwgKHR4ICogeikgKyAocyAqIHkpLCAwLFxuICAgICAgKHR4ICogeSkgKyAocyAqIHopLCAodHkgKiB5KSArIGMsICh0eSAqIHopIC0gKHMgKiB4KSwgMCxcbiAgICAgICh0eCAqIHopIC0gKHMgKiB5KSwgKHR5ICogeikgKyAocyAqIHgpLCAodCAqIHogKiB6KSArIGMsIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHNjYWxlIHRyYW5zZm9ybTpcbiAgICogYGBgXG4gICAqIHggIDAgIDAgIDBcbiAgICogMCAgeSAgMCAgMFxuICAgKiAwICAwICB6ICAwXG4gICAqIDAgIDAgIDAgIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZVNjYWxlXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgYW1vdW50IHRvIHNjYWxlIGluIHRoZSB4IGF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2NhbGUgaW4gdGhlIHkgYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIGFtb3VudCB0byBzY2FsZSBpbiB0aGUgeiBheGlzLlxuICAgKi9cbiAgbWFrZVNjYWxlKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICB4LCAwLCAwLCAwLFxuICAgICAgMCwgeSwgMCwgMCxcbiAgICAgIDAsIDAsIHosIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCBhcyBhIHNoZWFyIHRyYW5zZm9ybTpcbiAgICogYGBgXG4gICAqIDEgIHkgIHogIDBcbiAgICogeCAgMSAgeiAgMFxuICAgKiB4ICB5ICAxICAwXG4gICAqIDAgIDAgIDAgIDFcbiAgICogYGBgXG4gICAqIEBtZXRob2QgbWFrZVNoZWFyXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgYW1vdW50IHRvIHNoZWFyIGluIHRoZSB4IGF4aXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2hlYXIgaW4gdGhlIHkgYXhpcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGhlIGFtb3VudCB0byBzaGVhciBpbiB0aGUgeiBheGlzLlxuICAgKi9cbiAgbWFrZVNoZWFyKHgsIHksIHopIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAxLCB5LCB6LCAwLFxuICAgICAgeCwgMSwgeiwgMCxcbiAgICAgIHgsIHksIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIG1hdHJpeCB0byB0aGUgdHJhbnNmb3JtYXRpb24gY29tcG9zZWQgb2YgYHBvc2l0aW9uYCxcbiAgICogYHF1YXRlcm5pb25gLCBhbmQgYHNjYWxlYC4gSW50ZXJuYWxseSB0aGlzIGNhbGxzXG4gICAqIHtAbGluayBNYXRyaXg0I21ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9ufSBmb2xsb3dlZCBieVxuICAgKiB7QGxpbmsgTWF0cml4NCNzY2FsZX0sIHRoZW4gZmluYWxseSB7QGxpbmsgTWF0cml4NCNzZXRQb3NpdGlvbn0uXG4gICAqIEBtZXRob2QgY29tcG9zZVxuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gcG9zaXRpb25cbiAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgKiBAcGFyYW0gIHtWZWN0b3IzfSBzY2FsZVxuICAgKi9cbiAgY29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUpIHtcbiAgICB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgIHRoaXMuc2NhbGUoc2NhbGUpO1xuICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcG9zZXMgdGhpcyBtYXRyaXggaW50byBpdCdzIGBwb3NpdGlvbmAsICdxdWF0ZXJuaW9uJywgYW5kICdzY2FsZSdcbiAgICogY29tcG9uZW50cy5cbiAgICogQG1ldGhvZCBkZWNvbXBvc2VcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjN9IHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAgICogQHBhcmFtICB7VmVjdG9yM30gc2NhbGVcbiAgICovXG4gIGRlY29tcG9zZShwb3NpdGlvbiA9IG51bGwsIHF1YXRlcm5pb24gPSBudWxsLCBzY2FsZSA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGRlY29tcG9zZVYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWNvbXBvc2VWID0gbmV3IFZlY3RvcjMoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlY29tcG9zZU0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWNvbXBvc2VNID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IHN4ID0gZGVjb21wb3NlVi5zZXQodGVbMF0sIHRlWzFdLCB0ZVsyXSkubGVuZ3RoKCk7XG4gICAgY29uc3Qgc3kgPSBkZWNvbXBvc2VWLnNldCh0ZVs0XSwgdGVbNV0sIHRlWzZdKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeiA9IGRlY29tcG9zZVYuc2V0KHRlWzhdLCB0ZVs5XSwgdGVbMTBdKS5sZW5ndGgoKTtcblxuICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgY29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXG4gICAgaWYgKGRldCA8IDApIHtcbiAgICAgIHN4ID0gLXN4O1xuICAgIH1cblxuICAgIHBvc2l0aW9uLnNldCh0ZVsxMl0sIHRlWzEzXSwgdGVbMTRdKTtcblxuICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuICAgIGRlY29tcG9zZU0uY29weSh0aGlzKTtcbiAgICBjb25zdCBpbnZTWCA9IDEgLyBzeDtcbiAgICBjb25zdCBpbnZTWSA9IDEgLyBzeTtcbiAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbMF0gKj0gaW52U1g7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1sxXSAqPSBpbnZTWDtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzJdICo9IGludlNYO1xuXG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s0XSAqPSBpbnZTWTtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzVdICo9IGludlNZO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbNl0gKj0gaW52U1k7XG5cbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzhdICo9IGludlNaO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbOV0gKj0gaW52U1o7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1sxMF0gKj0gaW52U1o7XG5cbiAgICBxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChkZWNvbXBvc2VNKTtcbiAgICBzY2FsZS5zZXQoc3gsIHN5LCBzeik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQgZGVjb21wb3NlZFZhbHVlKCkge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBpZiAodHlwZW9mIGRlY29tcG9zZVYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWNvbXBvc2VWID0gbmV3IFZlY3RvcjMoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlY29tcG9zZU0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZWNvbXBvc2VNID0gbmV3IE1hdHJpeDQoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgbGV0IHN4ID0gZGVjb21wb3NlVi5zZXQodGVbMF0sIHRlWzFdLCB0ZVsyXSkubGVuZ3RoKCk7XG4gICAgY29uc3Qgc3kgPSBkZWNvbXBvc2VWLnNldCh0ZVs0XSwgdGVbNV0sIHRlWzZdKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeiA9IGRlY29tcG9zZVYuc2V0KHRlWzhdLCB0ZVs5XSwgdGVbMTBdKS5sZW5ndGgoKTtcblxuICAgIC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXG4gICAgY29uc3QgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuXG4gICAgaWYgKGRldCA8IDApIHtcbiAgICAgIHN4ID0gLXN4O1xuICAgIH1cblxuICAgIHBvc2l0aW9uLnNldCh0ZVsxMl0sIHRlWzEzXSwgdGVbMTRdKTtcblxuICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XG4gICAgLy8gYXQgdGhpcyBwb2ludCBtYXRyaXggaXMgaW5jb21wbGV0ZSBzbyB3ZSBjYW4ndCB1c2UgLmNvcHkoKVxuICAgIGRlY29tcG9zZU0uY29weSh0aGlzKTtcbiAgICBjb25zdCBpbnZTWCA9IDEgLyBzeDtcbiAgICBjb25zdCBpbnZTWSA9IDEgLyBzeTtcbiAgICBjb25zdCBpbnZTWiA9IDEgLyBzejtcblxuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbMF0gKj0gaW52U1g7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1sxXSAqPSBpbnZTWDtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzJdICo9IGludlNYO1xuXG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1s0XSAqPSBpbnZTWTtcbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzVdICo9IGludlNZO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbNl0gKj0gaW52U1k7XG5cbiAgICBkZWNvbXBvc2VNLmVsZW1lbnRzWzhdICo9IGludlNaO1xuICAgIGRlY29tcG9zZU0uZWxlbWVudHNbOV0gKj0gaW52U1o7XG4gICAgZGVjb21wb3NlTS5lbGVtZW50c1sxMF0gKj0gaW52U1o7XG5cbiAgICBxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChkZWNvbXBvc2VNKTtcbiAgICBzY2FsZS5zZXQoc3gsIHN5LCBzeik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgICBzY2FsZTogc2NhbGVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYVxuICAgKiBbcGVyc3BlY3RpdmUgcHJvamVjdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvM0RfcHJvamVjdGlvbiNQZXJzcGVjdGl2ZV9wcm9qZWN0aW9uKVxuICAgKiBtYXRyaXguXG4gICAqIEBtZXRob2QgbWFrZUZydXN0dW1cbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSByaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9wXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5lYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhclxuICAgKi9cbiAgbWFrZUZydXN0dW0oXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIG5lYXIsXG4gICAgZmFyLFxuICApIHtcbiAgICBjb25zdCB4ID0gMiAqIG5lYXIgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICBjb25zdCB5ID0gMiAqIG5lYXIgLyAodG9wIC0gYm90dG9tKTtcbiAgICBjb25zdCBhID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICBjb25zdCBiID0gKHRvcCArIGJvdHRvbSkgLyAoIHRvcCAtIGJvdHRvbSApO1xuICAgIGNvbnN0IGMgPSAtKGZhciArIG5lYXIpIC8gKGZhciAtIG5lYXIpO1xuICAgIGNvbnN0IGQgPSAtMiAqIGZhciAqIG5lYXIgLyAoZmFyIC0gbmVhcik7XG5cbiAgICAvLyAgICAgcmV0dXJuIHRoaXMuc2V0KFxuICAgIC8vICAgICAgICAgeCwgMCwgYSwgMCxcbiAgICAvLyAgICAgICAgIDAsIHksIGIsIDAsXG4gICAgLy8gICAgICAgICAwLCAwLCBjLCBkLFxuICAgIC8vICAgICAgICAgMCwgMCwgLTEsIDAsXG4gICAgLy8gICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAwLCAteCwgYSwgMCxcbiAgICAgIC15LCAwLCBiLCAwLFxuICAgICAgMCwgMCwgLWMsIGQsXG4gICAgICAwLCAwLCAxLCAwXG4gICAgKTtcbiAgfVxuXG4gIG1ha2VQZXJzcGVjdGl2ZShcbiAgICBmb3YsXG4gICAgYXNwZWN0LFxuICAgIG5lYXIsXG4gICAgZmFyXG4gICkge1xuICAgIGNvbnN0IHltaW4gPSBuZWFyICogTWF0aC50YW4oZGVnVG9SYWQoZm92ICogMC41KSk7XG4gICAgY29uc3QgeW1heCA9IC15bWluO1xuICAgIGNvbnN0IHhtaW4gPSB5bWF4ICogYXNwZWN0O1xuICAgIGNvbnN0IHhtYXggPSB5bWluICogYXNwZWN0O1xuICAgIHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhcik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhblxuICAgKiBbb3J0aG9ncmFwaGljIHByb2plY3Rpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09ydGhvZ3JhcGhpY19wcm9qZWN0aW9uKVxuICAgKiBtYXRyaXguIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5XG4gICAqIHtAbGluayBPcnRob2dyYXBoaWNDYW1lcmEjdXBkYXRlUHJvamVjdGlvbk1hdHJpeH0uXG4gICAqIEBtZXRob2QgbWFrZU9ydGhvZ3JhcGhpY1xuICAgKiBAbWVtYmVyb2YgTWF0cml4NC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b3BcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gbmVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFyXG4gICAqL1xuICBtYWtlT3J0aG9ncmFwaGljKFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBuZWFyLFxuICAgIGZhcixcbiAgKSB7XG4gICAgY29uc3QgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHcgPSAxLjAgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICBjb25zdCBoID0gMS4wIC8gKHRvcCAtIGJvdHRvbSk7XG4gICAgY29uc3QgcCA9IDEuMCAvIChmYXIgLSBuZWFyKTtcbiAgICBjb25zdCB4ID0gKHJpZ2h0ICsgbGVmdCkgKiB3O1xuICAgIGNvbnN0IHkgPSAodG9wICsgYm90dG9tKSAqIGg7XG4gICAgY29uc3QgeiA9IChmYXIgKyBuZWFyKSAqIHA7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoXG4gICAgICAyICogdywgMCwgMCwgLXgsXG4gICAgICAwLCAyICogaCwgMCwgLXksXG4gICAgICAwLCAwLCAtMiAqIHAsIC16LFxuICAgICAgMCwgMCwgMCwgMSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHRoaXMgbWF0cml4IGFuZCBgbWF0cml4YCBhcmUgZXF1YWwuXG4gICAqIEBtZXRob2QgZXF1YWxzXG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtNYXRyaXg0fSBtYXRyaXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhtYXRyaXgpIHtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgY29uc3QgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGlmICh0ZVtpXSAhPT0gbWVbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBNYXRyaXg0I2VsZW1lbnRzfSBvZiB0aGlzIG1hdHJpeCBiYXNlZCBvbiBhbiBgYXJyYXlgIGluXG4gICAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gICAqIGZvcm1hdC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIE1hdHJpeDQucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVhZCB0aGUge0BsaW5rIE1hdHJpeDQjZWxlbWVudHN9IGZyb20uXG4gICAqIEBwYXJhbSAge251bWJlcn0gW29mZnNldD0wXSBPZmZzZXQgaW50byB0aGUgYXJyYXkuXG4gICAqL1xuICBmcm9tQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRlW2ldID0gYXJyYXlbaSArIG9mZnNldF07XG4gICAgfVxuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBlbGVtZW50cyBvZiB0aGlzIG1hdHJpeCB0byBhbiBgYXJyYXlgIGluXG4gICAqIFtjb2x1bW4tbWFqb3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Jvdy1fYW5kX2NvbHVtbi1tYWpvcl9vcmRlciNDb2x1bW4tbWFqb3Jfb3JkZXIpXG4gICAqIGZvcm1hdC5cbiAgICogQG1ldGhvZCB0b0FycmF5XG4gICAqIEBtZW1iZXJvZiBNYXRyaXg0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gW2FycmF5PVtdXSBBcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIHZlY3RvciBpbi5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9mZnNldCBpbiB0aGUgYXJyYXkgYXQgd2hpY2ggdG8gcHV0IHRoZSByZXN1bHQuXG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKXtcbiAgICBjb25zdCB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGFycmF5W29mZnNldCArIGldID0gdGVbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgb25DaGFuZ2UoY2FsbGJhY2spIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uQ2hhbmdlQ2FsbGJhY2soKSB7fVxufVxuXG4iLCJpbXBvcnQgVmVjdG9yMyBmcm9tICcuL1ZlY3RvcjMnO1xuLy8gaW1wb3J0IEV1bGVyIGZyb20gJy4vRXVsZXInO1xuLy8gaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi9NYXRyaXg0JztcblxubGV0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTjtcblxuaWYgKHR5cGVvZiBFUFNJTE9OID09PSAndW5kZWZpbmVkJykge1xuICBFUFNJTE9OID0gTWF0aC5wb3coMiwgLTUyKTtcbn1cblxuLy8gY29uc3RhbnRzIGZvciBvcHRpbWlzYXRpb25cbmNvbnN0IHNldEZyb21Vbml0VmVjdG9yc0VQUyA9IDAuMDAwMDAxO1xubGV0IHNldEZyb21Vbml0VmVjdG9yc1Y7XG5cbi8vIGxldCB0aGlzLnggPSAwLCB0aGlzLnkgPSAwLCB0aGlzLnogPSAwLCB0aGlzLncgPSAxO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGFuZCBvZiB0aGUgZm9sbG93aW5nIG9jY3VyOlxuICogKiBUaGUge0BsaW5rIFF1YXRlcm5pb24jeH0sIHtAbGluayBRdWF0ZXJuaW9uI3l9LCB7QGxpbmsgUXVhdGVybmlvbiN6fSwgb3Ige0BsaW5rIFF1YXRlcm5pb24jd30gcHJvcGVydGllcyBhcmUgY2hhbmdlZC5cbiAqICogVGhlIHtAbGluayBRdWF0ZXJuaW9uI3NldH0sIHtAbGluayBRdWF0ZXJuaW9uI2NvcHl9LCB7QGxpbmsgUXVhdGVybmlvbiRjbG9uZX0sIHtAbGluayBRdWF0ZXJuaW9uI3NldEZyb21BeGlzQW5nbGV9LCB7QGxpbmsgUXVhdGVybmlvbiRzZXRGcm9tUm90YXRpb25NYXRyaXh9LCB7QGxpbmsgUXVhdGVybmlvbiNjb25qdWdhdGV9LCB7QGxpbmsgUXVhdGVybmlvbiNub3JtYWxpemV9LCB7QGxpbmsgUXVhdGVybmlvbiNtdWx0aXBseVF1YXRlcm5pb25zfSwge0BsaW5rIFF1YXRlcm5pb24jc2xlcnB9LCB7QGxpbmsgUXVhdGVybmlvbiNmcm9tQXJyYXl9IGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxuICogKiB7QGxpbmsgUXVhdGVybmlvbiNzZXRGcm9tRXVsZXJ9IGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGl0cyBgdXBkYXRlYCBhcmd1bWVudCBzZXQgdG8gYHRydWVgLlxuICogQnkgZGVmYXVsdCwgaXQgaXMgYW4gZW1wdHkgZnVuY3Rpb24sIGhvd2V2ZXIgeW91IGNhbiBjaGFuZ2UgaXQgaWYgbmVlZGVkIHVzaW5nIHtAbGluayBRdWF0ZXJuaW9uI29uQ2hhbmdlfS5cbiAqIEBwcm9wZXJ0eSBvbkNoYW5nZUNhbGxiYWNrXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4gKi9cbmxldCBvbkNoYW5nZUNhbGxiYWNrID0gKCkgPT4ge307XG5cbmNvbnN0IF9pc1F1YXRlcm5pb24gPSB0cnVlO1xuXG4vKipcbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAY2xhc3NkZXNjXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIFtxdWF0ZXJuaW9uXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YXRlcm5pb24pLlxuICogVGhpcyBpcyB1c2VkIGZvclxuICogW3JvdGF0aW5nIHRoaW5nc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvbnNfYW5kX3NwYXRpYWxfcm90YXRpb24pXG4gKiB3aXRob3V0IGVuY291bnRlcmluZyB0aGUgZHJlYWRlZFxuICogW2dpbWJhbCBsb2NrXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dpbWJhbF9sb2NrKSBpc3N1ZSwgYW1vbmdzdCBvdGhlclxuICogYWR2YW50YWdlcy5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gKiBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMSwgMCksIE1hdGguUEkgLyAyKTtcbiAqXG4gKiB2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG4gKiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbej0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt3PTFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YXRlcm5pb24ge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB3ID0gMSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMudyA9IHc7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiB7QGxpbmsgUXVhdGVybmlvbiNvbkNoYW5nZUNhbGxiYWNrfVxuICAgKiBiZWluZyBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0geFxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbiNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgLy8gZ2V0IHgoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMueDtcbiAgLy8gfVxuICAvL1xuICAvLyBzZXQgeCh2YWx1ZSkge1xuICAvLyAgIHRoaXMueCA9IHZhbHVlO1xuICAvLyAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgd2lsbCByZXN1bHQgaW4ge0BsaW5rIFF1YXRlcm5pb24jb25DaGFuZ2VDYWxsYmFja31cbiAgICogYmVpbmcgY2FsbGVkLlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHlcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24jXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIC8vIGdldCB5KCkge1xuICAvLyAgIHJldHVybiB0aGlzLnk7XG4gIC8vIH1cbiAgLy9cbiAgLy8gc2V0IHkodmFsdWUpIHtcbiAgLy8gICB0aGlzLnkgPSB2YWx1ZTtcbiAgLy8gICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IHdpbGwgcmVzdWx0IGluIHtAbGluayBRdWF0ZXJuaW9uI29uQ2hhbmdlQ2FsbGJhY2t9XG4gICAqIGJlaW5nIGNhbGxlZC5cbiAgICogQG1lbWJlciB7bnVtYmVyfSB6XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICAvLyBnZXQgeigpIHtcbiAgLy8gICByZXR1cm4gdGhpcy56O1xuICAvLyB9XG4gIC8vXG4gIC8vIHNldCB6KHZhbHVlKSB7XG4gIC8vICAgdGhpcy56ID0gdmFsdWU7XG4gIC8vICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHJlc3VsdCBpbiB7QGxpbmsgUXVhdGVybmlvbiNvbkNoYW5nZUNhbGxiYWNrfVxuICAgKiBiZWluZyBjYWxsZWQuXG4gICAqIEBtZW1iZXIge251bWJlcn0gd1xuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbiNcbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgLy8gZ2V0IHcoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMudztcbiAgLy8gfVxuICAvL1xuICAvLyBzZXQgdyh2YWx1ZSkge1xuICAvLyAgIHRoaXMudyA9IHZhbHVlO1xuICAvLyAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAvLyB9XG5cbiAgZ2V0IGlzUXVhdGVybmlvbigpIHtcbiAgICByZXR1cm4gX2lzUXVhdGVybmlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHtAbGluayBRdWF0ZXJuaW9uI3h9LCB7QGxpbmsgUXVhdGVybmlvbiN5fSwge0BsaW5rIFF1YXRlcm5pb24jen0sIGFuZFxuICAgKiB7QGxpbmsgUXVhdGVybmlvbiN3fSBwcm9wZXJ0aWVzIG9mIHRoaXMgcXVhdGVybmlvbi5cbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3XG4gICAqL1xuICBzZXQoeCwgeSwgeiwgdykge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMudyA9IHc7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgUXVhdGVybmlvbn0gd2l0aCBpZGVudGljYWwge0BsaW5rIFF1YXRlcm5pb24jeH0sXG4gICAqIHtAbGluayBRdWF0ZXJuaW9uI3l9LCB7QGxpbmsgUXVhdGVybmlvbiN6fSwgYW5kIHtAbGluayBRdWF0ZXJuaW9uI3d9XG4gICAqIHByb3BlcnRpZXMgdG8gdGhpcyBvbmUuXG4gICAqIEBtZXRob2QgY2xvbmVcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge1F1YXRlcm5pb259XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFF1YXRlcm5pb24odGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHtAbGluayBRdWF0ZXJuaW9uI3h9LCB7QGxpbmsgUXVhdGVybmlvbiN5fSxcbiAgICoge0BsaW5rIFF1YXRlcm5pb24jen0sIGFuZCB7QGxpbmsgUXVhdGVybmlvbiN3fSBwcm9wZXJ0aWVzIG9mIGBxdWF0ZXJuaW9uYFxuICAgKiBpbnRvIHRoaXMgcXVhdGVybmlvbi5cbiAgICogQG1ldGhvZCBjb3B5XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAgICovXG4gIGNvcHkocXVhdGVybmlvbikge1xuICAgIHRoaXMueCA9IHF1YXRlcm5pb24ueDtcbiAgICB0aGlzLnkgPSBxdWF0ZXJuaW9uLnk7XG4gICAgdGhpcy56ID0gcXVhdGVybmlvbi56O1xuICAgIHRoaXMudyA9IHF1YXRlcm5pb24udztcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiBmcm9tIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgYnkge0BsaW5rIEV1bGVyfSBhbmdsZS5cbiAgICogQG1ldGhvZCBzZXRGcm9tRXVsZXJcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb24ucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RXVsZXJ9IGV1bGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlXG4gICAqL1xuICBzZXRGcm9tRXVsZXIoZXVsZXIsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICAvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvXG4gICAgLy8gMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG4gICAgLy8gY29udGVudC9TcGluQ2FsYy5tXG4gICAgY29uc3QgYzEgPSBNYXRoLmNvcyhldWxlci54IC8gMik7XG4gICAgY29uc3QgYzIgPSBNYXRoLmNvcyhldWxlci55IC8gMik7XG4gICAgY29uc3QgYzMgPSBNYXRoLmNvcyhldWxlci56IC8gMik7XG4gICAgY29uc3QgczEgPSBNYXRoLnNpbihldWxlci54IC8gMik7XG4gICAgY29uc3QgczIgPSBNYXRoLnNpbihldWxlci55IC8gMik7XG4gICAgY29uc3QgczMgPSBNYXRoLnNpbihldWxlci56IC8gMik7XG4gICAgY29uc3Qgb3JkZXIgPSBldWxlci5vcmRlcjtcblxuICAgIGlmIChvcmRlciA9PT0gJ1hZWicpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpICsgKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSAtIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgKyAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpIC0gKHMxICogczIgKiBzMyk7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1lYWicpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpICsgKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSAtIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgLSAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpICsgKHMxICogczIgKiBzMyk7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pYWScpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpIC0gKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSArIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgKyAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpIC0gKHMxICogczIgKiBzMyk7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pZWCcpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpIC0gKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSArIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgLSAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpICsgKHMxICogczIgKiBzMyk7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1laWCcpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpICsgKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSArIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgLSAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpIC0gKHMxICogczIgKiBzMyk7XG4gICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1haWScpIHtcbiAgICAgIHRoaXMueCA9IChzMSAqIGMyICogYzMpIC0gKGMxICogczIgKiBzMyk7XG4gICAgICB0aGlzLnkgPSAoYzEgKiBzMiAqIGMzKSAtIChzMSAqIGMyICogczMpO1xuICAgICAgdGhpcy56ID0gKGMxICogYzIgKiBzMykgKyAoczEgKiBzMiAqIGMzKTtcbiAgICAgIHRoaXMudyA9IChjMSAqIGMyICogYzMpICsgKHMxICogczIgKiBzMyk7XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIGZyb20gcm90YXRpb24gc3BlY2lmaWVkIGJ5IGBheGlzYCBhbmQgYGFuZ2xlYC4gQWRhcHRlZFxuICAgKiBmcm9tIHRoZSBtZXRob2RcbiAgICogW2hlcmVdKGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG0pLlxuICAgKiBgYXhpc2AgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkLCBgYW5nbGVgIGlzIGluIHJhZGlhbnMuXG4gICAqIEBtZXRob2Qgc2V0RnJvbUF4aXNBbmdsZVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBheGlzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICovXG4gIHNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcbiAgICBjb25zdCBoYWxmQW5nbGUgPSBhbmdsZSAvIDI7XG4gICAgY29uc3QgcyA9IE1hdGguc2luKGhhbGZBbmdsZSk7XG4gICAgdGhpcy54ID0gYXhpcy54ICogcztcbiAgICB0aGlzLnkgPSBheGlzLnkgKiBzO1xuICAgIHRoaXMueiA9IGF4aXMueiAqIHM7XG4gICAgdGhpcy53ID0gTWF0aC5jb3MoaGFsZkFuZ2xlKTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiBmcm9tIHJvdGF0aW9uIGNvbXBvbmVudCBvZiBgbWAuIEFkYXB0ZWQgZnJvbSB0aGVcbiAgICogbWV0aG9kXG4gICAqIFtoZXJlXShodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bSkuXG4gICAqIEBtZXRob2Qgc2V0RnJvbVJvdGF0aW9uTWF0cml4XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIHNldEZyb21Sb3RhdGlvbk1hdHJpeChtKSB7XG4gICAgLy8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcbiAgICBjb25zdCB0ZSA9IG0uZWxlbWVudHM7XG5cbiAgICBjb25zdCBbXG4gICAgICBtMTEsIG0yMSwgbTMxLCBtNDEsXG4gICAgICBtMTIsIG0yMiwgbTMyLCBtNDIsXG4gICAgICBtMTMsIG0yMywgbTMzLCBtNDMsXG4gICAgXSA9IHRlO1xuXG4gICAgY29uc3QgdHJhY2UgPSBtMTEgKyBtMjIgKyBtMzM7XG4gICAgbGV0IHM7XG5cbiAgICBpZiAodHJhY2UgPiAwKSB7XG4gICAgICBzID0gMC41IC8gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKTtcbiAgICAgIHRoaXMudyA9IDAuMjUgLyBzO1xuICAgICAgdGhpcy54ID0gKG0zMiAtIG0yMykgKiBzO1xuICAgICAgdGhpcy55ID0gKG0xMyAtIG0zMSkgKiBzO1xuICAgICAgdGhpcy56ID0gKG0yMSAtIG0xMikgKiBzO1xuICAgIH0gZWxzZSBpZiAobTExID4gbTIyICYmIG0xMSA+IG0zMykge1xuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCgxLjAgKyBtMTEgLSBtMjIgLSBtMzMpO1xuICAgICAgdGhpcy53ID0gKG0zMiAtIG0yMykgLyBzO1xuICAgICAgdGhpcy54ID0gMC4yNSAqIHM7XG4gICAgICB0aGlzLnkgPSAobTEyICsgbTIxKSAvIHM7XG4gICAgICB0aGlzLnogPSAobTEzICsgbTMxKSAvIHM7XG4gICAgfSBlbHNlIGlmIChtMjIgPiBtMzMpIHtcbiAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoMS4wICsgbTIyIC0gbTExIC0gbTMzKTtcbiAgICAgIHRoaXMudyA9IChtMTMgLSBtMzEpIC8gcztcbiAgICAgIHRoaXMueCA9IChtMTIgKyBtMjEpIC8gcztcbiAgICAgIHRoaXMueSA9IDAuMjUgKiBzO1xuICAgICAgdGhpcy56ID0gKG0yMyArIG0zMikgLyBzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gMi4wICogTWF0aC5zcXJ0KDEuMCArIG0zMyAtIG0xMSAtIG0yMik7XG4gICAgICB0aGlzLncgPSAobTIxIC0gbTEyKSAvIHM7XG4gICAgICB0aGlzLnggPSAobTEzICsgbTMxKSAvIHM7XG4gICAgICB0aGlzLnkgPSAobTIzICsgbTMyKSAvIHM7XG4gICAgICB0aGlzLnogPSAwLjI1ICogcztcbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiB0byB0aGUgcm90YXRpb24gcmVxdWlyZWQgdG8gcm90YXRlIGRpcmVjdGlvbiB2ZWN0b3JcbiAgICogYHZGcm9tYCB0byBkaXJlY3Rpb24gdmVjdG9yIGB2VG9gLiBBZGFwdGVkIGZyb20gdGhlIG1ldGhvZFxuICAgKiBbaGVyZV0oaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDEzLzA5LzE4L2JlYXV0aWZ1bC1tYXRocy1xdWF0ZXJuaW9uLWZyb20tdmVjdG9ycykuXG4gICAqIGB2RnJvbWAgYW5kIGB2VG9gIGFyZSBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG4gICAqIEBtZXRob2Qgc2V0RnJvbVVuaXRWZWN0b3JzXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZGcm9tXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlRvXG4gICAqL1xuICBzZXRGcm9tVW5pdFZlY3RvcnModkZyb20sIHZUbykge1xuICAgIC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcbiAgICBpZiAodHlwZW9mIHNldEZyb21Vbml0VmVjdG9yc1YgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZXRGcm9tVW5pdFZlY3RvcnNWID0gbmV3IFZlY3RvcjMoKTtcbiAgICB9XG5cbiAgICBsZXQgciA9IHZGcm9tLmRvdCh2VG8pICsgMTtcblxuICAgIGlmIChyIDwgc2V0RnJvbVVuaXRWZWN0b3JzRVBTKSB7XG4gICAgICByID0gMDtcblxuICAgICAgaWYgKE1hdGguYWJzKHZGcm9tLngpID4gTWF0aC5hYnModkZyb20ueikpIHtcbiAgICAgICAgc2V0RnJvbVVuaXRWZWN0b3JzVi5zZXQoLXZGcm9tLnksIHZGcm9tLngsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RnJvbVVuaXRWZWN0b3JzVi5zZXQoMCwgLXZGcm9tLnosIHZGcm9tLnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRGcm9tVW5pdFZlY3RvcnNWLmNyb3NzVmVjdG9ycyh2RnJvbSwgdlRvKTtcbiAgICB9XG5cbiAgICB0aGlzLnggPSBzZXRGcm9tVW5pdFZlY3RvcnNWLng7XG4gICAgdGhpcy55ID0gc2V0RnJvbVVuaXRWZWN0b3JzVi55O1xuICAgIHRoaXMueiA9IHNldEZyb21Vbml0VmVjdG9yc1YuejtcbiAgICB0aGlzLncgPSByO1xuICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludmVydHMgdGhpcyBxdWF0ZXJuaW9uIC0gY2FsY3VsYXRlIHRoZSB7QGxpbmsgUXVhdGVybmlvbiNjb25qdWdhdGV9IGFuZFxuICAgKiB0aGVuIFtub3JtYWxpemVzXXtAbGluayBRdWF0ZXJuaW9uI25vcm1hbGl6ZX0gdGhlIHJlc3VsdC5cbiAgICogQG1ldGhvZCBpbnZlcnNlXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKi9cbiAgaW52ZXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb3RhdGlvbmFsIGNvbmp1Z2F0ZSBvZiB0aGlzIHF1YXRlcm5pb24uIFRoZSBjb25qdWdhdGUgb2YgYVxuICAgKiBxdWF0ZXJuaW9uIHJlcHJlc2VudHMgdGhlIHNhbWUgcm90YXRpb24gaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBhYm91dFxuICAgKiB0aGUgcm90YXRpb25hbCBheGlzLlxuICAgKiBAbWV0aG9kIGNvbmp1Z2F0ZVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICovXG4gIGNvbmp1Z2F0ZSgpIHtcbiAgICB0aGlzLnggKj0gLTE7XG4gICAgdGhpcy55ICo9IC0xO1xuICAgIHRoaXMueiAqPSAtMTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIFtkb3QgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG90X3Byb2R1Y3QpIG9mXG4gICAqIHF1YXRlcm5pb25zIGB2YCBhbmQgdGhpcyBvbmUuXG4gICAqIEBtZXRob2QgZG90XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZG90KHYpIHtcbiAgICByZXR1cm4gKHRoaXMueCAqIHYueCkgKyAodGhpcy55ICogdi55KSArICh0aGlzLnogKiB2LnopICsgKHRoaXMudyAqIHYudyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgb2YgdGhpcyBxdWF0ZXJuaW9uLCBjb25zaWRlcmVkIGFzIGEgNCBkaW1lbnNpb25hbFxuICAgKiB2ZWN0b3IuIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgYXJlIGNvbXBhcmluZyB0aGUgbGVuZ3RocyBvZiB0d29cbiAgICogcXVhdGVybmlvbnMsIGFzIHRoaXMgaXMgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgY2FsY3VsYXRpb24gdGhhblxuICAgKiB7QGxpbmsgUXVhdGVybmlvbiNsZW5ndGh9LlxuICAgKiBAbWV0aG9kIGxlbmd0aFNxXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gKHRoaXMueCAqIHRoaXMueCkgKyAodGhpcy55ICogdGhpcy55KSArICh0aGlzLnogKiB0aGlzLnopICsgKHRoaXMudyAqIHRoaXMudyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgb2YgdGhpcyBxdWF0ZXJuaW9uLCBjb25zaWRlcmVkIGFzIGEgNCBkaW1lbnNpb25hbFxuICAgKiB2ZWN0b3IuXG4gICAqIEBtZXRob2QgbGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy54ICogdGhpcy54KSArICh0aGlzLnkgKiB0aGlzLnkpICsgKHRoaXMueiAqIHRoaXMueikgKyAodGhpcy53ICogdGhpcy53KSk7XG4gIH1cblxuICAvKipcbiAgICogW05vcm1hbGl6ZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05vcm1hbGl6ZWRfdmVjdG9yKSB0aGlzXG4gICAqIHF1YXRlcm5pb24gLSB0aGF0IGlzLCBjYWxjdWxhdGVzIHRoZSBxdWF0ZXJuaW9uIHRoYXQgcGVyZm9ybXMgdGhlIHNhbWVcbiAgICogcm90YXRpb24gYXMgdGhpcyBvbmUsIGJ1dCBoYXMge0BsaW5rIFF1YXRlcm5pb24jbGVuZ3RofSBlcXVhbCB0byBgMWAuXG4gICAqIEBtZXRob2Qgbm9ybWFsaXplXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKi9cbiAgbm9ybWFsaXplKCkge1xuICAgIGxldCBsID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmIChsID09PSAwKSB7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMueiA9IDA7XG4gICAgICB0aGlzLncgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsID0gMSAvIGw7XG4gICAgICB0aGlzLnggPSB0aGlzLnggKiBsO1xuICAgICAgdGhpcy55ID0gdGhpcy55ICogbDtcbiAgICAgIHRoaXMueiA9IHRoaXMueiAqIGw7XG4gICAgICB0aGlzLncgPSB0aGlzLncgKiBsO1xuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyBxdWF0ZXJuaW9uIGJ5IGBxYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXG4gICAqL1xuICBtdWx0aXBseShxKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLCBxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmUtbXVsdGlwbGllcyB0aGlzIHF1YXRlcm5pb24gYnkgYHFgLlxuICAgKiBAbWV0aG9kIHByZW11bHRpcGx5XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAgICovXG4gIHByZW11bHRpcGx5KHEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHEsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIHRvIGBhIMOXIGJgLiBBZGFwdGVkIGZyb20gdGhlIG1ldGhvZCBvdXRsaW5lZFxuICAgKiBbaGVyZV0oaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bSkuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlRdWF0ZXJuaW9uc1xuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBhXG4gICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gYlxuICAgKi9cbiAgbXVsdGlwbHlRdWF0ZXJuaW9ucyhhLCBiKSB7XG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXG4gICAgY29uc3QgcWF4ID0gYS54O1xuICAgIGNvbnN0IHFheSA9IGEueTtcbiAgICBjb25zdCBxYXogPSBhLno7XG4gICAgY29uc3QgcWF3ID0gYS53O1xuICAgIGNvbnN0IHFieCA9IGIueDtcbiAgICBjb25zdCBxYnkgPSBiLnk7XG4gICAgY29uc3QgcWJ6ID0gYi56O1xuICAgIGNvbnN0IHFidyA9IGIudztcbiAgICB0aGlzLnggPSAocWF4ICogcWJ3KSArIChxYXcgKiBxYngpICsgKHFheSAqIHFieikgLSAocWF6ICogcWJ5KTtcbiAgICB0aGlzLnkgPSAocWF5ICogcWJ3KSArIChxYXcgKiBxYnkpICsgKHFheiAqIHFieCkgLSAocWF4ICogcWJ6KTtcbiAgICB0aGlzLnogPSAocWF6ICogcWJ3KSArIChxYXcgKiBxYnopICsgKHFheCAqIHFieSkgLSAocWF5ICogcWJ4KTtcbiAgICB0aGlzLncgPSAocWF3ICogcWJ3KSAtIChxYXggKiBxYngpIC0gKHFheSAqIHFieSkgLSAocWF6ICogcWJ6KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiBxdWF0ZXJuaW9ucy4gYHRgXG4gICAqIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiByb3RhdGlvbiBiZXR3ZWVuIHRoaXMgcXVhdGVybmlvbiAod2hlcmUgYHQgPSAwYClcbiAgICogYW5kIGBxYmAgKHdoZXJlIGB0ID0gMWApLiBUaGlzIHF1YXRlcm5pb24gaXMgc2V0IHRvIHRoZSByZXN1bHQuIEFsc28gc2VlXG4gICAqIHRoZSBzdGF0aWMgdmVyc2lvbiBvZiB0aGUge0BsaW5rIFF1YXRlcm5pb24uc2xlcnB9LlxuICAgKiBAbWV0aG9kIHNsZXJwXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxYiBUaGUgb3RoZXIgcXVhdGVybmlvbiByb3RhdGlvblxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQgIEludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIHJvdGF0ZSBhIG1lc2ggdG93YXJkcyBhIHRhcmdldCBxdWF0ZXJuaW9uXG4gICAqIG1lc2gucXVhdGVybmlvbi5zbGVycChlbmRRdWF0ZXJuaW9uLCAwLjAxKTtcbiAgICovXG4gIHNsZXJwKHFiLCB0KSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5KHFiKTtcbiAgICB9XG5cbiAgICBjb25zdCB4ID0gdGhpcy54O1xuICAgIGNvbnN0IHkgPSB0aGlzLnk7XG4gICAgY29uc3QgeiA9IHRoaXMuejtcbiAgICBjb25zdCB3ID0gdGhpcy53O1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cbiAgICBsZXQgY29zSGFsZlRoZXRhID0gKHcgKiBxYi53KSArICh4ICogcWIueCkgKyAoeSAqIHFiLnkpICsgKHogKiBxYi56KTtcblxuICAgIGlmIChjb3NIYWxmVGhldGEgPCAwKSB7XG4gICAgICB0aGlzLncgPSAtcWIudztcbiAgICAgIHRoaXMueCA9IC1xYi54O1xuICAgICAgdGhpcy55ID0gLXFiLnk7XG4gICAgICB0aGlzLnogPSAtcWIuejtcbiAgICAgIGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29weShxYik7XG4gICAgfVxuXG4gICAgaWYgKGNvc0hhbGZUaGV0YSA+PSAxLjApIHtcbiAgICAgIHRoaXMudyA9IHc7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHRoaXMueiA9IHo7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoMS4wIC0gKGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSkpO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpbkhhbGZUaGV0YSkgPCAwLjAwMSkge1xuICAgICAgdGhpcy53ID0gMC41ICogKHcgKyB0aGlzLncpO1xuICAgICAgdGhpcy54ID0gMC41ICogKHggKyB0aGlzLngpO1xuICAgICAgdGhpcy55ID0gMC41ICogKHkgKyB0aGlzLnkpO1xuICAgICAgdGhpcy56ID0gMC41ICogKHogKyB0aGlzLnopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgaGFsZlRoZXRhID0gTWF0aC5hdGFuMihzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSk7XG4gICAgY29uc3QgcmF0aW9BID0gTWF0aC5zaW4oKDEgLSB0KSAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGE7XG4gICAgY29uc3QgcmF0aW9CID0gTWF0aC5zaW4odCAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGE7XG4gICAgdGhpcy53ID0gKHcgKiByYXRpb0EpICsgKHRoaXMudyAqIHJhdGlvQik7XG4gICAgdGhpcy54ID0gKHggKiByYXRpb0EpICsgKHRoaXMueCAqIHJhdGlvQik7XG4gICAgdGhpcy55ID0gKHkgKiByYXRpb0EpICsgKHRoaXMueSAqIHJhdGlvQik7XG4gICAgdGhpcy56ID0gKHogKiByYXRpb0EpICsgKHRoaXMueiAqIHJhdGlvQik7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIHtAbGluayBRdWF0ZXJuaW9uI3h9LCB7QGxpbmsgUXVhdGVybmlvbiN5fSxcbiAgICoge0BsaW5rIFF1YXRlcm5pb24jen0sIGFuZCB7QGxpbmsgUXVhdGVybmlvbiN3fSBwcm9wZXJ0aWVzIG9mIGBxdWF0ZXJuaW9uYFxuICAgKiB0byB0aGUgZXF1aXZhbGVudCBwcm9wZXJ0aWVzIG9mIHRoaXMgcXVhdGVybmlvbiB0byBkZXRlcm1pbmUgaWYgdGhleVxuICAgKiByZXByZXNlbnQgdGhlIHNhbWUgcm90YXRpb24uXG4gICAqIEBtZXRob2QgZXF1YWxzXG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHEgUXVhdGVybmlvbiB0aGF0IHRoaXMgcXVhdGVybmlvbiB3aWxsIGJlIGNvbXBhcmVkIHRvLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKHEpIHtcbiAgICByZXR1cm4gKHEueCA9PT0gdGhpcy54KSAmJiAocS55ID09PSB0aGlzLnkpICYmIChxLnogPT09IHRoaXMueikgJiYgKHEudyA9PT0gdGhpcy53KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbidzIHtAbGluayBRdWF0ZXJuaW9uI3h9LCB7QGxpbmsgUXVhdGVybmlvbiN5fSxcbiAgICoge0BsaW5rIFF1YXRlcm5pb24jen0sIGFuZCB7QGxpbmsgUXVhdGVybmlvbiN3fSBwcm9wZXJ0aWVzIGZyb20gdGhlIGBhcnJheWAuXG4gICAqIEBtZXRob2QgZnJvbUFycmF5XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSBBcnJheSBvZiBmb3JtYXQgYCh4LCB5LCB6LCB3KWAgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIEFuIG9mZnNldCBpbnRvIHRoZSBhcnJheS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgdGhpcy54ID0gYXJyYXlbb2Zmc2V0XTtcbiAgICB0aGlzLnkgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICB0aGlzLnogPSBhcnJheVtvZmZzZXQgKyAyXTtcbiAgICB0aGlzLncgPSBhcnJheVtvZmZzZXQgKyAzXTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1lcmljYWwgZWxlbWVudHMgb2YgdGhpcyBxdWF0ZXJuaW9uIGluIGFuIGFycmF5IG9mIGZvcm1hdFxuICAgKiBgW3gsIHksIHosIHddYC5cbiAgICogQG1ldGhvZCB0b0FycmF5XG4gICAqIEBtZW1iZXJvZiBRdWF0ZXJuaW9uLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcltdfSBbYXJyYXk9W11dIEFuIG9wdGlvbmFsIGFycmF5IHRvIHN0b3JlIHRoZSBxdWF0ZXJuaW9uLiBJZiBub3Qgc3BlY2lmaWVkIGEgbmV3IGFycmF5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gSWYgc3BlY2lmaWVkLCB0aGUgcmVzdWx0IHdpbGwgYmUgY29waWVkIGludG8gdGhlIGBhcnJheWAuXG4gICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgKi9cbiAgdG9BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMF0gPSB0aGlzLng7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLnk7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSB0aGlzLno7XG4gICAgYXJyYXlbb2Zmc2V0ICsgM10gPSB0aGlzLnc7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBRdWF0ZXJuaW9uI29uQ2hhbmdlQ2FsbGJhY2t9IG1ldGhvZC5cbiAgICogQG1ldGhvZCBvbkNoYW5nZVxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbkNoYW5nZUNhbGxiYWNrKCkge307XG5cbiAgLyoqXG4gICAqIFVubGlrZSB0aGUgW25vcm1hbF17QGxpbmsgUXVhdGVybmlvbiNzbGVycH0gbWV0aG9kLCB0aGUgc3RhdGljIHZlcnNpb24gb2ZcbiAgICoge0BsaW5rIFF1YXRlcm5pb24uc2xlcnB9IHNldHMgYSB0YXJnZXQgcXVhdGVybmlvbiB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiBzbGVycCBvcGVyYXRpb24uXG4gICAqIEBtZXRob2Qgc2xlcnBcbiAgICogQG1lbWJlcm9mIFF1YXRlcm5pb25cbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxU3RhcnQgVGhlIHN0YXJ0aW5nIHF1YXRlcm5pb24gKHdoZXJlIGB0ID0gMGApLlxuICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFFbmQgVGhlIGVuZGluZyBxdWF0ZXJuaW9uICh3aGVyZSBgdCA9IDFgKS5cbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxVGFyZ2V0IFRoZSB0YXJnZXQgcXVhdGVybmlvbiB0aGF0IGdldHMgc2V0IHdpdGggdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHQgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ29kZSBzZXR1cFxuICAgKiB2YXIgc3RhcnRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXQoMCwgMCwgMCwgMSkubm9ybWFsaXplKCk7XG4gICAqIHZhciBlbmRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKS5zZXQoMSwgMSwgMSwgMSkubm9ybWFsaXplKCk7XG4gICAqIHZhciB0ID0gMDtcbiAgICpcbiAgICogLy8gVXBkYXRlIGEgbWVzaCdzIHJvdGF0aW9uIGluIHRoZSBsb29wXG4gICAqIHQgPSAodCArIDAuMDEpICUgMTsgLy8gY29uc3RhbnQgYW5ndWxhciBtb21lbnR1bVxuICAgKiBRdWF0ZXJuaW9uLnNsZXJwKHN0YXJ0UXVhdGVybmlvbiwgZW5kUXVhdGVybmlvbiwgbWVzaC5xdWF0ZXJuaW9uLCB0KTtcbiAgICovXG4gIHN0YXRpYyBzbGVycChxU3RhcnQsIHFFbmQsIHFUYXJnZXQsIHQpIHtcbiAgICByZXR1cm4gcVRhcmdldC5jb3B5KHFTdGFydCkuc2xlcnAocUVuZCwgdCk7XG4gIH1cblxuICAvKipcbiAgICogTGlrZSB0aGUgc3RhdGljIHtAbGluayBRdWF0ZXJuaW9uLnNsZXJwfSBtZXRob2QsIGJ1dCBvcGVyYXRlcyBkaXJlY3RseSBvblxuICAgKiBmbGF0IGFycmF5cyBvZiBudW1iZXJzLlxuICAgKiBAbWV0aG9kIHNsZXJwRmxhdFxuICAgKiBAbWVtYmVyb2YgUXVhdGVybmlvblxuICAgKiBAcGFyYW0ge251bWJlcltdfSBkc3QgVGhlIG91dHB1dCBhcnJheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRzdE9mZnNldCBBbiBvZmZzZXQgaW50byB0aGUgb3V0cHV0IGFycmF5LlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBzcmMwIFRoZSBzb3VyY2UgYXJyYXkgb2YgdGhlIHN0YXJ0aW5nIHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNPZmZzZXQwIEFuIG9mZnNldCBpbnRvIHRoZSBhcnJheSBgc3JjMGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHNyYzEgVGhlIHNvdXJjZSBhcnJheSBvZiB0aGUgdGFyZ2V0IHF1YXRlcm5pb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNPZmZzZXQxIEFuIG9mZnNldCBpbnRvIHRoZSBhcnJheSBgc3JjMWAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IE5vcm1hbGl6ZWQgaW50ZXJwb2xhdGlvbiBmYWN0b3IgKGJldHdlZW4gYDBgIGFuZCBgMWApLlxuICAgKi9cbiAgc3RhdGljIHNsZXJwRmxhdChcbiAgICBkc3QsXG4gICAgZHN0T2Zmc2V0LFxuICAgIHNyYzAsXG4gICAgc3JjT2Zmc2V0MCxcbiAgICBzcmMxLFxuICAgIHNyY09mZnNldDEsXG4gICAgdFxuICApIHtcbiAgICAvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXG4gICAgbGV0IHgwID0gc3JjMFtzcmNPZmZzZXQwICsgMF07XG4gICAgbGV0IHkwID0gc3JjMFtzcmNPZmZzZXQwICsgMV07XG4gICAgbGV0IHowID0gc3JjMFtzcmNPZmZzZXQwICsgMl07XG4gICAgbGV0IHcwID0gc3JjMFtzcmNPZmZzZXQwICsgM107XG4gICAgY29uc3QgeDEgPSBzcmMxW3NyY09mZnNldDEgKyAwXTtcbiAgICBjb25zdCB5MSA9IHNyYzFbc3JjT2Zmc2V0MSArIDFdO1xuICAgIGNvbnN0IHoxID0gc3JjMVtzcmNPZmZzZXQxICsgMl07XG4gICAgY29uc3QgdzEgPSBzcmMxW3NyY09mZnNldDEgKyAzXTtcblxuICAgIGlmICh3MCAhPT0gdzEgfHwgeDAgIT09IHgxIHx8IHkwICE9PSB5MSB8fCB6MCAhPT0gejEpIHtcbiAgICAgIGxldCBzID0gMSAtIHQ7XG4gICAgICBjb25zdCBjb3MgPSAoeDAgKiB4MSkgKyAoeTAgKiB5MSkgKyAoejAgKiB6MSkgKyAodzAgKiB3MSk7XG4gICAgICBjb25zdCBkaXIgPSBjb3MgPj0gMCA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IHNxclNpbiA9IDEgLSAoY29zICogY29zKTtcblxuICAgICAgLy8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcbiAgICAgIGlmIChzcXJTaW4gPiBFUFNJTE9OKSB7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc3FydChzcXJTaW4pO1xuICAgICAgICBjb25zdCBsZW4gPSBNYXRoLmF0YW4yKHNpbiwgY29zICogZGlyKTtcbiAgICAgICAgcyA9IE1hdGguc2luKHMgKiBsZW4pIC8gc2luO1xuICAgICAgICB0ID0gTWF0aC5zaW4odCAqIGxlbikgLyBzaW47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHREaXIgPSB0ICogZGlyO1xuICAgICAgeDAgPSAoeDAgKiBzKSArICh4MSAqIHREaXIpO1xuICAgICAgeTAgPSAoeTAgKiBzKSArICh5MSAqIHREaXIpO1xuICAgICAgejAgPSAoejAgKiBzKSArICh6MSAqIHREaXIpO1xuICAgICAgdzAgPSAodzAgKiBzKSArICh3MSAqIHREaXIpO1xuXG4gICAgICAvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG4gICAgICBpZiAocyA9PT0gMSAtIHQpIHtcbiAgICAgICAgY29uc3QgZiA9IDEgLyBNYXRoLnNxcnQoKHgwICogeDApICsgKHkwICogeTApICsgKHowICogejApICsgKHcwICogdzApKTtcbiAgICAgICAgeDAgKj0gZjtcbiAgICAgICAgeTAgKj0gZjtcbiAgICAgICAgejAgKj0gZjtcbiAgICAgICAgdzAgKj0gZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkc3RbZHN0T2Zmc2V0XSA9IHgwO1xuICAgIGRzdFtkc3RPZmZzZXQgKyAxXSA9IHkwO1xuICAgIGRzdFtkc3RPZmZzZXQgKyAyXSA9IHowO1xuICAgIGRzdFtkc3RPZmZzZXQgKyAzXSA9IHcwO1xuICB9XG59XG5cbiIsImNvbnN0IF9pc1ZlY3RvcjIgPSB0cnVlO1xuXG4vKipcbiAqIEBjbGFzcyBWZWN0b3IyXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAyRCBbdmVjdG9yXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3Jfc3BhY2UpLlxuICogQSAyRCB2ZWN0b3IgaXMgYW4gb3JkZXJlZCBwYWlyIG9mIG51bWJlcnMgKGxhYmVsZWQgYHhgIGFuZCBgeWApLCB3aGljaCBjYW4gYmVcbiAqIHVzZWQgdG8gcmVwcmVzZW50IGEgbnVtYmVyIG9mIHRoaW5ncywgc3VjaCBhczpcbiAqICogQSBwb2ludCBpbiAyRCBzcGFjZSAoaS5lLiBhIHBvc2l0aW9uIG9uIGEgcGxhbmUpLlxuICogKiBBIGRpcmVjdGlvbiBhbmQgbGVuZ3RoIGFjcm9zcyBhIHBsYW5lLiBGb3IgTGV0c2VlLCB0aGUgbGVuZ3RoIHdpbGwgYWx3YXlzIGJlIHRoZSBbRXVjbGlkZWFuIGRpc3RhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpIChzdHJhaWdodC1saW5lIGRpc3RhbmNlKSBmcm9tIGAoMCwgMClgIHRvIGAoeCwgeSlgIGFuZCB0aGUgZGlyZWN0aW9uIGlzIGFsc28gbWVhc3VyZWQgZnJvbSBgKDAsIDApYCB0b3dhcmRzIGAoeCwgeSlgLlxuICogKiBBbnkgYXJiaXRyYXJ5IG9yZGVyZWQgcGFpciBvZiBudW1iZXJzLlxuICogVGhlc2UgYXJlIG90aGVyIHRoaW5ncyBhIDJEIHZlY3RvciBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQsIHN1Y2ggYXMgbW9tZW50dW1cbiAqIHZlY3RvcnMsIGNvbXBsZXggbnVtYmVycyBhbmQgc28gb24sIGhvd2V2ZXIgdGhlc2UgYXJlIHRoZSBtb3N0IGNvbW1vbiB1c2VzLlxuICogQGV4YW1wbGVcbiAqIHZhciBhID0gbmV3IFZlY3RvcjIoMCwgMSk7XG4gKlxuICogLy8gbm8gYXJndW1lbnRzOyB3aWxsIGJlIGluaXRpYWxpc2VkIHRvICgwLCAwKVxuICogdmFyIGIgPSBuZXcgVmVjdG9yMigpO1xuICpcbiAqIHZhciBkID0gYS5kaXN0YW5jZVRvKGIpO1xuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSBUaGUge0BsaW5rIFZlY3RvcjIjeH0gdmFsdWUgb2YgdGhlIHZlY3Rvci5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gVGhlIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlIG9mIHRoZSB2ZWN0b3IuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvcjIge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3Ige0BsaW5rIFZlY3RvcjIjeH0uXG4gICAqIEBtZW1iZXIge251bWJlcn0gd2lkdGhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIjXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cblxuICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICB0aGlzLl94ID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWxpYXMgZm9yIHtAbGluayBWZWN0b3IyI3l9LlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IGhlaWdodFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMiNcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3k7XG4gIH1cblxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5feSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge251bWJlcn0geFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMiNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cblxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICBnZXQgaXNWZWN0b3IyKCkge1xuICAgIHJldHVybiBfaXNWZWN0b3IyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHtAbGluayBWZWN0b3IyI3h9IGFuZCB7QGxpbmsgVmVjdG9yMiN5fSBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICovXG4gIHNldCh4LCB5KSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlcyBvZiB0aGlzIHZlY3RvciBib3RoXG4gICAqIGVxdWFsIHRvIGBzY2FsYXJgLlxuICAgKiBAbWV0aG9kIHNldFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxhclxuICAgKi9cbiAgc2V0U2NhbGFyKHNjYWxhcikge1xuICAgIHRoaXMuX3ggPSBzY2FsYXI7XG4gICAgdGhpcy5feSA9IHNjYWxhcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gdmFsdWUgd2l0aCBgeGAuXG4gICAqIEBtZXRob2Qgc2V0WFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICovXG4gIHNldFgoeCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZSB3aXRoIGB5YC5cbiAgICogQG1ldGhvZCBzZXRZXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKi9cbiAgc2V0WSh5KSB7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgYGluZGV4YCBlcXVhbHMgdG8gYDBgLCBzZXQge0BsaW5rIFZlY3RvcjIjeH0gdG8gYHZhbHVlYC5cbiAgICogSWYgYGluZGV4YCBlcXVhbHMgdG8gYDFgLCBzZXQge0BsaW5rIFZlY3RvcjIjeX0gdG8gYHZhbHVlYC5cbiAgICogQG1ldGhvZCBzZXRDb21wb25lbnRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7MHwxfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICovXG4gIHNldENvbXBvbmVudChpbmRleCA9IDAgfCAxLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAke2luZGV4fWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGBpbmRleGAgZXF1YWxzIHRvIGAwYCwgcmV0dXJucyB7QGxpbmsgVmVjdG9yMiN4fS5cbiAgICogSWYgYGluZGV4YCBlcXVhbHMgdG8gYDFgLCByZXR1cm5zIHtAbGluayBWZWN0b3IyI3l9LlxuICAgKiBAbWV0aG9kIGdldENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7MHwxfSBpbmRleFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRDb21wb25lbnQoaW5kZXggPSAwIHwgMSkge1xuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICR7aW5kZXh9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcge0BsaW5rIFZlY3RvcjJ9IHdpdGggdGhlIHNhbWUge0BsaW5rIFZlY3RvcjIjeH0gYW5kXG4gICAqIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLl94LCB0aGlzLl95KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgcGFzc2VkIHtAbGluayBWZWN0b3IyfSdzIHtAbGluayBWZWN0b3IyI3h9IGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMiN5fSBwcm9wZXJ0aWVzIHRvIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKi9cbiAgY29weSh2KSB7XG4gICAgdGhpcy5feCA9IHYueDtcbiAgICB0aGlzLl95ID0gdi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYHZgIHRvIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqL1xuICBhZGQodikge1xuICAgIHRoaXMuX3ggKz0gdi54O1xuICAgIHRoaXMuX3kgKz0gdi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHNjYWxhciB2YWx1ZSBgc2AgdG8gdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBhbmRcbiAgICoge0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzLlxuICAgKiBAbWV0aG9kIGFkZFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGFkZFNjYWxhcihzKSB7XG4gICAgdGhpcy5feCArPSBzO1xuICAgIHRoaXMuX3kgKz0gcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGBhICsgYmAuXG4gICAqIEBtZXRob2QgYWRkVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gYlxuICAgKi9cbiAgYWRkVmVjdG9ycyhhLCBiKSB7XG4gICAgdGhpcy5feCA9IGEueCArIGIueDtcbiAgICB0aGlzLl95ID0gYS55ICsgYi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG11bHRpcGxlIG9mIGB2YCBhbmQgYHNgIHRvIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGFkZFNjYWxlZFZlY3RvclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAqL1xuICBhZGRTY2FsZWRWZWN0b3Iodiwgcykge1xuICAgIHRoaXMuX3ggKz0gdi54ICogcztcbiAgICB0aGlzLl95ICs9IHYueSAqIHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3RzIGB2YCBmcm9tIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIHN1YlxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqL1xuICBzdWIodikge1xuICAgIHRoaXMuX3ggLT0gdi54O1xuICAgIHRoaXMuX3kgLT0gdi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyBgc2AgZnJvbSB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IGFuZCB7QGxpbmsgVmVjdG9yMiN5fVxuICAgKiBjb21wb25lbnRzLlxuICAgKiBAbWV0aG9kIHN1YlNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIHN1YlNjYWxhcihzKSB7XG4gICAgdGhpcy5feCAtPSBzO1xuICAgIHRoaXMuX3kgLT0gcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIGBhIC0gYmAuXG4gICAqIEBtZXRob2Qgc3ViVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gYVxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBiXG4gICAqL1xuICBzdWJWZWN0b3JzKGEsIGIpIHtcbiAgICB0aGlzLl94ID0gYS54IC0gYi54O1xuICAgIHRoaXMuX3kgPSBhLnkgLSBiLnk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTXVsdGlwbGllcyB0aGlzIHZlY3RvciBieSBgdmAuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IHZcbiAgICovXG4gIG11bHRpcGx5KHYpIHtcbiAgICB0aGlzLl94ICo9IHYueDtcbiAgICB0aGlzLl95ICo9IHYueTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIGJ5IHNjYWxhciBgc2AuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlTY2FsYXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge251bWJlcn0gc1xuICAgKi9cbiAgbXVsdGlwbHlTY2FsYXIocykge1xuICAgIGlmIChpc0Zpbml0ZShzKSkge1xuICAgICAgdGhpcy5feCAqPSBzO1xuICAgICAgdGhpcy5feSAqPSBzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl94ID0gMDtcbiAgICAgIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdGhpcyB2ZWN0b3IgYnkgYHZgLlxuICAgKiBAbWV0aG9kIGRpdmlkZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqL1xuICBkaXZpZGUodikge1xuICAgIHRoaXMuX3ggLz0gdi54O1xuICAgIHRoaXMuX3kgLz0gdi55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZXMgdGhpcyB2ZWN0b3IgYnkgc2NhbGFyIGBzYC4gU2V0cyB2ZWN0b3IgdG8gYCgwLCAwKWAgaWYgYHMgPSAwYC5cbiAgICogQG1ldGhvZCBkaXZpZGVTY2FsYXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAqL1xuICBkaXZpZGVTY2FsYXIocykge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyBzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlIGlzIGdyZWF0ZXJcbiAgICogdGhhbiBgdmAncyB7QGxpbmsgVmVjdG9yMiN4fSBvciB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZSwgcmVwbGFjZSB0aGF0IHZhbHVlXG4gICAqIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbWluIHZhbHVlLlxuICAgKiBAbWV0aG9kIG1pblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAqL1xuICBtaW4odikge1xuICAgIHRoaXMuX3ggPSBNYXRoLm1pbih0aGlzLl94LCB2LngpO1xuICAgIHRoaXMuX3kgPSBNYXRoLm1pbih0aGlzLl95LCB2LnkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWUgaXMgbGVzcyB0aGFuXG4gICAqIGB2YCdzIHtAbGluayBWZWN0b3IyI3h9IG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlLCByZXBsYWNlIHRoYXQgdmFsdWUgd2l0aFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBtYXggdmFsdWUuXG4gICAqIEBtZXRob2QgbWF4XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICovXG4gIG1heCh2KSB7XG4gICAgdGhpcy5feCA9IE1hdGgubWF4KHRoaXMuX3gsIHYueCk7XG4gICAgdGhpcy5feSA9IE1hdGgubWF4KHRoaXMuX3ksIHYueSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBvciB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZSBpcyBncmVhdGVyXG4gICAqIHRoYW4gdGhlIGBtYXhgIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9IG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlLCBpdCBpc1xuICAgKiByZXBsYWNlZCBieSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS4gSWYgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMiN4fSBvclxuICAgKiB7QGxpbmsgVmVjdG9yMiN5fSB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIGBtaW5gIHZlY3RvcidzIHtAbGluayBWZWN0b3IyI3h9XG4gICAqIG9yIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQG1ldGhvZCBjbGFtcFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSBtaW4gVGhlIG1pbmltdW0ge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlcy5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSBtYXggVGhlIG1heGltdW0ge0BsaW5rIFZlY3RvcjIjeH0gYW5kIHtAbGluayBWZWN0b3IyI3l9IHZhbHVlcyBpbiB0aGUgZGVzaXJlZCByYW5nZS5cbiAgICovXG4gIGNsYW1wKG1pbiwgbWF4KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcbiAgICB0aGlzLl94ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLl94KSk7XG4gICAgdGhpcy5feSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy5feSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzIGFyZSBncmVhdGVyXG4gICAqIHRoYW4gdGhlIGBtYXhgIHZhbHVlLCB0aGV5IGFyZSByZXBsYWNlZCBieSB0aGUgYG1heGAgdmFsdWUuIElmIHRoaXNcbiAgICogdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gb3Ige0BsaW5rIFZlY3RvcjIjeX0gdmFsdWVzIGFyZSBsZXNzIHRoYW4gdGhlXG4gICAqIGBtaW5gIHZhbHVlLCB0aGV5IGFyZSByZXBsYWNlZCBieSB0aGUgYG1pbmAgdmFsdWUuXG4gICAqIEBtZXRob2QgY2xhbXBTY2FsYXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5WYWwgVGhlIG1pbmltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VmFsIFRoZSBtYXhpbXVtIHZhbHVlIHRoZSBjb21wb25lbnRzIHdpbGwgYmUgY2xhbXBlZCB0by5cbiAgICovXG4gIGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcbiAgICB0aGlzLl94ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMuX3gpKTtcbiAgICB0aGlzLl95ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMuX3kpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHZlY3RvcidzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhlIGBtYXhgIHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieVxuICAgKiB0aGUgYG1heGAgdmFsdWUuIElmIHRoaXMgdmVjdG9yJ3MgbGVuZ3RoIGlzIGxlc3MgdGhhbiB0aGUgYG1pbmAgdmFsdWUsIGl0XG4gICAqIGlzIHJlcGxhY2VkIGJ5IHRoZSBgbWluYCB2YWx1ZS5cbiAgICogQG1ldGhvZCBjbGFtcExlbmd0aFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0aGUgbGVuZ3RoIHdpbGwgYmUgY2xhbXBlZCB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0aGUgbGVuZ3RoIHdpbGwgYmUgY2xhbXBlZCB0by5cbiAgICovXG4gIGNsYW1wTGVuZ3RoKG1pbiwgbWF4KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgbGVuZ3RoKSkgLyBsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIGZsb29yXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKi9cbiAgZmxvb3IoKSB7XG4gICAgdGhpcy5feCA9IE1hdGguZmxvb3IodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IE1hdGguZmxvb3IodGhpcy5feSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHtAbGluayBWZWN0b3IyI3h9IGFuZCB7QGxpbmsgVmVjdG9yMiN5fSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3IgYXJlXG4gICAqIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cbiAgICogQG1ldGhvZCBjZWlsXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKi9cbiAgY2VpbCgpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5jZWlsKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSBNYXRoLmNlaWwodGhpcy5feSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciBhcmUgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIHJvdW5kXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKi9cbiAgcm91bmQoKSB7XG4gICAgdGhpcy5feCA9IE1hdGgucm91bmQodGhpcy5feCk7XG4gICAgdGhpcy5feSA9IE1hdGgucm91bmQodGhpcy5feSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciBhcmUgcm91bmRlZCB0b3dhcmRzIHplcm8gKHVwIGlmIG5lZ2F0aXZlLCBkb3duXG4gICAqIGlmIHBvc2l0aXZlKSB0byBhbiBpbnRlZ2VyIHZhbHVlLlxuICAgKiBAbWV0aG9kIHJvdW5kVG9aZXJvXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKi9cbiAgcm91bmRUb1plcm8oKSB7XG4gICAgdGhpcy5feCA9ICh0aGlzLl94IDwgMCkgPyBNYXRoLmNlaWwodGhpcy5feCkgOiBNYXRoLmZsb29yKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSAodGhpcy5feSA8IDApID8gTWF0aC5jZWlsKHRoaXMuX3kpIDogTWF0aC5mbG9vcih0aGlzLl95KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgdmVjdG9yIC0gaS5lLiBzZXRzIGB4ID0gLXhgIGFuZCBgeSA9IC15YC5cbiAgICogQG1ldGhvZCBuZWdhdGVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgdGhpcy5feCA9IC10aGlzLl94O1xuICAgIHRoaXMuX3kgPSAtdGhpcy5feTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIFtkb3QgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG90X3Byb2R1Y3QpIG9mXG4gICAqIHRoaXMgdmVjdG9yIGFuZCBgdmAuXG4gICAqIEBtZXRob2QgZG90XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZG90KHYpIHtcbiAgICByZXR1cm4gKHRoaXMuX3ggKiB2LngpICsgKHRoaXMuX3kgKiB2LnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbSBgKDAsIDApYCB0byBgKHgsIHkpYC4gSWYgeW91IGFyZSBjb21wYXJpbmcgdGhlXG4gICAqIGxlbmd0aHMgb2YgdmVjdG9ycywgeW91IHNob3VsZCBjb21wYXJlIHRoZSBsZW5ndGggc3F1YXJlZCBpbnN0ZWFkIGFzIGl0IGlzXG4gICAqIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50IHRvIGNhbGN1bGF0ZS5cbiAgICogQG1ldGhvZCBsZW5ndGhTcVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoU3EoKSB7XG4gICAgcmV0dXJuICh0aGlzLl94ICogdGhpcy5feCkgKyAodGhpcy5feSAqIHRoaXMuX3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZVxuICAgKiBbRXVjbGlkZWFuIGxlbmd0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlKVxuICAgKiAoc3RyYWlnaHQtbGluZSBsZW5ndGgpIGZyb20gYCgwLCAwKWAgdG8gYCh4LCB5KWAuXG4gICAqIEBtZXRob2QgbGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy5feCAqIHRoaXMuX3gpICsgKHRoaXMuX3kgKiB0aGlzLl95KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtNYW5oYXR0YW4gbGVuZ3RoXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheGljYWJfZ2VvbWV0cnkpIG9mIHRoaXNcbiAgICogdmVjdG9yLlxuICAgKiBAbWV0aG9kIGxlbmd0aE1hbmhhdHRhblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgbGVuZ3RoTWFuaGF0dGFuKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLl94KSArIE1hdGguYWJzKHRoaXMuX3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgdG8gYmUgYVxuICAgKiBbdW5pdCB2ZWN0b3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXRfdmVjdG9yKSAtIHRoYXQgaXMsIHNldHMgaXRcbiAgICogZXF1YWwgdG8gdGhlIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0XG4gICAqIHtAbGluayBWZWN0b3IyI2xlbmd0aH0gMS5cbiAgICogQG1ldGhvZCBub3JtYWxpemVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqL1xuICBub3JtYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9mIHRoaXMgdmVjdG9yIHdpdGggcmVzcGVjdCB0byB0aGUgcG9zaXRpdmVcbiAgICogeC1heGlzLlxuICAgKiBAbWV0aG9kIGFuZ2xlXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhbmdsZSgpIHtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuX3ksIHRoaXMuX3gpO1xuXG4gICAgaWYgKGFuZ2xlIDwgMCkgYW5nbGUgKz0gMiAqIE1hdGguUEk7XG4gICAgcmV0dXJuIGFuZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoaXMgdmVjdG9yIHRvIGB2YC5cbiAgICogQG1ldGhvZCBkaXN0YW5jZVRvXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZGlzdGFuY2VUbyh2KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHYpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoaXMgdmVjdG9yIHRvIGB2YC4gSWYgeW91IGFyZSBqdXN0XG4gICAqIGNvbXBhcmluZyB0aGUgZGlzdGFuY2Ugd2l0aCBhbm90aGVyIGRpc3RhbmNlLCB5b3Ugc2hvdWxkIGNvbXBhcmUgdGhlXG4gICAqIGRpc3RhbmNlIHNxdWFyZWQgaW5zdGVhZCBhcyBpdCBpcyBzbGlnaHRseSBtb3JlIGVmZmljaWVudCB0byBjYWxjdWxhdGUuXG4gICAqIEBtZXRob2QgZGlzdGFuY2VUb1NxdWFyZWRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkaXN0YW5jZVRvU3F1YXJlZCh2KSB7XG4gICAgY29uc3QgZHggPSB0aGlzLl94IC0gdi54O1xuICAgIGNvbnN0IGR5ID0gdGhpcy5feSAtIHYueTtcblxuICAgIHJldHVybiAoZHggKiBkeCkgKyAoZHkgKiBkeSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlXG4gICAqIFtNYW5oYXR0YW4gZGlzdGFuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RheGljYWJfZ2VvbWV0cnkpXG4gICAqIGZyb20gdGhpcyB2ZWN0b3IgdG8gYHZgLlxuICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9NYW5oYXR0YW5cbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkaXN0YW5jZVRvTWFuaGF0dGFuKHYpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5feCAtIHYueCkgKyBNYXRoLmFicyh0aGlzLl95IC0gdi55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yIHRvIHRoZSB2ZWN0b3Igd2l0aCB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhpcyBvbmUsIGJ1dFxuICAgKiB7QGxpbmsgVmVjdG9yMiNsZW5ndGh9IGBsZW5ndGhgLlxuICAgKiBAbWV0aG9kIHNldExlbmd0aFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGB2YCwgd2hlcmUgYGFscGhhYCBpcyB0aGVcbiAgICogZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgLSBgYWxwaHEgPSAwYCB3aWxsIGJlIHRoaXMgdmVjdG9yLCBhbmQgYGFscGhhID0gMWBcbiAgICogd2lsbCBiZSBgdmAuXG4gICAqIEBtZXRob2QgbGVycFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2IHtAbGluayBWZWN0b3IyfSB0byBpbnRlcnBvbGF0ZSB0b3dhcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYWxwaGEgSW50ZXJwb2xhdGlvbiBmYWN0b3IgaW4gdGhlIGNsb3NlZCBpbnRlcnZhbCBgWzAsIDFdYC5cbiAgICovXG4gIGxlcnAodiwgYWxwaGEpIHtcbiAgICB0aGlzLl94ICs9ICh2LnggLSB0aGlzLl94KSAqIGFscGhhO1xuICAgIHRoaXMuX3kgKz0gKHYueSAtIHRoaXMuX3kpICogYWxwaGE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byBiZSB0aGUgdmVjdG9yIGxpbmVhcmx5IGludGVycG9sYXRlZCBiZXR3ZWVuIGB2MWAgYW5kXG4gICAqIGB2MmAgd2hlcmUgYGFscGhhYCBpcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgY29ubmVjdGluZyB0aGUgdHdvXG4gICAqIHZlY3RvcnMgLSBgYWxwaGEgPSAwYCB3aWxsIGJlIGB2MWAsIGFuZCBgYWxwaGEgPSAxYCB3aWxsIGJlIGB2MmAuXG4gICAqIEBtZXRob2QgbGVycFZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gdjEgVGhlIHN0YXJ0aW5nIHtAbGluayBWZWN0b3IyfS5cbiAgICogQHBhcmFtIHtWZWN0b3IyfSB2MiB7QGxpbmsgVmVjdG9yMn0gdG8gaW50ZXJwb2xhdGUgdG93YXJkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIEludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG4gICAqL1xuICBsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyh2MiwgdjEpLm11bHRpcGx5U2NhbGFyKGFscGhhKS5hZGQodjEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3Igc3RyaWN0IGVxdWFsaXR5IG9mIHRoaXMgdmVjdG9yIGFuZCBgdmAuXG4gICAqIEBtZXRob2QgZXF1YWxzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHModikge1xuICAgIHJldHVybiAodi54ID09PSB0aGlzLl94KSAmJiAodi55ID09PSB0aGlzLl95KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjIjeH0gdG8gYmUgYGFycmF5WzAgKyBvZmZzZXRdYCBhbmRcbiAgICoge0BsaW5rIFZlY3RvcjIjeX0gdG8gYmUgYGFycmF5WzEgKyBvZmZzZXRdYC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge0FycmF5fSBhcnJheSBUaGUgc291cmNlIGFycmF5LlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvZmZzZXQ9MF0gT2Zmc2V0IGludG8gdGhlIGFycmF5LlxuICAgKi9cbiAgZnJvbUFycmF5KGFycmF5LCBvZmZzZXQgPSAwKSB7XG4gICAgdGhpcy5feCA9IGFycmF5W29mZnNldF07XG4gICAgdGhpcy5feSA9IGFycmF5W29mZnNldCArIDFdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgYFt4LCB5XWAsIG9yIGNvcGllcyBvZiB7QGxpbmsgVmVjdG9yMiN4fSBhbmRcbiAgICoge0BsaW5rIFZlY3RvcjIjeX0gaW50byB0aGUgcHJvdmlkZWQgYGFycmF5YC5cbiAgICogQG1ldGhvZCB0b0FycmF5XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0gIHtudW1iZXJbXX0gW2FycmF5PVtdXSAgQXJyYXkgdG8gc3RvcmUgdGhlIHZlY3RvciB0by4gSWYgdGhpcyBpcyBub3QgcHJvdmlkZWQgYSBuZXcgYXJyYXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvZmZzZXQ9MF0gT3B0aW9uYWwgb2Zmc2V0IGludG8gdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAgICovXG4gIHRvQXJyYXkoYXJyYXkgPSBbXSwgb2Zmc2V0ID0gMCkge1xuICAgIGFycmF5W29mZnNldF0gPSB0aGlzLl94O1xuICAgIGFycmF5W29mZnNldCArIDFdID0gdGhpcy5feTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSB2ZWN0b3IgYXJvdW5kIGBjZW50ZXJgIGJ5IGBhbmdsZWAgaW4gcmFkaWFucy5cbiAgICogQG1ldGhvZCByb3RhdGVBcm91bmRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yMn0gY2VudGVyIFRoZSBwb2ludCBhcm91bmQgd2hpY2ggdG8gcm90YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIHRvIHJvdGF0ZSwgaW4gcmFkaWFucy5cbiAgICovXG4gIHJvdGF0ZUFyb3VuZChjZW50ZXIsIGFuZ2xlKSB7XG4gICAgY29uc3QgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHggPSB0aGlzLl94IC0gY2VudGVyLng7XG4gICAgY29uc3QgeSA9IHRoaXMuX3kgLSBjZW50ZXIueTtcblxuICAgIHRoaXMuX3ggPSAoeCAqIGMpIC0gKHkgKiBzKSArIGNlbnRlci54OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1peGVkLW9wZXJhdG9yc1xuICAgIHRoaXMuX3kgPSAoeCAqIHMpICsgKHkgKiBjKSArIGNlbnRlci55O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbiIsImltcG9ydCB7Y2xhbXB9IGZyb20gJy4vTWF0aCc7XG4vLyBpbXBvcnQgTWF0cml4NCBmcm9tICcuL01hdHJpeDQnO1xuaW1wb3J0IFF1YXRlcm5pb24gZnJvbSAnLi9RdWF0ZXJuaW9uJztcbi8vIGltcG9ydCBFdWxlciBmcm9tICcuL0V1bGVyJztcbi8vIGltcG9ydCBDYW1lcmEgZnJvbSAnLi4vY2FtZXJhL0NhbWVyYSc7XG5cbi8vIGNvbnN0YW50cyBmb3Igb3B0aW1pc2F0aW9uXG5sZXQgYXBwbHlFdWxlclE7XG5sZXQgYXBwbHlBeGlzQW5nbGVRO1xuLy8gbGV0IHByb2plY3RNO1xuLy8gbGV0IHVucHJvamVjdE07XG5sZXQgcHJvamVjdE9uUGxhbmVWO1xubGV0IHJlZmxlY3RWO1xuXG4vLyBsZXQgdGhpcy5feCA9IDAsIHRoaXMuX3kgPSAwLCB0aGlzLl96ID0gMDtcbmxldCBvbkNoYW5nZUNhbGxiYWNrID0gKCkgPT4ge307XG5jb25zdCBfaXNWZWN0b3IzID0gdHJ1ZTtcblxuLyoqXG4gKiBAY2xhc3MgVmVjdG9yM1xuICogQGNsYXNzZGVzY1xuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgM0QgW3ZlY3Rvcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX3NwYWNlKS5cbiAqIEEgM0QgdmVjdG9yIGlzIGFuIG9yZGVyZWQgdHJpcGxldCBvZiBudW1iZXJzIChsYWJlbGVkIGB4YCwgYHlgLCBhbmQgYHpgKSxcbiAqIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBhIG51bWJlciBvZiB0aGluZ3MsIHN1Y2ggYXM6XG4gKiAqIEEgcG9pbnQgaW4gM0Qgc3BhY2UuXG4gKiAqIEEgZGlyZWN0aW9uIGFuZCBsZW5ndGggaW4gM0Qgc3BhY2UuIEZvciBMZXRzZWUsIHRoZSBsZW5ndGggd2lsbCBhbHdheXMgYmVcbiAqIHRoZSBbRXVjbGlkZWFuIGRpc3RhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gKiAoc3RyYWlnaHQtbGluZSBkaXN0YW5jZSkgZnJvbSBgKDAsIDAsIDApYCB0byBgKHgsIHksIHopYCBhbmQgdGhlIGRpcmVjdGlvbiBpc1xuICogYWxzbyBtZWFzdXJlZCBmcm9tIGAoMCwgMCwgMClgIHRvd2FyZHMgYCh4LCB5LCB6KWAuXG4gKiAqIEFueSBhcmJpdHJhcnkgb3JkZXJlZCB0cmlwbGV0IG9mIG51bWJlcnMuXG4gKiBUaGVyZSBhcmUgb3RoZXIgdGhpbmdzIGEgM0QgdmVjdG9yIGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCwgc3VjaCBhcyBtb21lbnR1bVxuICogdmVjdG9ycyBhbmQgc28gb24sIGhvd2V2ZXIgdGhlc2UgYXJlIHRoZSBtb3N0IGNvbW1vbiB1c2VzLlxuICogQGV4YW1wbGVcbiAqIHZhciBhID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gKlxuICogLy8gbm8gYXJndW1lbnRzOyB3aWxsIGJlIGluaXRpYWxpc2VkIHRvICgwLCAwLCAwKVxuICogdmFyIGIgPSBuZXcgVmVjdG9yMygpO1xuICpcbiAqIHZhciBkID0gYS5kaXN0YW5jZVRvKGIpO1xuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIFRoZSB4IHZhbHVlIG9mIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gVGhlIHkgdmFsdWUgb2YgdGhlIHZlY3Rvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbej0wXSBUaGUgeiB2YWx1ZSBvZiB0aGUgdmVjdG9yLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3IzIHtcbiAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB6ID0gMCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xuICAgIHRoaXMuX3ogPSB6O1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge251bWJlcn0geFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMyNcbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3g7XG4gIH1cblxuICBzZXQgeCh2YWx1ZSkge1xuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9IHlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMjXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGdldCB5KCkge1xuICAgIHJldHVybiB0aGlzLl95O1xuICB9XG5cbiAgc2V0IHkodmFsdWUpIHtcbiAgICB0aGlzLl95ID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlciB7bnVtYmVyfSB6XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzI1xuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBnZXQgeigpIHtcbiAgICByZXR1cm4gdGhpcy5fejtcbiAgfVxuXG4gIHNldCB6KHZhbHVlKSB7XG4gICAgdGhpcy5feiA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICB9XG5cbiAgZ2V0IGlzVmVjdG9yMygpIHtcbiAgICByZXR1cm4gX2lzVmVjdG9yMztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIGFuZCB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiBjb21wb25lbnRzIG9mIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICovXG4gIHNldCh4LCB5LCB6KSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBhbmQge0BsaW5rIFZlY3RvcjMjen0gdmFsdWVzXG4gICAqIG9mIHRoaXMgdmVjdG9yIGFsbCBlcXVhbCB0byBgc2NhbGFyYC5cbiAgICogQG1ldGhvZCBzZXRTY2FsYXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsYXJcbiAgICovXG4gIHNldFNjYWxhcihzY2FsYXIpIHtcbiAgICB0aGlzLl94ID0gc2NhbGFyO1xuICAgIHRoaXMuX3kgPSBzY2FsYXI7XG4gICAgdGhpcy5feiA9IHNjYWxhcjtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0gdmFsdWUgd2l0aCBgeGAuXG4gICAqIEBtZXRob2Qgc2V0WFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICovXG4gIHNldFgoeCkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN5fSB2YWx1ZSB3aXRoIGB5YC5cbiAgICogQG1ldGhvZCBzZXRZXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKi9cbiAgc2V0WSh5KSB7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZSB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlIHdpdGggYHpgLlxuICAgKiBAbWV0aG9kIHNldFpcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAqL1xuICBzZXRaKHopIHtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyBgMGAgc2V0IHtAbGluayBWZWN0b3IzI3h9IHRvIGB2YWx1ZWAuXG4gICAqIElmIGBpbmRleGAgZXF1YWxzIGAxYCBzZXQge0BsaW5rIFZlY3RvcjMjeX0gdG8gYHZhbHVlYC5cbiAgICogSWYgYGluZGV4YCBlcXVhbHMgYDJgIHNldCB7QGxpbmsgVmVjdG9yMyN6fSB0byBgdmFsdWVgLlxuICAgKiBAbWV0aG9kIHNldENvbXBvbmVudFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHswfDF8Mn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqL1xuICBzZXRDb21wb25lbnQoaW5kZXggPSAwIHwgMSB8IDIsIHZhbHVlKSB7XG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgYGluZGV4YCBlcXVhbHMgYDBgIHJldHVybnMgdGhlIHtAbGluayBWZWN0b3IzI3h9IHZhbHVlLlxuICAgKiBJZiBgaW5kZXhgIGVxdWFscyBgMWAgcmV0dXJucyB0aGUge0BsaW5rIFZlY3RvcjMjeX0gdmFsdWUuXG4gICAqIElmIGBpbmRleGAgZXF1YWxzIGAyYCByZXR1cm5zIHRoZSB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZS5cbiAgICogQG1ldGhvZCBnZXRDb21wb25lbnRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7MHwxfDJ9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbXBvbmVudChpbmRleCA9IDAgfCAxIHwgMikge1xuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5fejtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAke2luZGV4fWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHtAbGluayBWZWN0b3IzfSB3aXRoIHRoZSBzYW1lIHtAbGluayBWZWN0b3IzI3h9LFxuICAgKiB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICogQG1ldGhvZCBjbG9uZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHJldHVybiB7VmVjdG9yM31cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgcGFzc2VkIHtAbGluayBWZWN0b3IzfSdzIHtAbGluayBWZWN0b3IzI3h9LFxuICAgKiB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kIHtAbGluayBWZWN0b3IzI3p9IHByb3BlcnRpZXMgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBjb3B5KHYpIHtcbiAgICB0aGlzLl94ID0gdi54O1xuICAgIHRoaXMuX3kgPSB2Lnk7XG4gICAgdGhpcy5feiA9IHYuejtcbiAgICAvLyB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGB2YCB0byB0aGlzIHZlY3Rvci5cbiAgICogQG1ldGhvZCBhZGRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgYWRkKHYpIHtcbiAgICB0aGlzLl94ICs9IHYueDtcbiAgICB0aGlzLl95ICs9IHYueTtcbiAgICB0aGlzLl96ICs9IHYuejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzY2FsYXIgdmFsdWUgYHNgIHRvIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sXG4gICAqIHtAbGluayBWZWN0b3IzI3l9LCBhbmQge0BsaW5rIFZlY3RvcjMjen0gdmFsdWVzLlxuICAgKiBAbWV0aG9kIGFkZFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGFkZFNjYWxhcihzKSB7XG4gICAgdGhpcy5feCArPSBzO1xuICAgIHRoaXMuX3kgKz0gcztcbiAgICB0aGlzLl96ICs9IHM7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byBgYSArIGJgLlxuICAgKiBAbWV0aG9kIGFkZFZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGJcbiAgICovXG4gIGFkZFZlY3RvcnMoYSwgYikge1xuICAgIHRoaXMuX3ggPSBhLnggKyBiLng7XG4gICAgdGhpcy5feSA9IGEueSArIGIueTtcbiAgICB0aGlzLl96ID0gYS56ICsgYi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG11bHRpcGxlIG9mIGB2YCBhbmQgYHNgIHRvIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGFkZFNjYWxlZFZlY3RvclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAqL1xuICBhZGRTY2FsZWRWZWN0b3Iodiwgcykge1xuICAgIHRoaXMuX3ggKz0gdi54ICogcztcbiAgICB0aGlzLl95ICs9IHYueSAqIHM7XG4gICAgdGhpcy5feiArPSB2LnogKiBzO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyBgdmAgZnJvbSB0aGlzIHZlY3Rvci5cbiAgICogQG1ldGhvZCBzdWJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKi9cbiAgc3ViKHYpIHtcbiAgICB0aGlzLl94IC09IHYueDtcbiAgICB0aGlzLl95IC09IHYueTtcbiAgICB0aGlzLl96IC09IHYuejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgYHNgIGZyb20gdGhpcyB2ZWN0b3IncyB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIGFuZFxuICAgKiB7QGxpbmsgVmVjdG9yMyN6fSBjb21wb25lbnRzLlxuICAgKiBAbWV0aG9kIHN1YlNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIHN1YlNjYWxhcihzKSB7XG4gICAgdGhpcy5feCAtPSBzO1xuICAgIHRoaXMuX3kgLT0gcztcbiAgICB0aGlzLl96IC09IHM7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byBgYSAtIGJgLlxuICAgKiBAbWV0aG9kIHN1YlZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGJcbiAgICovXG4gIHN1YlZlY3RvcnMoYSwgYikge1xuICAgIHRoaXMuX3ggPSBhLnggLSBiLng7XG4gICAgdGhpcy5feSA9IGEueSAtIGIueTtcbiAgICB0aGlzLl96ID0gYS56IC0gYi56O1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgYnkgYHZgLlxuICAgKiBAbWV0aG9kIG11bHRpcGx5XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIG11bHRpcGx5KHYpIHtcbiAgICB0aGlzLl94ICo9IHYueDtcbiAgICB0aGlzLl95ICo9IHYueTtcbiAgICB0aGlzLl96ICo9IHYuejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoaXMgdmVjdG9yIGJ5IHNjYWxhciBgc2AuXG4gICAqIEBtZXRob2QgbXVsdGlwbHlTY2FsYXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAqL1xuICBtdWx0aXBseVNjYWxhcihzKSB7XG4gICAgdGhpcy5feCAqPSBzO1xuICAgIHRoaXMuX3kgKj0gcztcbiAgICB0aGlzLl96ICo9IHM7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciBlcXVhbCB0byBgYSDDlyBiYC5cbiAgICogQG1ldGhvZCBtdWx0aXBseVZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IGJcbiAgICovXG4gIG11bHRpcGx5VmVjdG9ycyhhLCBiKSB7XG4gICAgdGhpcy5feCA9IGEueCAqIGIueDtcbiAgICB0aGlzLl95ID0gYS55ICogYi55O1xuICAgIHRoaXMuX3ogPSBhLnogKiBiLno7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBldWxlciB0cmFuc2Zvcm0gdG8gdGhpcyB2ZWN0b3IgYnkgY29udmVydGluZyB0aGUge0BsaW5rIEV1bGVyfVxuICAgKiBvYmplY3QgdG8gYSB7QGxpbmsgUXVhdGVybmlvbn0gYW5kIGFwcGx5aW5nLlxuICAgKiBAbWV0aG9kIGFwcGx5RXVsZXJcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RXVsZXJ9IGV1bGVyXG4gICAqL1xuICBhcHBseUV1bGVyKGV1bGVyKSB7XG4gICAgaWYgKHR5cGVvZiBhcHBseUV1bGVyUSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFwcGx5RXVsZXJRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oYXBwbHlFdWxlclEuc2V0RnJvbUV1bGVyKGV1bGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIHJvdGF0aW9uIHNwZWNpZmllZCBieSBhbiBgYXhpc2AgYW5kIGFuIGBhbmdsZWAgdG8gdGhpcyB2ZWN0b3IuXG4gICAqIEBtZXRob2QgYXBwbHlBeGlzQW5nbGVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyBBIG5vcm1hbGl6ZWQge0BsaW5rIFZlY3RvcjN9LlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW4gYW5nbGUgaW4gcmFkaWFucy5cbiAgICovXG4gIGFwcGx5QXhpc0FuZ2xlKGF4aXMsIGFuZ2xlKSB7XG4gICAgaWYgKHR5cGVvZiBhcHBseUF4aXNBbmdsZVEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhcHBseUF4aXNBbmdsZVEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihhcHBseUF4aXNBbmdsZVEuc2V0RnJvbUF4aXNBbmdsZShheGlzLCBhbmdsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyB2ZWN0b3IgKHdpdGggYW4gaW1wbGljaXQgYDFgIGluIHRoZSA0dGggZGltZW5zaW9uKSBhbmQgYG1gLFxuICAgKiBhbmQgZGl2aWRlcyBieSBwZXJzcGVjdGl2ZS5cbiAgICogQG1ldGhvZCBhcHBseU1hdHJpeDRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgYXBwbHlNYXRyaXg0KG0pIHtcbiAgICBjb25zdCB4ID0gdGhpcy5feDtcbiAgICBjb25zdCB5ID0gdGhpcy5feTtcbiAgICBjb25zdCB6ID0gdGhpcy5fejtcbiAgICBjb25zdCBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMuX3ggPSAoZVswXSAqIHgpICsgKGVbNF0gKiB5KSArIChlWzhdICogeikgKyBlWzEyXTtcbiAgICB0aGlzLl95ID0gKGVbMV0gKiB4KSArIChlWzVdICogeSkgKyAoZVs5XSAqIHopICsgZVsxM107XG4gICAgdGhpcy5feiA9IChlWzJdICogeCkgKyAoZVs2XSAqIHkpICsgKGVbMTBdICogeikgKyBlWzE0XTtcbiAgICBjb25zdCB3ID0gKGVbM10gKiB4KSArIChlWzddICogeSkgKyAoZVsxMV0gKiB6KSArIGVbMTVdO1xuXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSB7QGxpbmsgUXVhdGVybmlvbn0gdHJhbnNmb3JtIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIGFwcGx5UXVhdGVybmlvblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXG4gICAqL1xuICBhcHBseVF1YXRlcm5pb24ocSkge1xuICAgIGNvbnN0IHggPSB0aGlzLl94O1xuICAgIGNvbnN0IHkgPSB0aGlzLl95O1xuICAgIGNvbnN0IHogPSB0aGlzLl96O1xuICAgIGNvbnN0IHF4ID0gcS54O1xuICAgIGNvbnN0IHF5ID0gcS55O1xuICAgIGNvbnN0IHF6ID0gcS56O1xuICAgIGNvbnN0IHF3ID0gcS53O1xuXG4gICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcbiAgICBjb25zdCBpeCA9IChxdyAqIHgpICsgKHF5ICogeikgLSAocXogKiB5KTtcbiAgICBjb25zdCBpeSA9IChxdyAqIHkpICsgKHF6ICogeCkgLSAocXggKiB6KTtcbiAgICBjb25zdCBpeiA9IChxdyAqIHopICsgKHF4ICogeSkgLSAocXkgKiB4KTtcbiAgICBjb25zdCBpdyA9ICgtcXggKiB4KSAtIChxeSAqIHkpIC0gKHF6ICogeik7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgdGhpcy5feCA9IChpeCAqIHF3KSArIChpdyAqIC1xeCkgKyAoaXkgKiAtcXopIC0gKGl6ICogLXF5KTtcbiAgICB0aGlzLl95ID0gKGl5ICogcXcpICsgKGl3ICogLXF5KSArIChpeiAqIC1xeCkgLSAoaXggKiAtcXopO1xuICAgIHRoaXMuX3ogPSAoaXogKiBxdykgKyAoaXcgKiAtcXopICsgKGl4ICogLXF5KSAtIChpeSAqIC1xeCk7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogW1Byb2plY3RzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfcHJvamVjdGlvbikgdGhlIHZlY3RvclxuICAgKiB3aXRoIHRoZSBgY2FtZXJhYC5cbiAgICogQG1ldGhvZCBwcm9qZWN0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIENhbWVyYSB0byB1c2UgaW4gdGhlIHByb2plY3Rpb24uXG4gICAqL1xuICBwcm9qZWN0KGNhbWVyYSkge1xuICAgIC8vIGlmICh0eXBlb2YgcHJvamVjdE0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gICBwcm9qZWN0TSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gcHJvamVjdE0ubXVsdGlwbHlNYXRyaWNlcyhjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgcHJvamVjdE0uZ2V0SW52ZXJzZShjYW1lcmEubWF0cml4V29ybGQpKTtcbiAgICAvLyByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQocHJvamVjdE0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpLmFwcGx5TWF0cml4NChjYW1lcmEucHJvamVjdGlvbk1hdHJpeCk7XG4gIH1cblxuICAvKipcbiAgICogW1VucHJvamVjdHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZlY3Rvcl9wcm9qZWN0aW9uKSB0aGUgdmVjdG9yXG4gICAqIHdpdGggdGhlIGBjYW1lcmFgJ3MgcHJvamVjdGlvbiBtYXRyaXguXG4gICAqIEBtZXRob2QgdW5wcm9qZWN0XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0NhbWVyYX0gY2FtZXJhIENhbWVyYSB0byB1c2UgaW4gdGhlIHByb2plY3Rpb24uXG4gICAqL1xuICB1bnByb2plY3QoY2FtZXJhKSB7XG4gICAgLy8gaWYgKHR5cGVvZiB1bnByb2plY3RNID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vICAgdW5wcm9qZWN0TSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgLy8gfVxuICAgIC8vXG4gICAgLy8gdW5wcm9qZWN0TS5tdWx0aXBseU1hdHJpY2VzKGNhbWVyYS5tYXRyaXhXb3JsZCwgdW5wcm9qZWN0TS5nZXRJbnZlcnNlKGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4KSk7XG4gICAgLy8gcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHVucHJvamVjdE0pO1xuICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NChjYW1lcmEucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NChjYW1lcmEubWF0cml4V29ybGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGRpcmVjdGlvbiBvZiB0aGlzIHZlY3RvciBieSBhIG1hdHJpeCAodGhlIHVwcGVyIGxlZnQgMyB4IDNcbiAgICogc3Vic2V0IG9mIHRoZSBgbWApIGFuZCB0aGVuIFtub3JtYWxpemVzXXtAbGluayBWZWN0b3IzI25vcm1hbGl6ZX0gdGhlXG4gICAqIHJlc3VsdC5cbiAgICogQG1ldGhvZCB0cmFuc2Zvcm1EaXJlY3Rpb25cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgdHJhbnNmb3JtRGlyZWN0aW9uKG0pIHtcbiAgICAvLyBpbnB1dCBhZmZpbmUgbWF0cml4XG4gICAgLy8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG4gICAgY29uc3QgeCA9IHRoaXMuX3g7XG4gICAgY29uc3QgeSA9IHRoaXMuX3k7XG4gICAgY29uc3QgeiA9IHRoaXMuX3o7XG4gICAgY29uc3QgZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLl94ID0gKGVbMF0gKiB4KSArIChlWzRdICogeSkgKyAoZVs4XSAqIHopO1xuICAgIHRoaXMuX3kgPSAoZVsxXSAqIHgpICsgKGVbNV0gKiB5KSArIChlWzldICogeik7XG4gICAgdGhpcy5feiA9IChlWzJdICogeCkgKyAoZVs2XSAqIHkpICsgKGVbMTBdICogeik7XG4gICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSBgdmAuXG4gICAqIEBtZXRob2QgZGl2aWRlXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIGRpdmlkZSh2KSB7XG4gICAgdGhpcy5feCAvPSB2Lng7XG4gICAgdGhpcy5feSAvPSB2Lnk7XG4gICAgdGhpcy5feiAvPSB2Lno7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSBzY2FsYXIgYHNgLiBTZXRzIHZlY3RvciB0byBgKDAsIDAsIDApYCBpZiBgcyA9IDBgLlxuICAgKiBAbWV0aG9kIGRpdmlkZVNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNcbiAgICovXG4gIGRpdmlkZVNjYWxhcihzKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gYHZgJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvclxuICAgKiB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZSwgcmVwbGFjZSB0aGF0IHZhbHVlIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbWluXG4gICAqIHZhbHVlLlxuICAgKiBAbWV0aG9kIG1pblxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBtaW4odikge1xuICAgIHRoaXMuX3ggPSBNYXRoLm1pbih0aGlzLl94LCB2LngpO1xuICAgIHRoaXMuX3kgPSBNYXRoLm1pbih0aGlzLl95LCB2LnkpO1xuICAgIHRoaXMuX3ogPSBNYXRoLm1pbih0aGlzLl96LCB2LnopO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiB2YWx1ZSBpcyBsZXNzIHRoYW4gYHZgJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvclxuICAgKiB7QGxpbmsgVmVjdG9yMyN6fSB2YWx1ZSwgcmVwbGFjZSB0aGF0IHZhbHVlIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbWF4XG4gICAqIHZhbHVlLlxuICAgKiBAbWV0aG9kIG1heFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqL1xuICBtYXgodikge1xuICAgIHRoaXMuX3ggPSBNYXRoLm1heCh0aGlzLl94LCB2LngpO1xuICAgIHRoaXMuX3kgPSBNYXRoLm1heCh0aGlzLl95LCB2LnkpO1xuICAgIHRoaXMuX3ogPSBNYXRoLm1heCh0aGlzLl96LCB2LnopO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGBtYXhgIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3h9LFxuICAgKiB7QGxpbmsgVmVjdG9yMyN5fSwgb3Ige0BsaW5rIFZlY3RvcjMjen0gdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5IHRoZVxuICAgKiBjb3JyZXNwb25kaW5nIHZhbHVlLiBJZiB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSxcbiAgICogb3Ige0BsaW5rIFZlY3RvcjMjen0gdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBgbWluYCB2ZWN0b3Inc1xuICAgKiB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIG9yIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlLCBpdCBpc1xuICAgKiByZXBsYWNlZCBieSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAgICogQG1ldGhvZCBjbGFtcFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBtaW5cbiAgICogQHBhcmFtIHtWZWN0b3IzfSBtYXhcbiAgICovXG4gIGNsYW1wKG1pbiwgbWF4KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcbiAgICB0aGlzLl94ID0gTWF0aC5tYXgobWluLngsIE1hdGgubWluKG1heC54LCB0aGlzLl94KSk7XG4gICAgdGhpcy5feSA9IE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy5feSkpO1xuICAgIHRoaXMuX3ogPSBNYXRoLm1heChtaW4ueiwgTWF0aC5taW4obWF4LnosIHRoaXMuX3opKTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGlzIHZlY3RvcidzIHtAbGluayBWZWN0b3IzI3h9LCB7QGxpbmsgVmVjdG9yMyN5fSwgb3Ige0BsaW5rIFZlY3RvcjMjen1cbiAgICogdmFsdWVzIGFyZSBncmVhdGVyIHRoYW4gdGhlIGBtYXhgIHZhbHVlLCBpdCBpcyByZXBsYWNlZCBieSB0aGUgYG1heGAgdmFsdWUuXG4gICAqIElmIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBvciB7QGxpbmsgVmVjdG9yMyN6fVxuICAgKiB2YWx1ZXMgYXJlIGxlc3MgdGhhbiB0aGUgYG1pbmAgdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5IHRoZSBgbWluYCB2YWx1ZS5cbiAgICogQG1ldGhvZCBjbGFtcFNjYWxhclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0aGUgY29tcG9uZW50cyB3aWxsIGJlIGNsYW1wZWQgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKi9cbiAgY2xhbXBTY2FsYXIobWluLCBtYXgpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuICAgIHRoaXMuX3ggPSBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdGhpcy5feCkpO1xuICAgIHRoaXMuX3kgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdGhpcy5feSkpO1xuICAgIHRoaXMuX3ogPSBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdGhpcy5feikpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoaXMgdmVjdG9yJ3MgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYG1heGAgdmFsdWUsIGl0IGlzIHJlcGxhY2VkIGJ5XG4gICAqIHRoZSBgbWF4YCB2YWx1ZS4gSWYgdGhpcyB2ZWN0b3IncyBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBgbWluYCB2YWx1ZSwgaXRcbiAgICogaXMgcmVwbGFjZWQgYnkgdGhlIGBtaW5gIHZhbHVlLlxuICAgKiBAbWV0aG9kIGNsYW1wTGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBtaW5pbXVtIHZhbHVlIHRoZSBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRoZSBsZW5ndGggd2lsbCBiZSBjbGFtcGVkIHRvLlxuICAgKi9cbiAgY2xhbXBMZW5ndGgobWluLCBtYXgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGxlbmd0aCkpIC8gbGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cbiAgICogQG1ldGhvZCBmbG9vclxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICovXG4gIGZsb29yKCkge1xuICAgIHRoaXMuX3ggPSBNYXRoLmZsb29yKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSBNYXRoLmZsb29yKHRoaXMuX3kpO1xuICAgIHRoaXMuX3ogPSBNYXRoLmZsb29yKHRoaXMuX3opO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgVmVjdG9yMyN4fSwge0BsaW5rIFZlY3RvcjMjeX0sIGFuZCB7QGxpbmsgVmVjdG9yMyN6fSBjb21wb25lbnRzXG4gICAqIG9mIHRoZSB2ZWN0b3IgYXJlIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3QgaW50ZWdlciB2YWx1ZS5cbiAgICogQG1ldGhvZCBjZWlsXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKi9cbiAgY2VpbCgpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5jZWlsKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSBNYXRoLmNlaWwodGhpcy5feSk7XG4gICAgdGhpcy5feiA9IE1hdGguY2VpbCh0aGlzLl96KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIGFyZSByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIgdmFsdWUuXG4gICAqIEBtZXRob2Qgcm91bmRcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqL1xuICByb3VuZCgpIHtcbiAgICB0aGlzLl94ID0gTWF0aC5yb3VuZCh0aGlzLl94KTtcbiAgICB0aGlzLl95ID0gTWF0aC5yb3VuZCh0aGlzLl95KTtcbiAgICB0aGlzLl96ID0gTWF0aC5yb3VuZCh0aGlzLl96KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIGFyZSByb3VuZGVkIHRvd2FyZHMgemVybyAodXAgaWYgbmVnYXRpdmUsXG4gICAqIGRvd24gaWYgcG9zaXRpdmUpIHRvIGFuIGludGVnZXIgdmFsdWUuXG4gICAqIEBtZXRob2Qgcm91bmRUb1plcm9cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqL1xuICByb3VuZFRvWmVybygpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feCA8IDAgPyBNYXRoLmNlaWwodGhpcy5feCkgOiBNYXRoLmZsb29yKHRoaXMuX3gpO1xuICAgIHRoaXMuX3kgPSB0aGlzLl95IDwgMCA/IE1hdGguY2VpbCh0aGlzLl95KSA6IE1hdGguZmxvb3IodGhpcy5feSk7XG4gICAgdGhpcy5feiA9IHRoaXMuX3ogPCAwID8gTWF0aC5jZWlsKHRoaXMuX3opIDogTWF0aC5mbG9vcih0aGlzLl96KTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoaXMgdmVjdG9yIC0gaS5lLiBzZXRzIGB4ID0gLXhgLCBgeSA9IC15YCwgYW5kIGB6ID0gLXpgLlxuICAgKiBAbWV0aG9kIG5lZ2F0ZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICovXG4gIG5lZ2F0ZSgpIHtcbiAgICB0aGlzLl94ID0gLXRoaXMuX3g7XG4gICAgdGhpcy5feSA9IC10aGlzLl95O1xuICAgIHRoaXMuX3ogPSAtdGhpcy5fejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIFtkb3QgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG90X3Byb2R1Y3QpIG9mXG4gICAqIHRoaXMgdmVjdG9yIGFuZCBgdmAuXG4gICAqIEBtZXRob2QgZG90XG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZG90KHYpIHtcbiAgICByZXR1cm4gKHRoaXMuX3ggKiB2LngpICsgKHRoaXMuX3kgKiB2LnkpICsgKHRoaXMuX3ogKiB2LnopO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzcXVhcmUgb2YgdGhlXG4gICAqIFtFdWNsaWRlYW4gbGVuZ3RoXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FdWNsaWRlYW5fZGlzdGFuY2UpXG4gICAqIChzdHJhaWdodC1saW5lIGxlbmd0aCkgZnJvbSBgKDAsIDAsIDApYCB0byBgKHgsIHksIHopYC4gSWYgeW91IGFyZVxuICAgKiBjb21wYXJpbmcgbGVuZ3RocyBvZiB2ZWN0b3JzLCB5b3Ugc2hvdWxkIGNvbXBhcmUgdGhlIGxlbmd0aCBzcXVhcmVkXG4gICAqIGluc3RlYWQgYXMgaXQgaXMgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnQgdG8gY2FsY3VsYXRlLlxuICAgKiBAbWV0aG9kIGxlbmd0aFNxXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGhTcSgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3ggKiB0aGlzLl94KSArICh0aGlzLl95ICogdGhpcy5feSkgKyAodGhpcy5feiAqIHRoaXMuX3opO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZVxuICAgKiBbRXVjbGlkZWFuIGxlbmd0aF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlKVxuICAgKiAoc3RyYWlnaHQtbGluZSBsZW5ndGgpIGZyb20gYCgwLCAwLCAwKWAgdG8gYCh4LCB5LCB6KWAuXG4gICAqIEBtZXRob2QgbGVuZ3RoXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy5feCAqIHRoaXMuX3gpICsgKHRoaXMuX3kgKiB0aGlzLl95KSArICh0aGlzLl96ICogdGhpcy5feikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZVxuICAgKiBbTWFuaGF0dGFuIGxlbmd0aF0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UYXhpY2FiX2dlb21ldHJ5KSBvZiB0aGlzXG4gICAqIHZlY3Rvci5cbiAgICogQG1ldGhvZCBsZW5ndGhNYW5oYXR0YW5cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGxlbmd0aE1hbmhhdHRhbigpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy5feCkgKyBNYXRoLmFicyh0aGlzLl95KSArIE1hdGguYWJzKHRoaXMuX3opO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyB2ZWN0b3IgdG8gYVxuICAgKiBbdW5pdCB2ZWN0b3JdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXRfdmVjdG9yKSAtIHRoYXQgaXMsIHNldHNcbiAgICogaXQgZXF1YWwgdG8gdGhlIHZlY3RvciB3aXRoIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGlzIG9uZSwgYnV0XG4gICAqIHtAbGluayBWZWN0b3IzI2xlbmd0aH0gYDFgLlxuICAgKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byB0aGUgdmVjdG9yIHdpdGggdGhlIHNhbWUgZGlyZWN0aW9uIGFzIHRoaXMgb25lLCBidXRcbiAgICoge0BsaW5rIFZlY3RvcjMjbGVuZ3RofSBgbGVuZ3RoYC5cbiAgICogQG1ldGhvZCBzZXRMZW5ndGhcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICovXG4gIHNldExlbmd0aChsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihsZW5ndGggLyB0aGlzLmxlbmd0aCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lYXJseSBpbnRlcnBvbGF0ZSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBgdmAsIHdoZXJlIGBhbHBoYWAgaXMgdGhlXG4gICAqIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lIC0gYGFscGhhID0gMGAgd2lsbCBiZSB0aGlzIHZlY3RvciwgYW5kIGBhbHBoYSA9IDFgXG4gICAqIHdpbGwgYmUgYHZgLlxuICAgKiBAbWV0aG9kIGxlcnBcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdiB7QGxpbmsgVmVjdG9yM30gdG8gaW50ZXJwb2xhdGUgdG93YXJkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIEludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG4gICAqL1xuICBsZXJwKHYsIGFscGhhKSB7XG4gICAgdGhpcy5feCArPSAodi54IC0gdGhpcy5feCkgKiBhbHBoYTtcbiAgICB0aGlzLl95ICs9ICh2LnkgLSB0aGlzLl95KSAqIGFscGhhO1xuICAgIHRoaXMuX3ogKz0gKHYueiAtIHRoaXMuX3opICogYWxwaGE7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byBiZSB0aGUgdmVjdG9yIGxpbmVhcmx5IGludGVycG9sYXRlZCBiZXR3ZWVuIGB2MWAgYW5kXG4gICAqIGB2MmAgd2hlcmUgYGFscGhhYCBpcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGxpbmUgY29ubmVjdGluZyB0aGUgdHdvXG4gICAqIHZlY3RvcnMgLSBgYWxwaGEgPSAwYCB3aWxsIGJlIGB2MWAsIGFuZCBgYWxwaGEgPSAxYCB3aWxsIGJlIGB2MmAuXG4gICAqIEBtZXRob2QgbGVycFZlY3RvcnNcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdjEgVGhlIHN0YXJ0aW5nIHtAbGluayBWZWN0b3IzfS5cbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2MiB7QGxpbmsgVmVjdG9yM30gdG8gaW50ZXJwb2xhdGUgdG93YXJkcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIEludGVycG9sYXRpb24gZmFjdG9yIGluIHRoZSBjbG9zZWQgaW50ZXJ2YWwgYFswLCAxXWAuXG4gICAqL1xuICBsZXJwVmVjdG9ycyh2MSwgdjIsIGFscGhhKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViVmVjdG9ycyh2MiwgdjEpLm11bHRpcGx5U2NhbGFyKGFscGhhKS5hZGQodjEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IgdG9cbiAgICogW2Nyb3NzIHByb2R1Y3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nyb3NzX3Byb2R1Y3QpIG9mIGl0c2VsZiBhbmRcbiAgICogYHZgLlxuICAgKiBAbWV0aG9kIGNyb3NzXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICovXG4gIGNyb3NzKHYpIHtcbiAgICBjb25zdCB4ID0gdGhpcy5feDtcbiAgICBjb25zdCB5ID0gdGhpcy5feTtcbiAgICBjb25zdCB6ID0gdGhpcy5fejtcblxuICAgIHRoaXMuX3ggPSAoeSAqIHYueikgLSAoeiAqIHYueSk7XG4gICAgdGhpcy5feSA9ICh6ICogdi54KSAtICh4ICogdi56KTtcbiAgICB0aGlzLl96ID0gKHggKiB2LnkpIC0gKHkgKiB2LngpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyB2ZWN0b3IgdG9cbiAgICogW2Nyb3NzIHByb2R1Y3RdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Nyb3NzX3Byb2R1Y3QpIG9mIGBhYCBhbmRcbiAgICogYGJgLlxuICAgKiBAbWV0aG9kIGNyb3NzVmVjdG9yc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gYlxuICAgKi9cbiAgY3Jvc3NWZWN0b3JzKGEsIGIpIHtcbiAgICBjb25zdCBheCA9IGEueDtcbiAgICBjb25zdCBheSA9IGEueTtcbiAgICBjb25zdCBheiA9IGEuejtcbiAgICBjb25zdCBieCA9IGIueDtcbiAgICBjb25zdCBieSA9IGIueTtcbiAgICBjb25zdCBieiA9IGIuejtcblxuICAgIHRoaXMuX3ggPSAoYXkgKiBieikgLSAoYXogKiBieSk7XG4gICAgdGhpcy5feSA9IChheiAqIGJ4KSAtIChheCAqIGJ6KTtcbiAgICB0aGlzLl96ID0gKGF4ICogYnkpIC0gKGF5ICogYngpO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFtQcm9qZWN0c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmVjdG9yX3Byb2plY3Rpb24pIHRoaXMgdmVjdG9yXG4gICAqIG9udG8gYW5vdGhlciBgdmVjdG9yYC5cbiAgICogQG1ldGhvZCBwcm9qZWN0T25WZWN0b3JcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdmVjdG9yXG4gICAqL1xuICBwcm9qZWN0T25WZWN0b3IodmVjdG9yKSB7XG4gICAgY29uc3Qgc2NhbGFyID0gdmVjdG9yLmRvdCh0aGlzKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29weSh2ZWN0b3IpLm11bHRpcGx5U2NhbGFyKHNjYWxhcik7XG4gIH1cblxuICAvKipcbiAgICogW1Byb2plY3RzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZWN0b3JfcHJvamVjdGlvbikgdGhpcyB2ZWN0b3JcbiAgICogb250byBhIHBsYW5lIGJ5IHN1YnRyYWN0aW5nIHRoaXMgdmVjdG9yIHByb2plY3RlZCBvbnRvIHRoZSBwbGFuZSdzIG5vcm1hbFxuICAgKiBmcm9tIHRoaXMgdmVjdG9yLlxuICAgKiBAbWV0aG9kIHByb2plY3RPblBsYW5lXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHBsYW5lTm9ybWFsIEEgdmVjdG9yIHJlcHJlc2VudGluZyBhIHBsYW5lIG5vcm1hbC5cbiAgICovXG4gIHByb2plY3RPblBsYW5lKHBsYW5lTm9ybWFsKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0T25QbGFuZVYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcm9qZWN0T25QbGFuZVYgPSBuZXcgVmVjdG9yMygpO1xuICAgIH1cblxuICAgIHByb2plY3RPblBsYW5lVi5jb3B5KHRoaXMpLnByb2plY3RPblZlY3RvcihwbGFuZU5vcm1hbCk7XG4gICAgcmV0dXJuIHRoaXMuc3ViKHByb2plY3RPblBsYW5lVik7XG4gIH1cblxuICAvKipcbiAgICogUmVmbGVjdCB0aGUgdmVjdG9yIG9mZiBvZiBwbGFuZSBvcnRob2dvbmFsIHRvIGBub3JtYWxgLiBgbm9ybWFsYCBpc1xuICAgKiBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGguXG4gICAqIEBtZXRob2QgcmVmbGVjdFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSBub3JtYWwgVGhlIG5vcm1hbCB0byB0aGUgcmVmbGVjdGluZyBwbGFuZS5cbiAgICovXG4gIHJlZmxlY3Qobm9ybWFsKSB7XG4gICAgaWYgKHR5cGVvZiByZWZsZWN0ViA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlZmxlY3RWID0gbmV3IFZlY3RvcjMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdWIocmVmbGVjdFYuY29weShub3JtYWwpLm11bHRpcGx5U2NhbGFyKDIgKiB0aGlzLmRvdChub3JtYWwpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIHZlY3RvciBhbmQgdmVjdG9yIGB2YCBpbiByYWRpYW5zLlxuICAgKiBAbWV0aG9kIGFuZ2xlVG9cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhbmdsZVRvKHYpIHtcbiAgICBjb25zdCB0aGV0YSA9IHRoaXMuZG90KHYpIC8gKE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkgKiB2Lmxlbmd0aFNxKCkpKTtcbiAgICAvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuICAgIHJldHVybiBNYXRoLmFjb3MoY2xhbXAodGhldGEsIC0xLCAxKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhpcyB2ZWN0b3IgdG8gYHZgLlxuICAgKiBAbWV0aG9kIGRpc3RhbmNlVG9cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7VmVjdG9yM30gdlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBkaXN0YW5jZVRvKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhpcyB2ZWN0b3IgdG8gYHZgLiBJZiB5b3UgYXJlIGp1c3RcbiAgICogY29tcGFyaW5nIHRoZSBkaXN0YW5jZSB3aXRoIGFub3RoZXIgZGlzdGFuY2UsIHlvdSBzaG91bGQgY29tcGFyZSB0aGVcbiAgICogZGlzdGFuY2Ugc3F1YXJlZCBpbnN0ZWFkIGFzIGl0IGlzIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50IHRvIGNhbGN1bGF0ZS5cbiAgICogQG1ldGhvZCBkaXN0YW5jZVRvU3F1YXJlZFxuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtWZWN0b3IzfSB2XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGRpc3RhbmNlVG9TcXVhcmVkKHYpIHtcbiAgICBjb25zdCBkeCA9IHRoaXMuX3ggLSB2Lng7XG4gICAgY29uc3QgZHkgPSB0aGlzLl95IC0gdi55O1xuICAgIGNvbnN0IGR6ID0gdGhpcy5feiAtIHYuejtcbiAgICByZXR1cm4gKGR4ICogZHgpICsgKGR5ICogZHkpICsgKGR6ICogZHopO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZVxuICAgKiBbTWFuaGF0dGFuIGRpc3RhbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UYXhpY2FiX2dlb21ldHJ5KSBmcm9tXG4gICAqIHRoaXMgdmVjdG9yIHRvIGB2YC5cbiAgICogQG1ldGhvZCBkaXN0YW5jZVRvTWFuaGF0dGFuXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1ZlY3RvcjN9IHZcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZGlzdGFuY2VUb01hbmhhdHRhbih2KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuX3ggLSB2LngpICsgTWF0aC5hYnModGhpcy5feSAtIHYueSkgKyBNYXRoLmFicyh0aGlzLl96IC0gdi56KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB2ZWN0b3IgdG8gdGhlIHBvc2l0aW9uIGVsZW1lbnRzIG9mIHRoZVxuICAgKiBbdHJhbnNmb3JtIG1hdHJpeF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJhbnNmb3JtYXRpb25fbWF0cml4KVxuICAgKiBgbWAuXG4gICAqIEBtZXRob2Qgc2V0RnJvbU1hdHJpeFBvc2l0aW9uXG4gICAqIEBtZW1iZXJvZiBWZWN0b3IzLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge01hdHJpeDR9IG1cbiAgICovXG4gIHNldEZyb21NYXRyaXhQb3NpdGlvbihtKSB7XG4gICAgLy8gcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAzKTtcblxuICAgIGNvbnN0IGUgPSBtLmVsZW1lbnRzO1xuICAgIHRoaXMuX3ggPSBlWzEyXTtcbiAgICB0aGlzLl95ID0gZVsxM107XG4gICAgdGhpcy5feiA9IGVbMTRdO1xuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIHZlY3RvciB0byB0aGUgc2NhbGUgZWxlbWVudHMgb2YgdGhlXG4gICAqIFt0cmFuc2Zvcm0gbWF0cml4XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UcmFuc2Zvcm1hdGlvbl9tYXRyaXgpXG4gICAqIGBtYC5cbiAgICogQG1ldGhvZCBzZXRGcm9tTWF0cml4U2NhbGVcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKi9cbiAgc2V0RnJvbU1hdHJpeFNjYWxlKG0pIHtcbiAgICBjb25zdCBzeCA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAwKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAxKS5sZW5ndGgoKTtcbiAgICBjb25zdCBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbihtLCAyKS5sZW5ndGgoKTtcbiAgICB0aGlzLl94ID0gc3g7XG4gICAgdGhpcy5feSA9IHN5O1xuICAgIHRoaXMuX3ogPSBzejtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTsgLy8gVE9ETyByZWR1bmRhbnRcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0sIHtAbGluayBWZWN0b3IzI3l9LCBhbmRcbiAgICoge0BsaW5rIFZlY3RvcjMjen0gZXF1YWwgdG8gdGhlIGNvbHVtbiBvZiB0aGUgYG1hdHJpeGAgc3BlY2lmaWVkIGJ5IHRoZVxuICAgKiBgaW5kZXhgLlxuICAgKiBAbWV0aG9kIHNldEZyb21NYXRyaXhDb2x1bW5cbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TWF0cml4NH0gbVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIHNldEZyb21NYXRyaXhDb2x1bW4obSwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tQXJyYXkobS5lbGVtZW50cywgaW5kZXggKiA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIHN0cmljdCBlcXVhbGl0eSBvZiB0aGlzIHZlY3RvciBhbmQgYHZgLlxuICAgKiBAbWV0aG9kIGVxdWFsc1xuICAgKiBAbWVtYmVyb2YgVmVjdG9yMy5wcm90b3R5cGVcbiAgICogQHBhcmFtICB7VmVjdG9yM30gdlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKHYpIHtcbiAgICByZXR1cm4gKCh2LnggPT09IHRoaXMuX3gpICYmICh2LnkgPT09IHRoaXMuX3kpICYmICh2LnogPT09IHRoaXMuX3opKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdmVjdG9yJ3Mge0BsaW5rIFZlY3RvcjMjeH0gdmFsdWUgdG8gYmUgYGFycmF5WzAgKyBvZmZzZXRdYCxcbiAgICoge0BsaW5rIFZlY3RvcjMjeX0gdmFsdWUgdG8gYmUgYGFycmF5WzEgKyBvZmZzZXRdYCwge0BsaW5rIFZlY3RvcjMjen0gdmFsdWVcbiAgICogdG8gYmUgYGFycmF5WzIgKyBvZmZzZXRdYC5cbiAgICogQG1ldGhvZCBmcm9tQXJyYXlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge251bWJlcltdfSBhcnJheSAgVGhlIHNvdXJjZSBhcnJheS5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9mZnNldCBpbnRvIHRoZSBhcnJheS5cbiAgICovXG4gIGZyb21BcnJheShhcnJheSA9IFtdLCBvZmZzZXQgPSAwKSB7XG4gICAgdGhpcy5feCA9IGFycmF5W29mZnNldCArIDBdO1xuICAgIHRoaXMuX3kgPSBhcnJheVtvZmZzZXQgKyAxXTtcbiAgICB0aGlzLl96ID0gYXJyYXlbb2Zmc2V0ICsgMl07XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBgW3gsIHksIHpdYCwgb3IgY29waWVzIHtAbGluayBWZWN0b3IzI3h9LFxuICAgKiB7QGxpbmsgVmVjdG9yMyN5fSwgYW5kIHtAbGluayBWZWN0b3IzI3p9IHZhbHVlcyBpbnRvIHRoZSBwcm92aWRlZCBgYXJyYXlgLlxuICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICogQG1lbWJlcm9mIFZlY3RvcjMucHJvdG90eXBlXG4gICAqIEBwYXJhbSAge251bWJlcltdfSBbYXJyYXk9W11dIEFycmF5IHRvIHN0b3JlIHRoZSB2ZWN0b3IgdG8uIElmIHRoaXMgaXMgbm90IHByb3ZpZGVkIGEgbmV3IGFycmF5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb2Zmc2V0PTBdIE9wdGlvbmFsIG9mZnNldCBpbnRvIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAqL1xuICB0b0FycmF5KGFycmF5ID0gW10sIG9mZnNldCA9IDApIHtcbiAgICBhcnJheVtvZmZzZXQgKyAwXSA9IHRoaXMuX3g7XG4gICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSB0aGlzLl95O1xuICAgIGFycmF5W29mZnNldCArIDJdID0gdGhpcy5fejtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBvbkNoYW5nZShjYWxsYmFjaykge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25DaGFuZ2VDYWxsYmFjaygpIHt9XG59XG5cbiIsImltcG9ydCB7RXZlbnREYXRhT2JqZWN0fSBmcm9tICcuLi9jb3JlL0RhdGEnO1xuaW1wb3J0IHtpc05pbH0gZnJvbSAnLi4vVXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBoYW5kbGVycykge1xuICAgIGlmIChpc05pbChFdmVudERhdGFPYmplY3QuZ2V0VGFyZ2V0KHRhcmdldCkpKSB7XG4gICAgICBFdmVudERhdGFPYmplY3QuYWRkSGFuZGxlcih0YXJnZXQsIGhhbmRsZXJzKTtcbiAgICB9XG4gIH1cblxuICBzdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBFdmVudERhdGFPYmplY3QuZ2V0SGFuZGxlcih0YXJnZXQsIHR5cGUpO1xuXG4gICAgaWYgKGhhbmRsZXIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGhhbmRsZXIuYWRkKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHVuc3Vic2NyaWJlKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBoYW5kbGVyID0gRXZlbnREYXRhT2JqZWN0LmdldEhhbmRsZXIodGFyZ2V0LCB0eXBlKTtcblxuICAgIGlmIChoYW5kbGVyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBoYW5kbGVyLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnkodGFyZ2V0LCB0eXBlLCBhcmdzKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IEV2ZW50RGF0YU9iamVjdC5nZXRIYW5kbGVyKHRhcmdldCwgdHlwZSk7XG5cbiAgICBpZiAoaGFuZGxlciBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgaGFuZGxlci5mb3JFYWNoKCh2YWx1ZSkgPT4gdmFsdWUoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgT2JzZXJ2ZXIgZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IEVudGl0eUV2ZW50IGZyb20gJy4uLy4uL2VudGl0eS9FbnRpdHlFdmVudCc7XG5pbXBvcnQge0VOVElUWV9FVkVOVH0gZnJvbSAnLi4vLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuLy8gaW1wb3J0IE1hdHJpeDQgZnJvbSAnLi4vbWF0aC9NYXRyaXg0JztbXG5cbmNvbnN0IEVudGl0eVR5cGUgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgbWF0cml4OiBudWxsLFxuICBwaXhlbFNpemU6IHtcbiAgICB3aWR0aDogMC4wLFxuICAgIGhlaWdodDogMC4wLFxuICAgIGRlcHRoOiAwLjBcbiAgfSxcbiAgc2NhbGU6IDEuMFxufTtcblxuY29uc3QgaGFuZGxlcnMgPSBuZXcgTWFwKFxuICBbXG4gICAgW0VOVElUWV9FVkVOVC5UUkFDS19TVEFSVCwgbmV3IFNldCgpXSxcbiAgICBbRU5USVRZX0VWRU5ULlRSQUNLX01PVkUsIG5ldyBTZXQoKV0sXG4gICAgW0VOVElUWV9FVkVOVC5UUkFDS19FTkQsIG5ldyBTZXQoKV1cbiAgXSk7XG5jb25zdCB0YXJnZXQgPSBFTlRJVFlfRVZFTlQuVEFSR0VUO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRpdHlPYnNlcnZlciBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodGFyZ2V0LCBoYW5kbGVycyk7XG4gIH1cblxuICBzdWJzY3JpYmUodHlwZSwgY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuXG4gIH1cblxuICBub3RpZnkodHlwZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBFbnRpdHlFdmVudCkge1xuICAgICAgc3VwZXIubm90aWZ5KHRhcmdldCwgdHlwZSwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLlxuICAgIH1cblxuICB9XG59XG4iLCJpbXBvcnQgT2JzZXJ2ZXIgZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHtFTlRJVFlfRVZFTlQsIExFVFNFRV9FVkVOVH0gZnJvbSAnLi4vLi4vbGlicy9NZXNzYWdlVHlwZXMnO1xuXG5jb25zdCBoYW5kbGVycyA9IG5ldyBNYXAoW1xuICBbTEVUU0VFX0VWRU5ULk9OX0xPQUQsIG5ldyBTZXQoKV0sXG4gIFtMRVRTRUVfRVZFTlQuT05fU1RBVFVTLCBuZXcgU2V0KCldLFxuICBbTEVUU0VFX0VWRU5ULlJPVEFUSU9OX0NIQU5HRSwgbmV3IFNldCgpXSxcbiAgW0xFVFNFRV9FVkVOVC5UUkFDS19TVEFSVCwgbmV3IFNldCgpXSxcbiAgW0xFVFNFRV9FVkVOVC5UUkFDS19NT1ZFLCBuZXcgU2V0KCldLFxuICBbTEVUU0VFX0VWRU5ULlRSQUNLX0VORCwgbmV3IFNldCgpXVxuXSk7XG5jb25zdCB0YXJnZXQgPSBMRVRTRUVfRVZFTlQuVEFSR0VUO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMZXRzZWVPYnNlcnZlciBleHRlbmRzIE9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodGFyZ2V0LCBoYW5kbGVycyk7XG4gIH1cblxuICBzdWJzY3JpYmUodHlwZSwgY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgICBzdXBlci5zdWJzY3JpYmUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjaywgLi4uYXJncyk7XG4gIH1cblxuICB1bnN1YnNjcmliZSh0eXBlLCBjYWxsYmFjaykge1xuICAgIHN1cGVyLnVuc3Vic2NyaWJlKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuXG4gIH1cblxuICBub3RpZnkodHlwZSwgZXZlbnQpIHtcbiAgICBzdXBlci5ub3RpZnkodGFyZ2V0LCB0eXBlLCBldmVudCk7XG4gIH1cbn1cbiIsImltcG9ydCB7ZG9tUmVuZGVyZXJ9IGZyb20gJy4vRE9NUmVuZGVyZXInO1xuaW1wb3J0IE9iamVjdDNEIGZyb20gJy4uL2NvcmUvT2JqZWN0M0QnO1xuaW1wb3J0IHtFbnRpdHlEYXRhT2JqZWN0fSBmcm9tICcuLi9jb3JlL0RhdGEnO1xuaW1wb3J0IHtPQkpFQ1RfRVZFTlR9IGZyb20gJy4uL2xpYnMvTWVzc2FnZVR5cGVzJztcbmltcG9ydCB7aXNOdWxsfSBmcm9tICcuLi9VdGlsJztcbmltcG9ydCB7Y29udGV4dH0gZnJvbSAnLi4vQ29udGV4dCc7XG5cbmNvbnN0IF90eXBlID0gJ0RPTVJlbmRlcmFibGUnO1xuY29uc3QgX2lzRE9NUmVuZGVyYWJsZSA9IHRydWU7XG5sZXQgZ2hvc3RJZCA9IDA7XG5cbi8qKlxuICogQGNsYXNzIENsYXNzIHJlcHJlc2VudGluZyBhIEhUTUwgZWxlbWVudCB0aGF0IGNhbiBiZSBhdWdtZW50ZWQuXG4gKiBAbmFtZSBET01SZW5kZXJhYmxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gSFRNTCBFbGVtZW50XG4gKiBAcmV0dXJucyB7RE9NUmVuZGVyYWJsZX1cbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgSFRNTCBlbGVtZW50XG4gKiAvLyBIVE1MIOyXmOumrOuovO2KuOulvCDsg53shLHtlanri4jri6QuXG4gKiBjb25zdCBzYW1wbGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gKlxuICogLy8gb3IgZ2V0IGV4aXN0IGVsZW1lbnRcbiAqIC8vIOuYkO2VnCBET03sg4Hsl5Ag7KG07J6s7ZWY64qUIEhUTUwg7JeY66as66i87Yq466W8IOyCrOyaqe2VoCDsiJjrj4Qg7J6I7Iq164uI64ukLlxuICogY29uc3QgZXhpc3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbycpO1xuICpcbiAqIC8vIENyZWF0ZSBET00gUmVuZGVyYWJsZVxuICogLy8gRE9NIFJlbmRlcmFibGXsnYQg7IOd7ISx7ZWp64uI64ukLlxuICogY29uc3Qgc2FtcGxlUmVuZGVyYWJsZSA9IG5ldyBET01SZW5kZXJhYmxlKHNhbXBsZUVsZW1lbnQpO1xuICogY29uc3QgZXhpc3RSZW5kZXJhYmxlID0gbmV3IERPTVJlbmRlcmFibGUoZXhpc3RFbGVtZW50KTtcbiAqXG4gKiAvLyDsg53shLHtlZwgcmVuZGVyYWJsZeydhCDsl5TthLDti7Dsl5Ag65Ox66Gd7ZWp64uI64ukLlxuICogZW50aXR5LmFkZFJlbmRlcmFibGUoc2FtcGxlUmVuZGVyYWJsZSk7XG4gKiBlbnRpdHkuYWRkUmVuZGVyYWJsZShleGlzdFJlbmRlcmFibGUpO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01SZW5kZXJhYmxlIGV4dGVuZHMgT2JqZWN0M0Qge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvLyB0aGlzLnJlbmRlcmVyID0gbmV3IERPTVJlbmRlcmVyKCk7XG4gICAgaWYgKGlzTnVsbChlbGVtZW50LnBhcmVudEVsZW1lbnQpKSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250ZXh0LnBsYWNlaG9sZGVySWQpLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgY29uc3QgZ2hvc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBnaG9zdEVsZW1lbnQuaWQgPSBgZ2hvc3QtJHtnaG9zdElkfWA7XG4gICAgZ2hvc3RFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ25vbmUnLCAnaW1wb3J0YW50Jyk7XG4gICAgLy8gZ2hvc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSAhaW1wb3J0YW50J1xuXG4gICAgRW50aXR5RGF0YU9iamVjdC5hZGRFbGVtZW50KGVsZW1lbnQsIG5ldyBNYXAoXG4gICAgICBbXG4gICAgICAgIFsnb3JpZ2luYWwnLCBvcmlnaW5hbEVsZW1lbnRdLFxuICAgICAgICBbJ2dob3N0JywgZ2hvc3RFbGVtZW50XVxuICAgICAgXSkpO1xuICAgIGdob3N0SWQrKztcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICAgIHRoaXMuaXNBZGRlZFRvQ2FtZXJhID0gZmFsc2U7XG5cbiAgICAvLyB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2ZhY2VWaXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLldlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgdGhpcy5zdWJzY3JpYmUoT0JKRUNUX0VWRU5ULk9CSkVDVF9BRERFRCwgKGUpID0+IHtcbiAgICAgIGlmIChlLnRhcmdldC5pc0RPTVJlbmRlcmFibGUpIHRoaXMuYWRkZWQoZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN1YnNjcmliZShPQkpFQ1RfRVZFTlQuT0JKRUNUX1JFTU9WRUQsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuaXNET01SZW5kZXJhYmxlKSB0aGlzLnJlbW92ZWQoZSk7XG4gICAgfSk7XG4gIH1cblxuICBhZGRlZChlKSB7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnRyYWNrKSB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIGxldCBvYmplY3QgPSBlLnRhcmdldDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAob2JqZWN0LmlzU2NlbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWRkZWRUb0NhbWVyYSkge1xuICAgICAgICAgIGRvbVJlbmRlcmVyLmFwcGVuZEVsZW1lbnQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICB0aGlzLmlzQWRkZWRUb0NhbWVyYSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnBhcmVudCkge1xuICAgICAgICBvYmplY3QgPSBvYmplY3QucGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlZChlKSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpc0RPTVJlbmRlcmFibGUoKSB7XG4gICAgcmV0dXJuIF9pc0RPTVJlbmRlcmFibGU7XG4gIH07XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBfdHlwZTtcbiAgfVxufVxuXG4iLCJpbXBvcnQge2NvbnRleHR9IGZyb20gJy4uL0NvbnRleHQnO1xuaW1wb3J0IFNjZW5lIGZyb20gJy4uL2NvcmUvU2NlbmUnO1xuaW1wb3J0IHtkZWdUb1JhZH0gZnJvbSAnLi4vbWF0aC9NYXRoJztcbmltcG9ydCBFbnRpdHlPYnNlcnZlciBmcm9tICcuLi9vYnNlcnZlcnMvb2JzZXJ2ZXIvRW50aXR5T2JzZXJ2ZXInO1xuaW1wb3J0IHtFbnRpdHlEYXRhT2JqZWN0fSBmcm9tICcuLi9jb3JlL0RhdGEnO1xuXG5jb25zdCBlcHNpbG9uID0gKHZhbHVlKSA9PiBNYXRoLmFicyh2YWx1ZSkgPCAxZS0xMCA/IDAgOiB2YWx1ZTtcbmNvbnN0IGdldENhbWVyYUNTU01hdHJpeCA9IChjYW1lcmEpID0+IHtcbiAgY29uc3QgY2FtZXJhTWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5lbGVtZW50cy5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gMSB8fCBpbmRleCA9PT0gNSB8fCBpbmRleCA9PT0gOSB8fCBpbmRleCA9PT0gMTMpID8gZXBzaWxvbigtZWxlbWVudCkgOiBlcHNpbG9uKGVsZW1lbnQpO1xuICB9KTtcblxuICByZXR1cm4gYG1hdHJpeDNkKCR7Y2FtZXJhTWF0cml4LmpvaW4oJywnKX0pYDtcbn07XG5jb25zdCBnZXRPYmplY3RDU1NNYXRyaXggPSAocmVuZGVyYWJsZSkgPT4ge1xuICByZW5kZXJhYmxlLnVwZGF0ZU1hdHJpeCgpO1xuICBjb25zdCBvYmplY3RNYXRyaXggPSByZW5kZXJhYmxlLm1hdHJpeFdvcmxkLmVsZW1lbnRzLm1hcCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKGluZGV4ID49IDQgJiYgaW5kZXggPD0gNykgPyBlcHNpbG9uKC1lbGVtZW50KSA6IGVwc2lsb24oZWxlbWVudCk7XG4gIH0pO1xuXG4gIHJldHVybiBgdHJhbnNsYXRlKC01MCUsLTUwJSkgbWF0cml4M2QoJHtvYmplY3RNYXRyaXguam9pbignLCcpfSlgO1xufTtcblxubGV0IF9jYWNoZWRTdHlsZXM7XG5sZXQgX2NhbWVyYSA9IG51bGw7XG5cbmNvbnN0IF9zY2VuZSA9IG5ldyBTY2VuZSgpO1xuY29uc3QgX2RvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbmNvbnN0IF9jYW1lcmFFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbmNsYXNzIERPTVJlbmRlcmVyIGV4dGVuZHMgRW50aXR5T2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIF9jYWNoZWRTdHlsZXMgPSB7fTtcbiAgICBfZG9tRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLldlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBfZG9tRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgX2RvbUVsZW1lbnQuY2xhc3NOYW1lID0gJ2FyLXJlbmRlcmVyJztcbiAgICBfZG9tRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUudG9wID0gJzAnO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUubWFyZ2luID0gJzAnO1xuICAgIF9kb21FbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMCc7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUuekluZGV4ID0gJzExMCc7XG5cbiAgICBfY2FtZXJhRWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgX2NhbWVyYUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICAgIF9kb21FbGVtZW50LmFwcGVuZENoaWxkKF9jYW1lcmFFbGVtZW50KTtcblxuICAgIHRoaXMuc3Vic2NyaWJlKCd0cmFja21vdmUnLCAoZSkgPT4gdGhpcy5yZW5kZXIoZSkpO1xuICAgIHRoaXMuc3Vic2NyaWJlKCd0cmFja3N0YXJ0JywgKGUpID0+IHRoaXMucmVuZGVyKGUpKTtcbiAgICB0aGlzLnN1YnNjcmliZSgndHJhY2tlbmQnLCAoZSkgPT4gdGhpcy5yZW5kZXIoZSkpO1xuXG4gICAgdGhpcy5fd2lkdGggPSAwO1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gIH1cblxuICBpbml0UmVuZGVyZXIoY2FtZXJhLCBpZCwgekluZGV4LCB6SW5kZXhJbmNyZW1lbnQpIHtcbiAgICBfY2FtZXJhID0gY2FtZXJhO1xuICAgIHRoaXMud2lkdGggPSBjb250ZXh0LndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gY29udGV4dC5oZWlnaHQ7XG4gICAgdGhpcy5zZXRTaXplKCk7XG4gICAgX2RvbUVsZW1lbnQuaWQgPSBpZDtcbiAgICBfZG9tRWxlbWVudC5zdHlsZS56SW5kZXggPSB6SW5kZXggKyB6SW5kZXhJbmNyZW1lbnQ7XG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoX2RvbUVsZW1lbnQsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfVxuXG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH1cblxuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gIH1cblxuICBnZXQgc2NlbmUoKSB7XG4gICAgcmV0dXJuIF9zY2VuZTtcbiAgfVxuXG4gIHVwZGF0ZU9yaWVudGF0aW9uKG5ld0NvbmZpZykge1xuICAgIHRoaXMud2lkdGggPSBuZXdDb25maWcud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdDb25maWcuaGVpZ2h0O1xuICAgIHRoaXMuc2V0U2l6ZSgpO1xuICB9XG5cbiAgc2V0U2l6ZSgpIHtcbiAgICBfZG9tRWxlbWVudC5zdHlsZS53aWR0aCA9IF9jYW1lcmFFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7dGhpcy53aWR0aH1weGA7XG4gICAgX2RvbUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gX2NhbWVyYUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5oZWlnaHR9cHhgO1xuICB9XG5cbiAgYWRkKG9iamVjdCkge1xuICAgIF9zY2VuZS5hZGQob2JqZWN0KTtcbiAgfVxuXG4gIHJlbW92ZShvYmplY3QpIHtcbiAgICBfc2NlbmUucmVtb3ZlKG9iamVjdCk7XG4gIH1cblxuICBhcHBlbmRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoRW50aXR5RGF0YU9iamVjdC5nZXRFbGVtZW50KGVsZW1lbnQpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGdob3N0ID0gRW50aXR5RGF0YU9iamVjdC5nZXRFbGVtZW50KGVsZW1lbnQpLmdldCgnZ2hvc3QnKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0gRW50aXR5RGF0YU9iamVjdC5nZXRFbGVtZW50KGVsZW1lbnQpLmdldCgnb3JpZ2luYWwnKTtcblxuICAgICAgaWYgKG9yaWdpbmFsLnBhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChnaG9zdCwgZWxlbWVudCk7XG4gICAgICAgIF9jYW1lcmFFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luYWwucGFyZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQoZWxlbWVudCwgb3JpZ2luYWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFwcGVuZEFsbEVsZW1lbnRzKCkge1xuXG4gICAgRW50aXR5RGF0YU9iamVjdC5nZXRBbGxFbGVtZW50cygpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGdob3N0ID0gdmFsdWUuZ2V0KCdnaG9zdCcpO1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZS5nZXQoJ29yaWdpbmFsJyk7XG5cbiAgICAgIG9yaWdpbmFsLnBhcmVudEVsZW1lbnQucmVwbGFjZUNoaWxkKGdob3N0LCBvcmlnaW5hbCk7XG4gICAgICBfY2FtZXJhRWxlbWVudC5hcHBlbmRDaGlsZChrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVzZXRFbGVtZW50KCkge1xuICAgIEVudGl0eURhdGFPYmplY3QuZ2V0QWxsRWxlbWVudHMoKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBjb25zdCBnaG9zdCA9IHZhbHVlLmdldCgnZ2hvc3QnKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0gdmFsdWUuZ2V0KCdvcmlnaW5hbCcpO1xuXG4gICAgICBnaG9zdC5wYXJlbnRFbGVtZW50LnJlcGxhY2VDaGlsZChvcmlnaW5hbCwgZ2hvc3QpO1xuICAgICAgX2NhbWVyYUVsZW1lbnQucmVtb3ZlQ2hpbGQoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIF9jYW1lcmFFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgb25UcmFja01vdmUoZSkge31cbiAgb25UcmFja1N0YXJ0KGUpIHt9XG4gIG9uVHJhY2tFbmQoZSkge31cblxuICByZW5kZXIoZSkge1xuICAgIGlmIChfY2FtZXJhKSB7XG4gICAgICBjb25zdCBmb3YgPSAwLjUgLyBNYXRoLnRhbihkZWdUb1JhZChfY2FtZXJhLmdldEVmZmVjdGl2ZUZPVigpICogMC41KSkgKiB0aGlzLmhlaWdodDtcbiAgICAgIGNvbnN0IGNhbWVyYUNTU01hdHJpeCA9IGB0cmFuc2xhdGVaKCR7Zm92fXB4KSR7Z2V0Q2FtZXJhQ1NTTWF0cml4KF9jYW1lcmEpfWA7XG4gICAgICBjb25zdCBjYW1lcmFUcmFuc2Zvcm0gPSBgJHtjYW1lcmFDU1NNYXRyaXh9dHJhbnNsYXRlKCR7dGhpcy53aWR0aCAqIDAuNX1weCwke3RoaXMuaGVpZ2h0ICogMC41fXB4KWA7XG5cbiAgICAgIF9kb21FbGVtZW50LnN0eWxlLldlYmtpdFBlcnNwZWN0aXZlID0gYCR7Zm92fXB4YDtcbiAgICAgIF9kb21FbGVtZW50LnN0eWxlLnBlcnNwZWN0aXZlID0gYCR7Zm92fXB4YDtcbiAgICAgIF9jYW1lcmFFbGVtZW50LnN0eWxlLldlYmtpdFRyYW5zZm9ybSA9IGNhbWVyYVRyYW5zZm9ybTtcbiAgICAgIF9jYW1lcmFFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGNhbWVyYVRyYW5zZm9ybTtcblxuICAgICAgdGhpcy5zZXRTaXplKCk7XG4gICAgICBfc2NlbmUudHJhdmVyc2UoKG9iaikgPT4ge1xuICAgICAgICBpZiAob2JqLmVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gb2JqLmVsZW1lbnQ7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRPYmplY3RDU1NNYXRyaXgob2JqKTtcbiAgICAgICAgICBjb25zdCBjYWNoZWRTdHlsZSA9IF9jYWNoZWRTdHlsZXNbb2JqLmlkXTtcblxuICAgICAgICAgIGlmIChjYWNoZWRTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGNhY2hlZFN0eWxlICE9PSBzdHlsZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSBzdHlsZTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gc3R5bGU7XG4gICAgICAgICAgICBfY2FjaGVkU3R5bGVzW29iai5pZF0gPSBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZG9tUmVuZGVyZXIgPSBuZXcgRE9NUmVuZGVyZXIoKTtcbiIsIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLmFkYXB0ZXIgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hZGFwdGVyX2ZhY3RvcnkgPSByZXF1aXJlKCcuL2FkYXB0ZXJfZmFjdG9yeS5qcycpO1xuXG52YXIgYWRhcHRlciA9ICgwLCBfYWRhcHRlcl9mYWN0b3J5LmFkYXB0ZXJGYWN0b3J5KSh7IHdpbmRvdzogd2luZG93IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBhZGFwdGVyOyAvLyB0aGlzIGlzIHRoZSBkaWZmZXJlbmNlIGZyb20gYWRhcHRlcl9jb3JlLlxuXG59LHtcIi4vYWRhcHRlcl9mYWN0b3J5LmpzXCI6Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGFwdGVyRmFjdG9yeSA9IGFkYXB0ZXJGYWN0b3J5O1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG52YXIgX2Nocm9tZV9zaGltID0gcmVxdWlyZSgnLi9jaHJvbWUvY2hyb21lX3NoaW0nKTtcblxudmFyIGNocm9tZVNoaW0gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY2hyb21lX3NoaW0pO1xuXG52YXIgX2VkZ2Vfc2hpbSA9IHJlcXVpcmUoJy4vZWRnZS9lZGdlX3NoaW0nKTtcblxudmFyIGVkZ2VTaGltID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2VkZ2Vfc2hpbSk7XG5cbnZhciBfZmlyZWZveF9zaGltID0gcmVxdWlyZSgnLi9maXJlZm94L2ZpcmVmb3hfc2hpbScpO1xuXG52YXIgZmlyZWZveFNoaW0gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfZmlyZWZveF9zaGltKTtcblxudmFyIF9zYWZhcmlfc2hpbSA9IHJlcXVpcmUoJy4vc2FmYXJpL3NhZmFyaV9zaGltJyk7XG5cbnZhciBzYWZhcmlTaGltID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3NhZmFyaV9zaGltKTtcblxudmFyIF9jb21tb25fc2hpbSA9IHJlcXVpcmUoJy4vY29tbW9uX3NoaW0nKTtcblxudmFyIGNvbW1vblNoaW0gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29tbW9uX3NoaW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuZnVuY3Rpb24gYWRhcHRlckZhY3RvcnkoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHdpbmRvdyA9IF9yZWYud2luZG93O1xuXG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgc2hpbUNocm9tZTogdHJ1ZSxcbiAgICBzaGltRmlyZWZveDogdHJ1ZSxcbiAgICBzaGltRWRnZTogdHJ1ZSxcbiAgICBzaGltU2FmYXJpOiB0cnVlXG4gIH07XG5cbiAgLy8gVXRpbHMuXG4gIHZhciBsb2dnaW5nID0gdXRpbHMubG9nO1xuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG5cbiAgdmFyIGFkYXB0ZXIgPSB7XG4gICAgYnJvd3NlckRldGFpbHM6IGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW06IGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IHV0aWxzLmV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IHV0aWxzLmRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiB1dGlscy5kaXNhYmxlV2FybmluZ3NcbiAgfTtcblxuICAvLyBTaGltIGJyb3dzZXIgaWYgZm91bmQuXG4gIHN3aXRjaCAoYnJvd3NlckRldGFpbHMuYnJvd3Nlcikge1xuICAgIGNhc2UgJ2Nocm9tZSc6XG4gICAgICBpZiAoIWNocm9tZVNoaW0gfHwgIWNocm9tZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uIHx8ICFvcHRpb25zLnNoaW1DaHJvbWUpIHtcbiAgICAgICAgbG9nZ2luZygnQ2hyb21lIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgY2hyb21lLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBjaHJvbWVTaGltO1xuXG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGNocm9tZVNoaW0uc2hpbU1lZGlhU3RyZWFtKHdpbmRvdyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltT25UcmFjayh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdyk7XG4gICAgICBjaHJvbWVTaGltLnNoaW1HZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5zaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgY2hyb21lU2hpbS5maXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3cpO1xuXG4gICAgICBjb21tb25TaGltLnNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVBbGxvd0V4dG1hcE1peGVkKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmaXJlZm94JzpcbiAgICAgIGlmICghZmlyZWZveFNoaW0gfHwgIWZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbiB8fCAhb3B0aW9ucy5zaGltRmlyZWZveCkge1xuICAgICAgICBsb2dnaW5nKCdGaXJlZm94IHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgZmlyZWZveC4nKTtcbiAgICAgIC8vIEV4cG9ydCB0byB0aGUgYWRhcHRlciBnbG9iYWwgb2JqZWN0IHZpc2libGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgICBhZGFwdGVyLmJyb3dzZXJTaGltID0gZmlyZWZveFNoaW07XG5cbiAgICAgIGZpcmVmb3hTaGltLnNoaW1HZXRVc2VyTWVkaWEod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbU9uVHJhY2sod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SZW1vdmVTdHJlYW0od2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1TZW5kZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpO1xuICAgICAgZmlyZWZveFNoaW0uc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBmaXJlZm94U2hpbS5zaGltQ3JlYXRlT2ZmZXIod2luZG93KTtcbiAgICAgIGZpcmVmb3hTaGltLnNoaW1DcmVhdGVBbnN3ZXIod2luZG93KTtcblxuICAgICAgY29tbW9uU2hpbS5zaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdyk7XG4gICAgICBjb21tb25TaGltLnNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VkZ2UnOlxuICAgICAgaWYgKCFlZGdlU2hpbSB8fCAhZWRnZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uIHx8ICFvcHRpb25zLnNoaW1FZGdlKSB7XG4gICAgICAgIGxvZ2dpbmcoJ01TIGVkZ2Ugc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBlZGdlLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBlZGdlU2hpbTtcblxuICAgICAgZWRnZVNoaW0uc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpO1xuICAgICAgZWRnZVNoaW0uc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3cpO1xuICAgICAgZWRnZVNoaW0uc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdyk7XG4gICAgICBlZGdlU2hpbS5zaGltUmVwbGFjZVRyYWNrKHdpbmRvdyk7XG5cbiAgICAgIC8vIHRoZSBlZGdlIHNoaW0gaW1wbGVtZW50cyB0aGUgZnVsbCBSVENJY2VDYW5kaWRhdGUgb2JqZWN0LlxuXG4gICAgICBjb21tb25TaGltLnNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzYWZhcmknOlxuICAgICAgaWYgKCFzYWZhcmlTaGltIHx8ICFvcHRpb25zLnNoaW1TYWZhcmkpIHtcbiAgICAgICAgbG9nZ2luZygnU2FmYXJpIHNoaW0gaXMgbm90IGluY2x1ZGVkIGluIHRoaXMgYWRhcHRlciByZWxlYXNlLicpO1xuICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgIH1cbiAgICAgIGxvZ2dpbmcoJ2FkYXB0ZXIuanMgc2hpbW1pbmcgc2FmYXJpLicpO1xuICAgICAgLy8gRXhwb3J0IHRvIHRoZSBhZGFwdGVyIGdsb2JhbCBvYmplY3QgdmlzaWJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgIGFkYXB0ZXIuYnJvd3NlclNoaW0gPSBzYWZhcmlTaGltO1xuXG4gICAgICBzYWZhcmlTaGltLnNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltQ2FsbGJhY2tzQVBJKHdpbmRvdyk7XG4gICAgICBzYWZhcmlTaGltLnNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNhZmFyaVNoaW0uc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpO1xuICAgICAgc2FmYXJpU2hpbS5zaGltR2V0VXNlck1lZGlhKHdpbmRvdyk7XG5cbiAgICAgIGNvbW1vblNoaW0uc2hpbVJUQ0ljZUNhbmRpZGF0ZSh3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5zaGltTWF4TWVzc2FnZVNpemUod2luZG93KTtcbiAgICAgIGNvbW1vblNoaW0uc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgY29tbW9uU2hpbS5yZW1vdmVBbGxvd0V4dG1hcE1peGVkKHdpbmRvdyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbG9nZ2luZygnVW5zdXBwb3J0ZWQgYnJvd3NlciEnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8vIEJyb3dzZXIgc2hpbXMuXG5cbn0se1wiLi9jaHJvbWUvY2hyb21lX3NoaW1cIjozLFwiLi9jb21tb25fc2hpbVwiOjYsXCIuL2VkZ2UvZWRnZV9zaGltXCI6MTIsXCIuL2ZpcmVmb3gvZmlyZWZveF9zaGltXCI6NyxcIi4vc2FmYXJpL3NhZmFyaV9zaGltXCI6MTAsXCIuL3V0aWxzXCI6MTF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2hpbUdldERpc3BsYXlNZWRpYSA9IGV4cG9ydHMuc2hpbUdldFVzZXJNZWRpYSA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2dldHVzZXJtZWRpYSA9IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldFVzZXJNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXR1c2VybWVkaWEuc2hpbUdldFVzZXJNZWRpYTtcbiAgfVxufSk7XG5cbnZhciBfZ2V0ZGlzcGxheW1lZGlhID0gcmVxdWlyZSgnLi9nZXRkaXNwbGF5bWVkaWEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGltR2V0RGlzcGxheU1lZGlhJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldGRpc3BsYXltZWRpYS5zaGltR2V0RGlzcGxheU1lZGlhO1xuICB9XG59KTtcbmV4cG9ydHMuc2hpbU1lZGlhU3RyZWFtID0gc2hpbU1lZGlhU3RyZWFtO1xuZXhwb3J0cy5zaGltT25UcmFjayA9IHNoaW1PblRyYWNrO1xuZXhwb3J0cy5zaGltR2V0U2VuZGVyc1dpdGhEdG1mID0gc2hpbUdldFNlbmRlcnNXaXRoRHRtZjtcbmV4cG9ydHMuc2hpbUdldFN0YXRzID0gc2hpbUdldFN0YXRzO1xuZXhwb3J0cy5zaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyA9IHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzO1xuZXhwb3J0cy5zaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUgPSBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmU7XG5leHBvcnRzLnNoaW1BZGRUcmFja1JlbW92ZVRyYWNrID0gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2s7XG5leHBvcnRzLnNoaW1QZWVyQ29ubmVjdGlvbiA9IHNoaW1QZWVyQ29ubmVjdGlvbjtcbmV4cG9ydHMuZml4TmVnb3RpYXRpb25OZWVkZWQgPSBmaXhOZWdvdGlhdGlvbk5lZWRlZDtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpIHtcbiAgd2luZG93Lk1lZGlhU3RyZWFtID0gd2luZG93Lk1lZGlhU3RyZWFtIHx8IHdpbmRvdy53ZWJraXRNZWRpYVN0cmVhbTtcbn1cblxuZnVuY3Rpb24gc2hpbU9uVHJhY2sod2luZG93KSB7XG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb250cmFjaztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChmKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbnRyYWNrID0gZik7XG4gICAgICB9LFxuXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl9vbnRyYWNrcG9seSkge1xuICAgICAgICB0aGlzLl9vbnRyYWNrcG9seSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cbiAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGZ1bmN0aW9uICh0ZSkge1xuICAgICAgICAgICAgdmFyIHJlY2VpdmVyID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gX3RoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRyYWNrICYmIHIudHJhY2suaWQgPT09IHRlLnRyYWNrLmlkO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0geyB0cmFjazogdGUudHJhY2sgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0ZS50cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHsgcmVjZWl2ZXI6IHJlY2VpdmVyIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBfdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdHJhY2suaWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7IHRyYWNrOiB0cmFjayB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCd0cmFjaycpO1xuICAgICAgICAgICAgZXZlbnQudHJhY2sgPSB0cmFjaztcbiAgICAgICAgICAgIGV2ZW50LnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgICAgICBldmVudC50cmFuc2NlaXZlciA9IHsgcmVjZWl2ZXI6IHJlY2VpdmVyIH07XG4gICAgICAgICAgICBldmVudC5zdHJlYW1zID0gW2Uuc3RyZWFtXTtcbiAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHN0cmVhbScsIHRoaXMuX29udHJhY2twb2x5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGV2ZW4gaWYgUlRDUnRwVHJhbnNjZWl2ZXIgaXMgaW4gd2luZG93LCBpdCBpcyBvbmx5IHVzZWQgYW5kXG4gICAgLy8gZW1pdHRlZCBpbiB1bmlmaWVkLXBsYW4uIFVuZm9ydHVuYXRlbHkgdGhpcyBtZWFucyB3ZSBuZWVkXG4gICAgLy8gdG8gdW5jb25kaXRpb25hbGx5IHdyYXAgdGhlIGV2ZW50LlxuICAgIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZS50cmFuc2NlaXZlcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ3RyYW5zY2VpdmVyJywgeyB2YWx1ZTogeyByZWNlaXZlcjogZS5yZWNlaXZlciB9IH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbUdldFNlbmRlcnNXaXRoRHRtZih3aW5kb3cpIHtcbiAgLy8gT3ZlcnJpZGVzIGFkZFRyYWNrL3JlbW92ZVRyYWNrLCBkZXBlbmRzIG9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrLlxuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICB2YXIgc2hpbVNlbmRlcldpdGhEdG1mID0gZnVuY3Rpb24gc2hpbVNlbmRlcldpdGhEdG1mKHBjLCB0cmFjaykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxuICAgICAgICBnZXQgZHRtZigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gcGMuY3JlYXRlRFRNRlNlbmRlcih0cmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9kdG1mID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2R0bWY7XG4gICAgICAgIH0sXG4gICAgICAgIF9wYzogcGNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGF1Z21lbnQgYWRkVHJhY2sgd2hlbiBnZXRTZW5kZXJzIGlzIG5vdCBhdmFpbGFibGUuXG4gICAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZGVycy5zbGljZSgpOyAvLyByZXR1cm4gYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS5cbiAgICAgIH07XG4gICAgICB2YXIgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgIHZhciBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgX3RoaXMyLl9zZW5kZXJzLnB1c2goc2hpbVNlbmRlcldpdGhEdG1mKF90aGlzMiwgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ1JlbW92ZVN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG5cbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB2YXIgc2VuZGVyID0gX3RoaXMzLl9zZW5kZXJzLmZpbmQoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy50cmFjayA9PT0gdHJhY2s7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHNlbmRlclxuICAgICAgICAgIF90aGlzMy5fc2VuZGVycy5zcGxpY2UoX3RoaXMzLl9zZW5kZXJzLmluZGV4T2Yoc2VuZGVyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICB2YXIgb3JpZ0dldFNlbmRlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnM7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgIHJldHVybiBzZW5kZXIuX3BjID0gX3RoaXM0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlLCAnZHRtZicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHRoaXMuX3BjLmNyZWF0ZURUTUZTZW5kZXIodGhpcy50cmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIHZhciBfYXJndW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgc2VsZWN0b3IgPSBfYXJndW1lbnRzWzBdLFxuICAgICAgICBvblN1Y2MgPSBfYXJndW1lbnRzWzFdLFxuICAgICAgICBvbkVyciA9IF9hcmd1bWVudHNbMl07XG5cbiAgICAvLyBJZiBzZWxlY3RvciBpcyBhIGZ1bmN0aW9uIHRoZW4gd2UgYXJlIGluIHRoZSBvbGQgc3R5bGUgc3RhdHMgc28ganVzdFxuICAgIC8vIHBhc3MgYmFjayB0aGUgb3JpZ2luYWwgZ2V0U3RhdHMgZm9ybWF0IHRvIGF2b2lkIGJyZWFraW5nIG9sZCB1c2Vycy5cblxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG9yaWdHZXRTdGF0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gc3BlYy1zdHlsZSBnZXRTdGF0cyBpcyBzdXBwb3J0ZWQsIHJldHVybiB0aG9zZSB3aGVuIGNhbGxlZCB3aXRoXG4gICAgLy8gZWl0aGVyIG5vIGFyZ3VtZW50cyBvciB0aGUgc2VsZWN0b3IgYXJndW1lbnQgaXMgbnVsbC5cbiAgICBpZiAob3JpZ0dldFN0YXRzLmxlbmd0aCA9PT0gMCAmJiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICB9XG5cbiAgICB2YXIgZml4Q2hyb21lU3RhdHNfID0gZnVuY3Rpb24gZml4Q2hyb21lU3RhdHNfKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgc3RhbmRhcmRSZXBvcnQgPSB7fTtcbiAgICAgIHZhciByZXBvcnRzID0gcmVzcG9uc2UucmVzdWx0KCk7XG4gICAgICByZXBvcnRzLmZvckVhY2goZnVuY3Rpb24gKHJlcG9ydCkge1xuICAgICAgICB2YXIgc3RhbmRhcmRTdGF0cyA9IHtcbiAgICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogcmVwb3J0LnRpbWVzdGFtcCxcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgICAgICAgICByZW1vdGVjYW5kaWRhdGU6ICdyZW1vdGUtY2FuZGlkYXRlJ1xuICAgICAgICAgIH1bcmVwb3J0LnR5cGVdIHx8IHJlcG9ydC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlcG9ydC5uYW1lcygpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICBzdGFuZGFyZFN0YXRzW25hbWVdID0gcmVwb3J0LnN0YXQobmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGFuZGFyZFJlcG9ydFtzdGFuZGFyZFN0YXRzLmlkXSA9IHN0YW5kYXJkU3RhdHM7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHN0YW5kYXJkUmVwb3J0O1xuICAgIH07XG5cbiAgICAvLyBzaGltIGdldFN0YXRzIHdpdGggbWFwbGlrZSBzdXBwb3J0XG4gICAgdmFyIG1ha2VNYXBTdGF0cyA9IGZ1bmN0aW9uIG1ha2VNYXBTdGF0cyhzdGF0cykge1xuICAgICAgcmV0dXJuIG5ldyBNYXAoT2JqZWN0LmtleXMoc3RhdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBba2V5LCBzdGF0c1trZXldXTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFja1dyYXBwZXJfID0gZnVuY3Rpb24gc3VjY2Vzc0NhbGxiYWNrV3JhcHBlcl8ocmVzcG9uc2UpIHtcbiAgICAgICAgb25TdWNjKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gb3JpZ0dldFN0YXRzLmFwcGx5KHRoaXMsIFtzdWNjZXNzQ2FsbGJhY2tXcmFwcGVyXywgc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICAvLyBwcm9taXNlLXN1cHBvcnRcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgb3JpZ0dldFN0YXRzLmFwcGx5KF90aGlzNSwgW2Z1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNvbHZlKG1ha2VNYXBTdGF0cyhmaXhDaHJvbWVTdGF0c18ocmVzcG9uc2UpKSk7XG4gICAgICB9LCByZWplY3RdKTtcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBzZW5kZXIgc3RhdHMuXG4gIGlmICghKCdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpKSB7XG4gICAgdmFyIG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICAgIGlmIChvcmlnR2V0U2VuZGVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbmRlci5fcGMgPSBfdGhpczY7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICB2YXIgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbmRlci5fcGMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfTtcbiAgICB9XG4gICAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIHZhciBzZW5kZXIgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyogTm90ZTogdGhpcyB3aWxsIGluY2x1ZGUgc3RhdHMgb2YgYWxsIHNlbmRlcnMgdGhhdFxuICAgICAgICAgICAqICAgc2VuZCBhIHRyYWNrIHdpdGggdGhlIHNhbWUgaWQgYXMgc2VuZGVyLnRyYWNrIGFzXG4gICAgICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB1dGlscy5maWx0ZXJTdGF0cyhyZXN1bHQsIHNlbmRlci50cmFjaywgdHJ1ZSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvLyBzaGltIHJlY2VpdmVyIHN0YXRzLlxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUpKSB7XG4gICAgdmFyIG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgICAgcmVjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLl9wYyA9IF90aGlzNztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWNlaXZlcnM7XG4gICAgICB9O1xuICAgIH1cbiAgICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIHZhciByZWNlaXZlciA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgdmFyIG9yaWdHZXRTdGF0cyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgIHZhciB0cmFjayA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBzZW5kZXIgPSB2b2lkIDA7XG4gICAgICB2YXIgcmVjZWl2ZXIgPSB2b2lkIDA7XG4gICAgICB2YXIgZXJyID0gdm9pZCAwO1xuICAgICAgdGhpcy5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICBpZiAocy50cmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kZXIgPSBzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFJlY2VpdmVycygpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCBzZW5kZXIgJiYgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdykge1xuICAvLyBzaGltIGFkZFRyYWNrL3JlbW92ZVRyYWNrIHdpdGggbmF0aXZlIHZhcmlhbnRzIGluIG9yZGVyIHRvIG1ha2VcbiAgLy8gdGhlIGludGVyYWN0aW9ucyB3aXRoIGxlZ2FjeSBnZXRMb2NhbFN0cmVhbXMgYmVoYXZlIGFzIGluIG90aGVyIGJyb3dzZXJzLlxuICAvLyBLZWVwcyBhIG1hcHBpbmcgc3RyZWFtLmlkID0+IFtzdHJlYW0sIHJ0cHNlbmRlcnMuLi5dXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyA9IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLm1hcChmdW5jdGlvbiAoc3RyZWFtSWQpIHtcbiAgICAgIHJldHVybiBfdGhpczguX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBvcmlnQWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICByZXR1cm4gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuXG4gICAgdmFyIHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0gPSBbc3RyZWFtLCBzZW5kZXJdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdLmluZGV4T2Yoc2VuZGVyKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5wdXNoKHNlbmRlcik7XG4gICAgfVxuICAgIHJldHVybiBzZW5kZXI7XG4gIH07XG5cbiAgdmFyIG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbiBhZGRTdHJlYW0oc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcblxuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgdmFyIGFscmVhZHlFeGlzdHMgPSBfdGhpczkuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgbmV3U2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbHRlcihmdW5jdGlvbiAobmV3U2VuZGVyKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdTZW5kZXJzLmluZGV4T2YobmV3U2VuZGVyKSA9PT0gLTE7XG4gICAgfSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuXG4gIHZhciBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICB2YXIgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGlmIChzZW5kZXIpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbUlkKSB7XG4gICAgICAgIHZhciBpZHggPSBfdGhpczEwLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgX3RoaXMxMC5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMTAuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczEwLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2sod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBicm93c2VyRGV0YWlscyA9IHV0aWxzLmRldGVjdEJyb3dzZXIod2luZG93KTtcbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIHZhciBvcmlnR2V0TG9jYWxTdHJlYW1zID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXM7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgIHZhciBuYXRpdmVTdHJlYW1zID0gb3JpZ0dldExvY2FsU3RyZWFtcy5hcHBseSh0aGlzKTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIHJldHVybiBuYXRpdmVTdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gX3RoaXMxMS5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgb3JpZ0FkZFN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG5cbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuXG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICB2YXIgYWxyZWFkeUV4aXN0cyA9IF90aGlzMTIuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGlkZW50aXR5IG1hcHBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggYWRkVHJhY2suXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICB2YXIgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShzdHJlYW0uZ2V0VHJhY2tzKCkpO1xuICAgICAgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID0gbmV3U3RyZWFtO1xuICAgICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbbmV3U3RyZWFtLmlkXSA9IHN0cmVhbTtcbiAgICAgIHN0cmVhbSA9IG5ld1N0cmVhbTtcbiAgICB9XG4gICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gIH07XG5cbiAgdmFyIG9yaWdSZW1vdmVTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcblxuICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW1dKTtcbiAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID8gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICB9O1xuXG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8ICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQoZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ID09PSB0cmFjaztcbiAgICB9KSkge1xuICAgICAgLy8gdGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCBidXQgYWxsIHdlIGNhbiBtYW5hZ2Ugd2l0aG91dFxuICAgICAgLy8gW1thc3NvY2lhdGVkIE1lZGlhU3RyZWFtc11dIGludGVybmFsIHNsb3QuXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgYWRhcHRlci5qcyBhZGRUcmFjayBwb2x5ZmlsbCBvbmx5IHN1cHBvcnRzIGEgc2luZ2xlICcgKyAnIHN0cmVhbSB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCB0cmFjay4nLCAnTm90U3VwcG9ydGVkRXJyb3InKTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLnRyYWNrID09PSB0cmFjaztcbiAgICB9KTtcbiAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgdmFyIG9sZFN0cmVhbSA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXTtcbiAgICBpZiAob2xkU3RyZWFtKSB7XG4gICAgICAvLyB0aGlzIGlzIHVzaW5nIG9kZCBDaHJvbWUgYmVoYXZpb3VyLCB1c2Ugd2l0aCBjYXV0aW9uOlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTc4MTVcbiAgICAgIC8vIE5vdGU6IHdlIHJlbHkgb24gdGhlIGhpZ2gtbGV2ZWwgYWRkVHJhY2svZHRtZiBzaGltIHRvXG4gICAgICAvLyBjcmVhdGUgdGhlIHNlbmRlciB3aXRoIGEgZHRtZiBzZW5kZXIuXG4gICAgICBvbGRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuXG4gICAgICAvLyBUcmlnZ2VyIE9OTiBhc3luYy5cbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczEzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCduZWdvdGlhdGlvbm5lZWRlZCcpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3U3RyZWFtID0gbmV3IHdpbmRvdy5NZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgIHRoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSA9IG5ld1N0cmVhbTtcbiAgICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zW25ld1N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgICB0aGlzLmFkZFN0cmVhbShuZXdTdHJlYW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTZW5kZXJzKCkuZmluZChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIHJlcGxhY2UgdGhlIGludGVybmFsIHN0cmVhbSBpZCB3aXRoIHRoZSBleHRlcm5hbCBvbmUgYW5kXG4gIC8vIHZpY2UgdmVyc2EuXG4gIGZ1bmN0aW9uIHJlcGxhY2VJbnRlcm5hbFN0cmVhbUlkKHBjLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBzZHAgPSBkZXNjcmlwdGlvbi5zZHA7XG4gICAgT2JqZWN0LmtleXMocGMuX3JldmVyc2VTdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcm5hbElkKSB7XG4gICAgICB2YXIgZXh0ZXJuYWxTdHJlYW0gPSBwYy5fcmV2ZXJzZVN0cmVhbXNbaW50ZXJuYWxJZF07XG4gICAgICB2YXIgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGludGVybmFsU3RyZWFtLmlkLCAnZycpLCBleHRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcDogc2RwXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVwbGFjZUV4dGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGludGVybmFsSWQpIHtcbiAgICAgIHZhciBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIHZhciBpbnRlcm5hbFN0cmVhbSA9IHBjLl9zdHJlYW1zW2V4dGVybmFsU3RyZWFtLmlkXTtcbiAgICAgIHNkcCA9IHNkcC5yZXBsYWNlKG5ldyBSZWdFeHAoZXh0ZXJuYWxTdHJlYW0uaWQsICdnJyksIGludGVybmFsU3RyZWFtLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiBkZXNjcmlwdGlvbi50eXBlLFxuICAgICAgc2RwOiBzZHBcbiAgICB9KTtcbiAgfVxuICBbJ2NyZWF0ZU9mZmVyJywgJ2NyZWF0ZUFuc3dlciddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHZhciBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgdmFyIG1ldGhvZE9iaiA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgbWV0aG9kLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG5cbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGlzTGVnYWN5Q2FsbCA9IGFyZ3VtZW50cy5sZW5ndGggJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChfdGhpczE0LCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGFyZ3VtZW50c1syXV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZChfdGhpczE0LCBkZXNjcmlwdGlvbik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBtZXRob2RPYmpbbWV0aG9kXTtcbiAgfSk7XG5cbiAgdmFyIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCAhYXJndW1lbnRzWzBdLnR5cGUpIHtcbiAgICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhcmd1bWVudHNbMF0gPSByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZCh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgIHJldHVybiBvcmlnU2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIFRPRE86IG1hbmdsZSBnZXRTdGF0czogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1zdGF0cy8jZG9tLXJ0Y21lZGlhc3RyZWFtc3RhdHMtc3RyZWFtaWRlbnRpZmllclxuXG4gIHZhciBvcmlnTG9jYWxEZXNjcmlwdGlvbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ2xvY2FsRGVzY3JpcHRpb24nKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGRlc2NyaXB0aW9uID0gb3JpZ0xvY2FsRGVzY3JpcHRpb24uZ2V0LmFwcGx5KHRoaXMpO1xuICAgICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBsYWNlSW50ZXJuYWxTdHJlYW1JZCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9KTtcblxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgUlRDUGVlckNvbm5lY3Rpb25cXCdzIHNpZ25hbGluZ1N0YXRlIGlzIFxcJ2Nsb3NlZFxcJy4nLCAnSW52YWxpZFN0YXRlRXJyb3InKTtcbiAgICB9XG4gICAgLy8gV2UgY2FuIG5vdCB5ZXQgY2hlY2sgZm9yIHNlbmRlciBpbnN0YW5jZW9mIFJUQ1J0cFNlbmRlclxuICAgIC8vIHNpbmNlIHdlIHNoaW0gUlRQU2VuZGVyLiBTbyB3ZSBjaGVjayBpZiBzZW5kZXIuX3BjIGlzIHNldC5cbiAgICBpZiAoIXNlbmRlci5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FyZ3VtZW50IDEgb2YgUlRDUGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2sgJyArICdkb2VzIG5vdCBpbXBsZW1lbnQgaW50ZXJmYWNlIFJUQ1J0cFNlbmRlci4nLCAnVHlwZUVycm9yJyk7XG4gICAgfVxuICAgIHZhciBpc0xvY2FsID0gc2VuZGVyLl9wYyA9PT0gdGhpcztcbiAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1NlbmRlciB3YXMgbm90IGNyZWF0ZWQgYnkgdGhpcyBjb25uZWN0aW9uLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuYXRpdmUgc3RyZWFtIHRoZSBzZW5kZXJzIHRyYWNrIGJlbG9uZ3MgdG8uXG4gICAgdGhpcy5fc3RyZWFtcyA9IHRoaXMuX3N0cmVhbXMgfHwge307XG4gICAgdmFyIHN0cmVhbSA9IHZvaWQgMDtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdHJlYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW1pZCkge1xuICAgICAgdmFyIGhhc1RyYWNrID0gX3RoaXMxNS5fc3RyZWFtc1tzdHJlYW1pZF0uZ2V0VHJhY2tzKCkuZmluZChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHNlbmRlci50cmFjayA9PT0gdHJhY2s7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNUcmFjaykge1xuICAgICAgICBzdHJlYW0gPSBfdGhpczE1Ll9zdHJlYW1zW3N0cmVhbWlkXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgdHJhY2sgb2YgdGhlIHN0cmVhbSwgcmVtb3ZlIHRoZSBzdHJlYW0uIFRoaXNcbiAgICAgICAgLy8gdGFrZXMgY2FyZSBvZiBhbnkgc2hpbW1lZCBfc2VuZGVycy5cbiAgICAgICAgdGhpcy5yZW1vdmVTdHJlYW0odGhpcy5fcmV2ZXJzZVN0cmVhbXNbc3RyZWFtLmlkXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBzYW1lIG9kZCBjaHJvbWUgYmVoYXZpb3VyIGFzIGFib3ZlLlxuICAgICAgICBzdHJlYW0ucmVtb3ZlVHJhY2soc2VuZGVyLnRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdykge1xuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG5cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2hpbSBpbXBsaWNpdCBjcmVhdGlvbiBvZiBSVENTZXNzaW9uRGVzY3JpcHRpb24vUlRDSWNlQ2FuZGlkYXRlXG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgICAgdmFyIG1ldGhvZE9iaiA9IF9kZWZpbmVQcm9wZXJ0eSh7fSwgbWV0aG9kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3VwcG9ydCBmb3IgYWRkSWNlQ2FuZGlkYXRlKG51bGwgb3IgdW5kZWZpbmVkKVxuICB2YXIgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGU7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLy8gRmlyZWZveCA2OCsgZW1pdHMgYW5kIHByb2Nlc3NlcyB7Y2FuZGlkYXRlOiBcIlwiLCAuLi59LCBpZ25vcmVcbiAgICAvLyBpbiBvbGRlciB2ZXJzaW9ucy4gTmF0aXZlIHN1cHBvcnQgcGxhbm5lZCBmb3IgQ2hyb21lIE03Ny5cbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4ICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpeE5lZ290aWF0aW9uTmVlZGVkKHdpbmRvdykge1xuICB1dGlscy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKHBjLnNpZ25hbGluZ1N0YXRlICE9PSAnc3RhYmxlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbn0se1wiLi4vdXRpbHMuanNcIjoxMSxcIi4vZ2V0ZGlzcGxheW1lZGlhXCI6NCxcIi4vZ2V0dXNlcm1lZGlhXCI6NX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoaW1HZXREaXNwbGF5TWVkaWEgPSBzaGltR2V0RGlzcGxheU1lZGlhO1xuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIGdldFNvdXJjZUlkKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGdldFNvdXJjZUlkIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aFxuICAvLyB0aGUgc291cmNlSWQgb2YgdGhlIHNjcmVlbi93aW5kb3cvdGFiIHRvIGJlIHNoYXJlZC5cbiAgaWYgKHR5cGVvZiBnZXRTb3VyY2VJZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ3NoaW1HZXREaXNwbGF5TWVkaWE6IGdldFNvdXJjZUlkIGFyZ3VtZW50IGlzIG5vdCAnICsgJ2EgZnVuY3Rpb24nKTtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0RGlzcGxheU1lZGlhID0gZnVuY3Rpb24gZ2V0RGlzcGxheU1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUlkKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChzb3VyY2VJZCkge1xuICAgICAgdmFyIHdpZHRoU3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiYgY29uc3RyYWludHMudmlkZW8ud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0U3BlY2lmaWVkID0gY29uc3RyYWludHMudmlkZW8gJiYgY29uc3RyYWludHMudmlkZW8uaGVpZ2h0O1xuICAgICAgdmFyIGZyYW1lUmF0ZVNwZWNpZmllZCA9IGNvbnN0cmFpbnRzLnZpZGVvICYmIGNvbnN0cmFpbnRzLnZpZGVvLmZyYW1lUmF0ZTtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0ge1xuICAgICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgICBjaHJvbWVNZWRpYVNvdXJjZTogJ2Rlc2t0b3AnLFxuICAgICAgICAgIGNocm9tZU1lZGlhU291cmNlSWQ6IHNvdXJjZUlkLFxuICAgICAgICAgIG1heEZyYW1lUmF0ZTogZnJhbWVSYXRlU3BlY2lmaWVkIHx8IDNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh3aWR0aFNwZWNpZmllZCkge1xuICAgICAgICBjb25zdHJhaW50cy52aWRlby5tYW5kYXRvcnkubWF4V2lkdGggPSB3aWR0aFNwZWNpZmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRTcGVjaWZpZWQpIHtcbiAgICAgICAgY29uc3RyYWludHMudmlkZW8ubWFuZGF0b3J5Lm1heEhlaWdodCA9IGhlaWdodFNwZWNpZmllZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9O1xufVxuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltR2V0VXNlck1lZGlhID0gc2hpbUdldFVzZXJNZWRpYTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzLmpzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbnZhciBsb2dnaW5nID0gdXRpbHMubG9nO1xuXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICB2YXIgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIHZhciBjb25zdHJhaW50c1RvQ2hyb21lXyA9IGZ1bmN0aW9uIGNvbnN0cmFpbnRzVG9DaHJvbWVfKGMpIHtcbiAgICBpZiAoKHR5cGVvZiBjID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjKSkgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICB2YXIgY2MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByID0gX3R5cGVvZihjW2tleV0pID09PSAnb2JqZWN0JyA/IGNba2V5XSA6IHsgaWRlYWw6IGNba2V5XSB9O1xuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgci5taW4gPSByLm1heCA9IHIuZXhhY3Q7XG4gICAgICB9XG4gICAgICB2YXIgb2xkbmFtZV8gPSBmdW5jdGlvbiBvbGRuYW1lXyhwcmVmaXgsIG5hbWUpIHtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2RldmljZUlkJyA/ICdzb3VyY2VJZCcgOiBuYW1lO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmlkZWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2Mub3B0aW9uYWwgPSBjYy5vcHRpb25hbCB8fCBbXTtcbiAgICAgICAgdmFyIG9jID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygci5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnbWluJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICAgIG9jID0ge307XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21heCcsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvY1tvbGRuYW1lXygnJywga2V5KV0gPSByLmlkZWFsO1xuICAgICAgICAgIGNjLm9wdGlvbmFsLnB1c2gob2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoci5leGFjdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiByLmV4YWN0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXygnJywga2V5KV0gPSByLmV4YWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWydtaW4nLCAnbWF4J10uZm9yRWFjaChmdW5jdGlvbiAobWl4KSB7XG4gICAgICAgICAgaWYgKHJbbWl4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnkgPSBjYy5tYW5kYXRvcnkgfHwge307XG4gICAgICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8obWl4LCBrZXkpXSA9IHJbbWl4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjLmFkdmFuY2VkKSB7XG4gICAgICBjYy5vcHRpb25hbCA9IChjYy5vcHRpb25hbCB8fCBbXSkuY29uY2F0KGMuYWR2YW5jZWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG4gIH07XG5cbiAgdmFyIHNoaW1Db25zdHJhaW50c18gPSBmdW5jdGlvbiBzaGltQ29uc3RyYWludHNfKGNvbnN0cmFpbnRzLCBmdW5jKSB7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjEpIHtcbiAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgaWYgKGNvbnN0cmFpbnRzICYmIF90eXBlb2YoY29uc3RyYWludHMuYXVkaW8pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHJlbWFwID0gZnVuY3Rpb24gcmVtYXAob2JqLCBhLCBiKSB7XG4gICAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgICBkZWxldGUgb2JqW2FdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3RyYWludHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ2F1dG9HYWluQ29udHJvbCcsICdnb29nQXV0b0dhaW5Db250cm9sJyk7XG4gICAgICByZW1hcChjb25zdHJhaW50cy5hdWRpbywgJ25vaXNlU3VwcHJlc3Npb24nLCAnZ29vZ05vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgIGNvbnN0cmFpbnRzLmF1ZGlvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMuYXVkaW8pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMgJiYgX3R5cGVvZihjb25zdHJhaW50cy52aWRlbykgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxuICAgICAgdmFyIGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKCh0eXBlb2YgZmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZmFjZSkpID09PSAnb2JqZWN0JyA/IGZhY2UgOiB7IGlkZWFsOiBmYWNlIH0pO1xuICAgICAgdmFyIGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuXG4gICAgICBpZiAoZmFjZSAmJiAoZmFjZS5leGFjdCA9PT0gJ3VzZXInIHx8IGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpICYmICEobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkuZmFjaW5nTW9kZSAmJiAhZ2V0U3VwcG9ydGVkRmFjaW5nTW9kZUxpZXMpKSB7XG4gICAgICAgIGRlbGV0ZSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGZhY2UuZXhhY3QgPT09ICdlbnZpcm9ubWVudCcgfHwgZmFjZS5pZGVhbCA9PT0gJ2Vudmlyb25tZW50Jykge1xuICAgICAgICAgIG1hdGNoZXMgPSBbJ2JhY2snLCAncmVhciddO1xuICAgICAgICB9IGVsc2UgaWYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAndXNlcicpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydmcm9udCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgLy8gTG9vayBmb3IgbWF0Y2hlcyBpbiBsYWJlbCwgb3IgdXNlIGxhc3QgY2FtIGZvciBiYWNrICh0eXBpY2FsKS5cbiAgICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuICAgICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkLmtpbmQgPT09ICd2aWRlb2lucHV0JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRldiA9IGRldmljZXMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5zb21lKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMobWF0Y2gpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkZXYgJiYgZGV2aWNlcy5sZW5ndGggJiYgbWF0Y2hlcy5pbmNsdWRlcygnYmFjaycpKSB7XG4gICAgICAgICAgICAgIGRldiA9IGRldmljZXNbZGV2aWNlcy5sZW5ndGggLSAxXTsgLy8gbW9yZSBsaWtlbHkgdGhlIGJhY2sgY2FtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2KSB7XG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkID0gZmFjZS5leGFjdCA/IHsgZXhhY3Q6IGRldi5kZXZpY2VJZCB9IDogeyBpZGVhbDogZGV2LmRldmljZUlkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdHJhaW50cy52aWRlbyA9IGNvbnN0cmFpbnRzVG9DaHJvbWVfKGNvbnN0cmFpbnRzLnZpZGVvKTtcbiAgICAgICAgICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgIH1cbiAgICBsb2dnaW5nKCdjaHJvbWU6ICcgKyBKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgfTtcblxuICB2YXIgc2hpbUVycm9yXyA9IGZ1bmN0aW9uIHNoaW1FcnJvcl8oZSkge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDY0KSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgUGVybWlzc2lvbkRlbmllZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgUGVybWlzc2lvbkRpc21pc3NlZEVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgSW52YWxpZFN0YXRlRXJyb3I6ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBEZXZpY2VzTm90Rm91bmRFcnJvcjogJ05vdEZvdW5kRXJyb3InLFxuICAgICAgICBDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3I6ICdPdmVyY29uc3RyYWluZWRFcnJvcicsXG4gICAgICAgIFRyYWNrU3RhcnRFcnJvcjogJ05vdFJlYWRhYmxlRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBNZWRpYURldmljZUtpbGxTd2l0Y2hPbjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFRhYkNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InLFxuICAgICAgICBTY3JlZW5DYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgRGV2aWNlQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcidcbiAgICAgIH1bZS5uYW1lXSB8fCBlLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICBjb25zdHJhaW50OiBlLmNvbnN0cmFpbnQgfHwgZS5jb25zdHJhaW50TmFtZSxcbiAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYV8oY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIHNoaW1Db25zdHJhaW50c18oY29uc3RyYWludHMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKHNoaW1FcnJvcl8oZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYV8uYmluZChuYXZpZ2F0b3IpO1xuXG4gIC8vIEV2ZW4gdGhvdWdoIENocm9tZSA0NSBoYXMgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyBhbmQgYSBnZXRVc2VyTWVkaWFcbiAgLy8gZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGl0IGRvZXMgbm90IGFjY2VwdCBzcGVjLXN0eWxlXG4gIC8vIGNvbnN0cmFpbnRzLlxuICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICB2YXIgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gb3JpZ0dldFVzZXJNZWRpYShjKS50aGVuKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8IGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignJywgJ05vdEZvdW5kRXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc2hpbUVycm9yXyhlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuXG59LHtcIi4uL3V0aWxzLmpzXCI6MTF9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltUlRDSWNlQ2FuZGlkYXRlID0gc2hpbVJUQ0ljZUNhbmRpZGF0ZTtcbmV4cG9ydHMuc2hpbU1heE1lc3NhZ2VTaXplID0gc2hpbU1heE1lc3NhZ2VTaXplO1xuZXhwb3J0cy5zaGltU2VuZFRocm93VHlwZUVycm9yID0gc2hpbVNlbmRUaHJvd1R5cGVFcnJvcjtcbmV4cG9ydHMuc2hpbUNvbm5lY3Rpb25TdGF0ZSA9IHNoaW1Db25uZWN0aW9uU3RhdGU7XG5leHBvcnRzLnJlbW92ZUFsbG93RXh0bWFwTWl4ZWQgPSByZW1vdmVBbGxvd0V4dG1hcE1peGVkO1xuXG52YXIgX3NkcCA9IHJlcXVpcmUoJ3NkcCcpO1xuXG52YXIgX3NkcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZHApO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdykge1xuICAvLyBmb3VuZGF0aW9uIGlzIGFyYml0cmFyaWx5IGNob3NlbiBhcyBhbiBpbmRpY2F0b3IgZm9yIGZ1bGwgc3VwcG9ydCBmb3JcbiAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYnJ0Yy1wYy8jcnRjaWNlY2FuZGlkYXRlLWludGVyZmFjZVxuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAnZm91bmRhdGlvbicgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZTtcbiAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIFJUQ0ljZUNhbmRpZGF0ZShhcmdzKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBhPSB3aGljaCBzaG91bGRuJ3QgYmUgcGFydCBvZiB0aGUgY2FuZGlkYXRlIHN0cmluZy5cbiAgICBpZiAoKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhcmdzKSkgPT09ICdvYmplY3QnICYmIGFyZ3MuY2FuZGlkYXRlICYmIGFyZ3MuY2FuZGlkYXRlLmluZGV4T2YoJ2E9JykgPT09IDApIHtcbiAgICAgIGFyZ3MgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcbiAgICAgIGFyZ3MuY2FuZGlkYXRlID0gYXJncy5jYW5kaWRhdGUuc3Vic3RyKDIpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIHZhciBuYXRpdmVDYW5kaWRhdGUgPSBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICAgICAgdmFyIHBhcnNlZENhbmRpZGF0ZSA9IF9zZHAyLmRlZmF1bHQucGFyc2VDYW5kaWRhdGUoYXJncy5jYW5kaWRhdGUpO1xuICAgICAgdmFyIGF1Z21lbnRlZENhbmRpZGF0ZSA9IE9iamVjdC5hc3NpZ24obmF0aXZlQ2FuZGlkYXRlLCBwYXJzZWRDYW5kaWRhdGUpO1xuXG4gICAgICAvLyBBZGQgYSBzZXJpYWxpemVyIHRoYXQgZG9lcyBub3Qgc2VyaWFsaXplIHRoZSBleHRyYSBhdHRyaWJ1dGVzLlxuICAgICAgYXVnbWVudGVkQ2FuZGlkYXRlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5kaWRhdGU6IGF1Z21lbnRlZENhbmRpZGF0ZS5jYW5kaWRhdGUsXG4gICAgICAgICAgc2RwTWlkOiBhdWdtZW50ZWRDYW5kaWRhdGUuc2RwTWlkLFxuICAgICAgICAgIHNkcE1MaW5lSW5kZXg6IGF1Z21lbnRlZENhbmRpZGF0ZS5zZHBNTGluZUluZGV4LFxuICAgICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IGF1Z21lbnRlZENhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF1Z21lbnRlZENhbmRpZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gIH07XG4gIHdpbmRvdy5SVENJY2VDYW5kaWRhdGUucHJvdG90eXBlID0gTmF0aXZlUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZTtcblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHV0aWxzLndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2NhbmRpZGF0ZScsIHtcbiAgICAgICAgdmFsdWU6IG5ldyB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlKGUuY2FuZGlkYXRlKSxcbiAgICAgICAgd3JpdGFibGU6ICdmYWxzZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIGlmICghKCdzY3RwJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnc2N0cCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc2N0cEluRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzY3RwSW5EZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc2VjdGlvbnMgPSBfc2RwMi5kZWZhdWx0LnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIHZhciBtTGluZSA9IF9zZHAyLmRlZmF1bHQucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgcmV0dXJuIG1MaW5lICYmIG1MaW5lLmtpbmQgPT09ICdhcHBsaWNhdGlvbicgJiYgbUxpbmUucHJvdG9jb2wuaW5kZXhPZignU0NUUCcpICE9PSAtMTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ2V0UmVtb3RlRmlyZWZveFZlcnNpb24gPSBmdW5jdGlvbiBnZXRSZW1vdGVGaXJlZm94VmVyc2lvbihkZXNjcmlwdGlvbikge1xuICAgIC8vIFRPRE86IElzIHRoZXJlIGEgYmV0dGVyIHNvbHV0aW9uIGZvciBkZXRlY3RpbmcgRmlyZWZveD9cbiAgICB2YXIgbWF0Y2ggPSBkZXNjcmlwdGlvbi5zZHAubWF0Y2goL21vemlsbGEuLi5USElTX0lTX1NEUEFSVEEtKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgdmFyIHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG5cbiAgdmFyIGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIHZhciBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuXG4gIHZhciBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIGdldE1heE1lc3NhZ2VTaXplKGRlc2NyaXB0aW9uLCByZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBOb3RlOiA2NTUzNiBieXRlcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBTRFAgc3BlYy4gQWxzbyxcbiAgICAvLyAgICAgICBldmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IHN1cHBvcnRzIHJlY2VpdmluZyA2NTUzNiBieXRlcy5cbiAgICB2YXIgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcblxuICAgIC8vIEZGIDU3IGhhcyBhIHNsaWdodGx5IGluY29ycmVjdCBkZWZhdWx0IHJlbW90ZSBtYXggbWVzc2FnZSBzaXplLCBzb1xuICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IGl0IGhlcmUgdG8gYXZvaWQgYSBmYWlsdXJlIHdoZW4gc2VuZGluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MjU2OTdcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPT09IDU3KSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDY1NTM1O1xuICAgIH1cblxuICAgIHZhciBtYXRjaCA9IF9zZHAyLmRlZmF1bHQubWF0Y2hQcmVmaXgoZGVzY3JpcHRpb24uc2RwLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cigxOSksIDEwKTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiByZW1vdGVJc0ZpcmVmb3ggIT09IC0xKSB7XG4gICAgICAvLyBJZiB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgaXMgbm90IHByZXNlbnQgaW4gdGhlIHJlbW90ZSBTRFAgYW5kXG4gICAgICAvLyBib3RoIGxvY2FsIGFuZCByZW1vdGUgYXJlIEZpcmVmb3gsIHRoZSByZW1vdGUgcGVlciBjYW4gcmVjZWl2ZVxuICAgICAgLy8gfjIgR2lCLlxuICAgICAgbWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgIH1cbiAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gIH07XG5cbiAgdmFyIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSBmdW5jdGlvbiBzZXRSZW1vdGVEZXNjcmlwdGlvbigpIHtcbiAgICB0aGlzLl9zY3RwID0gbnVsbDtcbiAgICAvLyBDaHJvbWUgZGVjaWRlZCB0byBub3QgZXhwb3NlIC5zY3RwIGluIHBsYW4tYiBtb2RlLlxuICAgIC8vIEFzIHVzdWFsLCBhZGFwdGVyLmpzIGhhcyB0byBkbyBhbiAndWdseSB3b3Jha2Fyb3VuZCdcbiAgICAvLyB0byBjb3ZlciB1cCB0aGUgbWVzcy5cbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3Nikge1xuICAgICAgdmFyIF9nZXRDb25maWd1cmF0aW9uID0gdGhpcy5nZXRDb25maWd1cmF0aW9uKCksXG4gICAgICAgICAgc2RwU2VtYW50aWNzID0gX2dldENvbmZpZ3VyYXRpb24uc2RwU2VtYW50aWNzO1xuXG4gICAgICBpZiAoc2RwU2VtYW50aWNzID09PSAncGxhbi1iJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjdHAnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3NjdHAgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHRoaXMuX3NjdHA7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY3RwSW5EZXNjcmlwdGlvbihhcmd1bWVudHNbMF0pKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVtb3RlIGlzIEZGLlxuICAgICAgdmFyIGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICB2YXIgY2FuU2VuZE1NUyA9IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZShpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBHZXQgdGhlIG1heGltdW0gbWVzc2FnZSBzaXplIG9mIHRoZSByZW1vdGUgcGVlci5cbiAgICAgIHZhciByZW1vdGVNTVMgPSBnZXRNYXhNZXNzYWdlU2l6ZShhcmd1bWVudHNbMF0sIGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIERldGVybWluZSBmaW5hbCBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZVxuICAgICAgdmFyIG1heE1lc3NhZ2VTaXplID0gdm9pZCAwO1xuICAgICAgaWYgKGNhblNlbmRNTVMgPT09IDAgJiYgcmVtb3RlTU1TID09PSAwKSB7XG4gICAgICAgIG1heE1lc3NhZ2VTaXplID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgfSBlbHNlIGlmIChjYW5TZW5kTU1TID09PSAwIHx8IHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWF4KGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE1hdGgubWluKGNhblNlbmRNTVMsIHJlbW90ZU1NUyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IFJUQ1NjdHBUcmFuc3BvcnQgb2JqZWN0IGFuZCB0aGUgJ21heE1lc3NhZ2VTaXplJ1xuICAgICAgLy8gYXR0cmlidXRlLlxuICAgICAgdmFyIHNjdHAgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9zY3RwID0gc2N0cDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgdmFyIG9yaWdEYXRhQ2hhbm5lbFNlbmQgPSBkYy5zZW5kO1xuICAgIGRjLnNlbmQgPSBmdW5jdGlvbiBzZW5kKCkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICB2YXIgb3JpZ0NyZWF0ZURhdGFDaGFubmVsID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbDtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVEYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uIGNyZWF0ZURhdGFDaGFubmVsKCkge1xuICAgIHZhciBkYXRhQ2hhbm5lbCA9IG9yaWdDcmVhdGVEYXRhQ2hhbm5lbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHdyYXBEY1NlbmQoZGF0YUNoYW5uZWwsIHRoaXMpO1xuICAgIHJldHVybiBkYXRhQ2hhbm5lbDtcbiAgfTtcbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAnZGF0YWNoYW5uZWwnLCBmdW5jdGlvbiAoZSkge1xuICAgIHdyYXBEY1NlbmQoZS5jaGFubmVsLCBlLnRhcmdldCk7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG4vKiBzaGltcyBSVENDb25uZWN0aW9uU3RhdGUgYnkgcHJldGVuZGluZyBpdCBpcyB0aGUgc2FtZSBhcyBpY2VDb25uZWN0aW9uU3RhdGUuXG4gKiBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3dlYnJ0Yy9pc3N1ZXMvZGV0YWlsP2lkPTYxNDUjYzEyXG4gKiBmb3Igd2h5IHRoaXMgaXMgYSB2YWxpZCBoYWNrIGluIENocm9tZS4gSW4gRmlyZWZveCBpdCBpcyBzbGlnaHRseSBpbmNvcnJlY3RcbiAqIHNpbmNlIERUTFMgZmFpbHVyZXMgd291bGQgYmUgaGlkZGVuLiBTZWVcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNjU4MjdcbiAqIGZvciB0aGUgRmlyZWZveCB0cmFja2luZyBidWcuXG4gKi9cbmZ1bmN0aW9uIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8ICdjb25uZWN0aW9uU3RhdGUnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnY29ubmVjdGlvblN0YXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGVkOiAnY29ubmVjdGVkJyxcbiAgICAgICAgY2hlY2tpbmc6ICdjb25uZWN0aW5nJ1xuICAgICAgfVt0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZV0gfHwgdGhpcy5pY2VDb25uZWN0aW9uU3RhdGU7XG4gICAgfSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSB8fCBudWxsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoY2IpIHtcbiAgICAgIGlmICh0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBjYik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbiddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHZhciBvcmlnTWV0aG9kID0gcHJvdG9bbWV0aG9kXTtcbiAgICBwcm90b1ttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZXBvbHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBwYyA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmIChwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSAhPT0gcGMuY29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICBwYy5fbGFzdENvbm5lY3Rpb25TdGF0ZSA9IHBjLmNvbm5lY3Rpb25TdGF0ZTtcbiAgICAgICAgICAgIHZhciBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGxvd0V4dG1hcE1peGVkKHdpbmRvdykge1xuICAvKiByZW1vdmUgYT1leHRtYXAtYWxsb3ctbWl4ZWQgZm9yIENocm9tZSA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDcxKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYXRpdmVTUkQgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmIChkZXNjICYmIGRlc2Muc2RwICYmIGRlc2Muc2RwLmluZGV4T2YoJ1xcbmE9ZXh0bWFwLWFsbG93LW1peGVkJykgIT09IC0xKSB7XG4gICAgICBkZXNjLnNkcCA9IGRlc2Muc2RwLnNwbGl0KCdcXG4nKS5maWx0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxufSx7XCIuL3V0aWxzXCI6MTEsXCJzZHBcIjoxM31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc2hpbUdldERpc3BsYXlNZWRpYSA9IGV4cG9ydHMuc2hpbUdldFVzZXJNZWRpYSA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2dldHVzZXJtZWRpYSA9IHJlcXVpcmUoJy4vZ2V0dXNlcm1lZGlhJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnc2hpbUdldFVzZXJNZWRpYScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9nZXR1c2VybWVkaWEuc2hpbUdldFVzZXJNZWRpYTtcbiAgfVxufSk7XG5cbnZhciBfZ2V0ZGlzcGxheW1lZGlhID0gcmVxdWlyZSgnLi9nZXRkaXNwbGF5bWVkaWEnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdzaGltR2V0RGlzcGxheU1lZGlhJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2dldGRpc3BsYXltZWRpYS5zaGltR2V0RGlzcGxheU1lZGlhO1xuICB9XG59KTtcbmV4cG9ydHMuc2hpbU9uVHJhY2sgPSBzaGltT25UcmFjaztcbmV4cG9ydHMuc2hpbVBlZXJDb25uZWN0aW9uID0gc2hpbVBlZXJDb25uZWN0aW9uO1xuZXhwb3J0cy5zaGltU2VuZGVyR2V0U3RhdHMgPSBzaGltU2VuZGVyR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1SZWNlaXZlckdldFN0YXRzID0gc2hpbVJlY2VpdmVyR2V0U3RhdHM7XG5leHBvcnRzLnNoaW1SZW1vdmVTdHJlYW0gPSBzaGltUmVtb3ZlU3RyZWFtO1xuZXhwb3J0cy5zaGltUlRDRGF0YUNoYW5uZWwgPSBzaGltUlRDRGF0YUNoYW5uZWw7XG5leHBvcnRzLnNoaW1BZGRUcmFuc2NlaXZlciA9IHNoaW1BZGRUcmFuc2NlaXZlcjtcbmV4cG9ydHMuc2hpbUNyZWF0ZU9mZmVyID0gc2hpbUNyZWF0ZU9mZmVyO1xuZXhwb3J0cy5zaGltQ3JlYXRlQW5zd2VyID0gc2hpbUNyZWF0ZUFuc3dlcjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciB1dGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF91dGlscyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDVHJhY2tFdmVudCAmJiAncmVjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSAmJiAhKCd0cmFuc2NlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUsICd0cmFuc2NlaXZlcicsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4geyByZWNlaXZlcjogdGhpcy5yZWNlaXZlciB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1QZWVyQ29ubmVjdGlvbih3aW5kb3cpIHtcbiAgdmFyIGJyb3dzZXJEZXRhaWxzID0gdXRpbHMuZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuXG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIC8vIHNoaW0gYXdheSBuZWVkIGZvciBvYnNvbGV0ZSBSVENJY2VDYW5kaWRhdGUvUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLlxuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIHZhciBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICB2YXIgbWV0aG9kT2JqID0gX2RlZmluZVByb3BlcnR5KHt9LCBtZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdXBwb3J0IGZvciBhZGRJY2VDYW5kaWRhdGUobnVsbCBvciB1bmRlZmluZWQpXG4gIC8vIGFzIHdlbGwgYXMgaWdub3Jpbmcge3NkcE1pZCwgY2FuZGlkYXRlOiBcIlwifVxuICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY4KSB7XG4gICAgdmFyIG5hdGl2ZUFkZEljZUNhbmRpZGF0ZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gYWRkSWNlQ2FuZGlkYXRlKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgIGFyZ3VtZW50c1sxXS5hcHBseShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICAvLyBGaXJlZm94IDY4KyBlbWl0cyBhbmQgcHJvY2Vzc2VzIHtjYW5kaWRhdGU6IFwiXCIsIC4uLn0sIGlnbm9yZVxuICAgICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgICBpZiAoYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1swXS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVBZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIG1vZGVyblN0YXRzVHlwZXMgPSB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfTtcblxuICB2YXIgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgdmFyIF9hcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzZWxlY3RvciA9IF9hcmd1bWVudHNbMF0sXG4gICAgICAgIG9uU3VjYyA9IF9hcmd1bWVudHNbMV0sXG4gICAgICAgIG9uRXJyID0gX2FyZ3VtZW50c1syXTtcblxuICAgIHJldHVybiBuYXRpdmVHZXRTdGF0cy5hcHBseSh0aGlzLCBbc2VsZWN0b3IgfHwgbnVsbF0pLnRoZW4oZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDUzICYmICFvblN1Y2MpIHtcbiAgICAgICAgLy8gU2hpbSBvbmx5IHByb21pc2UgZ2V0U3RhdHMgd2l0aCBzcGVjLWh5cGhlbnMgaW4gdHlwZSBuYW1lc1xuICAgICAgICAvLyBMZWF2ZSBjYWxsYmFjayB2ZXJzaW9uIGFsb25lOyBtaXNjIG9sZCB1c2VzIG9mIGZvckVhY2ggYmVmb3JlIE1hcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXQpIHtcbiAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0LCBpKSB7XG4gICAgICAgICAgICBzdGF0cy5zZXQoaSwgT2JqZWN0LmFzc2lnbih7fSwgc3RhdCwge1xuICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltU2VuZGVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9yaWdHZXRTZW5kZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzO1xuICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLl9wYyA9IF90aGlzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VuZGVycztcbiAgICB9O1xuICB9XG5cbiAgdmFyIG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gIGlmIChvcmlnQWRkVHJhY2spIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2soKSB7XG4gICAgICB2YXIgc2VuZGVyID0gb3JpZ0FkZFRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBzZW5kZXIuX3BjID0gdGhpcztcbiAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgfTtcbiAgfVxuICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrID8gdGhpcy5fcGMuZ2V0U3RhdHModGhpcy50cmFjaykgOiBQcm9taXNlLnJlc29sdmUobmV3IE1hcCgpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3JpZ0dldFJlY2VpdmVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzO1xuICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzID0gZnVuY3Rpb24gZ2V0UmVjZWl2ZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXIuX3BjID0gX3RoaXMyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVjZWl2ZXJzO1xuICAgIH07XG4gIH1cbiAgdXRpbHMud3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCAndHJhY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucmVjZWl2ZXIuX3BjID0gZS5zcmNFbGVtZW50O1xuICAgIHJldHVybiBlO1xuICB9KTtcbiAgd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cyh0aGlzLnRyYWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHV0aWxzLmRlcHJlY2F0ZWQoJ3JlbW92ZVN0cmVhbScsICdyZW1vdmVUcmFjaycpO1xuICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2goZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgaWYgKHNlbmRlci50cmFjayAmJiBzdHJlYW0uZ2V0VHJhY2tzKCkuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICBfdGhpczMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdykge1xuICAvLyByZW5hbWUgRGF0YUNoYW5uZWwgdG8gUlRDRGF0YUNoYW5uZWwgKG5hdGl2ZSBmaXggaW4gRkY2MCk6XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExNzM4NTFcbiAgaWYgKHdpbmRvdy5EYXRhQ2hhbm5lbCAmJiAhd2luZG93LlJUQ0RhdGFDaGFubmVsKSB7XG4gICAgd2luZG93LlJUQ0RhdGFDaGFubmVsID0gd2luZG93LkRhdGFDaGFubmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1BZGRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnQWRkVHJhbnNjZWl2ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyO1xuICBpZiAob3JpZ0FkZFRyYW5zY2VpdmVyKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFuc2NlaXZlciA9IGZ1bmN0aW9uIGFkZFRyYW5zY2VpdmVyKCkge1xuICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgPSBbXTtcbiAgICAgIHZhciBpbml0UGFyYW1ldGVycyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzaG91bGRQZXJmb3JtQ2hlY2sgPSBpbml0UGFyYW1ldGVycyAmJiAnc2VuZEVuY29kaW5ncycgaW4gaW5pdFBhcmFtZXRlcnM7XG4gICAgICBpZiAoc2hvdWxkUGVyZm9ybUNoZWNrKSB7XG4gICAgICAgIC8vIElmIHNlbmRFbmNvZGluZ3MgcGFyYW1zIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgZ3JhbW1hclxuICAgICAgICBpbml0UGFyYW1ldGVycy5zZW5kRW5jb2RpbmdzLmZvckVhY2goZnVuY3Rpb24gKGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgdmFyIHJpZFJlZ2V4ID0gL15bYS16MC05XXswLDE2fSQvaTtcbiAgICAgICAgICAgIGlmICghcmlkUmVnZXgudGVzdChlbmNvZGluZ1BhcmFtLnJpZCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBSSUQgdmFsdWUgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnc2NhbGVSZXNvbHV0aW9uRG93bkJ5JyBpbiBlbmNvZGluZ1BhcmFtKSB7XG4gICAgICAgICAgICBpZiAoIShwYXJzZUZsb2F0KGVuY29kaW5nUGFyYW0uc2NhbGVSZXNvbHV0aW9uRG93bkJ5KSA+PSAxLjApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzY2FsZV9yZXNvbHV0aW9uX2Rvd25fYnkgbXVzdCBiZSA+PSAxLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdtYXhGcmFtZXJhdGUnIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5tYXhGcmFtZXJhdGUpID49IDApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdtYXhfZnJhbWVyYXRlIG11c3QgYmUgPj0gMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciB0cmFuc2NlaXZlciA9IG9yaWdBZGRUcmFuc2NlaXZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1DaGVjaykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5pdCBvcHRpb25zIHdlcmUgYXBwbGllZC4gSWYgbm90IHdlIGRvIHRoaXMgaW4gYW5cbiAgICAgICAgLy8gYXN5bmNocm9ub3VzIHdheSBhbmQgc2F2ZSB0aGUgcHJvbWlzZSByZWZlcmVuY2UgaW4gYSBnbG9iYWwgb2JqZWN0LlxuICAgICAgICAvLyBUaGlzIGlzIGFuIHVnbHkgaGFjaywgYnV0IGF0IHRoZSBzYW1lIHRpbWUgaXMgd2F5IG1vcmUgcm9idXN0IHRoYW5cbiAgICAgICAgLy8gY2hlY2tpbmcgdGhlIHNlbmRlciBwYXJhbWV0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGNyZWF0ZU9mZmVyXG4gICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IGFmdGVyIHRoZSBjcmVhdGVvZmZlciB3ZSBhcmUgbm90IDEwMCUgc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBwYXJhbXMgd2VyZSBhc3luY2hyb25vdXNseSBhcHBsaWVkIHNvIHdlIG1pZ2h0IG1pc3MgdGhlXG4gICAgICAgIC8vIG9wcG9ydHVuaXR5IHRvIHJlY3JlYXRlIG9mZmVyLlxuICAgICAgICB2YXIgc2VuZGVyID0gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuXG4gICAgICAgIHZhciBwYXJhbXMgPSBzZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IGluaXRQYXJhbWV0ZXJzLnNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLmNhdGNoKGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2NlaXZlcjtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlcih3aW5kb3cpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Y0hhY2tzL2FkYXB0ZXIvaXNzdWVzLzk5OCNpc3N1ZWNvbW1lbnQtNTE2OTIxNjQ3XG4gIC8vIEZpcmVmb3ggaWdub3JlcyB0aGUgaW5pdCBzZW5kRW5jb2RpbmdzIG9wdGlvbnMgcGFzc2VkIHRvIGFkZFRyYW5zY2VpdmVyXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzOTY5MThcbiAgaWYgKCEoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXMsXG4gICAgICAgIF9hcmd1bWVudHMyID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseShfdGhpczQsIF9hcmd1bWVudHMyKTtcbiAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzaGltQ3JlYXRlQW5zd2VyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9yaWdDcmVhdGVBbnN3ZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnN3ZXIoKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXMsXG4gICAgICAgIF9hcmd1bWVudHMzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzICYmIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkoX3RoaXM1LCBfYXJndW1lbnRzMyk7XG4gICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbn0se1wiLi4vdXRpbHNcIjoxMSxcIi4vZ2V0ZGlzcGxheW1lZGlhXCI6OCxcIi4vZ2V0dXNlcm1lZGlhXCI6OX1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTggVGhlIGFkYXB0ZXIuanMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNoaW1HZXREaXNwbGF5TWVkaWEgPSBzaGltR2V0RGlzcGxheU1lZGlhO1xuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgdmFyIGVyciA9IG5ldyBET01FeGNlcHRpb24oJ2dldERpc3BsYXlNZWRpYSB3aXRob3V0IHZpZGVvICcgKyAnY29uc3RyYWludHMgaXMgdW5kZWZpbmVkJyk7XG4gICAgICBlcnIubmFtZSA9ICdOb3RGb3VuZEVycm9yJztcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLURPTUV4Y2VwdGlvbi1lcnJvci1uYW1lc1xuICAgICAgZXJyLmNvZGUgPSA4O1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy52aWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSB7IG1lZGlhU291cmNlOiBwcmVmZXJyZWRNZWRpYVNvdXJjZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgfTtcbn1cblxufSx7fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuc2hpbUdldFVzZXJNZWRpYSA9IHNoaW1HZXRVc2VyTWVkaWE7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICB2YXIgYnJvd3NlckRldGFpbHMgPSB1dGlscy5kZXRlY3RCcm93c2VyKHdpbmRvdyk7XG4gIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgdmFyIE1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cgJiYgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG5cbiAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgLy8gUmVwbGFjZSBGaXJlZm94IDQ0KydzIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2l0aCB1bnByZWZpeGVkIHZlcnNpb24uXG4gICAgdXRpbHMuZGVwcmVjYXRlZCgnbmF2aWdhdG9yLmdldFVzZXJNZWRpYScsICduYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYScpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gIH07XG5cbiAgaWYgKCEoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+IDU1ICYmICdhdXRvR2FpbkNvbnRyb2wnIGluIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMoKSkpIHtcbiAgICB2YXIgcmVtYXAgPSBmdW5jdGlvbiByZW1hcChvYmosIGEsIGIpIHtcbiAgICAgIGlmIChhIGluIG9iaiAmJiAhKGIgaW4gb2JqKSkge1xuICAgICAgICBvYmpbYl0gPSBvYmpbYV07XG4gICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBuYXRpdmVHZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYS5iaW5kKG5hdmlnYXRvci5tZWRpYURldmljZXMpO1xuICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmICgodHlwZW9mIGMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGMpKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihjLmF1ZGlvKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlR2V0VXNlck1lZGlhKGMpO1xuICAgIH07XG5cbiAgICBpZiAoTWVkaWFTdHJlYW1UcmFjayAmJiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncykge1xuICAgICAgdmFyIG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iaiA9IG5hdGl2ZUdldFNldHRpbmdzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlbWFwKG9iaiwgJ21vekF1dG9HYWluQ29udHJvbCcsICdhdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicsICdub2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMpIHtcbiAgICAgIHZhciBuYXRpdmVBcHBseUNvbnN0cmFpbnRzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cztcbiAgICAgIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5raW5kID09PSAnYXVkaW8nICYmICh0eXBlb2YgYyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICAgICAgICByZW1hcChjLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICAgIHJlbWFwKGMsICdub2lzZVN1cHByZXNzaW9uJywgJ21vek5vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmF0aXZlQXBwbHlDb25zdHJhaW50cy5hcHBseSh0aGlzLCBbY10pO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxufSx7XCIuLi91dGlsc1wiOjExfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5zaGltTG9jYWxTdHJlYW1zQVBJID0gc2hpbUxvY2FsU3RyZWFtc0FQSTtcbmV4cG9ydHMuc2hpbVJlbW90ZVN0cmVhbXNBUEkgPSBzaGltUmVtb3RlU3RyZWFtc0FQSTtcbmV4cG9ydHMuc2hpbUNhbGxiYWNrc0FQSSA9IHNoaW1DYWxsYmFja3NBUEk7XG5leHBvcnRzLnNoaW1HZXRVc2VyTWVkaWEgPSBzaGltR2V0VXNlck1lZGlhO1xuZXhwb3J0cy5zaGltQ29uc3RyYWludHMgPSBzaGltQ29uc3RyYWludHM7XG5leHBvcnRzLnNoaW1SVENJY2VTZXJ2ZXJVcmxzID0gc2hpbVJUQ0ljZVNlcnZlclVybHM7XG5leHBvcnRzLnNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXIgPSBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyO1xuZXhwb3J0cy5zaGltQ3JlYXRlT2ZmZXJMZWdhY3kgPSBzaGltQ3JlYXRlT2ZmZXJMZWdhY3k7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgdXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRMb2NhbFN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0cmVhbXM7XG4gICAgfTtcbiAgfVxuICBpZiAoISgnYWRkU3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHZhciBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gZW11bGF0ZSBDaHJvbWUncyBiZWhhdmlvdXIgb2YgYWRkaW5nIGluIGF1ZGlvLXZpZGVvIG9yZGVyLlxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfYWRkVHJhY2suY2FsbChfdGhpcywgdHJhY2ssIHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgIHJldHVybiBfYWRkVHJhY2suY2FsbChfdGhpcywgdHJhY2ssIHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XG4gICAgICB2YXIgc3RyZWFtID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcyA9IFtzdHJlYW1dO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2NhbFN0cmVhbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHZhciB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgaWYgKHRyYWNrcy5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgICAgX3RoaXMyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoJ2dldFJlbW90ZVN0cmVhbXMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID0gZnVuY3Rpb24gZ2V0UmVtb3RlU3RyZWFtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdGVTdHJlYW1zID8gdGhpcy5fcmVtb3RlU3RyZWFtcyA6IFtdO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ29uYWRkc3RyZWFtJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb25hZGRzdHJlYW0nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uYWRkc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGYpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzMy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICBfdGhpczMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpczMuX3JlbW90ZVN0cmVhbXMuaW5jbHVkZXMoc3RyZWFtKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpczMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIF90aGlzMy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHBjID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5fb25hZGRzdHJlYW1wb2x5KSB7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2snLCB0aGlzLl9vbmFkZHN0cmVhbXBvbHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIGlmICghcGMuX3JlbW90ZVN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgcGMuX3JlbW90ZVN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYy5fcmVtb3RlU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPj0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgcGMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdTZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseShwYywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1DYWxsYmFja3NBUEkod2luZG93KSB7XG4gIGlmICgodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yod2luZG93KSkgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByb3RvdHlwZSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBvcmlnQ3JlYXRlT2ZmZXIgPSBwcm90b3R5cGUuY3JlYXRlT2ZmZXI7XG4gIHZhciBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgdmFyIHNldExvY2FsRGVzY3JpcHRpb24gPSBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbjtcbiAgdmFyIHNldFJlbW90ZURlc2NyaXB0aW9uID0gcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uO1xuICB2YXIgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcblxuICBwcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiBjcmVhdGVPZmZlcihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIHZhciBwcm9taXNlID0gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcblxuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID49IDIgPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIHByb21pc2UgPSBvcmlnQ3JlYXRlQW5zd2VyLmFwcGx5KHRoaXMsIFtvcHRpb25zXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcblxuICB2YXIgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gd2l0aENhbGxiYWNrKGRlc2NyaXB0aW9uLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlID0gc2V0TG9jYWxEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHdpdGhDYWxsYmFjaztcblxuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiB3aXRoQ2FsbGJhY2soZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSBzZXRSZW1vdGVEZXNjcmlwdGlvbi5hcHBseSh0aGlzLCBbZGVzY3JpcHRpb25dKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuc2V0UmVtb3RlRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG5cbiAgd2l0aENhbGxiYWNrID0gZnVuY3Rpb24gd2l0aENhbGxiYWNrKGNhbmRpZGF0ZSwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IGFkZEljZUNhbmRpZGF0ZS5hcHBseSh0aGlzLCBbY2FuZGlkYXRlXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IHdpdGhDYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSh3aW5kb3cpIHtcbiAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgLy8gc2hpbSBub3QgbmVlZGVkIGluIFNhZmFyaSAxMi4xXG4gICAgdmFyIG1lZGlhRGV2aWNlcyA9IG5hdmlnYXRvci5tZWRpYURldmljZXM7XG4gICAgdmFyIF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICAgICAgcmV0dXJuIF9nZXRVc2VyTWVkaWEoc2hpbUNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghbmF2aWdhdG9yLmdldFVzZXJNZWRpYSAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50cywgY2IsIGVycmNiKSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihjYiwgZXJyY2IpO1xuICAgIH0uYmluZChuYXZpZ2F0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cywgeyB2aWRlbzogdXRpbHMuY29tcGFjdE9iamVjdChjb25zdHJhaW50cy52aWRlbykgfSk7XG4gIH1cblxuICByZXR1cm4gY29uc3RyYWludHM7XG59XG5cbmZ1bmN0aW9uIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdykge1xuICAvLyBtaWdyYXRlIGZyb20gbm9uLXNwZWMgUlRDSWNlU2VydmVyLnVybCB0byBSVENJY2VTZXJ2ZXIudXJsc1xuICB2YXIgT3JpZ1BlZXJDb25uZWN0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbiBSVENQZWVyQ29ubmVjdGlvbihwY0NvbmZpZywgcGNDb25zdHJhaW50cykge1xuICAgIGlmIChwY0NvbmZpZyAmJiBwY0NvbmZpZy5pY2VTZXJ2ZXJzKSB7XG4gICAgICB2YXIgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoIXNlcnZlci5oYXNPd25Qcm9wZXJ0eSgndXJscycpICYmIHNlcnZlci5oYXNPd25Qcm9wZXJ0eSgndXJsJykpIHtcbiAgICAgICAgICB1dGlscy5kZXByZWNhdGVkKCdSVENJY2VTZXJ2ZXIudXJsJywgJ1JUQ0ljZVNlcnZlci51cmxzJyk7XG4gICAgICAgICAgc2VydmVyID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzZXJ2ZXIpKTtcbiAgICAgICAgICBzZXJ2ZXIudXJscyA9IHNlcnZlci51cmw7XG4gICAgICAgICAgZGVsZXRlIHNlcnZlci51cmw7XG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SWNlU2VydmVycy5wdXNoKHBjQ29uZmlnLmljZVNlcnZlcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwY0NvbmZpZy5pY2VTZXJ2ZXJzID0gbmV3SWNlU2VydmVycztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmlnUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpO1xuICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlID0gT3JpZ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gd3JhcCBzdGF0aWMgbWV0aG9kcy4gQ3VycmVudGx5IGp1c3QgZ2VuZXJhdGVDZXJ0aWZpY2F0ZS5cbiAgaWYgKCdnZW5lcmF0ZUNlcnRpZmljYXRlJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLCAnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gT3JpZ1BlZXJDb25uZWN0aW9uLmdlbmVyYXRlQ2VydGlmaWNhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKCh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXIgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KSB7XG4gIHZhciBvcmlnQ3JlYXRlT2ZmZXIgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIob2ZmZXJPcHRpb25zKSB7XG4gICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gc3VwcG9ydCBiaXQgdmFsdWVzXG4gICAgICAgIG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID0gISFvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbztcbiAgICAgIH1cbiAgICAgIHZhciBhdWRpb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKGZ1bmN0aW9uICh0cmFuc2NlaXZlcikge1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgIH0pO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmICFhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICB9XG4gICAgICB2YXIgdmlkZW9UcmFuc2NlaXZlciA9IHRoaXMuZ2V0VHJhbnNjZWl2ZXJzKCkuZmluZChmdW5jdGlvbiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbyc7XG4gICAgICB9KTtcbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UgJiYgdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdzZW5kcmVjdicpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdzZW5kb25seScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdzZW5kb25seSc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID09PSAncmVjdm9ubHknKSB7XG4gICAgICAgICAgaWYgKHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbignaW5hY3RpdmUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPSAnaW5hY3RpdmUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSAmJiAhdmlkZW9UcmFuc2NlaXZlcikge1xuICAgICAgICB0aGlzLmFkZFRyYW5zY2VpdmVyKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JpZ0NyZWF0ZU9mZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbn0se1wiLi4vdXRpbHNcIjoxMX1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5leHRyYWN0VmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uO1xuZXhwb3J0cy53cmFwUGVlckNvbm5lY3Rpb25FdmVudCA9IHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50O1xuZXhwb3J0cy5kaXNhYmxlTG9nID0gZGlzYWJsZUxvZztcbmV4cG9ydHMuZGlzYWJsZVdhcm5pbmdzID0gZGlzYWJsZVdhcm5pbmdzO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuZXhwb3J0cy5kZXRlY3RCcm93c2VyID0gZGV0ZWN0QnJvd3NlcjtcbmV4cG9ydHMuY29tcGFjdE9iamVjdCA9IGNvbXBhY3RPYmplY3Q7XG5leHBvcnRzLndhbGtTdGF0cyA9IHdhbGtTdGF0cztcbmV4cG9ydHMuZmlsdGVyU3RhdHMgPSBmaWx0ZXJTdGF0cztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIGxvZ0Rpc2FibGVkXyA9IHRydWU7XG52YXIgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIHZhciBtYXRjaCA9IHVhc3RyaW5nLm1hdGNoKGV4cHIpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IHBvcyAmJiBwYXJzZUludChtYXRjaFtwb3NdLCAxMCk7XG59XG5cbi8vIFdyYXBzIHRoZSBwZWVyY29ubmVjdGlvbiBldmVudCBldmVudE5hbWVUb1dyYXAgaW4gYSBmdW5jdGlvblxuLy8gd2hpY2ggcmV0dXJucyB0aGUgbW9kaWZpZWQgZXZlbnQgb2JqZWN0IChvciBmYWxzZSB0byBwcmV2ZW50XG4vLyB0aGUgZXZlbnQpLlxuZnVuY3Rpb24gd3JhcFBlZXJDb25uZWN0aW9uRXZlbnQod2luZG93LCBldmVudE5hbWVUb1dyYXAsIHdyYXBwZXIpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByb3RvID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXApIHtcbiAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiB3cmFwcGVkQ2FsbGJhY2soZSkge1xuICAgICAgdmFyIG1vZGlmaWVkRXZlbnQgPSB3cmFwcGVyKGUpO1xuICAgICAgaWYgKG1vZGlmaWVkRXZlbnQpIHtcbiAgICAgICAgY2IobW9kaWZpZWRFdmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9ldmVudE1hcCA9IHRoaXMuX2V2ZW50TWFwIHx8IHt9O1xuICAgIHRoaXMuX2V2ZW50TWFwW2NiXSA9IHdyYXBwZWRDYWxsYmFjaztcbiAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5hcHBseSh0aGlzLCBbbmF0aXZlRXZlbnROYW1lLCB3cmFwcGVkQ2FsbGJhY2tdKTtcbiAgfTtcblxuICB2YXIgbmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gIHByb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lLCBjYikge1xuICAgIGlmIChuYXRpdmVFdmVudE5hbWUgIT09IGV2ZW50TmFtZVRvV3JhcCB8fCAhdGhpcy5fZXZlbnRNYXAgfHwgIXRoaXMuX2V2ZW50TWFwW2NiXSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgdmFyIHVud3JhcHBlZENiID0gdGhpcy5fZXZlbnRNYXBbY2JdO1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcFtjYl07XG4gICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgdW53cmFwcGVkQ2JdKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbicgKyBldmVudE5hbWVUb1dyYXAsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzWydfb24nICsgZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGNiKSB7XG4gICAgICBpZiAodGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCwgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pO1xuICAgICAgICBkZWxldGUgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCwgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0gPSBjYik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkaXNhYmxlTG9nKGJvb2wpIHtcbiAgaWYgKHR5cGVvZiBib29sICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdBcmd1bWVudCB0eXBlOiAnICsgKHR5cGVvZiBib29sID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihib29sKSkgKyAnLiBQbGVhc2UgdXNlIGEgYm9vbGVhbi4nKTtcbiAgfVxuICBsb2dEaXNhYmxlZF8gPSBib29sO1xuICByZXR1cm4gYm9vbCA/ICdhZGFwdGVyLmpzIGxvZ2dpbmcgZGlzYWJsZWQnIDogJ2FkYXB0ZXIuanMgbG9nZ2luZyBlbmFibGVkJztcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG9yIGVuYWJsZSBkZXByZWNhdGlvbiB3YXJuaW5nc1xuICogQHBhcmFtIHshYm9vbGVhbn0gYm9vbCBzZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHdhcm5pbmdzLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlV2FybmluZ3MoYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyAodHlwZW9mIGJvb2wgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGJvb2wpKSArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGRlcHJlY2F0aW9uV2FybmluZ3NfID0gIWJvb2w7XG4gIHJldHVybiAnYWRhcHRlci5qcyBkZXByZWNhdGlvbiB3YXJuaW5ncyAnICsgKGJvb2wgPyAnZGlzYWJsZWQnIDogJ2VuYWJsZWQnKTtcbn1cblxuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHdpbmRvdykpID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChsb2dEaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU2hvd3MgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHN1Z2dlc3RpbmcgdGhlIG1vZGVybiBhbmQgc3BlYy1jb21wYXRpYmxlIEFQSS5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlZChvbGRNZXRob2QsIG5ld01ldGhvZCkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ3NfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihvbGRNZXRob2QgKyAnIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgJyArIG5ld01ldGhvZCArICcgaW5zdGVhZC4nKTtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGRldGVjdG9yLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gcmVzdWx0IGNvbnRhaW5pbmcgYnJvd3NlciBhbmQgdmVyc2lvblxuICogICAgIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJyb3dzZXIod2luZG93KSB7XG4gIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuXG4gIC8vIFJldHVybmVkIHJlc3VsdCBvYmplY3QuXG5cbiAgdmFyIHJlc3VsdCA9IHsgYnJvd3NlcjogbnVsbCwgdmVyc2lvbjogbnVsbCB9O1xuXG4gIC8vIEZhaWwgZWFybHkgaWYgaXQncyBub3QgYSBicm93c2VyXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5hdmlnYXRvcikge1xuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBGaXJlZm94LlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2ZpcmVmb3gnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0ZpcmVmb3hcXC8oXFxkKylcXC4vLCAxKTtcbiAgfSBlbHNlIGlmIChuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgPT09IGZhbHNlICYmIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbiAmJiAhd2luZG93LlJUQ0ljZUdhdGhlcmVyKSB7XG4gICAgLy8gQ2hyb21lLCBDaHJvbWl1bSwgV2VidmlldywgT3BlcmEuXG4gICAgLy8gVmVyc2lvbiBtYXRjaGVzIENocm9tZS9XZWJSVEMgdmVyc2lvbi5cbiAgICAvLyBDaHJvbWUgNzQgcmVtb3ZlZCB3ZWJraXRHZXRVc2VyTWVkaWEgb24gaHR0cCBhcyB3ZWxsIHNvIHdlIG5lZWQgdGhlXG4gICAgLy8gbW9yZSBjb21wbGljYXRlZCBmYWxsYmFjayB0byB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbi5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdjaHJvbWUnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0Nocm9tKGV8aXVtKVxcLyhcXGQrKVxcLi8sIDIpO1xuICB9IGVsc2UgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS4oXFxkKykkLykpIHtcbiAgICAvLyBFZGdlLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2VkZ2UnO1xuICAgIHJlc3VsdC52ZXJzaW9uID0gZXh0cmFjdFZlcnNpb24obmF2aWdhdG9yLnVzZXJBZ2VudCwgL0VkZ2VcXC8oXFxkKykuKFxcZCspJC8sIDIpO1xuICB9IGVsc2UgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pKSB7XG4gICAgLy8gU2FmYXJpLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ3NhZmFyaSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vLCAxKTtcbiAgICByZXN1bHQuc3VwcG9ydHNVbmlmaWVkUGxhbiA9IHdpbmRvdy5SVENSdHBUcmFuc2NlaXZlciAmJiAnY3VycmVudERpcmVjdGlvbicgaW4gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGZhbGx0aHJvdWdoOiBub3Qgc3VwcG9ydGVkLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIHN1cHBvcnRlZCBicm93c2VyLic7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxuICogb2YgTG9kYXNoJ3MgYGNvbXBhY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcbiAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW11bGF0b3IsIGtleSkge1xuICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgdmFyIHZhbHVlID0gaXNPYmogPyBjb21wYWN0T2JqZWN0KGRhdGFba2V5XSkgOiBkYXRhW2tleV07XG4gICAgdmFyIGlzRW1wdHlPYmplY3QgPSBpc09iaiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc0VtcHR5T2JqZWN0KSB7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjY3VtdWxhdG9yLCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgdmFsdWUpKTtcbiAgfSwge30pO1xufVxuXG4vKiBpdGVyYXRlcyB0aGUgc3RhdHMgZ3JhcGggcmVjdXJzaXZlbHkuICovXG5mdW5jdGlvbiB3YWxrU3RhdHMoc3RhdHMsIGJhc2UsIHJlc3VsdFNldCkge1xuICBpZiAoIWJhc2UgfHwgcmVzdWx0U2V0LmhhcyhiYXNlLmlkKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXN1bHRTZXQuc2V0KGJhc2UuaWQsIGJhc2UpO1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUuZW5kc1dpdGgoJ0lkJykpIHtcbiAgICAgIHdhbGtTdGF0cyhzdGF0cywgc3RhdHMuZ2V0KGJhc2VbbmFtZV0pLCByZXN1bHRTZXQpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5lbmRzV2l0aCgnSWRzJykpIHtcbiAgICAgIGJhc2VbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoaWQpLCByZXN1bHRTZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZmlsdGVyIGdldFN0YXRzIGZvciBhIHNlbmRlci9yZWNlaXZlciB0cmFjay4gKi9cbmZ1bmN0aW9uIGZpbHRlclN0YXRzKHJlc3VsdCwgdHJhY2ssIG91dGJvdW5kKSB7XG4gIHZhciBzdHJlYW1TdGF0c1R5cGUgPSBvdXRib3VuZCA/ICdvdXRib3VuZC1ydHAnIDogJ2luYm91bmQtcnRwJztcbiAgdmFyIGZpbHRlcmVkUmVzdWx0ID0gbmV3IE1hcCgpO1xuICBpZiAodHJhY2sgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmlsdGVyZWRSZXN1bHQ7XG4gIH1cbiAgdmFyIHRyYWNrU3RhdHMgPSBbXTtcbiAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICd0cmFjaycgJiYgdmFsdWUudHJhY2tJZGVudGlmaWVyID09PSB0cmFjay5pZCkge1xuICAgICAgdHJhY2tTdGF0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICB0cmFja1N0YXRzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrU3RhdCkge1xuICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgaWYgKHN0YXRzLnR5cGUgPT09IHN0cmVhbVN0YXRzVHlwZSAmJiBzdGF0cy50cmFja0lkID09PSB0cmFja1N0YXQuaWQpIHtcbiAgICAgICAgd2Fsa1N0YXRzKHJlc3VsdCwgc3RhdHMsIGZpbHRlcmVkUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbn1cblxufSx7fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU0RQIGhlbHBlcnMuXG52YXIgU0RQVXRpbHMgPSB7fTtcblxuLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4vLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgMTApO1xufTtcblxuLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG5TRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbi8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG5TRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24oYmxvYikge1xuICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICB9KTtcbn07XG4vLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cblNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCwgaW5kZXgpIHtcbiAgICByZXR1cm4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbic7XG4gIH0pO1xufTtcblxuLy8gcmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cblNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyByZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcblxuLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cblNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24oYmxvYiwgcHJlZml4KSB7XG4gIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICB9KTtcbn07XG5cbi8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbi8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuLy8gcnBvcnQgNTU5OTZcIlxuU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cztcbiAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cbiAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddXG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgY2FuZGlkYXRlLnVmcmFnID0gcGFydHNbaSArIDFdOyAvLyBmb3IgYmFja3dhcmQgY29tcGFiaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZ1xuICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG5TRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICB2YXIgc2RwID0gW107XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmNvbXBvbmVudCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuXG4gIHZhciB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gIHNkcC5wdXNoKCd0eXAnKTtcbiAgc2RwLnB1c2godHlwZSk7XG4gIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmXG4gICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpO1xuICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICBzZHAucHVzaCgndWZyYWcnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpO1xuICB9XG4gIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4vLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcblNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICB2YXIgcGFyc2VkID0ge1xuICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZSBhbiBhPXJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4vLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgdmFyIGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gYT1leHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgdXJpOiBwYXJ0c1sxXVxuICB9O1xufTtcblxuLy8gR2VuZXJhdGVzIGE9ZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4vLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG5TRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uKGhlYWRlckV4dGVuc2lvbikge1xuICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2J1xuICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgOiAnJykgK1xuICAgICAgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGZ0bXAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGt2O1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBhPWZ0bXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0pIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhbiBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICB9O1xufTtcbi8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lcyA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZ1bmN0aW9uKGZiKSB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYW4gUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICB2YXIgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHIoNywgc3AgLSA3KSwgMTApXG4gIH07XG4gIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cihzcCArIDEsIGNvbG9uIC0gc3AgLSAxKTtcbiAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyKGNvbG9uICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuXG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTMpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgc2VtYW50aWNzOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHNzcmNzOiBwYXJ0cy5tYXAoZnVuY3Rpb24oc3NyYykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHNzcmMsIDEwKTtcbiAgICB9KVxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gcmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHIoNik7XG4gIH1cbn07XG5cblNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUuXG4gIC8vIE5vdGUyOiAnYWxnb3JpdGhtJyBpcyBub3QgY2FzZSBzZW5zaXRpdmUgZXhjZXB0IGluIEVkZ2UuXG4gIHJldHVybiB7XG4gICAgcm9sZTogJ2F1dG8nLFxuICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgdmFyIHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGZwKSB7XG4gICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICB9KTtcbiAgcmV0dXJuIHNkcDtcbn07XG4vLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4vLyBGSVhNRTogZm9yIGNvbnNpc3RlbmN5IHdpdGggb3RoZXIgZnVuY3Rpb25zIHRoaXMgc2hvdWxkIG9ubHlcbi8vICAgZ2V0IHRoZSBpY2UtdWZyYWcgYW5kIGljZS1wd2QgbGluZXMgYXMgaW5wdXQuXG5TRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIC8vIFNlYXJjaCBpbiBzZXNzaW9uIHBhcnQsIHRvby5cbiAgbGluZXMgPSBsaW5lcy5jb25jYXQoU0RQVXRpbHMuc3BsaXRMaW5lcyhzZXNzaW9ucGFydCkpO1xuICB2YXIgaWNlUGFyYW1ldGVycyA9IHtcbiAgICB1c2VybmFtZUZyYWdtZW50OiBsaW5lcy5maWx0ZXIoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuaW5kZXhPZignYT1pY2UtdWZyYWc6JykgPT09IDA7XG4gICAgfSlbMF0uc3Vic3RyKDEyKSxcbiAgICBwYXNzd29yZDogbGluZXMuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLXB3ZDonKSA9PT0gMDtcbiAgICB9KVswXS5zdWJzdHIoMTApXG4gIH07XG4gIHJldHVybiBpY2VQYXJhbWV0ZXJzO1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZGVzY3JpcHRpb24gPSB7XG4gICAgY29kZWNzOiBbXSxcbiAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICBydGNwOiBbXVxuICB9O1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHsgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgIHZhciBwdCA9IG1saW5lW2ldO1xuICAgIHZhciBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICB2YXIgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIHZhciBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpXG4gICAgICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBvbmx5IFJFRCBhbmQgVUxQRkVDIGFyZSByZWNvZ25pemVkIGFzIEZFQyBtZWNoYW5pc21zLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICB2YXIgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyBVRFAvVExTL1JUUC9TQVZQRiAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgfSk7XG4gIHZhciBtYXhwdGltZSA9IDA7XG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICB9XG4gIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG5cbiAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIHZhciBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIHZhciBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIHZhciBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbihwYXJ0cykge1xuICAgICAgcmV0dXJuIHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICB9KTtcbiAgdmFyIHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICB2YXIgc2Vjb25kYXJ5U3NyYztcblxuICB2YXIgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICB2YXIgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApXG4gICAgICB9O1xuICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgZW5jUGFyYW0ucnR4ID0ge3NzcmM6IHNlY29uZGFyeVNzcmN9O1xuICAgICAgfVxuICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICB2YXIgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig3KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNSksIDEwKSAqIDEwMDAgKiAwLjk1XG4gICAgICAgICAgLSAoNTAgKiA0MCAqIDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYSB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgdmFyIHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICB9KVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIHZhciByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIHZhciBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHBhcnRzO1xuICB2YXIgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cig3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICB2YXIgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24obXNpZFBhcnRzKSB7XG4gICAgICByZXR1cm4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnO1xuICAgIH0pO1xuICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcblNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICB2YXIgbWF4TWVzc2FnZVNpemU7XG4gIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHIoMTkpLCAxMCk7XG4gIH1cbiAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gIH1cbiAgdmFyIHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cigxMiksIDEwKSxcbiAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICBtYXhNZXNzYWdlU2l6ZTogbWF4TWVzc2FnZVNpemVcbiAgICB9O1xuICB9XG4gIHZhciBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXJ0cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKVswXVxuICAgICAgLnN1YnN0cigxMClcbiAgICAgIC5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgbWF4TWVzc2FnZVNpemU6IG1heE1lc3NhZ2VTaXplXG4gICAgfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gb3V0cHV0cyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgdmVyc2lvbiB0aGF0IGFsbCBicm93c2Vyc1xuLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbi8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4vLyBwcm90b2NvbCBvZiBEVExTL1NDVFAgLS0gd2l0aG91dCBVRFAvIG9yIFRDUC8pXG5TRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhLCBzY3RwKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbidcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nXG4gICAgXTtcbiAgfVxuICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4vLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbi8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjEpO1xufTtcblxuLy8gV3JpdGUgYm9pbGRlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICB2YXIgc2Vzc2lvbklkO1xuICB2YXIgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICBpZiAoc2Vzc0lkKSB7XG4gICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICB9IGVsc2Uge1xuICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gIH1cbiAgdmFyIHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArXG4gICAgICAgICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgK1xuICAgICAgJ3M9LVxcclxcbicgK1xuICAgICAgJ3Q9MCAwXFxyXFxuJztcbn07XG5cblNEUFV0aWxzLndyaXRlTWVkaWFTZWN0aW9uID0gZnVuY3Rpb24odHJhbnNjZWl2ZXIsIGNhcHMsIHR5cGUsIHN0cmVhbSkge1xuICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbih0cmFuc2NlaXZlci5raW5kLCBjYXBzKTtcblxuICAvLyBNYXAgSUNFIHBhcmFtZXRlcnMgKHVmcmFnLCBwd2QpIHRvIFNEUC5cbiAgc2RwICs9IFNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyhcbiAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5nZXRMb2NhbFBhcmFtZXRlcnMoKSk7XG5cbiAgLy8gTWFwIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzKFxuICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuZ2V0TG9jYWxQYXJhbWV0ZXJzKCksXG4gICAgdHlwZSA9PT0gJ29mZmVyJyA/ICdhY3RwYXNzJyA6ICdhY3RpdmUnKTtcblxuICBzZHAgKz0gJ2E9bWlkOicgKyB0cmFuc2NlaXZlci5taWQgKyAnXFxyXFxuJztcblxuICBpZiAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uKSB7XG4gICAgc2RwICs9ICdhPScgKyB0cmFuc2NlaXZlci5kaXJlY3Rpb24gKyAnXFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9c2VuZHJlY3ZcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgIHNkcCArPSAnYT1zZW5kb25seVxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9cmVjdm9ubHlcXHJcXG4nO1xuICB9IGVsc2Uge1xuICAgIHNkcCArPSAnYT1pbmFjdGl2ZVxcclxcbic7XG4gIH1cblxuICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgLy8gc3BlYy5cbiAgICB2YXIgbXNpZCA9ICdtc2lkOicgKyBzdHJlYW0uaWQgKyAnICcgK1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIudHJhY2suaWQgKyAnXFxyXFxuJztcbiAgICBzZHAgKz0gJ2E9JyArIG1zaWQ7XG5cbiAgICAvLyBmb3IgQ2hyb21lLlxuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgICAnICcgKyBtc2lkO1xuICAgIGlmICh0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICcgJyArIG1zaWQ7XG4gICAgICBzZHAgKz0gJ2E9c3NyYy1ncm91cDpGSUQgJyArXG4gICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICsgJyAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9XG4gIH1cbiAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIGJlIHdyaXR0ZW4gYnkgd3JpdGVSdHBEZXNjcmlwdGlvbi5cbiAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAnIGNuYW1lOicgKyBTRFBVdGlscy5sb2NhbENOYW1lICsgJ1xcclxcbic7XG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG5TRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cigyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICB9XG4gIH1cbiAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gIH1cbiAgcmV0dXJuICdzZW5kcmVjdic7XG59O1xuXG5TRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cigyKTtcbn07XG5cblNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG59O1xuXG5TRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIHBhcnRzID0gbGluZXNbMF0uc3Vic3RyKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJylcbiAgfTtcbn07XG5cblNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxuICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s1XVxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbn1cblxufSx7fV19LHt9LFsxXSkoMSlcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==